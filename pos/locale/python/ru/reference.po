# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2010, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2010-06-30 14:00\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.7.0\n"

msgid "Compound statements"
msgstr "Составные инструкции"

msgid "Compound statements contain (groups of) other statements; they affect or control the execution of those other statements in some way.  In general, compound statements span multiple lines, although in simple incarnations a whole compound statement may be contained in one line."
msgstr ""
"Составные инструкции содержат другие инструкции или их группы. Они влияют, "
"или прямо контролируют исполнение содержащихся инструкций каким-либо "
"образом. Как правило составные инструкции состоят из нескольких строк, "
"однако в простых выражениях составная инструкция может целиком размещаться в "
"одной строке."

msgid "The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement traditional control flow constructs.  :keyword:`try` specifies exception handlers and/or cleanup code for a group of statements, while the :keyword:`with` statement allows the execution of initialization and finalization code around a block of code.  Function and class definitions are also syntactically compound statements."
msgstr ""
"Инструкции «:keyword:`if`», «:keyword:`while`» и «:keyword:`for`» реализуют "
"стандартные конструкции управления потоком исполнения. «:keyword:`try`» "
"определяет для определённой группы выражений обработчик исключения и/или код "
"ликвидации последствий, тогда как инструкция «:keyword:`with`» позволяет "
"исполнять инициализирующий и завершающий код соответственно до и после "
"определённого кода. Определения функций и классов синтаксически также "
"являются составными инструкциями"

msgid "Compound statements consist of one or more 'clauses.'  A clause consists of a header and a 'suite.'  The clause headers of a particular compound statement are all at the same indentation level. Each clause header begins with a uniquely identifying keyword and ends with a colon.  A suite is a group of statements controlled by a clause.  A suite can be one or more semicolon-separated simple statements on the same line as the header, following the header's colon, or it can be one or more indented statements on subsequent lines.  Only the latter form of suite can contain nested compound statements; the following is illegal, mostly because it wouldn't be clear to which :keyword:`if` clause a following :keyword:`else` clause would belong::"
msgstr ""
"Составные инструкции состоят из одной или более «групп» . Группа состоит из "
"«заголовка» и «содержимого» . Все «заголовки» групп одной составной "
"инструкции находятся на одном уровне отступов. Каждый «заголовок» группы "
"начинается с однозначно идентифицирующего ключевого слова и заканчивается "
"двоеточием. Инструкции «содержимого» являются подконтрольными в группе . "
"«Содержимое» может быть одной или более простыми инструкциями разделенными "
"точкой с запятой в той же строке, что и «заголовок» , после двоеточия "
"«заголовка» , или же может быть одной или более инструкций, идущих в "
"отдельных строках с отступом. Только последняя форма содержимого группы "
"может содержать вложенные составные инструкции. Следующий пример недопустим, "
"главным образом потому, что не ясно, группе которого «:keyword:`if`» будет "
"относиться группа следующего «:keyword:`else`» ::"

msgid "if test1: if test2: print(x)"
msgstr "if test1: if test2: print(x)"

msgid "Also note that the semicolon binds tighter than the colon in this context, so that in the following example, either all or none of the :func:`print` calls are executed::"
msgstr ""
"К тому же, заметьте, что (в данном контексте) точка-с-запятой связывается "
"сильнее, чем двоеточие, таким образом в следующем примере исполняются или "
"все инструкции «:func:`print`» , или ни одной ::"

msgid "if x < y < z: print(x); print(y); print(z)"
msgstr "if x < y < z: print(x); print(y); print(z)"

msgid "Summarizing:"
msgstr "В итоге :"

msgid "Note that statements always end in a ``NEWLINE`` possibly followed by a ``DEDENT``.  Also note that optional continuation clauses always begin with a keyword that cannot start a statement, thus there are no ambiguities (the 'dangling :keyword:`else`' problem is solved in Python by requiring nested :keyword:`if` statements to be indented)."
msgstr ""
"Заметьте, что инструкции всегда заканчиваются признаком «``NEWLINE``» , "
"после которого может идти «``DEDENT``» . Также отметьте, что необязательные "
"ветви в условиях всегда начинаются с такого ключевого слова, по которому "
"ясно, что это именно продолжение инструкции необязательною ветвью, и с этого "
"слова не может начинаться новая инструкция. Проблема “оторванных” "
"«:keyword:`else`» решена в Питоне через обязательность отступов для "
"вложенных «:keyword:`if`» ."

#, fuzzy
msgid "The formatting of the grammar rules in the following sections places each clause on a separate line for clarity."
msgstr ""
"В следующих описаниях грамматических правил для удобочитаемости каждая "
"формула размещается с новой строки."

msgid "The :keyword:`if` statement"
msgstr "Инструкция «:keyword:`if`»"

msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "Инструкция «:keyword:`if`» служит для исполнения по условию :"

msgid "It selects exactly one of the suites by evaluating the expressions one by one until one is found to be true (see section :ref:`booleans` for the definition of true and false); then that suite is executed (and no other part of the :keyword:`if` statement is executed or evaluated).  If all expressions are false, the suite of the :keyword:`else` clause, if present, is executed."
msgstr ""
"Инструкция «:keyword:`if`» выбирает только одну вложенную группу инструкций, "
"вычисляя выражения-условия по очереди до первого со значением "
"«:keyword:`True`» (смотрите раздел «Логические (булевы) операции» "
":ref:`booleans` ) , затем соответствующая вложенная группа исполняется (и "
"больше не вычисляются другие выражения-условия и не выполняются другие "
"группы) . Если все выражения-условия имеют значение «:keyword:`False`» , то "
"вложенная группа ветви «:keyword:`else`» выполняется, если присутствует."

msgid "The :keyword:`while` statement"
msgstr "Инструкция «:keyword:`while`»"

msgid "The :keyword:`while` statement is used for repeated execution as long as an expression is true:"
msgstr ""
"Инструкция «:keyword:`while`» используется для циклического исполнения пока "
"выражение истинно :"

msgid "This repeatedly tests the expression and, if it is true, executes the first suite; if the expression is false (which may be the first time it is tested) the suite of the :keyword:`else` clause, if present, is executed and the loop terminates."
msgstr ""
"Инструкция «:keyword:`while`» циклически проверяет выражение-условие, и если "
"оно истинно – выполняет первую вложенную группу, а если оно ложно – (даже "
"если это происходит при первой же проверке) цикл завершается и вложенная "
"группа ветви «:keyword:`else`» выполняется, если присутствует."

msgid "A :keyword:`break` statement executed in the first suite terminates the loop without executing the :keyword:`else` clause's suite.  A :keyword:`continue` statement executed in the first suite skips the rest of the suite and goes back to testing the expression."
msgstr ""
"Исполнение инструкции «:keyword:`break`» в первой группе прекращает цикл без "
"исполнения ветви «:keyword:`else`» . Инструкция «:keyword:`continue`» в "
"первой группе пропускает остаток этой группы, и происходит переход обратно к "
"проверке выражения-условия."

msgid "The :keyword:`for` statement"
msgstr "Инструкция «:keyword:`for`»"

msgid "The :keyword:`for` statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"Инструкция «:keyword:`for`» используется для того, чтобы перебирать "
"последовательно элементы последовательности (например текстовые данные, "
"«кортежи» , списки) или другого перечислимого объекта :"

msgid "The expression list is evaluated once; it should yield an iterable object.  An iterator is created for the result of the ``expression_list``.  The suite is then executed once for each item provided by the iterator, in the order of ascending indices.  Each item in turn is assigned to the target list using the standard rules for assignments (see :ref:`assignment`), and then the suite is executed.  When the items are exhausted (which is immediately when the sequence is empty or an iterator raises a :exc:`StopIteration` exception), the suite in the :keyword:`else` clause, if present, is executed, and the loop terminates."
msgstr ""
"Список выражений «``expression_list``» вычисляется только один раз – он "
"должен давать в результате итерируемый объект, для которого создаётся "
"итератор. Вложенный блок затем исполняется по одному разу для каждого "
"элемента, выданного итератором в порядке увеличения индексов. Каждый такой "
"выданный итератором элемент назначается списку целей в соответствии со "
"стандартными правилами назначения (смотрите раздел «Инструкции назначения» "
":ref:`assignment`) , и затем уже́ вложенный блок исполняется. Когда эти "
"элементы кончаются (в самом начале, если последовательность пустая, или "
"когда итератор инициирует исключение «:exc:`StopIteration`» ) , то "
"исполняется блок инструкций ветви «:keyword:`else`» , если таковая "
"присутствует, и цикл прекращается."

msgid "A :keyword:`break` statement executed in the first suite terminates the loop without executing the :keyword:`else` clause's suite.  A :keyword:`continue` statement executed in the first suite skips the rest of the suite and continues with the next item, or with the :keyword:`else` clause if there was no next item."
msgstr ""
"Инструкция «:keyword:`break`» , исполненная в основной ветви "
"(«:keyword:`for`») , прекращает цикл без исполнения ветви «:keyword:`else`» "
". Инструкция «:keyword:`continue`» , исполненная в основной ветви "
"(«:keyword:`for`») , пропускает оставшиеся инструкции блока и, если "
"итерируемые элементы ещё есть – переходит к новому исполнению блока со "
"следующим элементом, а иначе переходит к ветви «:keyword:`else`» ."

msgid "The suite may assign to the variable(s) in the target list; this does not affect the next item assigned to it."
msgstr ""
"Внутри вложенного блока можно изменять значение переменных из списка целей, "
"и это ни как не повлияет на их значение, когда при следующем проходе им "
"будет назначено значение очередного элемента."

msgid "Names in the target list are not deleted when the loop is finished, but if the sequence is empty, it will not have been assigned to at all by the loop.  Hint: the built-in function :func:`range` returns an iterator of integers suitable to emulate the effect of Pascal's ``for i := a to b do``; e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"Имена из списка целей не удаляются после окончания цикла, но, если "
"последовательность пустая, то этим именам вообще не будет назначено значение "
"(и, если переменные не существовали, то и не будут созданы) . Подсказка : "
"встроенная функция «:func:`range`» возвращает итератор целых чисел, который "
"можно использовать для эмулирования эффекта Паскалевского «``for i := a to b "
"do``» , например, «``list(range(3))``» возвращает список «``[0, 1, 2]``» ."

msgid "There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists).  An internal counter is used to keep track of which item is used next, and this is incremented on each iteration.  When this counter has reached the length of the sequence the loop terminates.  This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated).  Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g., ::"
msgstr ""
"Есть тонкость, когда итерируемая последовательность изменяется внутри цикла "
"(это может произойти только с изменяемыми последовательностями, например "
"списком) . Для отслеживания того, какой элемент будет использован следующим, "
"– используется внутренний счётчик, увеличиваемый на единицу при каждом "
"проходе. Когда он достигает длинны последовательности – цикл прекращается. "
"Это значит, что если внутри блока цикла удаляется текущий (или один из "
"предыдущих) элемент последовательности, то элемент, который должен был быть "
"выдан следующим будет пропущен, поскольку он получит индекс элемента, "
"обрабатываемого в данный момент. Таким же образом, если внутри блока цикла в "
"последовательность добавляется элемент до текущего элемента, то текущий "
"элемент будет обработан ещё раз на следующем проходе цикла. Это может "
"приводить к очень неприятным ошибкам, которых можно избежать, если для "
"последовательности делать временную копию, с помощью среза всей "
"последовательности, например : ::"

msgid "for x in a[:]:     if x < 0: a.remove(x)"
msgstr "for x in a[:]:     if x < 0: a.remove(x)"

msgid "The :keyword:`try` statement"
msgstr "Инструкция «:keyword:`try`»"

msgid "The :keyword:`try` statement specifies exception handlers and/or cleanup code for a group of statements:"
msgstr ""
"Инструкция «:keyword:`try`» задаёт обработчики исключения и/или завершающий "
"код для блока инструкций :"

msgid "The :keyword:`except` clause(s) specify one or more exception handlers. When no exception occurs in the :keyword:`try` clause, no exception handler is executed. When an exception occurs in the :keyword:`try` suite, a search for an exception handler is started.  This search inspects the except clauses in turn until one is found that matches the exception.  An expression-less except clause, if present, must be last; it matches any exception.  For an except clause with an expression, that expression is evaluated, and the clause matches the exception if the resulting object is \"compatible\" with the exception.  An object is compatible with an exception if it is the class or a base class of the exception object or a tuple containing an item compatible with the exception."
msgstr ""
"Ветвь «:keyword:`except`» задаёт один или более обработчиков исключений. "
"Если не происходит ни одного исключения в соответствующей ветви "
"«:keyword:`try`» , то никакой из этих обработчиков не вызывается. Когда "
"случается какое-либо исключение в соответствующей ветви «:keyword:`try`» , "
"то начинается поиск обработчика этого исключения. При этом поиске "
"просматриваются последовательно все блоки «:keyword:`except`» пока не "
"встретится первый блок соответствующий произошедшему исключению. Если задан "
"блок «:keyword:`except`» без указания исключения , который подразумевает "
"любое исключение, то его логично указывать последним. Для инструкции "
"«:keyword:`except`» с выражением – это выражение вычисляется, и если "
"объект-результат является “совместимым” с обрабатываемым исключением, то "
"данный блок «:keyword:`except`» соответствует данному исключению. Объект "
"совместим с данным исключением, если он является классом или базовым классом "
"данного исключения, или же является кортежем, содержащим объект, "
"совместимый с данным исключением."

msgid "If no except clause matches the exception, the search for an exception handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"Если не найдено ни одного блока «:keyword:`except`» , соответствующего "
"исключению, то поиск продолжается в окружающем коде и по стеку вызовов. [#]_ "
" Исключение передаётся вверх по стеку вызовов только если отсутствует блок "
"«:keyword:`finally`» , такой, который нейтрализует данное исключение."

msgid "If the evaluation of an expression in the header of an except clause raises an exception, the original search for a handler is canceled and a search starts for the new exception in the surrounding code and on the call stack (it is treated as if the entire :keyword:`try` statement raised the exception)."
msgstr ""
"Если при вычислении выражения у само́й инструкции «:keyword:`except`» "
"возникает исключение, то обработка текущего исключения (возникшего внутри "
"блока «:keyword:`try`» , к которому относится данная инструкция "
"«:keyword:`except`» ) отменяется, и начинается поиск обработчика для этого "
"нового исключения в объемлющем коде и по стеку вызовов (тоесть, считается, "
"что исключение вызвала вся конструкция «:keyword:`try`» ) ."

msgid "When a matching except clause is found, the exception is assigned to the target specified after the :keyword:`as` keyword in that except clause, if present, and the except clause's suite is executed.  All except clauses must have an executable block.  When the end of this block is reached, execution continues normally after the entire try statement.  (This means that if two nested handlers exist for the same exception, and the exception occurs in the try clause of the inner handler, the outer handler will not handle the exception.)"
msgstr ""
"Если найдена соответствующая ветвь «:keyword:`except`» , то внутри этой "
"ветви данное исключение назначается получателю, указанному после ключевого "
"слова «:keyword:`as`» , если таковое присутствует, и затем блок кода этой "
"ветви «:keyword:`except`» исполняется. Все ветви «:keyword:`except`» должны "
"иметь исполнимый блок. Когда исполнение этого блока завершается – обработка "
"данного исключения завершена, и исполнение продолжается уже́ обычным образом "
"после всей конструкции «:keyword:`try`» . (Это также значит, что если есть "
"два вложенных обработчика для одного вида исключения, то когда оно "
"происходит внутри внутренней ветви «:keyword:`try`» – внешний обработчик не "
"получит этого исключения.)"

msgid "When an exception has been assigned using ``as target``, it is cleared at the end of the except clause.  This is as if ::"
msgstr ""
"Если исключение назначается переменной, указанной после ключевого слова "
"«:keyword:`as`» , то эта переменная автоматически удаляется при завершении "
"этого блока «:keyword:`except`» , как если бы ::"

msgid "except E as N:     foo"
msgstr "except E as N:     foo"

msgid "was translated to ::"
msgstr "транслировалось в ::"

msgid "except E as N:     try:         foo     finally:         del N"
msgstr "except E as N:     try:         foo     finally:         del N"

msgid "This means the exception must be assigned to a different name to be able to refer to it after the except clause.  Exceptions are cleared because with the traceback attached to them, they form a reference cycle with the stack frame, keeping all locals in that frame alive until the next garbage collection occurs."
msgstr ""
"Из этого следует, что если нужно иметь возможность обращаться к данному "
"объекту-исключению после завершения блока «:keyword:`except`» , то нужно "
"назначить это исключение ещё какому-либо имени. Причиной этого является то, "
"что исключения со связанной с ними трассировкой образуют циклические ссылки "
"с кадром стека, из-за чего все локальные переменные в этом кадре будут "
"сохраняться до следующего сбора мусора."

msgid "Before an except clause's suite is executed, details about the exception are stored in the :mod:`sys` module and can be access via :func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of: ``exc_type``, the exception class; ``exc_value``, the exception instance; ``exc_traceback``, a traceback object (see section :ref:`types`) identifying the point in the program where the exception occurred. :func:`sys.exc_info` values are restored to their previous values (before the call) when returning from a function that handled an exception."
msgstr ""
"Перед исполнением блока кода ветви «:keyword:`except`» информация об "
"исключении записывается в модуль «:mod:`sys`» и её можно получить с помощью "
"«:func:`sys.exc_info`» . «:func:`sys.exc_info`» возвращает тройной кортеж, "
"содержащий : «``exc_type``» – класс данного исключения; «``exc_value``» – "
"экземпляр исключения; «``exc_traceback``» – объект трассировки (смотрите "
"раздел об иерархии стандартных типов :ref:`types`) указывающий место "
"программы, в котором произошло исключение. Значения «:func:`sys.exc_info`» "
"восстанавливаются в их предыдущее значение при возвращении из функции "
"обработки исключения."

msgid "The optional :keyword:`else` clause is executed if and when control flows off the end of the :keyword:`try` clause. [#]_ Exceptions in the :keyword:`else` clause are not handled by the preceding :keyword:`except` clauses."
msgstr ""
"Необязательная ветвь «:keyword:`else`» исполняется только если и когда "
"происходит выход из блока «:keyword:`try`» в связи с его исчерпанием, а не в "
"связи с исключением или исполнением инструкций «:keyword:`return`» , "
"«:keyword:`continue`» или «:keyword:`break`» . [#]_ Исключения в такой ветви "
"«:keyword:`else`» не обрабатываются идущими перед нею ветвями "
"«:keyword:`except`» (относящимися к той же конструкции «:keyword:`try`») , а "
"являются исключением, возникшим в целой этой конструкции «:keyword:`try`» "
"(и обрабатываются во внешнем коде) ."

msgid "If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :keyword:`try` clause is executed, including any :keyword:`except` and :keyword:`else` clauses.  If an exception occurs in any of the clauses and is not handled, the exception is temporarily saved. The :keyword:`finally` clause is executed.  If there is a saved exception, it is re-raised at the end of the :keyword:`finally` clause. If the :keyword:`finally` clause raises another exception or executes a :keyword:`return` or :keyword:`break` statement, the saved exception is lost.  The exception information is not available to the program during execution of the :keyword:`finally` clause."
msgstr ""
"Если присутствует ветвь «:keyword:`finally`» , то она определяет завершающий "
"(зачищающий) обработчик. Выполняется ветвь «:keyword:`try`» , а также все "
"ветви «:keyword:`except`» и «:keyword:`else`» . Если в любой из них "
"происходит исключение, и оно не обработано, то оно временно сохраняется. "
"Затем выполняется ветвь «:keyword:`finally`» . Затем, если было сохранено "
"исключение, оно вызывается заново по завершении ветви «:keyword:`finally`» . "
"Если в ветви «:keyword:`finally`» происходит исключение или исполняется "
"инструкция «:keyword:`return`» или «:keyword:`break`» , то сохранённое "
"исключение теряется. Информация об сохранённом исключении не доступна "
"программе во время исполнения ветви «:keyword:`finally`» ."

msgid "When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement is executed in the :keyword:`try` suite of a :keyword:`try`...\\ :keyword:`finally` statement, the :keyword:`finally` clause is also executed 'on the way out.' A :keyword:`continue` statement is illegal in the :keyword:`finally` clause. (The reason is a problem with the current implementation --- this restriction may be lifted in the future)."
msgstr ""
"Если в ветви «:keyword:`try`» исполняется инструкция «:keyword:`return`» или "
"«:keyword:`break`» , то ветвь «:keyword:`finally`» тоже исполняется перед "
"выходом из всей конструкции «:keyword:`try`...finally» . В ветви "
"«:keyword:`finally`» инструкция «:keyword:`continue`» недопустима. (Проблема "
"в текущей реализации – это ограничение может быть снято в будущем.)"

msgid "Additional information on exceptions can be found in section :ref:`exceptions`, and information on using the :keyword:`raise` statement to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Дополнительная информация об исключениях есть в разделе “Исключения” "
":ref:`exceptions` , а об использовании инструкции «:keyword:`raise`» для "
"вызова исключений – в разделе “Инструкция «raise»” :ref:`raise` ."

msgid "The :keyword:`with` statement"
msgstr "Инструкция «:keyword:`with`»"

msgid "The :keyword:`with` statement is used to wrap the execution of a block with methods defined by a context manager (see section :ref:`context-managers`). This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"Инструкция «:keyword:`with`» используется для “оборачивания” исполнения "
"блока методами, определёнными менеджером контекста (смотрите раздел "
"“Менеджеры контекста инструкции «:keyword:`with`» ” :ref:`context-managers` "
") . Это позволяет общим схемам использования «:keyword:`try`...\\ "
":keyword:`except`...\\ :keyword:`finally`» быть инкапсулированными для "
"удобного повторного использования."

msgid "The execution of the :keyword:`with` statement with one \"item\" proceeds as follows:"
msgstr ""
"Исполнение инструкции «:keyword:`with`» с одним “элементом” происходит так:"

msgid "The context expression is evaluated to obtain a context manager."
msgstr ""
"Выражение контекста («:token:`with_item`») вычисляется, чтобы получить "
"менеджер контекста."

msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""

msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "Вызывается метод «:meth:`__enter__`» этого менеджера контекста."

msgid "If a target was included in the :keyword:`with` statement, the return value from :meth:`__enter__` is assigned to it."
msgstr ""
"Если присутствует цель назначения («:token:`target`») , то возвращаемое от "
"«:meth:`__enter__`» значение назначается этой цели."

msgid "The :keyword:`with` statement guarantees that if the :meth:`__enter__` method returns without an error, then :meth:`__exit__` will always be called. Thus, if an error occurs during the assignment to the target list, it will be treated the same as an error occurring within the suite would be. See step 6 below."
msgstr ""
"Инструкция «:keyword:`with`» гарантирует, что если метод «:meth:`__enter__`» "
"выполняется без ошибки, то обязательно будет вызван «:meth:`__exit__`» . "
"Таким образом, если ошибка происходит в течение назначения списку целей, то "
"на этом этапе она уже́ будет воспринята как ошибка внутри блока "
"«:keyword:`with`» . Смотрите шаг 6 ниже."

msgid "The suite is executed."
msgstr "Исполняется блок кода."

msgid "The context manager's :meth:`__exit__` method is invoked.  If an exception caused the suite to be exited, its type, value, and traceback are passed as arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are supplied."
msgstr ""
"Вызывается метод «:meth:`__exit__`» менеджера контекста. Если какое-либо "
"исключение приводит к выходу из блока, то тип, значение и стек вызовов этого "
"исключения передаются в качестве аргументов в «:meth:`__exit__`» – иначе "
"передаются три аргумента «:const:`None`» ."

msgid "If the suite was exited due to an exception, and the return value from the :meth:`__exit__` method was false, the exception is reraised.  If the return value was true, the exception is suppressed, and execution continues with the statement following the :keyword:`with` statement."
msgstr ""
"Если выход из блока был из-за исключения, и возвращённое методом "
"«:meth:`__exit__`» значение было “ложь” , то это исключение перевызывается. "
"Если же возвращённое значение было “истина” , то это исключение отменяется, "
"и исполнение продолжается с инструкции следующей за блоком инструкции "
"«:keyword:`with`» ."

msgid "If the suite was exited for any reason other than an exception, the return value from :meth:`__exit__` is ignored, and execution proceeds at the normal location for the kind of exit that was taken."
msgstr ""
"Если выход из блока был по любой другой причине, то возвращённое методом "
"«:meth:`__exit__`» значение игнорируется, и исполнение продолжается обычным "
"образом."

msgid "With more than one item, the context managers are processed as if multiple :keyword:`with` statements were nested::"
msgstr ""
"Если у «:keyword:`with`» более одного элемента, то это обрабатывается как "
"если бы соответствующие блоки находились один внутри другого ::"

msgid "with A() as a, B() as b:     suite"
msgstr "with A() as a, B() as b:     suite"

msgid "is equivalent to ::"
msgstr "является эквивалентом ::"

msgid "with A() as a:     with B() as b:         suite"
msgstr "with A() as a:     with B() as b:         suite"

msgid "See also"
msgstr "Смотрите также"

msgid "The specification, background, and examples for the Python :keyword:`with` statement."
msgstr ""
"Спецификация, объяснения и примеры по Питоновской инструкции "
"«:keyword:`with`» ."

msgid "Function definitions"
msgstr "Задание функций"

msgid "A function definition defines a user-defined function object (see section :ref:`types`):"
msgstr ""
"Код, задающий функцию, создаёт объект пользовательской функции (смотри́те "
"раздел “Иерархия стандартных типов” :ref:`types` ) :"

msgid "A function definition is an executable statement.  Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function).  This function object contains a reference to the current global namespace as the global namespace to be used when the function is called."
msgstr ""
"Код, задающий функцию, является исполнимой инструкцией. Его исполнение "
"связывает заданное имя в текущей локальной области имён с объектом функции "
"(в котором содержится исполнимый код функции) . Этот объект функции содержит "
"ссылку на текущую глобальную область имён, и она будет использоваться в "
"качестве глобальной во время вызова этой функции."

msgid "The function definition does not execute the function body; this gets executed only when the function is called. [#]_"
msgstr ""
"Код, задающий функцию, не исполняет тело этой функции – оно будет "
"исполняться, когда функция будет вызвана. [#]_ Запись текстовой константы, "
"идущая как первая инструкция внутри тела функции, преобразуется в атрибут "
"«:attr:`__doc__`» этой функции и таким образом становится текстом "
"документации этой функции."

msgid "A function definition may be wrapped by one or more :term:`decorator` expressions. Decorator expressions are evaluated when the function is defined, in the scope that contains the function definition.  The result must be a callable, which is invoked with the function object as the only argument. The returned value is bound to the function name instead of the function object.  Multiple decorators are applied in nested fashion. For example, the following code ::"
msgstr ""
"Код, задающий функцию, может подвергаться действию одного или нескольких "
"выражений “декораторов” (:term:`decorator`) . “Декоратор” исполняется после "
"того, как соответствующая функция уже́ определена, в той же области "
"видимости, в которой содержится код, задающий эту функцию. Результат "
"исполнения выражения “декоратора” должен быть вызываемым объектом, который "
"вызывается, с данной функцией в качестве единственного аргумента. "
"Возвращаемый объект назначается имени данной функции вместо прежнего "
"объекта-функции. Множественные “декораторы” применяются поочерёдно, в "
"порядке близости к функции (в стиле вложенности) . Например, следующий код"

msgid "@f1(arg) @f2 def func(): pass"
msgstr "@f1(arg) @f2 def func(): pass"

msgid "def func(): pass func = f1(arg)(f2(func))"
msgstr "def func(): pass func = f1(arg)(f2(func))"

#, fuzzy
msgid "When one or more parameters have the form *parameter* ``=`` *expression*, the function is said to have \"default parameter values.\"  For a parameter with a default value, the corresponding argument may be omitted from a call, in which case the parameter's default value is substituted.  If a parameter has a default value, all following parameters up until the \"``*``\" must also have a default value --- this is a syntactic restriction that is not expressed by the grammar."
msgstr ""
"Функция хранит значения по-умолчанию для тех параметров, которые имеют форму "
"*parameter* ``=`` *expression*. Для таких параметров при вызове функции "
"соответствующее им значение может быть пропущено – в этом случае будет "
"подставлено значение по-умолчанию этого параметра. Если некоторый параметр в "
"описании указан со значением по-умолчанию, то все остальные параметры до "
"«``*``» обязаны тоже иметь значение по-умолчанию."

msgid "**Default parameter values are evaluated when the function definition is executed.** This means that the expression is evaluated once, when the function is defined, and that that same \"pre-computed\" value is used for each call.  This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended.  A way around this is to use ``None`` as the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"** Значения параметров по-умолчанию вычисляются, когда исполняется "
"определение функции.** Это означает, что выражение вычисляется один раз, "
"когда функция определяется, и одно и то же “предварительно вычисленное” "
"значение используется для каждого вызова. Это особенно важно понять, когда "
"параметр по-умолчанию является изменяемым объектом (например списком или "
"словарём) : если функция изменяет этот объект (например, путем добавления "
"элемента в список) , то это значение по-умолчанию останется изменённым. Как "
"правило, это не то, что было задумано. Способом обойти это является "
"использование «:const:`None`» в качестве значения по-умолчанию, и явная "
"проверка этого параметра в теле функции, например: ::"

msgid "def whats_on_the_telly(penguin=None):     if penguin is None:         penguin = []     penguin.append(\"property of the zoo\")     return penguin"
msgstr ""
"def whats_on_the_telly(penguin=None):     if penguin is None:         "
"penguin = []     penguin.append(\"property of the zoo\")     return penguin"

msgid "Function call semantics are described in more detail in section :ref:`calls`. A function call always assigns values to all parameters mentioned in the parameter list, either from position arguments, from keyword arguments, or from default values.  If the form \"``*identifier``\" is present, it is initialized to a tuple receiving any excess positional parameters, defaulting to the empty tuple.  If the form \"``**identifier``\" is present, it is initialized to a new dictionary receiving any excess keyword arguments, defaulting to a new empty dictionary. Parameters after \"``*``\" or \"``*identifier``\" are keyword-only parameters and may only be passed used keyword arguments."
msgstr ""
"Семантика вызова функции описана более подробно в разделе «:ref:`calls`» . "
"Вызов функции всегда присваивает значения всем параметрам, упомянутым в "
"списке параметров в определении, либо от переданных позиционных аргументов, "
"либо от переданных именованных аргументов, либо от значений по умолчанию. "
"Если присутствует форма “``*identifier``” , то она инициализируется "
"кортежем, содержащим все лишние позиционные параметры, а при отсутствии "
"таковых – пустым кортежем. Если присутствует форма “``**identifier``” , то "
"она инициализируется новый словарём, содержащим все лишние именованные "
"аргументы, а при отсутствии таковых – новым пустым словарём. Параметры после "
"“``*``” или “``*identifier``” могут быть только именованными параметрами и "
"могут быть переданы только через именованные параметры."

msgid "Parameters may have annotations of the form \"``: expression``\" following the parameter name.  Any parameter may have an annotation even those of the form ``*identifier`` or ``**identifier``.  Functions may have \"return\" annotation of the form \"``-> expression``\" after the parameter list.  These annotations can be any valid Python expression and are evaluated when the function definition is executed.  Annotations may be evaluated in a different order than they appear in the source code.  The presence of annotations does not change the semantics of a function.  The annotation values are available as values of a dictionary keyed by the parameters' names in the :attr:`__annotations__` attribute of the function object."
msgstr ""
"Параметры могут иметь описания в форме “``: expression``” после имени "
"параметра. Любой параметр может иметь описание, даже те, которые в форме "
"“``*identifier``” или “``**identifier``” . Функции могут иметь описание "
"возвращаемого результата в форме “``-> expression``” в позиции после списка "
"параметров. Эти описания могут быть любыми допустимыми выражениями Питона, "
"они вычисляются при исполнении определения функции. Описания могут быть "
"вычислены в другом порядке, чем они появляются в исходном коде. Наличие "
"описаний не меняет семантику функции. Значения описаний доступны в виде "
"значений словаря в атрибуте «:attr:`__annotations__`» данной функции, с "
"именем нужного параметра в качестве ключа."

msgid "It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions.  This uses lambda forms, described in section :ref:`lambda`.  Note that the lambda form is merely a shorthand for a simplified function definition; a function defined in a \":keyword:`def`\" statement can be passed around or assigned to another name just like a function defined by a lambda form.  The \":keyword:`def`\" form is actually more powerful since it allows the execution of multiple statements and annotations."
msgstr ""
"Кроме того, можно создавать анонимные функции (функции, не связанные с "
"именем), для непосредственного использования по месту создания внутри "
"выражения. Для этого используются ламбда-формы – это практически синоним "
"понятия “упрощенное определение функции” – их описание в разделе Ламбды. "
"Функцию, определенную инструкцией «:keyword:`def`» можно передавать или "
"назначать другому имени так же, как и функцию, определенную ламбда-формой. "
"Форма «:keyword:`def`» вообще-то имеет больше возможностей, например, "
"позволяет выполнять несколько инструкций и иметь описания."

msgid "**Programmer's note:** Functions are first-class objects.  A \"``def``\" form executed inside a function definition defines a local function that can be returned or passed around.  Free variables used in the nested function can access the local variables of the function containing the def.  See section :ref:`naming` for details."
msgstr ""
"**Замечание:** Функции являются объектами первого класса. Форма "
"«:keyword:`def`» выполняемая внутри определения другой функции – создаёт "
"локальную функцию, которая может быть внешнею функцией возвращена в качестве "
"результата или передана куда-либо. Свободные имена, используемые во "
"вложенной функции, могут указывать на локальные переменные внешней функции. "
"Смотрите детали в разделе “:ref:`naming`” ."

#, fuzzy
msgid "Class definitions"
msgstr "Создание классов"

#, fuzzy
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Объект-класс создаётся “определением” класса (смотрите раздел :ref:`types` ) "
":"

msgid "A class definition is an executable statement.  It first evaluates the inheritance list, if present.  Each item in the inheritance list should evaluate to a class object or class type which allows subclassing.  The class's suite is then executed in a new execution frame (see section :ref:`naming`), using a newly created local namespace and the original global namespace. (Usually, the suite contains only function definitions.)  When the class's suite finishes execution, its execution frame is discarded but its local namespace is saved. [#]_ A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary.  The class name is bound to this class object in the original local namespace."
msgstr ""
"Код, задающий класс (“определение” класса) , является исполнимой "
"инструкцией. Сначала, если имеется, вычисляется список наследуемых базовых "
"классов. Каждый элемент в этом списке должен давать в результате "
"объект-класс, такой, который допускает создание производного класса. Затем "
"основной класс исполняется в новом кадре исполнения (смотри́те раздел "
":ref:`naming` ) с использованием новосозданной локальной области имён и "
"исходной глобальной области имён. (Обычно код класса содержит только "
"“определения” функций. ) Текстовый объект, идущий с первой строки содержания "
"кода класса, преобразуется в элемент с именем “``__doc__``” в данной "
"локальной области и, таким образом становится “документацией” этого класса. "
"[#]_ Когда код класса завершён, его кадр исполнения удаляется, а его "
"локальная область имён сохраняется. Затем создаётся объект-класс с "
"использованием списка наследования для базовых классов, а полученная ранее "
"область имён становится словарём атрибутов класса. Затем полученный "
"объект-класс назначается указанному имени в исходной области имён."

msgid "Classes can also be decorated; as with functions, ::"
msgstr "Классы могут быть “декорированы” , таким же образом как и функции: ::"

msgid "@f1(arg) @f2 class Foo: pass"
msgstr "@f1(arg) @f2 class Foo: pass"

msgid "class Foo: pass Foo = f1(arg)(f2(Foo))"
msgstr "class Foo: pass Foo = f1(arg)(f2(Foo))"

msgid "**Programmer's note:** Variables defined in the class definition are class variables; they are shared by instances. Instance variables can be set in a method with ``self.name = value``.  Both class and instance variables are accessible through the notation \"``self.name``\", and an instance variable hides a class variable with the same name when accessed in this way.  Class variables can be used as defaults for instance variables, but using mutable values there can lead to unexpected results.  Descriptors can be used to create instance variables with different implementation details."
msgstr ""
"**Замечание:** Переменные, созданные в “определении” класса становятся "
"атрибутами класса, общими для всех его экземпляров. Атрибуты экземпляра "
"могут быть созданы из какого-либо метода посредством «``self.name = "
"значение``» . Атрибуты и класса и экземпляра доступны через формулировку "
"«``self.name``» , и при таком способе доступа атрибут экземпляра перекрывает "
"атрибут класса с тем же именем. Атрибуты класса могут использоваться как "
"значения по умолчанию для атрибутов экземпляра, но если эти атрибуты класса "
"являются изменяемыми – то это может привести к неожиданным результатам. Для "
"создания у экземпляра переменных с нестандартными деталями реализации – "
"можно использовать дескрипторы."

msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - “Декораторы” классов"

msgid "Class definitions, like function definitions, may be wrapped by one or more :term:`decorator` expressions.  The evaluation rules for the decorator expressions are the same as for functions.  The result must be a class object, which is then bound to the class name."
msgstr ""
"“Определение” класса (так же как и функции) , может подвергаться действию "
"одного или нескольких выражений :term:`“декораторов”<decorator>` . Правила "
"исполнения :term:`“декораторов”<decorator>` такие же, как и для функций. "
"Результат исполнения выражения :term:`“декоратора”<decorator>` должен быть "
"объектом-классом, который затем назначается имени данного класса вместо "
"прежнего класса."

msgid "Footnotes"
msgstr "Сноски"

msgid "The exception is propagated to the invocation stack only if there is no :keyword:`finally` clause that negates the exception."
msgstr ""
"Исключение передаётся вверх по стеку вызовов только если отсутствует блок "
"«:keyword:`finally`» , такой, который нейтрализует данное исключение."

msgid "Currently, control \"flows off the end\" except in the case of an exception or the execution of a :keyword:`return`, :keyword:`continue`, or :keyword:`break` statement."
msgstr ""

msgid "A string literal appearing as the first statement in the function body is transformed into the function's ``__doc__`` attribute and therefore the function's :term:`docstring`."
msgstr ""
"Запись текстовой константы, идущая как первая инструкция внутри тела "
"функции, преобразуется в атрибут «``__doc__``» этой функции и таким образом "
"становится текстом :term:`“документации”<docstring>` этой функции."

msgid "A string literal appearing as the first statement in the class body is transformed into the namespace's ``__doc__`` item and therefore the class's :term:`docstring`."
msgstr ""
"Текстовый объект, идущий с первой строки содержания кода класса, "
"преобразуется в элемент с именем “``__doc__``” в данной локальной области и, "
"таким образом, становится :term:`“документацией”<docstring>` этого класса."

msgid "Data model"
msgstr "Модель данных"

msgid "Objects, values and types"
msgstr "Объекты, значения и типы"

msgid ":dfn:`Objects` are Python's abstraction for data.  All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann's model of a \"stored program computer,\" code is also represented by objects.)"
msgstr ""
"Объекты в Питоне являются абстракцией для данных. Все данные в программе на "
"Питоне представлены объектами или взаимоотношениями между объектами. (А с "
"точки зрения Фон Неймановской модели «хранимых в памяти программ» , код "
"также представляется объектами.)"

msgid "Every object has an identity, a type and a value.  An object's *identity* never changes once it has been created; you may think of it as the object's address in memory.  The ':keyword:`is`' operator compares the identity of two objects; the :func:`id` function returns an integer representing its identity (currently implemented as its address). An object's :dfn:`type` is also unchangeable. [#]_ An object's type determines the operations that the object supports (e.g., \"does it have a length?\") and also defines the possible values for objects of that type.  The :func:`type` function returns an object's type (which is an object itself).  The *value* of some objects can change.  Objects whose value can change are said to be *mutable*; objects whose value is unchangeable once they are created are called *immutable*. (The value of an immutable container object that contains a reference to a mutable object can change when the latter's value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed.  So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object's mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable."
msgstr ""
"Каждый объект имеет идентификатор, тип и значение. *Идентификатор* объекта "
"никогда не изменяется после создания объекта, его можно представить себе как "
"адрес объекта в памяти. Оператор «:keyword:`is`» сравнивает идентификаторы "
"двух объектов; функция «:func:`id`» возвращает целое число, представляющее "
"идентификатор (на текущий момент реализованный как адрес объекта). Тип "
"объекта также является неизменяемым. [#]_ Тип объекта определяет операции, "
"поддерживаемые объектом (например, имеет ли объект длину), а также возможные "
"значения для объекта этого типа. Функция «:func:`type`» возвращает тип "
"объекта (тип, в свою очередь, как и любые данные, является объектом). "
"*Значение* некоторых объектов может меняться. Объекты, значение которых "
"может меняться с сохранением того же идентификатора, называются "
"*изменяемыми*; объекты, значение которых после их создания не может быть "
"изменено так, чтобы идентификатор остался неизменным, называются "
"*неизменяемыми*. (В некотором смысле значение неизменяемого "
"объекта-контейнера, который содержит ссылки на изменяемые объекты, может "
"виртуально меняться, когда значение последних изменено, тем не менее сам "
"контейнер рассматривается как неизменяемый, потому что набор содержащихся в "
"нем объектов не может быть изменен. Таким образом, неизменяемость *объекта* "
"не подразумевает неизменяемость *результата* вычисления (интерпретирования) "
"этого объекта.) Изменяемость объекта определяется его типом, например: "
"числа, текстовые данные и кортежи неизменяемы, тогда как словари и списки "
"изменяемы."

msgid "Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.  An implementation is allowed to postpone garbage collection or omit it altogether --- it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable."
msgstr ""
"Объекты никогда явным образом не уничтожаются, тем не менее, когда они "
"становятся недоступны они могут быть обработаны “сборщиком мусора” . В "
"реализациях допустимы также отложенная “сборка мусора” или полное ее "
"отсутствие. Каким образом реализована сборка мусора - это вопрос качества "
"реализации, но при обязательном условии, что объекты, которые все еще "
"доступны, не будут собраны “сборщиком мусора” ."

msgid "CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references.  See the documentation of the :mod:`gc` module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change."
msgstr ""
"В настоящее время “CPython” использует схему подсчёта ссылок с (опционально) "
"отсрочкой определения циклически связанного “мусора” , которая собирает "
"большинство объектов, как только они становятся недоступными, но не "
"гарантируется сборка мусора, содержащего циклические ссылки. Смотрите "
"документацию модуля «:mod:`gc`», чтобы узнать о контроле сбора циклического "
"мусора."

msgid "Note that the use of the implementation's tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a ':keyword:`try`...\\ :keyword:`except`' statement may keep objects alive."
msgstr ""
"Обратите внимание, что в данной реализации использование трассировки или "
"отладки может сохранить объекты, которые в норме были бы “собраны” . "
"Отметьте также, что перехват исключения в выражении «:keyword:`try`...\\ "
":keyword:`except`» может сохранить объекты."

msgid "Some objects contain references to \"external\" resources such as open files or windows.  It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a :meth:`close` method. Programs are strongly recommended to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:`finally`' statement and the ':keyword:`with`' statement provide convenient ways to do this."
msgstr ""
"Некоторые объекты содержат ссылки на “внешние” ресурсы, такие как открытые "
"файлы или “окна” . Понятно что эти ресурсы освобождаются при сборке мусора, "
"однако поскольку не гарантировано что “сбор мусора” произойдет, то такие "
"объекты также предоставляют явный способ освобождения таких внешних ресурсов "
"– как правило это метод :meth:`close` . В программах настоятельно "
"рекомендуется закрывать такие объекты явно. Для этого удобно использовать "
"конструкции «:keyword:`try`...\\ :keyword:`finally`» и «:keyword:`with`» ."

msgid "Some objects contain references to other objects; these are called *containers*. Examples of containers are tuples, lists and dictionaries.  The references are part of a container's value.  In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied.  So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Некоторые объекты содержат ссылки на другие объекты; они называются "
"“контейнерами” . Примеры “контейнеров” – это кортежи, списки и словари. "
"Ссылки являются частью значения контейнера. В большинстве случаев, когда мы "
"говорим о значении контейнера, мы подразумеваем значения, а не "
"идентификаторы хранимых объектов; однако, когда мы говорим о "
"изменяемости/неизменяемости контейнера, подразумеваются только "
"непосредственно хранимые объекты (тоесть сами идентификаторы, а не "
"указываемые значения) . Поэтому, если неизменный контейнер (как, например, "
"кортеж) содержит ссылку на изменяемый объект, то значение, получающееся в "
"результате интерпретирования этого контейнера меняется, если меняется "
"указываемый изменяемый объект."

msgid "Types affect almost all aspects of object behavior.  Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer to the same object with the value one, depending on the implementation, but after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two different, unique, newly created empty lists. (Note that ``c = d = []`` assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"Типы влияют почти на все аспекты поведения объекта. Даже идентичность "
"объектов в какой-то степени подвержена этому влиянию: для неизменяемых "
"типов, операции, которые вычисляют новые значения могут в действительности "
"возвращать ссылку на какой-либо существующий объект такого же типа и с таким "
"же значением, тогда как для изменяемых объектов это не допустимо. Например, "
"после ``a = 1; b = 1`` , ``a`` и ``b`` могут ссылаться на один и тот же "
"объект, имеющий значение “единица” (а могут и на разные), что зависит от "
"конкретной реализации, но после ``c = []; d = []`` , ``c`` и ``d`` "
"обязательно ссылаются на два различных, уникальных, заново созданных пустых "
"списка. (Заметьте, что ``c = d = []`` присваивает один и тот же объект и "
"``c`` и ``d`` .)"

msgid "The standard type hierarchy"
msgstr "Иерархия стандартных типов"

msgid "Below is a list of the types that are built into Python.  Extension modules (written in C, Java, or other languages, depending on the implementation) can define additional types.  Future versions of Python may add types to the type hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.), although such additions will often be provided via the standard library instead."
msgstr ""
"Ниже перечислены типы, встроенные в Питон. Модули расширения (написанные на "
"“C”, “Java”, или других языках - в зависимости от реализации Питона в "
"конкретном случае) могут определять дополнительные типы. Будущие версии "
"Питона могут добавить новые к иерархии типов (напр. рациональные числа, "
"эффективные массивы целых и т.д.), хотя, чаще всего, такие дополнения будут "
"предоставляться с помощью стандартных библиотек."

msgid "Some of the type descriptions below contain a paragraph listing 'special attributes.'  These are attributes that provide access to the implementation and are not intended for general use.  Their definition may change in the future."
msgstr ""
"Некоторые из описаний типов, данные ниже, содержат абзац, перечисляющий "
"“специальные атрибуты”. Это атрибуты, которые предоставляют доступ к "
"внутреннему механизму реализации, и они не предназначены для использования в "
"норме. Их определение может измениться в будущем."

msgid "This type has a single value.  There is a single object with this value. This object is accessed through the built-in name ``None``. It is used to signify the absence of a value in many situations, e.g., it is returned from functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Этот тип может иметь только единственное значение. И имеется только "
"единственый объект с этим значением. Доступ к этому объекту происходит через "
"встроенное имя «:const:`None`» . Во многих ситуациях он используется, чтобы "
"обозначить отсутствие значения, например он возвращается из функций, "
"которые не возвращают ничего явным образом. «:const:`None`» имеет значение "
"истинности: «:const:`False`» (“ложь”) ."

msgid "This type has a single value.  There is a single object with this value. This object is accessed through the built-in name ``NotImplemented``. Numeric methods and rich comparison methods may return this value if they do not implement the operation for the operands provided.  (The interpreter will then try the reflected operation, or some other fallback, depending on the operator.)  Its truth value is true."
msgstr ""
"Этот тип может иметь только единственное значение. И имеется только "
"единственый объект с этим значением. Доступ к этому объекту происходит через "
"встроенное имя «:const:`NotImplemented`» . Числовые методы и методы "
"сравнения могут вернуть это значение, если они не имеют реализации данной "
"операции для данных операндов. «:const:`NotImplemented`» имеет значение "
"истинности: «:const:`True`» (\"истина\") ."

msgid "This type has a single value.  There is a single object with this value. This object is accessed through the literal ``...`` or the built-in name ``Ellipsis``.  Its truth value is true."
msgstr ""
"Этот тип может иметь только единственное значение. И имеется только "
"единственый объект с этим значением. Доступ к этому объекту происходит через "
"запись ``...`` (троеточие), или встроенное имя «:const:`Ellipsis`» . "
"«:const:`Ellipsis`» имеет значение истинности: «:const:`True`» (\"истина\")."

msgid "These are created by numeric literals and returned as results by arithmetic operators and arithmetic built-in functions.  Numeric objects are immutable; once created their value never changes.  Python numbers are of course strongly related to mathematical numbers, but subject to the limitations of numerical representation in computers."
msgstr ""
"Объекты этого типа создаются непосредственной записью числа, а также "
"возвращаются как результат арифметическими операторами и арифметическими "
"встроенными функциями. Числовые объекты являются неизменяемыми (“immutable”) "
"- будучи однажды созданным, их значение никогда не меняется. Питоновские "
"числа, конечно, ассоциируются с числами, как они понимаются в математике, "
"только имеют ограничения компьютерного числового представления."

msgid "Python distinguishes between integers, floating point numbers, and complex numbers:"
msgstr "Питон различает целые, комплексные и числа с плавающей запятой :"

msgid "These represent elements from the mathematical set of integers (positive and negative)."
msgstr ""
"Представляют собой элементы математического множества целых (положительных и "
"отрицательных) ."

msgid "There are two types of integers:"
msgstr "Есть два типа целых :"

msgid "Integers (:class:`int`)"
msgstr "Целые (:class:`int`)"

msgid "These represent numbers in an unlimited range, subject to available (virtual) memory only.  For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of 2's complement which gives the illusion of an infinite string of sign bits extending to the left."
msgstr ""
"Этот тип представляет целые числа в теоретически неограниченном диапазоне, "
"ограничиваясь только доступной памятью (виртуальной). При выполнении "
"операций сдвига и маскирования подразумевается двоичная запись числа, и "
"отрицательные числа представлены в варианте двоичного дополнительного кода, "
"который даёт впечатление бесконечного ряда знаковых битов, "
"распространяющихся влево."

msgid "These represent the truth values False and True.  The two objects representing the values False and True are the only Boolean objects. The Boolean type is a subtype of the integer type, and Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings ``\"False\"`` or ``\"True\"`` are returned, respectively."
msgstr ""
"Этот тип представляет значения истинности - «:const:`False`» и "
"«:const:`True`» . Только два объекта, представляющие «:const:`False`» и "
"«:const:`True`» , являются булевыми(логическими). Булевый - является "
"подтипом целых, и булевые значения ведут себя как значения “0” и “1” (для "
"«:const:`False`» и «:const:`True`» соответственно) - почти во всех "
"контекстах - с тем исключением, что при конвертации в строку возвращаются "
"строки ``\"False\"`` или ``\"True\"`` ."

msgid "The rules for integer representation are intended to give the most meaningful interpretation of shift and mask operations involving negative integers."
msgstr ""
"Правила представления целых нацелены на наиболее функциональную "
"интерпретацию операций сдвига и маскирования для целых чисел, включая "
"отрицательные."

msgid "These represent machine-level double precision floating point numbers. You are at the mercy of the underlying machine architecture (and C or Java implementation) for the accepted range and handling of overflow. Python does not support single-precision floating point numbers; the savings in processor and memory usage that are usually the reason for using these is dwarfed by the overhead of using objects in Python, so there is no reason to complicate the language with two kinds of floating point numbers."
msgstr ""
"Представляют собой машинную реализацию чисел с плавающей запятой двойной "
"точности. Приходится полностью полагаться на архитектуру машины, на которой "
"происходит исполнение (и на реализацию “C” или “Java”) , в отношении "
"диапазона и обработки переполнения. Питон не поддерживает числа с плавающей "
"запятой одинарной точности – экономия ресурсов процессора и памяти, которая "
"обычно является причиной их использования, перечёркивается дополнительными "
"затратами при использовании объектов Питона, так что нет причин усложнять "
"язык двумя видами чисел с плавающей запятой."

msgid "These represent complex numbers as a pair of machine-level double precision floating point numbers.  The same caveats apply as for floating point numbers. The real and imaginary parts of a complex number ``z`` can be retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Этот тип определяет комплексные числа, как пары зависящих от машинной "
"реализации чисел двойной длины с плавающей точкой. Для них действительны те "
"же ограничения, что и для чисел с плавающей точкой. Значения вещественной и "
"мнимой частей комплексного числа ``z`` могут быть получены с помощью "
"атрибутов (только для чтения) ``z.real`` и ``z.imag`` ."

msgid "These represent finite ordered sets indexed by non-negative numbers. The built-in function :func:`len` returns the number of items of a sequence. When the length of a sequence is *n*, the index set contains the numbers 0, 1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"Этот тип представляет ограниченое (не бесконечное) упорядоченое множество, "
"индексированное неотрицательными целыми числами. При длинне "
"последовательности *n* множество индексов содержит числа 0, 1, ..., *n*-1. "
"Элемент *i* последовательности a адресуется записью ``a[i]`` . Встроенная "
"функция :func:`len` возвращает количество элементов в последовательности."

msgid "Sequences also support slicing: ``a[i:j]`` selects all items with index *k* such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is a sequence of the same type.  This implies that the index set is renumbered so that it starts at 0."
msgstr ""
"Для последовательностей также доступно вырезание (“срезы”, “slices”). Так "
"``a[i:j]`` выбирает все элементы с индексом *k*, таким, что *i* ``<=`` *k* "
"``<`` *j*. При использовании в качестве выражения, срез является "
"последовательностью того же типа, что и исходная последовательность. При "
"этом множество индексов заново перечисляется, начиная с 0."

msgid "Some sequences also support \"extended slicing\" with a third \"step\" parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Некоторые последовательности также поддерживают “расширенные срезы” с "
"третьим параметром “шаг” . Так ``a[i:j:k]`` выбирает все элементы из *a* с "
"индексом *x* , где ``x = i + n*k`` , *n* ``>=`` ``0`` , *i* ``<=`` *x* ``<`` "
"*j* ."

msgid "Sequences are distinguished according to their mutability:"
msgstr "Последовательности различаются с точки зрения их изменяемости :"

msgid "An object of an immutable sequence type cannot change once it is created.  (If the object contains references to other objects, these other objects may be mutable and may be changed; however, the collection of objects directly referenced by an immutable object cannot change.)"
msgstr ""
"Объект принадлежащий к типу неизменяемой последовательности не может "
"изменяться с момента создания. (Если же этот объект содержит ссылки на "
"другие объекты, то уже́́́ эти другие объекты могут оказаться изменяемыми - и "
"могут меняться; однако тот набор объектов, на которые непосредственно "
"ссылается неизменяемый объект, меняться не может."

msgid "The following types are immutable sequences:"
msgstr "Следующие типы являются неизменяемыми последовательностями :"

msgid "The items of a string object are Unicode code units.  A Unicode code unit is represented by a string object of one item and can hold either a 16-bit or 32-bit value representing a Unicode ordinal (the maximum value for the ordinal is given in ``sys.maxunicode``, and depends on how Python is configured at compile time).  Surrogate pairs may be present in the Unicode object, and will be reported as two separate items.  The built-in functions :func:`chr` and :func:`ord` convert between code units and nonnegative integers representing the Unicode ordinals as defined in the Unicode Standard 3.0. Conversion from and to other encodings are possible through the string method :meth:`encode`."
msgstr ""
"Элементами текстового (“строкового”) объекта являются "
"элементарные(минимальные) единицы(порции) кода Юникод. Код символа Юникод "
"реализуется текстовым объектом из одного символа и может использовать 16- "
"или 32-битное значение, означающее номер символа Юникод (максимальное "
"значение для этого номера задано в ``sys.maxunicode`` , и зависит от того, "
"как Питон сконфигурирован при компиляции) . Могущие присутствовать в "
"Юникодном объекте “суррогатные пары” будут восприниматься как два отдельных "
"объекта. Встроенные функции «:func:`chr`» и «:func:`ord`» выполняют "
"преобразование между односимвольным текстовым объектом и неотрицательным "
"целым числовым объектом с соответствующим значением номера символа Юникода, "
"как определено в “Unicode Standard 3.0” . Преобазования из и в другие "
"кодировки возможны с помощью метода «:meth:`encode`» ."

msgid "The items of a tuple are arbitrary Python objects. Tuples of two or more items are formed by comma-separated lists of expressions.  A tuple of one item (a 'singleton') can be formed by affixing a comma to an expression (an expression by itself does not create a tuple, since parentheses must be usable for grouping of expressions).  An empty tuple can be formed by an empty pair of parentheses."
msgstr ""
"Элементами “кортежа” могут быть любые объекты Питона. Кортежи из двух и "
"более элементов образуются перечнем выражений, разделённых запятыми. Кортеж "
"из одного элемента (“singleton”) может быть образован добавлением запятой "
"после выражения (само выражение без запятой - не создаёт кортеж, поскольку в "
"таком случае скобки обозначают группирование в выражении). Пустой кортеж "
"может быть образован пустой парой скобок."

msgid "A bytes object is an immutable array.  The items are 8-bit bytes, represented by integers in the range 0 <= x < 256.  Bytes literals (like ``b'abc'`` and the built-in function :func:`bytes` can be used to construct bytes objects.  Also, bytes objects can be decoded to strings via the :meth:`decode` method."
msgstr ""
"Байтовый объект является неизменяемым массивом. Его элементами являются "
"8-битовые байты, которые могут быть представлены целыми числами в диапазоне "
"0 <= x < 256. Для создания байтовых объектов можно использовать "
"непосредственную запись байтов (как например  ``b'abc'`` ), или встроенную "
"функцию «:func:`bytes`» . Кроме того, байтовые объекты могут быть "
"перекодированы в строковые с помощью метода «:meth:`decode`» ."

msgid "Mutable sequences can be changed after they are created.  The subscription and slicing notations can be used as the target of assignment and :keyword:`del` (delete) statements."
msgstr ""
"Изменяемые последовательности могут быть изменены после их создания. "
"Обозначения индексации и “среза” могут быть использованы в качестве цели для "
"выражений присваивания и :keyword:`del` (удаления) ."

msgid "There are currently two intrinsic mutable sequence types:"
msgstr "В данной версии есть два типа изменяемых последовательностей:"

msgid "The items of a list are arbitrary Python objects.  Lists are formed by placing a comma-separated list of expressions in square brackets. (Note that there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Элементами списка могут быть любые объекты Питона. Списки задаются "
"перечислением выражений через запятую внутри пары квадратных скобок. "
"(Заметьте, что нет специальной формы для списка пустого или с одним "
"элементом.)"

msgid "A bytearray object is a mutable array. They are created by the built-in :func:`bytearray` constructor.  Aside from being mutable (and hence unhashable), byte arrays otherwise provide the same interface and functionality as immutable bytes objects."
msgstr ""
"Объект типа массив байтов является изменяемым массивом. Они создаются "
"встроенным конструктором «:func:`bytearray`» . За исключением изменяемости, "
"байтовые массивы в остальном предоставляют теже интерфейс и функциональность "
"как и неизменяемые байтовые объекты."

msgid "The extension module :mod:`array` provides an additional example of a mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"Модулях расширения «:mod:`array`» и «:mod:`collections`» предоставлены "
"дополнительные варианты типов изменяемых последовательностей."

msgid "These represent unordered, finite sets of unique, immutable objects. As such, they cannot be indexed by any subscript. However, they can be iterated over, and the built-in function :func:`len` returns the number of items in a set. Common uses for sets are fast membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference."
msgstr ""
"Эти типы представляют неупорядоченные, конечные наборы неповторяющихся "
"объектов. В связи с этим к ним не могут применяться операции выбора "
"элементов по их индексу. Однако элементы наборов могут быть последовательно "
"перебраны (“итерированы”), а также можно получить их количество с помощью "
"встроенной функции «:func:`len`» . Обычно наборы находят применение для "
"быстрого определения вхождения во множество, для удаления повторов из "
"последовательностей и для проведения операций типа пересечения, объединения, "
"разности."

msgid "For set elements, the same immutability rules apply as for dictionary keys. Note that numeric types obey the normal rules for numeric comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be contained in a set."
msgstr ""
"Для элементов наборов применяются теже правила неизменяемости, как и для "
"ключей словарей. Обратите внимание, что для числовых типов реализуются "
"обычные правила сравнения чисел : если два числа равны (с точки зрения "
"операции сравнения, как например ``1`` и ``1.0`` ), то только одно может "
"присутствовать в наборе."

msgid "There are currently two intrinsic set types:"
msgstr "В данной версии языка существует два внутренних наборных типа :"

msgid "These represent a mutable set. They are created by the built-in :func:`set` constructor and can be modified afterwards by several methods, such as :meth:`add`."
msgstr ""
"Этот тип представляет изменяемый набор. Наборы создаются встроенным "
"конструктором «:func:`set`» и впоследствии могут быть изменены с помощью "
"некоторых \"методов\" - например «:meth:`add`» ."

msgid "These represent an immutable set.  They are created by the built-in :func:`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Этот тип представляет неизменяемый набор. Они создаются встроенным "
"конструктором «:func:`frozenset`» . Поскольку они неизменяемые и "
"“хешируемые” (“:term:`hashable`”) - они могут в свою очередь быть "
"использованы как элемент другого набора, или как ключ словаря."

msgid "These represent finite sets of objects indexed by arbitrary index sets. The subscript notation ``a[k]`` selects the item indexed by ``k`` from the mapping ``a``; this can be used in expressions and as the target of assignments or :keyword:`del` statements. The built-in function :func:`len` returns the number of items in a mapping."
msgstr ""
"Это конечные наборы объектов, индексированных произвольным набором индексов. "
"Запись индексирования (извлечения) «``a[k]``» выбирает элемент, "
"индексированный значением «``k``» , из отображения «``a``» . Такая запись "
"может использоваться в выражениях и как получатель значения или с "
"инструкцией «:keyword:`del`» . Встроенная функция «:func:`len`» возвращает "
"количество элементов в отображении."

msgid "There is currently a single intrinsic mapping type:"
msgstr "В данной версии есть единственный тип отображения :"

msgid "These represent finite sets of objects indexed by nearly arbitrary values.  The only types of values not acceptable as keys are values containing lists or dictionaries or other mutable types that are compared by value rather than by object identity, the reason being that the efficient implementation of dictionaries requires a key's hash value to remain constant. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used interchangeably to index the same dictionary entry."
msgstr ""
"Словари - это конечные множества объектов, индексируемых соответственно "
"элементами (которые могут быть практически любыми значениями) другого набора "
"той же длины. Единственными типами значений, недопустимыми в качестве "
"индекса (ключа), являются значения, содержащие списки или словари или другие "
"изменяемые типы, сравнение которых производится по значению, а не по "
"идентификатору, по причине того, что для эффективной реализации словарей "
"требуется, чтобы значения хешей ключей оставались неизменяемыми. для "
"числовых типов, используемых в качестве ключей, реализуются обычные правила "
"сравнения чисел : если два числа равны (с точки зрения операции сравнения, "
"как например ``1`` и ``1.0`` ), то они являются взаимозаменяемыми и любое из "
"них может может быть использовано в качестве ключа к одной и той же записи "
"словаря."

msgid "Dictionaries are mutable; they can be created by the ``{...}`` notation (see section :ref:`dict`)."
msgstr ""
"Словари являются изменяемыми. Они могут быть созданы с помощью записи "
"«``{...}``» (смотрите раздел :ref:`dict`) ."

msgid "The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"В модулях расширения «:mod:`dbm.ndbm`» и «:mod:`dbm.gnu`» , также, как и в "
"«:mod:`collections`» предоставлены дополнительные варианты типов "
"отображений."

msgid "These are the types to which the function call operation (see section :ref:`calls`) can be applied:"
msgstr ""
"Это типы, к которым применима операция вызова (исполнения) функции (смотрите "
"раздел \"Вызовы\" :ref:`calls` ) :"

msgid "A user-defined function object is created by a function definition (see section :ref:`function`).  It should be called with an argument list containing the same number of items as the function's formal parameter list."
msgstr ""
"Объект функции определяемой пользователем создаётся определением функции "
"(смотрите раздел “Определения функций” :ref:`function` ). Её следует "
"вызывать со списком, содержащим ровно то же количество аргументов, что и в "
"списке формальных параметров этой функции."

msgid "Special attributes:"
msgstr "Специальные атрибуты :"

msgid "Attribute"
msgstr "Атрибут"

msgid "Meaning"
msgstr "Смысл"

msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

msgid "The function's documentation string, or ``None`` if unavailable"
msgstr ""
"Строка описания (“документации”) данной функции, или иначе значение "
":const:`None` ."

msgid "Writable"
msgstr "Изменяемый"

msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

msgid "The function's name"
msgstr "Имя данной функции."

msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

msgid "The name of the module the function was defined in, or ``None`` if unavailable."
msgstr ""
"Имя модуля, в котором данная функция была определена, или иначе значение "
":const:`None` ."

msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

msgid "A tuple containing default argument values for those arguments that have defaults, or ``None`` if no arguments have a default value"
msgstr ""
"Кортеж, содержащий значения по умолчанию для аргументов, для которых они "
"определены, или значение :const:`None` , если нет аргументов со значением по "
"умолчанию."

msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

msgid "The code object representing the compiled function body."
msgstr "Объект кода, представляющий компилированное тело данной функции."

msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

msgid "A reference to the dictionary that holds the function's global variables --- the global namespace of the module in which the function was defined."
msgstr ""
"Ссылка на словарь, содержащий глобальные переменные данной функции — "
"глобальная область имён того модуля, в котором данная функция была "
"определена."

msgid "Read-only"
msgstr "Неизменяемый"

msgid ":attr:`__dict__`"
msgstr ":attr:`__dict__`"

msgid "The namespace supporting arbitrary function attributes."
msgstr "Пространство имён для поддержки произвольных атрибутов данной функции."

msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

msgid "``None`` or a tuple of cells that contain bindings for the function's free variables."
msgstr ""
"«:const:`None`» или кортеж ячеек, содержащих назначения для тех переменных "
"данной функции, которые более нигде не связаны (тоесть, “замыкание”) ."

msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

msgid "A dict containing annotations of parameters.  The keys of the dict are the parameter names, or ``'return'`` for the return annotation, if provided."
msgstr ""
"Словарь, содержащий описания параметров. Ключи этого словаря совпадают с "
"именами параметров к этой функции, также может присутствовать ключ "
"«``'return'``» для соответствующего описания ."

msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

msgid "A dict containing defaults for keyword-only parameters."
msgstr ""
"Словарь, содержащий значения по умолчанию для параметров, доступных только "
"по имени."

msgid "Most of the attributes labelled \"Writable\" check the type of the assigned value."
msgstr ""
"Большинство атрибутов помеченных “Изменяемый” проверяют тип записываемого в "
"них значения."

msgid "Function objects also support getting and setting arbitrary attributes, which can be used, for example, to attach metadata to functions.  Regular attribute dot-notation is used to get and set such attributes. *Note that the current implementation only supports function attributes on user-defined functions. Function attributes on built-in functions may be supported in the future.*"
msgstr ""
"Объекты-функции также поддерживают получение и установку произвольных "
"атрибутов, которые могут быть использованы, например, для прикрепления "
"метаданных к функциям. Для получения и установки таких атрибутов "
"используется стандартная запись атрибутов через точку. Обратите внимание, "
"что текущая реализация поддерживает только атрибуты пользовательских "
"функций. Атрибуты встроенных функций могут быть реализованы в будущем."

msgid "Additional information about a function's definition can be retrieved from its code object; see the description of internal types below."
msgstr ""
"Дополнительная информация об определении функции может быть получена из ее "
"объекта-кода; смотрите описание встроенных типов ниже."

msgid "An instance method object combines a class, a class instance and any callable object (normally a user-defined function)."
msgstr ""
"Объект метода экземпляра сочетает в себе класс, экземпляр класса и любой "
"вызываемый объект (обычно - функция, определяемая пользователем) ."

msgid "Special read-only attributes: :attr:`__self__` is the class instance object, :attr:`__func__` is the function object; :attr:`__doc__` is the method's documentation (same as ``__func__.__doc__``); :attr:`__name__` is the method name (same as ``__func__.__name__``); :attr:`__module__` is the name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""
"Специальные атрибуты, доступные только для чтения : «:attr:`__self__`» это "
"данный объект экземпляра класса, «:attr:`__func__`» это данный объект "
"функции; «:attr:`__doc__`» это описание данного метода (то же, что и "
"«``__func__.__doc__``»); «:attr:`__name__`» это имя данного метода (то же, "
"что и «``__func__.__name__``»); «:attr:`__module__`» это имя того модуля, в "
"котором данный метод был определен, или, если не применимо - «:const:`None`» "
"."

msgid "Methods also support accessing (but not setting) the arbitrary function attributes on the underlying function object."
msgstr ""
"Методы также поддерживают доступ (но не запись) к произвольному атрибуту "
"функции в объекте соответствующей функции."

#, fuzzy
msgid "User-defined method objects may be created when getting an attribute of a class (perhaps via an instance of that class), if that attribute is a user-defined function object or a class method object."
msgstr ""
"Определяемые пользователем объекты методы могут быть созданы при получении "
"атрибутов класса (возможно, через какой-либо экземпляр этого класса), если "
"этот атрибут является пользовательским объектом функцией или объектом метода "
"класса."

#, fuzzy
msgid "When an instance method object is created by retrieving a user-defined function object from a class via one of its instances, its :attr:`__self__` attribute is the instance, and the method object is said to be bound.  The new method's :attr:`__func__` attribute is the original function object."
msgstr ""
"Когда объект метода экземпляра создается путем получения пользовательского "
"объекта функции из какого-либо класса через один из его экземпляров, его "
"атрибут «:attr:`__self__`» является этим же экземпляром, и этот объект "
"метода называется связанным. Атрибут «:attr:`__func__`» этого нового метода "
"является оригинальным объектом функции."

#, fuzzy
msgid "When a user-defined method object is created by retrieving another method object from a class or instance, the behaviour is the same as for a function object, except that the :attr:`__func__` attribute of the new instance is not the original method object but its :attr:`__func__` attribute."
msgstr ""
"Когда определяемый пользователем метод создается путем извлечения другого "
"объекта метода из класса или экземпляра, его поведение остается таким же, "
"как у функционального объекта, за исключением того, что атрибут "
"«:attr:`__func__`» нового экземпляра является не исходным методом объекта, а "
"его атрибутом «:attr:`__func__`» ."

#, fuzzy
msgid "When an instance method object is created by retrieving a class method object from a class or instance, its :attr:`__self__` attribute is the class itself, and its :attr:`__func__` attribute is the function object underlying the class method."
msgstr ""
"Когда объект экземпляра метода создается путем извлечения метода класса "
"объекта из класса или экземпляра, его атрибут :attr:`__self__` - это сам "
"класс, а его атрибут :attr:`__func__` - это объект функции лежащей в основе "
"метода класса."

#, fuzzy
msgid "When an instance method object is called, the underlying function (:attr:`__func__`) is called, inserting the class instance (:attr:`__self__`) in front of the argument list.  For instance, when :class:`C` is a class which contains a definition for a function :meth:`f`, and ``x`` is an instance of :class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"Когда вызывается объект метода экземпляра, вызывается содержащаяся в его "
"основе функция (:attr:`__func__`), помещающая экземпляр класса "
"(:attr:`__self__`) в начало списка аргументов. Например, если ``C`` - класс, "
"содержащий определение функции ``f()``, а ``x`` - экземпляр класса ``C`` , "
"вызов ``x.f(1)`` эквивалентен вызову ``C.f(x, 1)`` ."

msgid "When an instance method object is derived from a class method object, the \"class instance\" stored in :attr:`__self__` will actually be the class itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"Если метод экземпляра не определён в этом экземпляре, а унаследован от "
"метода класса, то атрибут «:attr:`__self__`» на самом деле будет указывать "
"не на этот экземпляр класса, а непосредственно на сам класс, и, таким "
"образом, вызов и «``x.f(1)``» и «``C.f(1)``» является эквивалентом вызову "
"«``f(C,1)``» , где «``f``» - соответствующая функция."

msgid "Note that the transformation from function object to instance method object happens each time the attribute is retrieved from the instance.  In some cases, a fruitful optimization is to assign the attribute to a local variable and call that local variable. Also notice that this transformation only happens for user-defined functions; other callable objects (and all non-callable objects) are retrieved without transformation.  It is also important to note that user-defined functions which are attributes of a class instance are not converted to bound methods; this *only* happens when the function is an attribute of the class."
msgstr ""
"Заметьте, что преобразование из объекта функции в объект метода экземпляра "
"происходит каждый раз при извлечении атрибута из экземпляра. В некоторых "
"случаях эффективной оптимизацией является назначение атрибута локальной "
"переменной и вызов этой локальной переменной. Также учитывайте, что это "
"преобразование выполняется только для функций, определенных пользователем; "
"прочие вызываемые объекты (и все невызываемые объекты) извлекаются без "
"преобразования. Важно заметить, что такие определенные пользователем "
"функции, которые являются атрибутами экземпляров классов, не преобразуются в "
"связанные методы; это происходит **только** если функция является атрибутом "
"класса."

msgid "A function or method which uses the :keyword:`yield` statement (see section :ref:`yield`) is called a :dfn:`generator function`.  Such a function, when called, always returns an iterator object which can be used to execute the body of the function:  calling the iterator's :meth:`__next__` method will cause the function to execute until it provides a value using the :keyword:`yield` statement.  When the function executes a :keyword:`return` statement or falls off the end, a :exc:`StopIteration` exception is raised and the iterator will have reached the end of the set of values to be returned."
msgstr ""
"Функция или метод, задействующие инструкцию «:keyword:`yield`» (смотрите "
"раздел “Инструкция «yield»” :ref:`yield` ) , называется : функция-генератор "
"(:dfn:`generator function`) . При вызове такая функция всегда возвращает "
"объект-итератор, который может быть использован для выполнения тела функции "
"– вызов метода «:meth:`__next__`» данного итератора приведёт к исполнению "
"данной функции, пока она предоставляет какое-либо значение с использованием "
"инструкции «:keyword:`yield`» . Когда данная функция исполняет инструкцию "
"«:keyword:`return`» или достигает своего конца – вызывается исключение "
"«:exc:`StopIteration`» – и объект-итератор таким образом достигнет конца "
"множества значений, которые он должен выдать."

msgid "A built-in function object is a wrapper around a C function.  Examples of built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a standard built-in module). The number and type of the arguments are determined by the C function. Special read-only attributes: :attr:`__doc__` is the function's documentation string, or ``None`` if unavailable; :attr:`__name__` is the function's name; :attr:`__self__` is set to ``None`` (but see the next item); :attr:`__module__` is the name of the module the function was defined in or ``None`` if unavailable."
msgstr ""
"Объект - встроенная функция – это посредник к функции на “C” . Примерами "
"встроенных функций являются : «:func:`len`» и «:func:`math.sin`» ( "
"«:mod:`math`» – стандартный встроенный модуль) . Количество и тип её "
"аргументов определяется соответствующей функцией на “C” . Особые доступные "
"только для чтения атрибуты : «:attr:`__doc__`» – текст документации данной "
"функции или иначе «:const:`None`» ; «:attr:`__name__`» – имя данной функции; "
"«attr:`__self__`» – установлен в «:const:`None`» (но далее смотрите об этом "
"подробнее) ; «:attr:`__module__`» – имя модуля, в котором определена данная "
"функция или иначе «:const:`None`» ."

msgid "This is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument.  An example of a built-in method is ``alist.append()``, assuming *alist* is a list object. In this case, the special read-only attribute :attr:`__self__` is set to the object denoted by *list*."
msgstr ""
"Это, по сути, другое обличие встроенных функций, которые в этом случае имеют "
"дополнительный аргумент, передаваемый в функцию на “C” неявно. Примером "
"встроенного метода является «``alist.append()``» , где *alist* – это "
"объект-список. В таком случае особый предназначенный только для чтения "
"атрибут «:attr:`__self__`» содержит указание на этот объект *alist* ."

msgid "Classes are callable.  These objects normally act as factories for new instances of themselves, but variations are possible for class types that override :meth:`__new__`.  The arguments of the call are passed to :meth:`__new__` and, in the typical case, to :meth:`__init__` to initialize the new instance."
msgstr ""
"Классы являются вызываемыми (исполняемыми) объектами. Как правило, они "
"работают как фабрики для новых собственных экземпляров класса, при этом "
"генерация может проходить с вариациями у таких типов классов, в которых "
"переопределён метод «:meth:`__new__`» . Аргументы вызова передаются методу "
"«:meth:`__new__`» и, как правило, методу «:meth:`__init__`» для "
"инициализации нового экземпляра."

msgid "Instances of arbitrary classes can be made callable by defining a :meth:`__call__` method in their class."
msgstr ""
"Экземпляры любого класса могут быть сделаны вызываемыми (исполнимыми) "
"посредством определения метода «:meth:`__call__`» в их классе."

msgid "Modules are imported by the :keyword:`import` statement (see section :ref:`import`). A module object has a namespace implemented by a dictionary object (this is the dictionary referenced by the __globals__ attribute of functions defined in the module).  Attribute references are translated to lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module object does not contain the code object used to initialize the module (since it isn't needed once the initialization is done)."
msgstr ""
"Модули импортируются с помощью инструкции :keyword:`import` (смотрите раздел "
": “Инструкция «import»” :ref:`import` ). Объект модуль имеет область имён "
"реализованую в виде объекта словарь в атрибуте «:attr:`__dict__`» (это тот "
"самый словарь, на который ссылается атрибут «:attr:`__globals__`» функций "
"определеных в этом модуле). Упоминания атрибутов преобразуются в поиск в "
"этом словаре, например, «``m.x``» эквивалентно «``m.__dict__[\"x\"]``» . "
"Объект модуль не содержит объект код, используемый для инициализации этого "
"модуля (поскольку инициализация уже произведена, и он больше не может "
"понадобиться)."

msgid "Attribute assignment updates the module's namespace dictionary, e.g., ``m.x = 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"Назначение атрибуту, по сути, обновляет словарь области имён модуля, "
"например «``m.x = 1``» эквивалентно «``m.__dict__[\"x\"] = 1``» ."

msgid "Special read-only attribute: :attr:`__dict__` is the module's namespace as a dictionary object."
msgstr ""
"Специальный атрибут только для чтения : «:attr:`__dict__`» - область имён "
"модуля, в виде объекта словарь."

msgid "Predefined (writable) attributes: :attr:`__name__` is the module's name; :attr:`__doc__` is the module's documentation string, or ``None`` if unavailable; :attr:`__file__` is the pathname of the file from which the module was loaded, if it was loaded from a file. The :attr:`__file__` attribute is not present for C modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file."
msgstr ""
"Предопределённые изменяемые атрибуты : «:attr:`__name__`» - имя данного "
"модуля; «:attr:`__doc__`» - строка описания данного модуля, или иначе "
"значение «:const:`None`» ; «:attr:`__file__`» - путь файла, из которого "
"загружен данный модуль, если он был загружен из файла. Атрибут "
"«:attr:`__file__`» отсутствует в модулях на “C” , которые статически "
"прилинкованы к интерпретатору; для модулей расширений, подгруженных "
"динамически из общих библиотек - он является путём файла соответствующей "
"общей библиотеки."

msgid "Custom class types are typically created by class definitions (see section :ref:`class`).  A class has a namespace implemented by a dictionary object. Class attribute references are translated to lookups in this dictionary, e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a number of hooks which allow for other means of locating attributes). When the attribute name is not found there, the attribute search continues in the base classes. This search of the base classes uses the C3 method resolution order which behaves correctly even in the presence of 'diamond' inheritance structures where there are multiple inheritance paths leading back to a common ancestor. Additional details on the C3 MRO used by Python can be found in the documentation accompanying the 2.3 release at http://www.python.org/download/releases/2.3/mro/."
msgstr ""
"Типы определяемых классов, как правило, создаются определением класса "
"(смотрите раздел “Определения классов”  ). Класс имеет область имён "
"реализованую в виде объекта словарь. Указания атрибутов класса преобразуются "
"в поиск в этом словаре, например, «``C.x``» заменяется на "
"«``C.__dict__[\"x\"]``» (хотя есть ряд трюков, которые позволяют разместить "
"атрибуты другим путём). Когда имя данного атрибута там не найдено, поиск "
"атрибута продолжается в базовых классах. Такой поиск базовых классов "
"использует порядок разрешения метода “C3”, который ведет себя правильно, "
"даже в случае структуры наследования типа “diamond” , тоесть, где есть "
"несколько путей наследования сходящихся обратно к одному общему предку. "
"Дополнительную информацию об “C3 MRO” можно найти в документации, "
"сопровождающей релиз 2.3 по адресу : "
"http://www.python.org/download/releases/2.3/mro/  ."

msgid "When a class attribute reference (for class :class:`C`, say) would yield a class method object, it is transformed into an instance method object whose :attr:`__self__` attributes is :class:`C`.  When it would yield a static method object, it is transformed into the object wrapped by the static method object. See section :ref:`descriptors` for another way in which attributes retrieved from a class may differ from those actually contained in its :attr:`__dict__`."
msgstr ""
"Когда указание на атрибут класса (назовём класс “C”) должно давать объект - "
"метод класса – он преобразуется в объект - метод экземпляра, чей атрибут "
"«:attr:`__self__`» имеет значение «``C``» . А когда это указание должно "
"давать объект - статический метод – он преобразуется в тот же объект "
"“обёрнутый” объектом - статическим методом. Другие варианты, того как "
"атрибуты, получаемые из класса, могут отличаться от реально содержащихся в "
"их атрибуте «:attr:`__dict__`» – смотрите в разделе “Реализация "
"дескрипторов” :ref:`descriptors` ."

msgid "Class attribute assignments update the class's dictionary, never the dictionary of a base class."
msgstr ""
"Запись значений в атрибуты класса модифицирует словарь этого класса, но ни в "
"коем случае не соответствующий словарь базового класса."

msgid "A class object can be called (see above) to yield a class instance (see below)."
msgstr ""
"Объект класс может быть вызван (запущен на исполнение), как упомянуто выше, "
"чтобы сгенерировать экземпляр класса (смотрите ниже)."

msgid "Special attributes: :attr:`__name__` is the class name; :attr:`__module__` is the module name in which the class was defined; :attr:`__dict__` is the dictionary containing the class's namespace; :attr:`__bases__` is a tuple (possibly empty or a singleton) containing the base classes, in the order of their occurrence in the base class list; :attr:`__doc__` is the class's documentation string, or None if undefined."
msgstr ""
"Специальные атрибуты: «:attr:`__name__`» - имя класса; «:attr:`__module__`» "
"- имя модуля, в котором был определен этот класс; «:attr:`__dict__`» - "
"словарь, содержащий область имён этого класса; «:attr:`__bases__`» - кортеж "
"(возможно, пустой или с одним элементом (“singleton”)), содержащий базовые "
"классы, в порядке их появления в списке базовых классов; «:attr:`__doc__`» - "
"строка описания данного класса, или иначе значение «:const:`None`» ."

msgid "A class instance is created by calling a class object (see above).  A class instance has a namespace implemented as a dictionary which is the first place in which attribute references are searched.  When an attribute is not found there, and the instance's class has an attribute by that name, the search continues with the class attributes.  If a class attribute is found that is a user-defined function object, it is transformed into an instance method object whose :attr:`__self__` attribute is the instance.  Static method and class method objects are also transformed; see above under \"Classes\".  See section :ref:`descriptors` for another way in which attributes of a class retrieved via its instances may differ from the objects actually stored in the class's :attr:`__dict__`.  If no class attribute is found, and the object's class has a :meth:`__getattr__` method, that is called to satisfy the lookup."
msgstr ""
"Экземпляр класса создается путем вызова объекта класс (см. выше). Экземпляр "
"класса имеет область имён, реализованную в виде словаря, который является "
"первым местом, в котором ищутся атрибуты. Если атрибут здесь не найден, а "
"класс этого экземпляра имеет атрибут с таким именем, поиск продолжается в "
"атрибутах класса. Если становится известно, что некий атрибут класса "
"является объектом функцией пользователя, он преобразуется в объект метод "
"экземпляра, чей атрибут «:attr:`__self__`» является тем экземпляром. "
"Статические методы и объекты методы класса также преобразуются, см. выше в "
"разделе “Классы” . Смотрите также в разделе “Реализация дескрипторов” "
":ref:`descriptors` другой вариант того как атрибуты класса, полученного "
"через его экземпляры, могут отличаться от объектов, на самом деле хранящихся "
"в атрибуте «:attr:`__dict__`» этого класса. Если атрибут класса не найден, "
"но класс этого объекта имеет метод «:meth:`__getattr__`» , то этот метод "
"вызывается и возвращаемое им значение возвращается в качестве значения "
"искомого атрибута."

msgid "Attribute assignments and deletions update the instance's dictionary, never a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:`__delattr__` method, this is called instead of updating the instance dictionary directly."
msgstr ""
"Запись значения в атрибуты и их удаление обновляют словарь экземпляра. Если "
"класс имеет методы «:meth:`__setattr__`» или «:meth:`__delattr__`» , то "
"вызываются они - вместо обновления словаря экземпляра напрямую."

msgid "Class instances can pretend to be numbers, sequences, or mappings if they have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Экземпляры класса могут вести себя как числа, последовательности или "
"отображения, если у них есть методы с определёнными специальными именами. "
"См. раздел “Имена специальных методов” :ref:`specialnames` ."

msgid "Special attributes: :attr:`__dict__` is the attribute dictionary; :attr:`__class__` is the instance's class."
msgstr ""
"Специальные атрибуты: «:attr:`__dict__`» - словарь атрибутов; "
"«:attr:`__class__`» - класс данного экземпляра."

msgid "A file object represents an open file.  Various shortcuts are available to create file objects: the :func:`open` built-in function, and also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`makefile` method of socket objects (and perhaps by other functions or methods provided by extension modules)."
msgstr ""
"Файловый объект представляет собой открытый файл. Файловые объекты создаются "
"встроенной функцией «:func:`open`» , а также функциями «:func:`os.popen`» , "
"«:func:`os.fdopen`» , и методом «:meth:`makefile`» объектов сокетов (и, "
"возможно, другими функциями или методами, предоставляемыми модулями "
"расширения )."

msgid "The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to file objects corresponding to the interpreter's standard input, output and error streams; they are all open in text mode and therefore follow the interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Объекты «:obj:`sys.stdin`», «:obj:`sys.stdout`» и «:obj:`sys.stderr`» "
"инициализируются в файловые объекты, соответствующие стандартным потокам "
"ввода, вывода и ошибок интерпретатора. Все они открыты в текстовом режиме, "
"и, таким образом, соответствуют интерфейсу, определённому в абстрактном "
"классе «:class:`io.TextIOBase`» ."

msgid "A few types used internally by the interpreter are exposed to the user. Their definitions may change with future versions of the interpreter, but they are mentioned here for completeness."
msgstr ""
"Несколько типов, используемых для внутренних целей интерпретатором, "
"предоставяются пользователю. Их определения могут измениться в будущих "
"версиях интерпретатора, но они упоминаются здесь для полноты."

msgid "Code objects represent *byte-compiled* executable Python code, or :term:`bytecode`. The difference between a code object and a function object is that the function object contains an explicit reference to the function's globals (the module in which it was defined), while a code object contains no context; also the default argument values are stored in the function object, not in the code object (because they represent values calculated at run-time).  Unlike function objects, code objects are immutable and contain no references (directly or indirectly) to mutable objects."
msgstr ""
"Объекты кода представляют собой скомпилированный в байт-код "
"(:term:`bytecode`) исполняемый код Питона. Разница между объектом кода и "
"объектом функции заключается в том, что объект функции содержит явное "
"указание на область имён, в которой содержатся глобальные переменные функции "
"(модуль, в котором она была определена), а объект кода не содержит указания "
"на такой контекст; также в объекте функции хранятся значения по умолчанию "
"аргументов, а в объекте кода их нет (так как они представляют собой "
"значения, рассчитываемые во время выполнения). В отличие от объектов "
"функций, объекты кода являются неизменяемыми и не содержать ссылок (прямо "
"или косвенно) на изменяемые объекты."

msgid "Special read-only attributes: :attr:`co_name` gives the function name; :attr:`co_argcount` is the number of positional arguments (including arguments with default values); :attr:`co_nlocals` is the number of local variables used by the function (including arguments); :attr:`co_varnames` is a tuple containing the names of the local variables (starting with the argument names); :attr:`co_cellvars` is a tuple containing the names of local variables that are referenced by nested functions; :attr:`co_freevars` is a tuple containing the names of free variables; :attr:`co_code` is a string representing the sequence of bytecode instructions; :attr:`co_consts` is a tuple containing the literals used by the bytecode; :attr:`co_names` is a tuple containing the names used by the bytecode; :attr:`co_filename` is the filename from which the code was compiled; :attr:`co_firstlineno` is the first line number of the function; :attr:`co_lnotab` is a string encoding the mapping from bytecode offsets to line numbers (for details see the source code of the interpreter); :attr:`co_stacksize` is the required stack size (including local variables); :attr:`co_flags` is an integer encoding a number of flags for the interpreter."
msgstr ""
"Специальные атрибуты только для чтения: :attr:`co_name` содержит имя данной "
"функции; :attr:`co_argcount` это количество позиционных аргументов (в том "
"числе аргументов со значениями по умолчанию); :attr:`co_nlocals` это число "
"локальных переменных, используемых функцией (включая аргументы); "
":attr:`co_varnames` кортеж, содержащий имена локальных переменных (начиная с "
"имен аргументов); :attr:`co_cellvars` кортеж, содержащий имена локальных "
"переменных, на которые ссылаются вложенные функции; :attr:`co_freevars` "
"кортеж, содержащий имена свободных (нигде более не связанных) переменных; "
":attr:`co_code` строка, представляющая последовательность байт-код "
"инструкций; :attr:`co_consts` кортеж, содержащий непосредственные данные "
"используемые байт-кодом; :attr:`co_names` кортеж, содержащий имена, "
"используемые байт-кодом; :attr:`co_filename` имя файла, из которого код был "
"скомпилирован; :attr:`co_firstlineno` номер первой строки функции; "
":attr:`co_lnotab` текст, кодирующий соответствие смещения байт-кодов номерам "
"строк текста программы (подробнее см. исходный код интерпретатора); "
":attr:`co_stacksize` требуемый размер стека (включая локальные переменные); "
":attr:`co_flags` целое число, в котором закодировано некоторое количество "
"параметров(флагов) интерпретатора."

msgid "The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is set if the function uses the ``*arguments`` syntax to accept an arbitrary number of positional arguments; bit ``0x08`` is set if the function uses the ``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is set if the function is a generator."
msgstr ""
"Следующие сигнальные биты определены внутри :attr:`co_flags` : бит ``0x04`` "
"установлен, если данная функция использует синтаксис ``*arguments`` для "
"принятия произвольного количеотва позиционных аргументов; бит ``0x08`` "
"установлен, если данная функция использует синтаксис ``**keywords`` для "
"принятия произвольных именованных аргументов; бит ``0x20`` установлен, если "
"функция является генератором."

msgid "Future feature declarations (``from __future__ import division``) also use bits in :attr:`co_flags` to indicate whether a code object was compiled with a particular feature enabled: bit ``0x2000`` is set if the function was compiled with future division enabled; bits ``0x10`` and ``0x1000`` were used in earlier versions of Python."
msgstr ""
"Инструкция ``from __future__ import division`` также использует биты в "
":attr:`co_flags` для обозначения того, был ли объект-код скомпилирован со "
"включенными определёнными свойствами. Так, бит ``0x2000`` установлен, если "
"данная функция скомпилирована с задействованием ``future division`` . Биты "
"``0x10`` и ``0x1000`` использовались в более ранних версиях Питона."

msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""
"Другие биты в :attr:`co_flags` - зарезервированы для внутреннего "
"использования."

msgid "If a code object represents a function, the first item in :attr:`co_consts` is the documentation string of the function, or ``None`` if undefined."
msgstr ""
"Если объект кода является функцией, то первый элемент в :attr:`co_consts` "
"содержит текст описания (документацию) данной функции, или значение "
"«:const:`None`» ."

msgid "Frame objects represent execution frames.  They may occur in traceback objects (see below)."
msgstr ""
"Объекты-:term:`кадры<execution frame object>` реализуют кадры исполнения. "
"Они могут встречаться в :term:`объектах раскрутки стека<traceback object>` "
"(смотри́те далее) ."

msgid "Special read-only attributes: :attr:`f_back` is to the previous stack frame (towards the caller), or ``None`` if this is the bottom stack frame; :attr:`f_code` is the code object being executed in this frame; :attr:`f_locals` is the dictionary used to look up local variables; :attr:`f_globals` is used for global variables; :attr:`f_builtins` is used for built-in (intrinsic) names; :attr:`f_lasti` gives the precise instruction (this is an index into the bytecode string of the code object)."
msgstr ""
"Специальные атрибуты только для чтения: :attr:`f_back` указывает предыдущий "
"кадр стека (в сторону вызывающего), или «:const:`None`» если это дно стека; "
":attr:`f_code` является объектом-кодом, выполняющимся в данном кадре; "
":attr:`f_locals` является словарём, использующимся для поиска локальных "
"переменных; :attr:`f_globals` используется для глобальных переменных; "
":attr:`f_builtins` используется для встроенных (внутренних) имён; "
":attr:`f_lasti` дает точные инструкции (это индекс в массиве байт-кода у "
"объекта кода) ."

msgid "Special writable attributes: :attr:`f_trace`, if not ``None``, is a function called at the start of each source code line (this is used by the debugger); :attr:`f_lineno` is the current line number of the frame --- writing to this from within a trace function jumps to the given line (only for the bottom-most frame).  A debugger can implement a Jump command (aka Set Next Statement) by writing to f_lineno."
msgstr ""
"Специальные перезаписываемые атрибуты: «:attr:`f_trace`» , если не "
"«:const:`None`» , является функцией, вызываемою в начале каждой строки "
"исходного кода (это используется отладчиком); «:attr:`f_lineno`» содержит "
"номер текущей строки кадра – запись сюда изнутри функции отслеживания "
"(трассирования) приводит к переходу на данную строку (только для самого "
"нижнего кадра) . Отладчик может реализовать команду “Jump” , путём записи в "
"«:attr:`f_lineno`» ."

msgid "Traceback objects represent a stack trace of an exception.  A traceback object is created when an exception occurs.  When the search for an exception handler unwinds the execution stack, at each unwound level a traceback object is inserted in front of the current traceback.  When an exception handler is entered, the stack trace is made available to the program. (See section :ref:`try`.) It is accessible as the third item of the tuple returned by ``sys.exc_info()``. When the program contains no suitable handler, the stack trace is written (nicely formatted) to the standard error stream; if the interpreter is interactive, it is also made available to the user as ``sys.last_traceback``."
msgstr ""
"Объекты раскрутки стека представляют раскрутку стека исключений. Объект "
"раскрутки стека создается при возникновении исключения. Когда поиск "
"обработчика исключения раскручивает стек вызовов, на каждом уровне новый "
"объект раскрутки стека вставляется перед текущим. Когда обработчик "
"исключения найден, раскрутка стека делается доступной для программы. "
"(Смотри́те раздел :ref:`try` .) Она доступна в качестве третьего элемента "
"кортежа, возвращаемого :func:`sys.exc_info` . Если программа не содержит "
"подходящего обработчика, раскрутка стека выводится (в удобно оформленном "
"виде) в стандартный поток ошибок, а если интерпретатор в интерактивном "
"режиме, то она также доступна пользователю через :data:`sys.last_traceback` "
"."

msgid "Special read-only attributes: :attr:`tb_next` is the next level in the stack trace (towards the frame where the exception occurred), or ``None`` if there is no next level; :attr:`tb_frame` points to the execution frame of the current level; :attr:`tb_lineno` gives the line number where the exception occurred; :attr:`tb_lasti` indicates the precise instruction.  The line number and last instruction in the traceback may differ from the line number of its frame object if the exception occurred in a :keyword:`try` statement with no matching except clause or with a finally clause."
msgstr ""
"Специальные атрибуты только для чтения: «:attr:`tb_next`» указывает "
"следующий уровень в стеке (в сторону кадра, где произошло исключение) , или "
"«:const:`None`» , если нет следующего уровня; «:attr:`tb_frame`» указывает "
"на кадр исполнения текущего уровня; «:attr:`tb_lineno`» дает номер строки, "
"где произошло исключение; «:attr:`tb_lasti`» указывает точную инструкцию. "
"Номер строки и последняя команда в раскрутке может отличаться от номера "
"строки соответствующего объекта кадра, если исключение произошло в "
"инструкции «:keyword:`try`» не имеющей соответствующей ветви "
"«:keyword:`except`» , или с ветвью «:keyword:`finally`» ."

msgid "Slice objects are used to represent slices for :meth:`__getitem__` methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Объекты-срезы используются для хранения параметров для операции среза "
"(которая может быть явно вызвана через метод «:meth:`__getitem__`» ) . "
"Объект-срез также может быть создан встроенной функцией «:func:`slice`» ."

msgid "Special read-only attributes: :attr:`start` is the lower bound; :attr:`stop` is the upper bound; :attr:`step` is the step value; each is ``None`` if omitted. These attributes can have any type."
msgstr ""
"Особые атрибуты только для чтения::attr:`start` - нижняя "
"граница;:attr:`stop` - верхняя граница;:attr:`step` - значение шага;все они "
"по умолчанию имеют значение «:const:`None`» . Эти атрибуты могут быть любого "
"типа."

msgid "Slice objects support one method:"
msgstr "Объекты-срезы поддерживают один метод:"

msgid "This method takes a single integer argument *length* and computes information about the slice that the slice object would describe if applied to a sequence of *length* items.  It returns a tuple of three integers; respectively these are the *start* and *stop* indices and the *step* or stride length of the slice. Missing or out-of-bounds indices are handled in a manner consistent with regular slices."
msgstr ""
"Этот метод принимает один аргумент - целое число *length* и преобразовывает "
"параметры среза (пропущенные, выходящие за границы (отрицательные или "
"превышающие)) так, как они были бы преобразованы будучи применёнными (к "
"любой) последовательности длины *length* (т. е. , например, граница среза, "
"превышающая длину, заменяется на эту длину). Именно это преобразование "
"производится при обычной записи срезов. Этот метод возвращает кортеж из 3 "
"целых чисел, являющихся соответственно параметрами *start*, *stop*, *step* ."

msgid "Static method objects provide a way of defeating the transformation of function objects to method objects described above. A static method object is a wrapper around any other object, usually a user-defined method object. When a static method object is retrieved from a class or a class instance, the object actually returned is the wrapped object, which is not subject to any further transformation. Static method objects are not themselves callable, although the objects they wrap usually are. Static method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Статические методы обеспечивают способ предотвращения преобразования функций "
"в методы, описанные выше. Статические методы могут быть посредниками "
"(“обертками”) для любых других объектов, обычно для определяемых "
"пользователем методов. Когда статический метод запрашивается из класса или "
"экземпляра класса, то фактически возвращается объект, к которому тот "
"является посредником (т.е. “обёрнутый объект”), если он в свою очередь не "
"подлежит дальнейшей трансформации. Статические методы сами не являются "
"исполнимыми, хотя те объекты, к которым они явлвются посредниками - обычно "
"явлвются. Статические методы создаются при помощи встроенного конструктора "
":func:`staticmethod` ."

msgid "A class method object, like a static method object, is a wrapper around another object that alters the way in which that object is retrieved from classes and class instances. The behaviour of class method objects upon such retrieval is described above, under \"User-defined methods\". Class method objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"Метод класса, как и статический метод, является посредником к другому "
"объекту, изменяющим способ, которым этот объект извлекается из классов и "
"экземпляров класса. Поведение метода класса при таком доступе описано выше, "
"в разделе “Определяемые пользователем методы” . Методы классов создаются при "
"помощи встроенного конструктора :func:`classmethod` ."

msgid "Special method names"
msgstr "Имена спецальных методов"

msgid "A class can implement certain operations that are invoked by special syntax (such as arithmetic operations or subscripting and slicing) by defining methods with special names. This is Python's approach to :dfn:`operator overloading`, allowing classes to define their own behavior with respect to language operators.  For instance, if a class defines a method named :meth:`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where mentioned, attempts to execute an operation raise an exception when no appropriate method is defined (typically :exc:`AttributeError` or :exc:`TypeError`)."
msgstr ""
"Класс может реализовывать определенные операции, которые вызываются при "
"использовании специального синтаксиса (например, арифметические операции или "
"индексаця и срезы), путем определения методов со специальными именами. Это "
"Питоновский подход к переопределению операторов, позволяющему классам "
"определять их собственное поведение по отношению к операторам языка. "
"Например, если класс определяет метод под названием «:meth:`__getitem__`» и "
"«``x``» экземпляр этого класса, то «``x[i]``» приблизительно равно "
"«``type(x).__getitem__(x, i)``» . За исключением тех случаев, где это особо "
"оговорено – попытки исполнять операции вызывают исключение, если не "
"определено соответствующего метода (обычно :exc:`AttributeError` или "
":exc:`TypeError` ) ."

msgid "When implementing a class that emulates any built-in type, it is important that the emulation only be implemented to the degree that it makes sense for the object being modelled.  For example, some sequences may work well with retrieval of individual elements, but extracting a slice may not make sense.  (One example of this is the :class:`NodeList` interface in the W3C's Document Object Model.)"
msgstr ""
"При реализации класса, который эмулирует любой встроенный тип, важно, что "
"эмуляция должна быть реализована только в той степени, в какой это имеет "
"значение для моделируемого объекта. Например, некоторые последовательности "
"могут хорошо работать с извлечением отдельных элементов, но срезы могут не "
"иметь смысла. (Одним из примеров этого является интерфейс :class:`NodeList` "
"в “W3C’s Document Object Model” .)"

msgid "Basic customization"
msgstr "Основные средства настройки классов"

msgid "Called to create a new instance of class *cls*.  :meth:`__new__` is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument.  The remaining arguments are those passed to the object constructor expression (the call to the class).  The return value of :meth:`__new__` should be the new object instance (usually an instance of *cls*)."
msgstr ""
"Вызывается для создания нового экземпляра класса (назовём *cls*) . "
":meth:`__new__` – это статический метод (специальный, создаваемый "
"автоматически) , который принимает в качестве первого аргумента класс, "
"экземпляр которого требуется вернуть. Остальные аргументы такие же, какие "
"передаются конструктору этого же объекта (в выражении «``cls()``» ) . "
"«:meth:`__new__`» должен возвращать новый экземпляр объекта ( обычно "
"экземпляр класса *cls* ) ."

msgid "Typical implementations create a new instance of the class by invoking the superclass's :meth:`__new__` method using ``super(currentclass, cls).__new__(cls[, ...])`` with appropriate arguments and then modifying the newly-created instance as necessary before returning it."
msgstr ""
"Обычно применяется для создания нового экземпляра класса через вызов метода "
"«:meth:`__new__`» у “суперкласса” данного класса, вызывая "
"«``super(currentclass, cls).__new__(cls[, ...])``» с соответствующими "
"аргументами, и затем модифицируя (при необходимости) новосозданный экземпляр "
"перед его возвращением."

msgid "If :meth:`__new__` returns an instance of *cls*, then the new instance's :meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where *self* is the new instance and the remaining arguments are the same as were passed to :meth:`__new__`."
msgstr ""
"Если «:meth:`__new__`» возвращает экземпляр класса *cls* , то будет вызван "
"метод «:meth:`__init__`» этого нового экземпляра : «``__init__(self[, "
"...])``» , где *self* – это данный новый экземпляр, а остальные аргументы – "
"именно те, которые были переданы в «:meth:`__new__`» ."

msgid "If :meth:`__new__` does not return an instance of *cls*, then the new instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Если «:meth:`__new__`» не возвращает экземпляр класса *cls* , то метод "
"«:meth:`__init__`» нового экземпляра не будет вызываться."

msgid ":meth:`__new__` is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation.  It is also commonly overridden in custom metaclasses in order to customize class creation."
msgstr ""
"«:meth:`__new__`» главным образом нужен для того, чтобы дать возможность "
"классам, производным от неизменяемых типов (таких как “int” , “str” , "
"“tuple”) , настраивать создание экземпляров. Он к тому же часто "
"переопределяется в метаклассах для настройки создания класса."

msgid "Called when the instance is created.  The arguments are those passed to the class constructor expression.  If a base class has an :meth:`__init__` method, the derived class's :meth:`__init__` method, if any, must explicitly call it to ensure proper initialization of the base class part of the instance; for example: ``BaseClass.__init__(self, [args...])``.  As a special constraint on constructors, no value may be returned; doing so will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Этот метод вызывается при создании соответствующего экземпляра. Его "
"аргументами становятся те, которые были переданы выражению конструктору "
"класса. Если в базовом классе определён метод «:meth:`__init__`» , то метод "
"«:meth:`__init__`» производного класса (если определён) должен явно вызывать "
"его, чтобы гарантировать правильную инициализацию части экземпляра, "
"соответствующей базовому классу ( например : «``BaseClass.__init__(self, "
"[args...])``» ) . Для конструкторов есть особый запрет - они не должны "
"возвращать какого-либо значения - иначе вызывается ошибка :exc:`TypeError` ."

msgid "Called when the instance is about to be destroyed.  This is also called a destructor.  If a base class has a :meth:`__del__` method, the derived class's :meth:`__del__` method, if any, must explicitly call it to ensure proper deletion of the base class part of the instance.  Note that it is possible (though not recommended!) for the :meth:`__del__` method to postpone destruction of the instance by creating a new reference to it.  It may then be called at a later time when this new reference is deleted.  It is not guaranteed that :meth:`__del__` methods are called for objects that still exist when the interpreter exits."
msgstr ""
"Этот метод (называемый также деструктор) вызывается, когда данный экземпляр "
"должен быть уничтожен. Если в базовом классе определён метод "
"«:meth:`__del__`» , то метод «:meth:`__del__`» производного класса (если "
"определён) должен явно вызывать его, чтобы гарантировать правильное удаление "
"части экземпляра, соответствующей базовому классу. Заметьте, что метод "
"«:meth:`__del__`» может (хотя это не рекомендуется) отложить удаление "
"экземпляра, создав новую ссылку на него. Он может быть вызван потом, когда "
"будет удалена эта новая ссылка. Не гарантируется, что методы "
"«:meth:`__del__`» будут вызваны для объектов, существующих на момент "
"закрытия интерпретатора."

msgid "``del x`` doesn't directly call ``x.__del__()`` --- the former decrements the reference count for ``x`` by one, and the latter is only called when ``x``'s reference count reaches zero.  Some common situations that may prevent the reference count of an object from going to zero include: circular references between objects (e.g., a doubly-linked list or a tree data structure with parent and child pointers); a reference to the object on the stack frame of a function that caught an exception (the traceback stored in ``sys.exc_info()[2]`` keeps the stack frame alive); or a reference to the object on the stack frame that raised an unhandled exception in interactive mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame alive).  The first situation can only be remedied by explicitly breaking the cycles; the latter two situations can be resolved by storing ``None`` in ``sys.last_traceback``. Circular references which are garbage are detected when the option cycle detector is enabled (it's on by default), but can only be cleaned up if there are no Python- level :meth:`__del__` methods involved. Refer to the documentation for the :mod:`gc` module for more information about how :meth:`__del__` methods are handled by the cycle detector, particularly the description of the ``garbage`` value."
msgstr ""
"«``del x``» лишь уменьшает на 1 счётчик ссылок на «``x``» , а не вызывает "
"напрямую «``x.__del__()``» , который вызывается только когда счётчик ссылок "
"достигает ноля. Среди ситуаций, при которых счётчик ссылок на объект не "
"может обнулиться, самыми обычными являются : циклические ссылки между "
"объектами (например, список с двухсторонними связями, или древовидная "
"структура данных с указателями на родителя и потомка) ; ссылка на объект в "
"кадре стека функции, которая получила исключение (раскрутка стека, "
"содержащаяся в «``sys.exc_info()[2]``» , имея ссылку на этот кадр стека, не "
"даёт его уничтожить) ; или ссылка на объект в том кадре стека, в котором "
"произошло необработанное исключение в интерактивном режиме (раскрутка стека, "
"содержащаяся в «``sys.last_traceback``» , имея ссылку на этот кадр стека, "
"не даёт его уничтожить) . Первая ситуация может быть исправлена только путем "
"явного разрывания цикла, а две последние ситуации могут быть решены путём "
"записи «:const:`None`» в «``sys.last_traceback``» . Циклические ссылки, "
"являющиеся “мусором” , детектируются если включена опция обнаружения циклов "
"(по умолчанию включена) , но могут быть удалены только если не задействованы "
"методы Питоновского уровня «:meth:`__del__`» . Обратитесь к документации "
"модуля «:mod:`gc`» за более подробной информацией о том, как детектор циклов "
"обращается с методами «:meth:`__del__`» , в частности описание значения у "
"``garbage`` ."

msgid "Due to the precarious circumstances under which :meth:`__del__` methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is invoked in response to a module being deleted (e.g., when execution of the program is done), other globals referenced by the :meth:`__del__` method may already have been deleted or in the process of being torn down (e.g. the import machinery shutting down).  For this reason, :meth:`__del__` methods should do the absolute minimum needed to maintain external invariants.  Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the :meth:`__del__` method is called."
msgstr ""
"По причине ненадёжной ситуации, в которой вызываются методы "
"«:meth:`__del__`» , исключения, возникающие при их исполнении, игнорируются, "
"и вместо этого печатаются предупреждения в «``sys.stderr``» . Также, когда "
"«:meth:`__del__`» вызывается для удаления модуля (например, когда исполнение "
"программы завершено) , глобальные переменные, на которые ссылается метод "
"«:meth:`__del__`» , могут уже быть удалены или в процессе удаления "
"(например, отключение механизма импорта) . По этой причине методам "
"«:meth:`__del__`» следует производить самый минимум необходимого для "
"поддержания внешней целостности . Начиная с версии 1.5 , Питон гарантирует, "
"что глобальные переменные, чьё имя начинается с одиночного подчёркивания, "
"будут удалены из их модуля до удаления остальных глобальных переменных. Если "
"нет других ссылок на такие глобальные переменные, то это может помочь "
"убедиться, что импортированные модули ещё доступны в то время, когда "
"вызывается метод «:meth:`__del__`» ."

msgid "Called by the :func:`repr` built-in function to compute the \"official\" string representation of an object.  If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment).  If this is not possible, a string of the form ``<...some useful description...>`` should be returned. The return value must be a string object. If a class defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when an \"informal\" string representation of instances of that class is required."
msgstr ""
"Вызывается встроенной функцией «:func:`repr`» для вычисления «официального» "
"текстового представления (текстовый объект) для исходного объекта. В тех "
"случаях, когда это вообще возможно – это текст должен быть правильным "
"выражением на Питоне, который, при его интерпретации, даст обратно объект с "
"тем же значением (при условии такого же окружения) . А когда это не возможно "
"– будет возвращён текст вида : «``<…полезное описание…>``» . Если в классе "
"определён «:meth:`__repr__`» , но не определён «:meth:`__str__`» , то "
"«:meth:`__repr__`» используется также и вместо «:meth:`__str__`» ."

msgid "This is typically used for debugging, so it is important that the representation is information-rich and unambiguous."
msgstr ""
"Это обычно используется для отладки, поэтому важно, чтобы это представление "
"было информационно богатыми и недвусмысленным."

msgid "Called by the :func:`str` built-in function and by the :func:`print` function to compute the \"informal\" string representation of an object.  This differs from :meth:`__repr__` in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead. The return value must be a string object."
msgstr ""
"Вызывается встроенной функцией «:func:`str`» и функцией «:func:`print`» для "
"вычисления “неформального” текстового представления (текстовый объект) для "
"исходного объекта. Отличается от «:meth:`__repr__`» тем, что не обязан "
"выдавать правильное выражение на Питоне, вместо этого может выдать более "
"удобный или лаконичный текст."

msgid "Called by the :func:`format` built-in function (and by extension, the :meth:`format` method of class :class:`str`) to produce a \"formatted\" string representation of an object. The ``format_spec`` argument is a string that contains a description of the formatting options desired. The interpretation of the ``format_spec`` argument is up to the type implementing :meth:`__format__`, however most classes will either delegate formatting to one of the built-in types, or use a similar formatting option syntax."
msgstr ""
"Вызывается встроенной функцией «:func:`format`» для получения "
"“форматированого” текстового представления (текстовый объект) для исходного "
"объекта. Аргумент «``format_spec``» является строкой, содержащей описание "
"требуемых опций форматирования. Интерпретация этого аргумента полагается на "
"реализацию метода «:meth:`__format__`» у соответствующего типа, хотя "
"большинство классов будут перепоручать форматирование одному из встроенных "
"типов, или использовать аналогичный синтаксис опций форматирования."

msgid "See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Описание стандарта синтаксиса форматирования смотрите в :ref:`formatspec` ."

msgid "The return value must be a string object."
msgstr "Возвращаемое значение должно быть текстовым объектом."

msgid "These are the so-called \"rich comparison\" methods. The correspondence between operator symbols and method names is as follows: ``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"Это так называемые методы “расширенного сравнения” (“rich comparison”) . "
"Соответствие между символами операторов и именами методов такое : «``x<y``» "
"вызывает «``x.__lt__(y)``» , «``x<=y``» вызывает «``x.__le__(y)``» , "
"«``x==y``» вызывает «``x.__eq__(y)``» , «``x!=y``» вызывает "
"«``x.__ne__(y)``» , «``x>y``» вызывает «``x.__gt__(y)``» , «``x>=y``» "
"вызывает «``x.__ge__(y)``» ."

msgid "A rich comparison method may return the singleton ``NotImplemented`` if it does not implement the operation for a given pair of arguments. By convention, ``False`` and ``True`` are returned for a successful comparison. However, these methods can return any value, so if the comparison operator is used in a Boolean context (e.g., in the condition of an ``if`` statement), Python will call :func:`bool` on the value to determine if the result is true or false."
msgstr ""
"Метод расширенного сравнения может возвращать синглтон «``NotImplemented``» "
", если в нём не реализована операция сравнения для данной пары аргументов. "
"По соглашению – в случае успешных сравнений возвращается «:const:`False`» "
"или «:const:`True`» . Однако, эти методы могут возвращать любое значение – "
"так что, если эти операторы сравнения используются там, где требуется "
"логический (булев) результат (например условие инструкции «:keyword:`if`» ) "
", то Питон применит «:func:`bool`» к этим значениям (чтобы привести их к "
"булеву типу) ."

msgid "There are no implied relationships among the comparison operators. The truth of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the operators will behave as expected.  See the paragraph on :meth:`__hash__` for some important notes on creating :term:`hashable` objects which support custom comparison operations and are usable as dictionary keys."
msgstr ""
"Нет неявно подразумеваемых соотношений между операторами сравнения. "
"Истинность «``x==y``» не означает, что «``x!=y``» ложно. Таким образом, "
"определяя «:meth:`__eq__`» , следует также определить «:meth:`__ne__`» – "
"только тогда операторы будут вести себя, как ожидалось. Смотрите в пункте о "
"«:meth:`__hash__`» некоторые важные замечания о создании хэшируемых "
"объектов, которые поддерживают пользовательские операции сравнения и могут "
"использоваться в качестве ключей словаря."

msgid "There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does); rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` and :meth:`__ne__` are their own reflection."
msgstr ""
"Для этих методов нету реализации автоматической замены порядка аргументов "
"(когда левый аргумент не поддерживает данную операцию, а правый "
"поддерживает) . Но, вместо этого можно воспользоваться тем, что "
"«:meth:`__lt__`» с «:meth:`__gt__`» , «:meth:`__le__`» с «:meth:`__ge__`» , "
"«:meth:`__eq__`» с «:meth:`__ne__`» являются противоположностями друг друга "
"(попарно) ."

msgid "Arguments to rich comparison methods are never coerced."
msgstr ""
"Для аргументов расширенных сравнений никогда не производится приведение "
"типов."

msgid "To automatically generate ordering operations from a single root operation, see :func:`functools.total_ordering`."
msgstr ""
"Об автоматической генерации операций сравнения на основе одной операции "
"смотрите :func:`functools.total_ordering` ."

#, fuzzy
msgid "Called by built-in function :func:`hash` and for operations on members of hashed collections including :class:`set`, :class:`frozenset`, and :class:`dict`.  :meth:`__hash__` should return an integer.  The only required property is that objects which compare equal have the same hash value; it is advised to somehow mix together (e.g. using exclusive or) the hash values for the components of the object that also play a part in comparison of objects."
msgstr ""
"Вызывается встроенной функцией «:func:`hash`» и для операций над членами "
"хэшируемых коллекций, включая «набор» («:class:`set`») , «фиксированный "
"набор» («:class:`frozenset`») и «словарь» («:class:`dict`») . Метод "
"«:meth:`__hash__`» должен возвращать целое число. Единственным обязательным "
"свойством является то, что равные объекты имеют одинаковое значение хэша."

msgid "If a class does not define an :meth:`__eq__` method it should not define a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:`__hash__`, its instances will not be usable as items in hashable collections.  If a class defines mutable objects and implements an :meth:`__eq__` method, it should not implement :meth:`__hash__`, since the implementation of hashable collections requires that a key's hash value is immutable (if the object's hash value changes, it will be in the wrong hash bucket)."
msgstr ""
"Если класс не определяет метод «:meth:`__eq__`» , то он не должен определять "
"метод «:meth:`__hash__`» , а если он определяет «:meth:`__eq__`» , но не "
"определяет «:meth:`__hash__`» , то его экземпляры не смогут быть "
"использованы как элементы хэшируемых множеств. Если класс определяет "
"изменяемые объекты и реализует метод «:meth:`__eq__`» , то он не должен "
"реализовывать «:meth:`__hash__`» , поскольку реализация хэшируемых множеств "
"требует, чтобы значение хэша ключей было неизменяемым (если значение хэша "
"ключа объекта изменяется, то оно может оказаться не в своей группе хэшей "
"(“hash bucket”) (и будет пропущено при поиске) ) ."

msgid "User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by default; with them, all objects compare unequal (except with themselves) and ``x.__hash__()`` returns ``id(x)``."
msgstr ""
"Определяемые пользователем классы по умолчанию имеют методы «:meth:`__eq__`» "
"и «:meth:`__hash__`» , из-за которых все объекты экземпляров этих классов "
"являются неравными друг другу (они равны только сами себе) , а "
"«``x.__hash__()``» возвращает «``id(x)``» ."

msgid "Classes which inherit a :meth:`__hash__` method from a parent class but change the meaning of :meth:`__eq__` such that the hash value returned is no longer appropriate (e.g. by switching to a value-based concept of equality instead of the default identity based equality) can explicitly flag themselves as being unhashable by setting ``__hash__ = None`` in the class definition. Doing so means that not only will instances of the class raise an appropriate :exc:`TypeError` when a program attempts to retrieve their hash value, but they will also be correctly identified as unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike classes which define their own :meth:`__hash__` to explicitly raise :exc:`TypeError`)."
msgstr ""
"Классы, которые наследуют метод «:meth:`__hash__`» из родительского класса, "
"но изменяют значение «:meth:`__eq__`» так, что возвращаемое значение хэша "
"уже теряет разумный смысл (например, переходя к концепции сравнения на "
"основании значения вместо стандартного сравнения на основе уникальных "
"идентификаторов) могут явным образом обозначить себя как нехэшируемые "
"установив «``__hash__ = None``» в определении класса. Такое действие "
"приведёт не только к тому, что экземпляры данного класса будут вызывать "
"соответствующее исключение «:exc:`TypeError`» , когда программа попытается "
"получить их значение хэша, но и к тому, что экземпляры будут правильно "
"идентифицированы как нехэшируемые при проверке «``isinstance(obj, "
"collections.Hashable)``» (в отличие от классов, которые определили "
"собственный «:meth:`__hash__`» , явно вызывающий исключение "
"«:exc:`TypeError`» ) ."

msgid "If a class that overrides :meth:`__eq__` needs to retain the implementation of :meth:`__hash__` from a parent class, the interpreter must be told this explicitly by setting ``__hash__ = <ParentClass>.__hash__``. Otherwise the inheritance of :meth:`__hash__` will be blocked, just as if :attr:`__hash__` had been explicitly set to :const:`None`."
msgstr ""
"Если классу, переопределившему «:meth:`__eq__`» нужно оставить реализацию "
"«:meth:`__hash__`» из родительского класса, то это нужно обязательно делать "
"явным образом : «``__hash__ = <ParentClass>.__hash__``» . Иначе наследование "
"«:meth:`__hash__`» будет блокировано, так же, как если бы "
"«:meth:`__hash__`» был явно установлен в «:const:`None`» ."

msgid "Called to implement truth value testing and the built-in operation ``bool()``; should return ``False`` or ``True``.  When this method is not defined, :meth:`__len__` is called, if it is defined, and the object is considered true if its result is nonzero.  If a class defines neither :meth:`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""
"Вызывается для реализации проверки значения на истинность и встроенной "
"операции «:func:`bool`» . Должен возвращать «:const:`False`» или "
"«:const:`True`» . Если этот метод не определён, то вызывается "
"«:meth:`__len__`» , если тот определён, и, если результат ненулевой, то "
"данный объект считается значащим «:const:`True`» . Если класс не определяет "
"ни «:meth:`__len__`» , ни «:meth:`__bool__`» , то его экземпляры считаются "
"значащими «:const:`True`» ."

msgid "Customizing attribute access"
msgstr "Настройка доступа к атрибутам"

#, fuzzy
msgid "The following methods can be defined to customize the meaning of attribute access (use of, assignment to, or deletion of ``x.name``) for class instances."
msgstr ""
"Следующие методы могут быть определены для настройки доступа (чтение, запись "
"(назначение) , удаление) к атрибутам экземпляров класса."

msgid "Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for ``self``).  ``name`` is the attribute name. This method should return the (computed) attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"Вызывается, когда искомый атрибут не найден в соответствующих местах "
"(тоесть, он не является атрибутом экземпляра и не найден в дереве классов "
"данного экземпляра) . ``name`` – имя атрибута. Этот метод должен возвращать "
"значение (вычисленное) атрибута, или инициировать исключение "
"«:exc:`AttributeError`» ."

msgid "Note that if the attribute is found through the normal mechanism, :meth:`__getattr__` is not called.  (This is an intentional asymmetry between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for efficiency reasons and because otherwise :meth:`__getattr__` would have no way to access other attributes of the instance.  Note that at least for instance variables, you can fake total control by not inserting any values in the instance attribute dictionary (but instead inserting them in another object).  See the :meth:`__getattribute__` method below for a way to actually get total control over attribute access."
msgstr ""
"Заметьте, что если атрибут найден обычным способом, то «:meth:`__getattr__`» "
"не вызывается. (Несимметричность в этом смысле между «:meth:`__getattr__`» "
"и «:meth:`__setattr__`» создана намеренно. ) Это сделано и в целях "
"эффективности и из-за того, что иначе у «:meth:`__getattr__`» не было бы "
"никакой возможности доступа к другим атрибутам экземпляра. Кстати, по "
"крайней мере для переменных экземпляра вы можете имитировать тотальный "
"контроль за счёт непомещения их в словарь атрибутов данного экземпляра (а "
"храня их в другом объекте) . Смотрите метод «:meth:`__getattribute__`» ниже, "
"предоставляющий способ действительно полностью контролировать доступ к "
"атрибутам."

msgid "Called unconditionally to implement attribute accesses for instances of the class. If the class also defines :meth:`__getattr__`, the latter will not be called unless :meth:`__getattribute__` either calls it explicitly or raises an :exc:`AttributeError`. This method should return the (computed) attribute value or raise an :exc:`AttributeError` exception. In order to avoid infinite recursion in this method, its implementation should always call the base class method with the same name to access any attributes it needs, for example, ``object.__getattribute__(self, name)``."
msgstr ""
"Вызывается безусловно (всегда, когда определён) для реализации доступа к "
"атрибутам экземпляров данного класса. Если в классе также определён "
"«:meth:`__getattr__`» , то он не будет вызван, если только "
"«:meth:`__getattribute__`» не вызовет его явно или не инициирует исключение "
"«:exc:`AttributeError`» . Этот метод нужен, чтобы возвращать значение "
"(вычисленное) атрибута, или инициировать исключение «:exc:`AttributeError`» "
". Чтобы при доступе к нужным атрибутам избежать бесконечной рекурсии, в "
"реализации этого метода всегда нужно вызывать метод базового класса с тем же "
"именем, например, «``object.__getattribute__(self, name)``» (вместо "
"«``self.name``») ."

msgid "This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See :ref:`special-lookup`."
msgstr ""
"Этот метод всё же может быть обойдён обращением к специальным методам в "
"результате явного обращения с помощью специального синтаксиса языка или "
"встроенных функций. Смотрите «Обращение к специальным методам» :ref"
":`special-lookup` ."

msgid "Called when an attribute assignment is attempted.  This is called instead of the normal mechanism (i.e. store the value in the instance dictionary). *name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Вызывается при попытке записи (назначения) атрибута. Он вызывается вместо "
"стандартного механизма (тоесть, вместо сохранения значения в словаре "
"экземпляра) . *name* – имя атрибута, *value* – значение, которое нужно под "
"этим именем сохранить (назначить) ."

msgid "If :meth:`__setattr__` wants to assign to an instance attribute, it should call the base class method with the same name, for example, ``object.__setattr__(self, name, value)``."
msgstr ""
"Если «:meth:`__setattr__`» хочет получить доступ к атрибуту экземпляра, ему "
"следует вызывать метод базового класса с тем же именем, например, "
"«``object.__setattr__(self, name, value)``» (вместо «``self.name``») ."

msgid "Like :meth:`__setattr__` but for attribute deletion instead of assignment.  This should only be implemented if ``del obj.name`` is meaningful for the object."
msgstr ""
"Подобен «:meth:`__setattr__`» , только вместо назначения – удаляет атрибут. "
"Реализовывать его следует только если «``del obj.name``» должен иметь "
"какой-то специальный смысл для данного объекта."

msgid "Called when :func:`dir` is called on the object.  A list must be returned."
msgstr ""
"Вызывается, когда вызывается «:func:`dir`» с данным объектом в качестве "
"аргумента . Должен возвращаться список."

#, fuzzy
msgid "Implementing Descriptors"
msgstr "Дескрипторы"

msgid "The following methods only apply when an instance of the class containing the method (a so-called *descriptor* class) appears in the class dictionary of another class, known as the *owner* class.  In the examples below, \"the attribute\" refers to the attribute whose name is the key of the property in the owner class' :attr:`__dict__`."
msgstr ""
"Следующие методы служат для “перехвата” обращения к объекту, содержащему их. "
"Но есть принципиальные ограничения. Эти методы задействуются только у тех "
"объектов, у которых они определены в их классе (такой класс называется "
"“описатель” ) , и которые (объекты) являются атрибутом другого класса "
"(присутствуют в словаре атрибутов этого класса или его родительских классов) "
"(такой класс называется “владелец” ) . В примерах, данных ниже, “данный "
"атрибут” подразумевает тот атрибут, чьё имя является ключом словаря "
"«:attr:`__dict__`» класса – владельца."

msgid "Called to get the attribute of the owner class (class attribute access) or of an instance of that class (instance attribute access). *owner* is always the owner class, while *instance* is the instance that the attribute was accessed through, or ``None`` when the attribute is accessed through the *owner*.  This method should return the (computed) attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"Вызывается для получения “данного атрибута” класса-владельца (доступ к "
"атрибуту класса) или экземпляра класса-владельца (доступ к атрибуту "
"экземпляра) . Аргумент «*owner*» всегда – класс-владелец, а аргумент "
"«*instance*» – это тот экземпляр, через который “данный атрибут” был получен "
"или «:const:`None`» , когда “данный атрибут” был получен через “владельца” "
". Этот метод должен возвращать значение “данного атрибута” (вычисленное) , "
"или инициировать исключение «:exc:`AttributeError`» ."

msgid "Called to set the attribute on an instance *instance* of the owner class to a new value, *value*."
msgstr ""
"Вызывается для установки (записи) значения *value* для “данного атрибута” в "
"экземпляре *instance* “класса-владельца” ."

msgid "Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Вызывается для удаления “данного атрибута” в экземпляре *instance* "
"“класса-владельца” ."

msgid "Invoking Descriptors"
msgstr "Вызов дескрипторов"

#, fuzzy
msgid "In general, a descriptor is an object attribute with \"binding behavior\", one whose attribute access has been overridden by methods in the descriptor protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any of those methods are defined for an object, it is said to be a descriptor."
msgstr ""
"Дескриптором является такой атрибут, который при этом является объектом, в "
"классе которого определён хотябы один из методов: :meth:`__get__` , "
":meth:`__set__` , :meth:`__delete__`."

msgid "The default behavior for attribute access is to get, set, or delete the attribute from an object's dictionary. For instance, ``a.x`` has a lookup chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Обычно эффект доступа к атрибутам заключается в чтении, записи или удалении "
"их из словаря объекта. Например, поиск «``a.x``» происходит в такой "
"последовательности : «``a.__dict__['x']``» , затем "
"«``type(a).__dict__['x']``» и далее в базовых классах класса «``type(a)``» , "
"исключая метаклассы."

msgid "However, if the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead.  Where this occurs in the precedence chain depends on which descriptor methods were defined and how they were called."
msgstr ""
"Но, если значением искомого атрибута является объект, в котором определён "
"один из дескрипторных методов, то Питон может обойти обычное поведение и "
"вызвать вместо этого дескрипторный метод. На каком этапе последовательности "
"поиска атрибута это произойдёт – зависит от того, какие дескрипторные методы "
"были определены, и как они были вызваны."

#, fuzzy
msgid "The starting point for descriptor invocation is a binding, ``a.x``. How the arguments are assembled depends on ``a``:"
msgstr ""
"Отправной точкой для вызова дескриптора является значение «``a.x``» : то как "
"собираются аргументы для этого вызова – зависит от «``a``» :"

#, fuzzy
msgid "The simplest and least common call is when user code directly invokes a descriptor method:    ``x.__get__(a)``."
msgstr ""
"Простейшим, но наименее естественным является прямой вызов пользовательским "
"кодом дескрипторного метода : «``thexattr.__get__(a)``» (где «``thexattr = "
"a.__dict__[\"x\"]``» ) ."

msgid "If binding to an object instance, ``a.x`` is transformed into the call: ``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"При вызове через объект-экземпляр *a* : «``a.x``» преобразуется в вызов "
"«``type(a).__dict__['x'].__get__(a, type(a))``» ."

msgid "If binding to a class, ``A.x`` is transformed into the call: ``A.__dict__['x'].__get__(None, A)``."
msgstr ""
"При вызове через класс *A* : «``A.x``» преобразуется в вызов "
"«``A.__dict__['x'].__get__(None, A)``» ."

#, fuzzy
msgid "If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` immediately preceding ``B`` and then invokes the descriptor with the call: ``A.__dict__['m'].__get__(obj, A)``."
msgstr ""
"Если «``a``» является экземпляром класса :class:`super` , то при связывании "
"через «``super(B, obj).m()``» используется «``obj.__class__.__mro__``» чтобы "
"найти такой класс «``A``» , который является непосредственным базовым "
"классом для «``B``», и затем вызывается «``A.__dict__['m'].__get__(obj, "
"A)``» ."

msgid "For instance bindings, the precedence of descriptor invocation depends on the which descriptor methods are defined.  A descriptor can define any combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If it does not define :meth:`__get__`, then accessing the attribute will return the descriptor object itself unless there is a value in the object's instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:`__delete__`, it is a data descriptor; if it defines neither, it is a non-data descriptor.  Normally, data descriptors define both :meth:`__get__` and :meth:`__set__`, while non-data descriptors have just the :meth:`__get__` method.  Data descriptors with :meth:`__set__` and :meth:`__get__` defined always override a redefinition in an instance dictionary.  In contrast, non-data descriptors can be overridden by instances."
msgstr ""

msgid "Python methods (including :func:`staticmethod` and :func:`classmethod`) are implemented as non-data descriptors.  Accordingly, instances can redefine and override methods.  This allows individual instances to acquire behaviors that differ from other instances of the same class."
msgstr ""

msgid "The :func:`property` function is implemented as a data descriptor. Accordingly, instances cannot override the behavior of a property."
msgstr ""

msgid "__slots__"
msgstr "__slots__"

msgid "By default, instances of classes have a dictionary for attribute storage.  This wastes space for objects having very few instance variables.  The space consumption can become acute when creating large numbers of instances."
msgstr ""
"По умолчанию экземпляры классов имеют словарь для хранения атрибутов. Это "
"расходует много места для объектов, имеющих мало своих переменных. Расход "
"места может стать острым, при создании большого количества экземпляров."

msgid "The default can be overridden by defining *__slots__* in a class definition. The *__slots__* declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable.  Space is saved because *__dict__* is not created for each instance."
msgstr ""
"Это стандартное поведение можно отменить, определив «:attr:`__slots__`» в "
"определении класса. «:attr:`__slots__`» получает последовательность "
"переменных экземпляра и резервирует в каждом экземпляре только необходимое "
"для хранения значений всех его переменных количество места. Место "
"экономится, поскольку не создаётся «:attr:`__dict__`» для каждого "
"экземпляра."

msgid "This class variable can be assigned a string, iterable, or sequence of strings with variable names used by instances.  If defined in a class, *__slots__* reserves space for the declared variables and prevents the automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr ""
"Этой переменной класса можно назначить строку, итерируемый объект или "
"последовательность строк с именами переменных, используемых экземплярами. В "
"случае объявления его в классе, «:attr:`__slots__`» резервирует место для "
"объявленных переменных и отменяет автоматическое создание «:attr:`__dict__`» "
"и «:attr:`__weakref__`» для каждого экземпляра."

msgid "Notes on using *__slots__*"
msgstr "Замечания по использованию «:attr:`__slots__`»"

msgid "When inheriting from a class without *__slots__*, the *__dict__* attribute of that class will always be accessible, so a *__slots__* definition in the subclass is meaningless."
msgstr ""
"При наследовании от класса без «:attr:`__slots__`» , атрибут "
"«:attr:`__dict__`» этого класса будет всегда доступным, поэтому определение "
"«:attr:`__slots__`» в подклассах бесполезно."

msgid "Without a *__dict__* variable, instances cannot be assigned new variables not listed in the *__slots__* definition.  Attempts to assign to an unlisted variable name raises :exc:`AttributeError`. If dynamic assignment of new variables is desired, then add ``'__dict__'`` to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Без переменной «:attr:`__dict__`» экземплярам не могут быть назначены новые "
"переменные, не перечисленные в определении «:attr:`__slots__`» . Попытки "
"назначений не перечисленных имен переменных вызывают ошибку "
"«:exc:`AttributeError`» . Если желательно динамическое назначение новых "
"переменных, добавьте ``'__dict__'`` в последовательность строк в определении "
"«:attr:`__slots__`» ."

msgid "Without a *__weakref__* variable for each instance, classes defining *__slots__* do not support weak references to its instances. If weak reference support is needed, then add ``'__weakref__'`` to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Без переменной «:attr:`__weakref__`» у каждого экземпляра – классы, в "
"которых определён «:attr:`__slots__`» – не поддерживают «слабые» ссылки на "
"свои экземпляры. Если поддержка слабых ссылок нужна, то к последовательности "
"строк в объявлении «:attr:`__slots__`» добавьте «``'__weakref__'``» ."

msgid "*__slots__* are implemented at the class level by creating descriptors (:ref:`descriptors`) for each variable name.  As a result, class attributes cannot be used to set default values for instance variables defined by *__slots__*; otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"«:attr:`__slots__`» реализованы на уровне соответствующего класса "
"посредством создания дескрипторов (смотрите “Реализация дескрипторов” "
":ref:`descriptors` ) для каждого имени переменной. В результате атрибуты "
"класса не могут быть использованы для установки значений по-умолчанию для "
"переменных у экземпляров, определённых посредством «:attr:`__slots__`» – "
"иначе атрибуты этих классов могли бы переписать назначение этих "
"дескрипторов."

msgid "The action of a *__slots__* declaration is limited to the class where it is defined.  As a result, subclasses will have a *__dict__* unless they also define *__slots__* (which must only contain names of any *additional* slots)."
msgstr ""
"Эффект объявления «:attr:`__slots__`» распространяется только на тот класс, "
"в котором этот атрибут определён. Таким образом : подклассы будут иметь "
"атрибут «:attr:`__dict__`» , если сами также не определят "
"«:attr:`__slots__`» (который должен содержать имена только дополнительных "
"“слотов” ) ."

msgid "If a class defines a slot also defined in a base class, the instance variable defined by the base class slot is inaccessible (except by retrieving its descriptor directly from the base class). This renders the meaning of the program undefined.  In the future, a check may be added to prevent this."
msgstr ""
"Если класс определяет “слот” , который определён и в базовом классе, то та "
"переменная экземпляра, которая определена “слотом” базового класса, будет "
"недоступна (за исключением явного получения дескриптора через базовый класс) "
". Это делает неопределённым значение программы. В будущем для "
"предотвращения этого может быть добавлена какая-либо проверка."

msgid "Nonempty *__slots__* does not work for classes derived from \"variable-length\" built-in types such as :class:`int`, :class:`str` and :class:`tuple`."
msgstr ""
"Непустой атрибут «:attr:`__slots__`» не действует для классов, произведённых "
"от встроенных типов “переменной длинны” , таких как :class:`int` , "
":class:`str` и :class:`tuple` ."

msgid "Any non-string iterable may be assigned to *__slots__*. Mappings may also be used; however, in the future, special meaning may be assigned to the values corresponding to each key."
msgstr ""
"Любой перебираемый (“итерируемый”) объект, кроме текста – может быть "
"назначен атрибуту «:attr:`__slots__`» . Отображения тоже могут быть "
"использованы, однако, в будущем им может быть придан специальный смысл."

msgid "*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""
"Назначение атрибуту «:attr:`__class__`» работает, только если оба класса "
"имеют один и тот же «:attr:`__slots__`» ."

msgid "Customizing class creation"
msgstr "Управление созданием классов"

msgid "By default, classes are constructed using :func:`type`. A class definition is read into a separate namespace and the value of class name is bound to the result of ``type(name, bases, dict)``."
msgstr ""
"По умолчанию классы создаются с использованием «:func:`type`» . Определение "
"класса “считывается” в отдельное пространство имён, и получившемуся "
"результату ``type(name, bases, dict)`` назначается соответствующее имя "
"класса."

msgid "When the class definition is read, if a callable ``metaclass`` keyword argument is passed after the bases in the class definition, the callable given will be called instead of :func:`type`.  If other keyword arguments are passed, they will also be passed to the metaclass.  This allows classes or functions to be written which monitor or alter the class creation process:"
msgstr ""
"Когда описание данного класса считывается, если передан исполнимый аргумент "
"под ключевым словом «:keyword:`metaclass`» после базовых классов в "
"определении класса, то этот исполнимый объект будет вызван вместо "
"«:func:`type`» . Если переданы и другие именованные аргументы, то они также "
"будут переданы этому метаклассу. Это позволяет писать классы или функции, "
"которые отслеживают или изменяют процесс создания класса :"

msgid "Modifying the class dictionary prior to the class being created."
msgstr ""
"Модифицируя словарь данного класса перед тем, как данный класс будет создан."

msgid "Returning an instance of another class -- essentially performing the role of a factory function."
msgstr ""
"Возвращая экземпляр другого класса, по сути исполняя роль функций-фабрик."

msgid "These steps will have to be performed in the metaclass's :meth:`__new__` method -- :meth:`type.__new__` can then be called from this method to create a class with different properties.  This example adds a new element to the class dictionary before creating the class::"
msgstr ""
"Эти шаги должны быть исполнены в методе «:meth:`__new__`» данного метакласса "
"– затем из этого метода может быть вызван «:meth:`type.__new__`» для "
"создания класса с другими свойствами. Следующий пример добавляет новый "
"элемент к словарю данного класса перед созданием данного класса :"

msgid "class metacls(type):     def __new__(mcs, name, bases, dict):         dict['foo'] = 'metacls was here'         return type.__new__(mcs, name, bases, dict)"
msgstr ""
"class metacls(type):     def __new__(mcs, name, bases, dict):         "
"dict['foo'] = 'metacls was here'         return type.__new__(mcs, name, "
"bases, dict)"

msgid "You can of course also override other class methods (or add new methods); for example defining a custom :meth:`__call__` method in the metaclass allows custom behavior when the class is called, e.g. not always creating a new instance."
msgstr ""
"Конечно, вы можете ещё и переопределять другие методы класса (или добавлять "
"новые) . Например, определение метода «:meth:`__call__`» позволяет настроить "
"то, как ведёт себя данный класс при вызове, например, чтобы он не каждый "
"раз создавал новый экземпляр."

msgid "If the metaclass has a :meth:`__prepare__` attribute (usually implemented as a class or static method), it is called before the class body is evaluated with the name of the class and a tuple of its bases for arguments.  It should return an object that supports the mapping interface that will be used to store the namespace of the class.  The default is a plain dictionary.  This could be used, for example, to keep track of the order that class attributes are declared in by returning an ordered dictionary."
msgstr ""
"Если у данного класса есть атрибут «:meth:`__prepare__`» (обычно "
"реализованный как класс или статический метод) , то он вызывается с именем "
"данного класса и с кортежем его базовых классов в качестве аргументов – до "
"исполнения (интерпретации) “тела” данного класса. Результатом должен быть "
"объект, поддерживающий интерфейс отображения, который будет содержать "
"область имён данного класса. По-умолчанию – это простой словарь. Это может "
"использоваться, например, для запоминания (в возвращаемом упорядоченном "
"словаре) того порядка, в котором атрибуты данного класса были объявлены."

msgid "The appropriate metaclass is determined by the following precedence rules:"
msgstr ""
"Соответствующий метакласс определяется следующей последовательностью правил "
":"

msgid "If the ``metaclass`` keyword argument is passed with the bases, it is used."
msgstr ""
"Если аргумент под именем «``metaclass``» передан с базовыми классами, то "
"используется он."

msgid "Otherwise, if there is at least one base class, its metaclass is used."
msgstr ""
"Иначе, если есть хотя бы один базовый класс, то используются его метаклассы."

msgid "Otherwise, the default metaclass (:class:`type`) is used."
msgstr "Иначе – используется метакласс по умолчанию («:class:`type`») ."

msgid "The potential uses for metaclasses are boundless. Some ideas that have been explored including logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization."
msgstr ""
"Возможные применения для метаклассов неограничены. Наиболее разработаны "
"следующие : логирование, проверка интерфейса, автоматическое делегирование, "
"автоматическое создание свойств, посредники, среды исполнения, и т. д. ."

msgid "Here is an example of a metaclass that uses an :class:`collections.OrderedDict` to remember the order that class members were defined::"
msgstr ""
"Далее дан пример метакласса, использующего "
"«:class:`collections.OrderedDict`» для запоминания порядка, в котором члены "
"класса были определены : ::"

msgid "class OrderedClass(type):       @classmethod      def __prepare__(metacls, name, bases, **kwds):         return collections.OrderedDict()       def __new__(cls, name, bases, classdict):         result = type.__new__(cls, name, bases, dict(classdict))         result.members = tuple(classdict)         return result  class A(metaclass=OrderedClass):     def one(self): pass     def two(self): pass     def three(self): pass     def four(self): pass  >>> A.members ('__module__', 'one', 'two', 'three', 'four')"
msgstr ""
"class OrderedClass(type):       @classmethod      def __prepare__(metacls, "
"name, bases, **kwds):         return collections.OrderedDict()       def "
"__new__(cls, name, bases, classdict):         result = type.__new__(cls, "
"name, bases, dict(classdict))         result.members = tuple(classdict) "
"        return result  class A(metaclass=OrderedClass):     def one(self): "
"pass     def two(self): pass     def three(self): pass     def four(self): "
"pass  >>> A.members ('__module__', 'one', 'two', 'three', 'four')"

msgid "When the class definition for *A* gets executed, the process begins with calling the metaclass's :meth:`__prepare__` method which returns an empty :class:`collections.OrderedDict`.  That mapping records the methods and attributes of *A* as they are defined within the body of the class statement. Once those definitions are executed, the ordered dictionary is fully populated and the metaclass's :meth:`__new__` method gets invoked.  That method builds the new type and it saves the ordered dictionary keys in an attribute called *members*."
msgstr ""
"Когда происходит переход к исполнению определения класса *A* , то этот "
"процесс начинается с вызова из метакласса метода «:meth:`__prepare__`» , "
"который возвращает пустой объект «:class:`collections.OrderedDict`» . Это "
"отображение записывает методы и атрибуты класса *A* , как если бы они были "
"определены внутри тела этого класса. Когда эти определения исполнены – "
"данный упорядоченый словарь полностью заполняется, и метод «:meth:`__new__`» "
"метакласса вызывается. И последний создаёт новый тип и сохраняет ключи "
"упорядоченого словаря в атрибуте «``members``» ."

msgid "Customizing instance and subclass checks"
msgstr ""

msgid "The following methods are used to override the default behavior of the :func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""

msgid "In particular, the metaclass :class:`abc.ABCMeta` implements these methods in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual base classes\" to any class or type (including built-in types), including other ABCs."
msgstr ""

msgid "Return true if *instance* should be considered a (direct or indirect) instance of *class*. If defined, called to implement ``isinstance(instance, class)``."
msgstr ""

msgid "Return true if *subclass* should be considered a (direct or indirect) subclass of *class*.  If defined, called to implement ``issubclass(subclass, class)``."
msgstr ""

msgid "Note that these methods are looked up on the type (metaclass) of a class.  They cannot be defined as class methods in the actual class.  This is consistent with the lookup of special methods that are called on instances, only in this case the instance is itself a class."
msgstr ""

msgid "Includes the specification for customizing :func:`isinstance` and :func:`issubclass` behavior through :meth:`__instancecheck__` and :meth:`__subclasscheck__`, with motivation for this functionality in the context of adding Abstract Base Classes (see the :mod:`abc` module) to the language."
msgstr ""

msgid "Emulating callable objects"
msgstr "Эмулирование исполнимых объектов"

msgid "Called when the instance is \"called\" as a function; if this method is defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, ...)``."
msgstr ""
"Вызывается, когда данный экземпляр вызывается как функция, если этот метод "
"определён. «``x(arg1, arg2, ...)``» является краткой формой для "
"«``x.__call__(arg1, arg2, ...)``» ."

msgid "Emulating container types"
msgstr "Эмулирование контейнерных типов"

msgid "The following methods can be defined to implement container objects.  Containers usually are sequences (such as lists or tuples) or mappings (like dictionaries), but can represent other containers as well.  The first set of methods is used either to emulate a sequence or to emulate a mapping; the difference is that for a sequence, the allowable keys should be the integers *k* for which ``0 <= k < N`` where *N* is the length of the sequence, or slice objects, which define a range of items.  It is also recommended that mappings provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:`popitem`, :meth:`copy`, and :meth:`update` behaving similar to those for Python's standard dictionary objects.  The :mod:`collections` module provides a :class:`MutableMapping` abstract base class to help create those methods from a base set of :meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable sequences should provide methods :meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and :meth:`sort`, like Python standard list objects.  Finally, sequence types should implement addition (meaning concatenation) and multiplication (meaning repetition) by defining the methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; they should not define other numerical operators.  It is recommended that both mappings and sequences implement the :meth:`__contains__` method to allow efficient use of the ``in`` operator; for mappings, ``in`` should search the mapping's keys; for sequences, it should search through the values.  It is further recommended that both mappings and sequences implement the :meth:`__iter__` method to allow efficient iteration through the container; for mappings, :meth:`__iter__` should be the same as :meth:`keys`; for sequences, it should iterate through the values."
msgstr ""
"Следующие методы могут быть определены для реализации объектов-контейнеров. "
"Контейнеры – это обычно последовательности (как списки или кортежи) или "
"отображения (как словари) , но также могут быть реализованы другие виды. "
"Первая группа следующих далее методов используется для эмуляции как "
"последовательностей, так и отображений – разница в том, что для "
"последовательностей допустимые ключи должны быть целым числом *k* в "
"диапазоне «0 <= k < N» , где *N* равно длине данной последовательности, или "
"быть объектом-срезом (который определяет диапазон элементов) . Также "
"рекомендуется, чтобы отображения предоставляли методы : «:meth:`keys`» , "
"«:meth:`values`» , «:meth:`items`» , «:meth:`get`» , «:meth:`clear`» , "
"«:meth:`setdefault`» , «:meth:`pop`» , «:meth:`popitem`» , «:meth:`copy`» и "
"«:meth:`update`» , дающие тот же эффект, что и в стандартных Питоновских "
"словарях. Модуль «:mod:`collections`» предоставляет абстрактный базовый "
"класс «:class:`MutableMapping`» , облегчающий создание этих методов на "
"основе базового набора из : «:meth:`__getitem__`» , «:meth:`__setitem__`» , "
"«:meth:`__delitem__`» и «:meth:`keys`» . Изменяемые последовательности могут "
"предоставлять методы : «:meth:`append`» , «:meth:`count`» , «:meth:`index`» "
", «:meth:`extend`» , «:meth:`insert`» , «:meth:`pop`» , «:meth:`remove`» , "
"«:meth:`reverse`» и «:meth:`sort`» – как у обычных Питоновских списков. И, "
"наконец, типы-последовательности могут реализовать сложение (тоесть "
"конкатенацию) и умножение (тоесть повтор) – через определение методов : "
"«:meth:`__add__`» , «:meth:`__radd__`» , «:meth:`__iadd__`» , "
"«:meth:`__mul__`» , «:meth:`__rmul__`» и «:meth:`__imul__`» (их описание – "
"ниже) – эти типы не должны определять другие числовые операции. "
"Рекомендуется и в отображениях и в последовательностях обеспечивать метод "
"«:meth:`__contains__`» , который был бы эффективной реализацией оператора "
"«:keyword:`in`» . Для отображений – «:keyword:`in`» должен искать в ключах "
"этого отображения, а для последовательностей – в значениях. Кроме того, "
"рекомендуется для отображений и последовательностей реализовывать метод "
"«:meth:`__iter__`» для эффективного перебора элементов в этом контейнере. "
"Для отображений – «:meth:`__iter__`» должен быть то же, что и «:meth:`keys`» "
", а для последовательностей этот метод должен перебирать значения."

msgid "Called to implement the built-in function :func:`len`.  Should return the length of the object, an integer ``>=`` 0.  Also, an object that doesn't define a :meth:`__bool__` method and whose :meth:`__len__` method returns zero is considered to be false in a Boolean context."
msgstr ""
"Вызывается для реализации встроенной функции «:func:`len`» . Этот метод "
"должен возвращать длину данного объекта в виде целого значения >= 0 . Кроме "
"этого, объект, в котором не определён метод «:meth:`__bool__`» и чей метод "
"«:meth:`__len__`» возвращает ноль – считается ложью в контексте булевых "
"операций."

msgid "Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""
"Срезы производятся исключительно следующими тремя методами. Вызов вроде : ::"

msgid "a[1:2] = b"
msgstr "a[1:2] = b"

msgid "is translated to ::"
msgstr "преобразуется в : ::"

msgid "a[slice(1, 2, None)] = b"
msgstr "a[slice(1, 2, None)] = b"

msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr ""
"и так далее. Отсутствующие параметры среза всегда заполняются значениями "
"«:const:`None`» ."

msgid "Called to implement evaluation of ``self[key]``. For sequence types, the accepted keys should be integers and slice objects.  Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the :meth:`__getitem__` method. If *key* is of an inappropriate type, :exc:`TypeError` may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), :exc:`IndexError` should be raised. For mapping types, if *key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""
"Вызывается для реализации вычисления (получения) ``self[key]`` . Для "
"типов-последовательностей – допустимые ключи должны быть целыми числами или "
"специальными объектами-срезами. Заметьте, что особая интерпретация "
"негативных индексов (если данный класс желает эмулировать "
"тип-последовательность) распространяется и на метод «:meth:`__getitem__`» . "
"Если *key* не подходящего типа, то может инициироваться «:exc:`TypeError`» , "
"а если значение за пределами набора индексов данной последовательности "
"(вследствие какой-либо оригинальной интерпретации негативных значений) – то "
"должно инициироваться «:exc:`IndexError`» . Для отображающих типов, если "
"*key* отсутствует (не в контейнере) – должно инициироваться "
"«:exc:`KeyError`» ."

msgid ":keyword:`for` loops expect that an :exc:`IndexError` will be raised for illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
"циклы «:keyword:`for`» ожидают, что для недопустимых индексов будет "
"инициировано «:exc:`IndexError`» , что нужно для правильного определения "
"конца последовательности."

msgid "Called to implement assignment to ``self[key]``.  Same note as for :meth:`__getitem__`.  This should only be implemented for mappings if the objects support changes to the values for keys, or if new keys can be added, or for sequences if elements can be replaced.  The same exceptions should be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Вызывается для реализации назначения для ``self[key]`` . То же замечание об "
"отрицательных индексах, что и для «:meth:`__getitem__`» . Этот метод должен "
"быть реализован для отображений – только если эти объекты поддерживают "
"изменение значений ключей, или если могут добавляться новые ключи, или для "
"последовательностей, если элементы могут быть заменены. Для неправильных "
"значений *key* исключения должны инициироваться также, как и для "
"«:meth:`__getitem__`» ."

msgid "Called to implement deletion of ``self[key]``.  Same note as for :meth:`__getitem__`.  This should only be implemented for mappings if the objects support removal of keys, or for sequences if elements can be removed from the sequence.  The same exceptions should be raised for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Вызывается для реализации удаления ``self[key]`` . То же замечание об "
"отрицательных индексах, что и для «:meth:`__getitem__`» . Этот метод должен "
"быть реализован для отображений – только если эти объекты поддерживают "
"удаление ключей, или для последовательностей, если элементы могут быть "
"удалены из этой последовательности. Для неправильных значений *key* "
"исключения должны инициироваться также, как и для «:meth:`__getitem__`» ."

msgid "This method is called when an iterator is required for a container. This method should return a new iterator object that can iterate over all the objects in the container.  For mappings, it should iterate over the keys of the container, and should also be made available as the method :meth:`keys`."
msgstr ""
"Этот метод у данного объекта-контейнера вызывается, когда нужен итератор для "
"данного объекта. Этот метод должен возвращать новый объект-итератор, "
"который будет перебирать все объекты в этом объекте-контейнере. Для "
"отображений он должен перебирать ключи, и также должен быть доступен в "
"качестве метода «:meth:`keys`» ."

msgid "Iterator objects also need to implement this method; they are required to return themselves.  For more information on iterator objects, see :ref:`typeiter`."
msgstr ""
"Сами объекты-итераторы тоже должны реализовывать этот метод – для того, "
"чтобы возвращать самих себя. Дополнительную информацию об "
"объектах-итераторах смотрите в «Итерируемые типы» :ref:`typeiter` ."

msgid "Called (if present) by the :func:`reversed` built-in to implement reverse iteration.  It should return a new iterator object that iterates over all the objects in the container in reverse order."
msgstr ""
"Вызывается (если имеется) встроенной функцией «:func:`reversed`» для "
"реализации перебора в обратном порядке. Этот метод должен возвращать новый "
"объект-итератор, который будет перебирать в обратном порядке все объекты в "
"данном объекте-контейнере."

msgid "If the :meth:`__reversed__` method is not provided, the :func:`reversed` built-in will fall back to using the sequence protocol (:meth:`__len__` and :meth:`__getitem__`).  Objects that support the sequence protocol should only provide :meth:`__reversed__` if they can provide an implementation that is more efficient than the one provided by :func:`reversed`."
msgstr ""
"Если метод «:meth:`__reversed__`» не предоставлен, то встроенная функция "
"«:func:`reversed`» будет использовать рассматриваемый в данном параграфе "
"протокол последовательностей (а именно : «:meth:`__len__`» и "
"«:meth:`__getitem__`» ) . Объекты, поддерживающие данный протокол должны "
"предоставлять «:meth:`__reversed__`» , только если они могут обеспечить "
"более эффективную реализацию, чем предлагает «:func:`reversed`» ."

msgid "The membership test operators (:keyword:`in` and :keyword:`not in`) are normally implemented as an iteration through a sequence.  However, container objects can supply the following special method with a more efficient implementation, which also does not require the object be a sequence."
msgstr ""
"Операторы проверки вхождения ( «:keyword:`in`» и «:keyword:`not in`» ) "
"обычно реализуются через перебор последовательности. Однако, контейнерные "
"объекты могут предоставлять перечисленные ниже специальные методы с более "
"эффективной реализацией, при этом не обязательно, чтобы объекты были "
"последовательностями."

msgid "Called to implement membership test operators.  Should return true if *item* is in *self*, false otherwise.  For mapping objects, this should consider the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Вызывается для реализации операторов проверки членства. Должен возвращать "
"«:const:`True`» , если *item* находится в *self* , иначе – «:const:`False`» "
". Для объектов-отображений при этом подразумеваются ключи, а не значения или "
"пары ключ–значение."

msgid "For objects that don't define :meth:`__contains__`, the membership test first tries iteration via :meth:`__iter__`, then the old sequence iteration protocol via :meth:`__getitem__`, see :ref:`this section in the language reference <membership-test-details>`."
msgstr ""
"Для объектов, в которых не определён «__contains__()» , проверка членства "
"сначала пытается перебирать с помощью «__iter__()» , затем используя "
"устаревший подход – с помощью «__getitem__()» ( подробнее в "
":ref:`соответствующем разделе <membership-test-details>` ) ."

msgid "Emulating numeric types"
msgstr "Эмулирование числовых типов"

msgid "The following methods can be defined to emulate numeric objects. Methods corresponding to operations that are not supported by the particular kind of number implemented (e.g., bitwise operations for non-integral numbers) should be left undefined."
msgstr ""
"Следующие методы могут быть определены для эмулирования числовых объектов. "
"Методы, соответствующие операциям, не поддерживаемым данным конкретным видом "
"реализуемого числа (например, побитовые операции для не целых чисел) – не "
"следует определять."

msgid "These methods are called to implement the binary arithmetic operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the expression ``x + y``, where *x* is an instance of a class that has an :meth:`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an optional third argument if the ternary version of the built-in :func:`pow` function is to be supported."
msgstr ""
"Данные методы вызываются для реализации двухоперандных операций ( «``+``», "
"«``-``», «``*``», «``/``», «``//``», «``%``», «:func:`divmod`», "
"«:func:`pow`», «``**``», «``<<``», «``>>``», «``&``», «``^``», «``|``» ) . "
"Например, для вычисления выражения ``x + y`` , где *x* является экземпляром "
"класса, имеющего метод «:meth:`__add__`» – вызывается метод "
"«``x.__add__(y)``» . Метод «:meth:`__divmod__`» должен быть эквивалентным "
"использованию методов «:meth:`__floordiv__`» и «:meth:`__mod__`» , но он не "
"должен соответствовать «:meth:`__truediv__`» . Заметьте, что "
"«:meth:`__pow__`» должен быть определён принимающим необязательный третий "
"аргумент, если должна поддерживаться трёхоперандная версия встроенной "
"функции «:func:`pow`» ."

msgid "If one of those methods does not support the operation with the supplied arguments, it should return ``NotImplemented``."
msgstr ""
"Если какой-либо из указанных выше методов не поддерживает операцию над "
"предоставленными аргументами – он должен вернуть значение "
"«``NotImplemented``» ."

msgid "These methods are called to implement the binary arithmetic operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) operands. These functions are only called if the left operand does not support the corresponding operation and the operands are of different types. [#]_  For instance, to evaluate the expression ``x - y``, where *y* is an instance of a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""
"Данные методы вызываются для реализации двухоперандных операций ( «``+``», "
"«``-``», «``*``», «``/``», «``//``», «``%``», «:func:`divmod`», "
"«:func:`pow`», «``**``», «``<<``», «``>>``», «``&``», «``^``», «``|``» ) с "
"обратным порядком операндов . Эти функции вызываются, только если первый "
"(левый) операнд не поддерживает соответствующую операцию, а операнды разных "
"типов. [#]_ (Для операндов одинакового типа – подразумевается, что если "
"метод для “прямого” порядка (например, «:meth:`__add__()`» ) непримени́м, то "
"данная операция вообще не поддерживается – поэтому “обратная” операция и не "
"вызывается. ) Например : при вычислении выражения ``x - y`` , где *y* "
"является экземпляром класса, имеющего метод «:meth:`__rsub__`» – вызывается "
"«``y.__rsub__(x)``» , если «``x.__sub__(y)``» возвращает значение "
"«``NotImplemented``» ."

msgid "Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the coercion rules would become too complicated)."
msgstr ""
"Заметьте, что трёхоперандное «:func:`pow`» не будет пытаться вызвать "
"«:meth:`__rpow__`» (соответствующие правила приведения (перехода) были бы "
"слишком сложны) ."

msgid "If the right operand's type is a subclass of the left operand's type and that subclass provides the reflected method for the operation, this method will be called before the left operand's non-reflected method.  This behavior allows subclasses to override their ancestors' operations."
msgstr ""
"Если тип правого операнда является подклассом класса левого операнда, и этот "
"подкласс предоставляет для той же операции метод с обратным порядком "
"операндов, то этот метод будет вызван до метода с прямым порядком у левого "
"операнда. Такое поведение позволяет подклассам переопределять операции их "
"предков."

msgid "These methods are called to implement the augmented arithmetic assignments (``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation in-place (modifying *self*) and return the result (which could be, but does not have to be, *self*).  If a specific method is not defined, the augmented assignment falls back to the normal methods.  For instance, to execute the statement ``x += y``, where *x* is an instance of a class that has an :meth:`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance of a class that does not define a :meth:`__iadd__` method, ``x.__add__(y)`` and ``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr ""
"Данные методы вызываются для реализации расширеных арифметических "
"операций-назначений ( «``+=``», «``-=``», «``*=``», «``/=``», «``//=``», «``"
"%=``», «``**=``», «``<<=``», «``>>=``», «``&=``», «``^=``», «``|=``» ) . Эти "
"методы должны пытаться выполнять операции “на месте” (изменяя *self*) и "
"возвращать результат (который может, но не обязан быть *self* ) . Если "
"специальный метод не определён, то операция использует обычные "
"арифметические методы. Например, для вычисления выражения ``x += y`` , где "
"*x* является экземпляром класса, имеющего метод «:meth:`__iadd__`» – "
"вызывается «``x.__iadd__(y)``» . Если *x* является экземпляром класса, в "
"котором не определён метод «:meth:`__iadd__`» , то используются "
"«``x.__add__(y)``» и «``y.__radd__(x)``» – как для вычисления ``x + y`` ."

msgid "Called to implement the unary arithmetic operations (``-``, ``+``, :func:`abs` and ``~``)."
msgstr ""
"Данные методы вызываются для реализации однооперандных арифметических "
"операций ( «``-``», «``+``», «:func:`abs`» и «``~``» ) ."

msgid "Called to implement the built-in functions :func:`complex`, :func:`int`, :func:`float` and :func:`round`.  Should return a value of the appropriate type."
msgstr ""
"Данные методы вызываются для реализации встроенных функций "
"«:func:`complex`», «:func:`int`», «:func:`float`» и «:func:`round`» . Должны "
"возвращать значение соответствующего типа."

msgid "Called to implement :func:`operator.index`.  Also called whenever Python needs an integer object (such as in slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` functions). Must return an integer."
msgstr ""
"Данный метод вызывается для реализации функции «:func:`operator.index`» . "
"Также вызывается, когда Питону требуется целочисленный объект (например в "
"срезах; или во встроенных функциях : «:func:`bin`», «:func:`hex`» и "
"«:func:`oct`» ) . Должен возвращать целое число."

msgid "With Statement Context Managers"
msgstr ""
":dfn:`“Менеджеры контекста”<context manager>` для инструкции "
"«:keyword:`with`»"

msgid "A :dfn:`context manager` is an object that defines the runtime context to be established when executing a :keyword:`with` statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.  Context managers are normally invoked using the :keyword:`with` statement (described in section :ref:`with`), but can also be used by directly invoking their methods."
msgstr ""
":dfn:`“Менеджер контекста”<context manager>` – это объект, который задаёт "
"контекст, который должен быть установлен при исполнении инструкции "
"«:keyword:`with`» . Такой менеджер контекста управляет входом, выходом, "
"требуемым контекстом исполнения данного блока кода. Менеджеры контекста "
"обычно вызываются через инструкцию «:keyword:`with`» (описание в разделе "
"“Инструкция «:keyword:`with`»” :ref:`with` ) , но также могут использоваться "
"через явный вызов их методов."

msgid "Typical uses of context managers include saving and restoring various kinds of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Характерное применение менеджеров контекста включает : сохранение и "
"восстановление глобального состояния, блокирование и разблокирование "
"ресурсов, закрытие открытых файлов, и т.д. ."

msgid "For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""
"Дополнительную информацию смотрите в разделе :ref:`“Типы менеджеров "
"контекста”<typecontextmanager>` ."

msgid "Enter the runtime context related to this object. The :keyword:`with` statement will bind this method's return value to the target(s) specified in the :keyword:`as` clause of the statement, if any."
msgstr ""
"Входит в оперативный (существующий на стадии исполнения) контекст, "
"относящийся к данному объекту. Инструкция «:keyword:`with`» будет назначать "
"(связывать) возвращаемое значение этого метода целям (именам) заявленным в "
"ветви «:keyword:`as`» , если таковая имеется."

msgid "Exit the runtime context related to this object. The parameters describe the exception that caused the context to be exited. If the context was exited without an exception, all three arguments will be :const:`None`."
msgstr ""
"Выходит из оперативного (существующего на стадии исполнения) контекста, "
"относящегося к данному объекту. Указанные параметры определяют, какое именно "
"исключение привело к выходу из данного контекста. Если выход из данного "
"контекста происходит без исключения, то все три аргумента будут "
"«:const:`None`» ."

msgid "If an exception is supplied, and the method wishes to suppress the exception (i.e., prevent it from being propagated), it should return a true value. Otherwise, the exception will be processed normally upon exit from this method."
msgstr ""
"Если дано исключение и данный метод собирается “подавить” это исключение "
"(тоесть, не пропустить его дальше) , то он должен вернуть значение, "
"эквивалентное «:const:`True`» . Иначе : по выходу из этого метода будет "
"продолжена нормальная обработка данного исключения."

msgid "Note that :meth:`__exit__` methods should not reraise the passed-in exception; this is the caller's responsibility."
msgstr ""
"Заметьте, что методы «:meth:`__exit__`» не должны перевызывать переданные "
"внутрь них исключения – это обязанность вызвавшего кода."

msgid "Special method lookup"
msgstr "Обращение к специальным методам"

msgid "For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object's type, not in the object's instance dictionary.  That behaviour is the reason why the following code raises an exception::"
msgstr ""
"Для определяемых пользователем классов, работа явных вызовов специальных "
"методов гарантирована, только если эти методы определены в словаре класса "
"данного объекта, а не экземпляра. Такое поведение приводит к тому, что "
"следующий код приводит к исключению : ::"

msgid ">>> class C(object): ...     pass ... >>> c = C() >>> c.__len__ = lambda: 5 >>> len(c) Traceback (most recent call last):   File \"<stdin>\", line 1, in <module> TypeError: object of type 'C' has no len()"
msgstr ""
">>> class C(object): ...     pass ... >>> c = C() >>> c.__len__ = lambda: 5 "
">>> len(c) Traceback (most recent call last):   File \"<stdin>\", line 1, in "
"<module> TypeError: object of type 'C' has no len()"

msgid "The rationale behind this behaviour lies with a number of special methods such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all objects, including type objects. If the implicit lookup of these methods used the conventional lookup process, they would fail when invoked on the type object itself::"
msgstr ""
"Смысл в таком поведении заключается в том, что некоторые специальные методы, "
"такие как «:meth:`__hash__`» и «:meth:`__repr__`» , реализованы во всех "
"объектах, включая и объекты-типы. Если бы явное обращение к этим методам "
"использовало стандартный процесс обращения, то они бы вызывали ошибку при "
"применении к самому объекту-классу : ::"

msgid ">>> 1 .__hash__() == hash(1) True >>> int.__hash__() == hash(int) Traceback (most recent call last):   File \"<stdin>\", line 1, in <module> TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""
">>> 1 .__hash__() == hash(1) True >>> int.__hash__() == hash(int) Traceback "
"(most recent call last):   File \"<stdin>\", line 1, in <module> TypeError: "
"descriptor '__hash__' of 'int' object needs an argument"

msgid "Incorrectly attempting to invoke an unbound method of a class in this way is sometimes referred to as 'metaclass confusion', and is avoided by bypassing the instance when looking up special methods::"
msgstr ""
"Неправильные попытки вызвать таким способом несвязанный метод класса иногда "
"называют “путаница метаклассов” и справляются с этим, пропуская (обходя) "
"экземпляр при доступе к специальным методам : ::"

msgid ">>> type(1).__hash__(1) == hash(1) True >>> type(int).__hash__(int) == hash(int) True"
msgstr ""
">>> type(1).__hash__(1) == hash(1) True >>> type(int).__hash__(int) == "
"hash(int) True"

msgid "In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the :meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"В дополнение к пропуску любых атрибутов экземпляров с целью сохранения "
"корректности – явный поиск специального метода, в общем случае, также "
"пропускает метод «:meth:`__getattribute__`» даже в метаклассе данного "
"объекта : ::"

msgid ">>> class Meta(type): ...    def __getattribute__(*args): ...       print(\"Metaclass getattribute invoked\") ...       return type.__getattribute__(*args) ... >>> class C(object, metaclass=Meta): ...     def __len__(self): ...         return 10 ...     def __getattribute__(*args): ...         print(\"Class getattribute invoked\") ...         return object.__getattribute__(*args) ... >>> c = C() >>> c.__len__()                 # Explicit lookup via instance Class getattribute invoked 10 >>> type(c).__len__(c)          # Explicit lookup via type Metaclass getattribute invoked 10 >>> len(c)                      # Implicit lookup 10"
msgstr ""
">>> class Meta(type): ...    def __getattribute__(*args): ...       "
"print(\"Metaclass getattribute invoked\") ...       return "
"type.__getattribute__(*args) ... >>> class C(object, metaclass=Meta): ... "
"    def __len__(self): ...         return 10 ...     def "
"__getattribute__(*args): ...         print(\"Class getattribute invoked\") ... "
"        return object.__getattribute__(*args) ... >>> c = C() >>> "
"c.__len__()                 # Явный поиск через экземпляр Class getattribute "
"invoked 10 >>> type(c).__len__(c)          # Явный поиск через класс "
"Metaclass getattribute invoked 10 >>> len(c)                      # "
"Косвенный поиск 10"

msgid "Bypassing the :meth:`__getattribute__` machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method *must* be set on the class object itself in order to be consistently invoked by the interpreter)."
msgstr ""
"Пропуск (обход) механизма «:meth:`__getattribute__`» в такой манере даёт "
"значительное ограничение ради оптимизации по скорости в интерпретаторе, "
"незначительно жертвуя удобством в обращении со специальными методами "
"(специальный метод должен быть установлен в самом объекте-классе для того, "
"чтобы быть нормально вызванным интерпретатором) ."

msgid "It *is* possible in some cases to change an object's type, under certain controlled conditions. It generally isn't a good idea though, since it can lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"В некоторых случаях, при выполнении определённых условий, *возможно таки* "
"изменить тип объекта. В общем случае – это плохая практика, поскольку это "
"может приводить к некоторым очень странным результатам при неосторожном "
"обращении."

msgid "For operands of the same type, it is assumed that if the non-reflected method (such as :meth:`__add__`) fails the operation is not supported, which is why the reflected method is not called."
msgstr ""

msgid "Execution model"
msgstr "Модель исполнения"

msgid "Naming and binding"
msgstr "Именование и связывание"

msgid ":dfn:`Names` refer to objects.  Names are introduced by name binding operations. Each occurrence of a name in the program text refers to the :dfn:`binding` of that name established in the innermost function block containing the use."
msgstr ""
":dfn:`Имена` указывают на обьекты. Имена вводятся операцииями "
":dfn:`связывания` (назначения) имён. Каждое появление имени в тексте "
"программы указывает на то, что назначено этому имени в данном самом "
"внутреннем функциональном блоке."

msgid "A :dfn:`block` is a piece of Python program text that is executed as a unit. The following are blocks: a module, a function body, and a class definition. Each command typed interactively is a block.  A script file (a file given as standard input to the interpreter or specified on the interpreter command line the first argument) is a code block.  A script command (a command specified on the interpreter command line with the '**-c**' option) is a code block.  The string argument passed to the built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
":dfn:`Блок` - часть текста программы на Питоне, которая выполняется как одно "
"целое. Блоками является следующее : модуль, тело функции и определение "
"класса. Каждая команда, набранная интерактивно, является блоком. Файл "
"скрипта (файл, заданный как стандартный ввод интерпретатора или указанный в "
"первом аргументе командной строки интерпретатора) является блоком кода. "
"Команда скрипта (команда указанная с опцией '**-c**' в командной строке "
"интерпретатора) является блоком кода. Текстовый аргумент переданный "
"встроенным функциям «:func:`eval`» и «:func:`exec`» тоже является блоком "
"кода."

msgid "A code block is executed in an :dfn:`execution frame`.  A frame contains some administrative information (used for debugging) and determines where and how execution continues after the code block's execution has completed."
msgstr ""
"Блок кода выполняется в :dfn:`кадре исполнения`. Кадр содержит "
"административную информацию (использующуюся для отладки), и определяет, где "
"и как продолжается выполнение после завершения выполнения блока кода."

msgid "A :dfn:`scope` defines the visibility of a name within a block.  If a local variable is defined in a block, its scope includes that block.  If the definition occurs in a function block, the scope extends to any blocks contained within the defining one, unless a contained block introduces a different binding for the name.  The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods -- this includes comprehensions and generator expressions since they are implemented using a function scope.  This means that the following will fail::"
msgstr ""
"«:dfn:`Область видимости`» определяет видимость имени внутри блока. Если "
"локальная переменная определена в блоке, то ее область видимости включает "
"этот блок. Если это определение происходит в блоке функции, то ее область "
"видимости распространяется на любые блоки, содержащиеся в данном, если "
"только содержащийся блок не вводит своё назначение данному имени. Область "
"видимости имён, определенных в блоке класса ограничивается этим блоком "
"класса; но она не распространяется на блоки кода методов - включая "
"comprehensions и выражения генераторов, поскольку они реализованы с помощью "
"функций (которые создают свою область видимости). Это означает, что "
"следующее приведёт к ошибке :"

msgid "class A:     a = 42     b = list(a + i for i in range(10))"
msgstr "class A:     a = 42     b = list(a + i for i in range(10))"

msgid "When a name is used in a code block, it is resolved using the nearest enclosing scope.  The set of all such scopes visible to a code block is called the block's :dfn:`environment`."
msgstr ""
"Если имя упоминается в блоке кода, то его значение ищется последовательно "
"переходя от данной области видимости к следующей непосредственно объемлющей "
"её – и так далее – до первой содержащей определение данного имени. Множество "
"всех таких областей видимости, используемых блоком кода - называется "
":dfn:`окружением` данного блока."

msgid "If a name is bound in a block, it is a local variable of that block, unless declared as :keyword:`nonlocal`.  If a name is bound at the module level, it is a global variable.  (The variables of the module code block are local and global.)  If a variable is used in a code block but not defined there, it is a :dfn:`free variable`."
msgstr ""
"Если имя было назначено в блоке , то оно является локальной переменной этого "
"блока, если не объявлено явно как не локальное – :keyword:`nonlocal` . Если "
"имя назначено на уровне модуля - оно является глобальной переменной. "
"(Переменные в блоке кода модуля являются с разных точек зрения и локальными "
"и глобальными.) Если переменная используется в блоке кода но не определена "
"непосредственно в нём (но определена в окружении), то она является "
"“:dfn:`свободной переменной`” ."

msgid "When a name is not found at all, a :exc:`NameError` exception is raised.  If the name refers to a local variable that has not been bound, a :exc:`UnboundLocalError` exception is raised.  :exc:`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Когда имя вообще не найдено - вызывается исключение «:exc:`NameError`» . "
"Если это имя указывает на локальную переменную, которая ещё не была связана "
"- вызывается исключение «:exc:`UnboundLocalError`» , которое является "
"подклассом для «:exc:`NameError`» ."

msgid "The following constructs bind names: formal parameters to functions, :keyword:`import` statements, class and function definitions (these bind the class or function name in the defining block), and targets that are identifiers if occurring in an assignment, :keyword:`for` loop header, or after :keyword:`as` in a :keyword:`with` statement or :keyword.`except` clause. The :keyword:`import` statement of the form ``from ... import *`` binds all names defined in the imported module, except those beginning with an underscore.  This form may only be used at the module level."
msgstr ""
"Следующие конструкции назначают имена: формальные параметры функции, "
"инструкция «:keyword:`import`» , определения класса и функции (они назначают "
"имя класса или функции внутри определяющего блока) , и цели назначения, "
"которые являются идентификаторами, когда встречаются в операциях назначения, "
"заголовок цикла «:keyword:`for`» или после «:keyword:`as`» в инструкции "
"«:keyword:`with`» или в выражении «:keyword:`except`» . Инструкция "
"«:keyword:`import`» в форме «``from ... import *``» связывает все имена "
"определённые в импортируемом модуле, за исключением начинающихся со знака "
"подчёркивания. Эта форма может быть использована только на уровне модуля."

msgid "A target occurring in a :keyword:`del` statement is also considered bound for this purpose (though the actual semantics are to unbind the name).  It is illegal to unbind a name that is referenced by an enclosing scope; the compiler will report a :exc:`SyntaxError`."
msgstr ""
"Цель назначения для инструкции «:keyword:`del`» также считается получившей "
"назначение (хотя в действительности смысл в снятии связи с этого имени) . Не "
"допустимо удалять назначение имени, упоминаемого снаружи данного блока – "
"это приведет к сообщению об ошибке «:exc:`SyntaxError`» на этапе "
"компилирования."

msgid "Each assignment or import statement occurs within a block defined by a class or function definition or at the module level (the top-level code block)."
msgstr ""
"Любое назначение или импорт действует только в пределах блока класса, "
"функции или модуля (он является самым высокоуровневым блоком кода) ."

msgid "If a name binding operation occurs anywhere within a code block, all uses of the name within the block are treated as references to the current block.  This can lead to errors when a name is used within a block before it is bound.  This rule is subtle.  Python lacks declarations and allows name binding operations to occur anywhere within a code block.  The local variables of a code block can be determined by scanning the entire text of the block for name binding operations."
msgstr ""
"Если операция связывания имени встречается где-либо внутри блока кода, то "
"все упоминания этого имени внутри этого блока воспринимаются как обращения к "
"текущему блоку. Это может приводить к ошибкам, когда в блоке имя "
"используется до его обьявления. Это тонкое правило. Питон не страдает "
"избытком деклараций и позволяет делать назначения именам в любом месте блока "
"кода. Локальные для блока кода переменные определяются путём сканирования "
"операций связывания имён по всему тексту блока."

msgid "If the :keyword:`global` statement occurs within a block, all uses of the name specified in the statement refer to the binding of that name in the top-level namespace.  Names are resolved in the top-level namespace by searching the global namespace, i.e. the namespace of the module containing the code block, and the builtins namespace, the namespace of the module :mod:`builtins`.  The global namespace is searched first.  If the name is not found there, the builtins namespace is searched.  The global statement must precede all uses of the name."
msgstr ""
"Если инструкция «:keyword:`global`» встречается внутри блока, то все "
"использования данного имени, определённого в данной инструкции, обращаются к "
"тому, что назначено этому имени в области имён верхнего уровня. Значение "
"имени сначала ищется в глобальной области имён – тоесть в области имён "
"соответствующего модуля, содержащего данный блок кода, и, если не найдено, "
"то затем ищется в области имён «:mod:`builtins`» этого модуля. Инструкция "
"«:keyword:`global`» должна предшествовать всем упоминаниям данного имени."

msgid "The builtins namespace associated with the execution of a code block is actually found by looking up the name ``__builtins__`` in its global namespace; this should be a dictionary or a module (in the latter case the module's dictionary is used).  By default, when in the :mod:`__main__` module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any other module, ``__builtins__`` is an alias for the dictionary of the :mod:`builtins` module itself.  ``__builtins__`` can be set to a user-created dictionary to create a weak form of restricted execution."
msgstr ""
"Встроенная область имён, ассоциирующаяся с данным исполнением кода блока, в "
"действительности ищется под именем «``__builtins__``» в его глобальной "
"области имён – и это должен быть словарь или модуль (в последнем случае "
"используется соответствующий словарь этого модуля) . По умолчанию, для "
"модуля «:mod:`__main__`» – «``__builtins__``» – это встроенный модуль "
"«:mod:`builtins`» , а для любого другого модуля – «``__builtins__``» – это "
"псевдоним непосредственно словаря встроенного модуля «:mod:`builtins`» . "
"«``__builtins__``» может быть словарём, определённым пользователем, чтобы "
"создать слабую форму исполнения с ограничениями."

msgid "Users should not touch ``__builtins__``; it is strictly an implementation detail.  Users wanting to override values in the builtins namespace should :keyword:`import` the :mod:`builtins` module and modify its attributes appropriately."
msgstr ""
"Пользователи не должны влазить в «``__builtins__``» - его содержание - это "
"исключительно детали реализации. Пользователи, желающие переопределить "
"значения в этом встроенном пространстве имён должны импортировать модуль "
"«:mod:`builtins`» и модифицировать соответственно его атрибуты."

msgid "The namespace for a module is automatically created the first time a module is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"Пространство имён для модуля автоматически создаётся, когда модуль в первый "
"раз импортируется. Главный модуль скрипта всегда называется "
"«:mod:`__main__`» ."

msgid "The global statement has the same scope as a name binding operation in the same block.  If the nearest enclosing scope for a free variable contains a global statement, the free variable is treated as a global."
msgstr ""
"Инструкция «:keyword:`global`» остаётся в силе в тех же рамках, в каких "
"действует связывание имени, произведённое в том же блоке. Если не связанная "
"в данном блоке переменная (“свободная”) упоминается в нём в инструкции "
"«:keyword:`global`» , то эта переменная считается глобальной."

msgid "A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution.  The namespace of the class definition becomes the attribute dictionary of the class.  Names defined at the class scope are not visible in methods."
msgstr ""
"Описание (код) класса является исполнимым (в момент создания объекта класса) "
"и может упоминать и создавать имена. В этом случае к именам применяются "
"обычные правила интерпретации имён. Область имён самого́ объекта класса "
"становится словарём атрибутов этого класса. Имена определённые в пределах "
"класса не видимы в методах класса."

msgid "Interaction with dynamic features"
msgstr "Взаимодействие с динамическими свойствами"

msgid "There are several cases where Python statements are illegal when used in conjunction with nested scopes that contain free variables."
msgstr ""
"Есть несколько случаев, в которых инструкции Питона являются недопустимыми "
"при использовании совместно с вложенными блоками, содержащими не связанные "
"там (“свободные”) переменные."

msgid "If a variable is referenced in an enclosing scope, it is illegal to delete the name.  An error will be reported at compile time."
msgstr ""
"Если переменная упоминается снаружи данного блока, то удалять её имя "
"недопустимо. Это приведет к сообщению об ошибке на этапе компилирования."

msgid "If the wild card form of import --- ``import *`` --- is used in a function and the function contains or is a nested block with free variables, the compiler will raise a :exc:`SyntaxError`."
msgstr ""
"Если в функции используется вариант импорта всего - «``import *``» , и эта "
"функция содержит блок или содержится в блоке в котором есть свободная "
"переменная, то компилятор выдаёт ошибку «:exc:`SyntaxError`» ."

msgid "The :func:`eval` and :func:`exec` functions do not have access to the full environment for resolving names.  Names may be resolved in the local and global namespaces of the caller.  Free variables are not resolved in the nearest enclosing namespace, but in the global namespace.  [#]_ The :func:`exec` and :func:`eval` functions have optional arguments to override the global and local namespace.  If only one namespace is specified, it is used for both."
msgstr ""
"Функции «:func:`eval`» и «:func:`exec`» не имеют доступа ко всему окружению "
"для интерпретации имён. Значения имён могут искаться в локальной и в "
"глобальной областях имён относительно места вызова. Свободные переменные не "
"ищутся в области имён одним уровнем выше, за исключением глобальной. (Это "
"ограничение происходит от того, что код, исполняемый этими инструкциями не "
"доступен во время компиляции данного модуля.) Функции «:func:`eval`» и "
"«:func:`exec`» имеют необязательные аргументы для переопределения глобальной "
"и локальной областей имён. Если задан только один аргумент, то он "
"используется для обеих областей."

msgid "Exceptions"
msgstr "Исключения"

msgid "Exceptions are a means of breaking out of the normal flow of control of a code block in order to handle errors or other exceptional conditions.  An exception is *raised* at the point where the error is detected; it may be *handled* by the surrounding code block or by any code block that directly or indirectly invoked the code block where the error occurred."
msgstr ""
"Исключения являются средством прерывания нормального хода исполнения кода "
"для обработки ошибок или других исключительных ситуаций. Исключение "
"возникает в месте, где обнаружена ошибка; оно может быть обработано в "
"текущем блоке кода или в любом блоке кода, в котором прямо или косвенно "
"вызван тот блок кода, который вызвал ошибку."

msgid "The Python interpreter raises an exception when it detects a run-time error (such as division by zero).  A Python program can also explicitly raise an exception with the :keyword:`raise` statement. Exception handlers are specified with the :keyword:`try` ... :keyword:`except` statement.  The :keyword:`finally` clause of such a statement can be used to specify cleanup code which does not handle the exception, but is executed whether an exception occurred or not in the preceding code."
msgstr ""
"Интерпретатор Питона исполняет исключение, когда обнаруживает ошибку "
"исполнения (например деление на ноль) . Программа на Питоне также может явно "
"вызывать исключение инструкцией «:keyword:`raise`» . Обработчики исключений "
"задаются инструкцией «:keyword:`try` ... :keyword:`except`» . Ветвь "
"«:keyword:`finally`» этой инструкции может быть использована для задания "
"кода, который исполняется независимо от того, произошло ли исключение в "
"соответствующем блоке «:keyword:`try` ... :keyword:`except`» ( и которая не "
"является функцией, получающей как аргумент идентификатор ошибки, и не "
"является собственно обработчиком ошибки) ."

msgid "Python uses the \"termination\" model of error handling: an exception handler can find out what happened and continue execution at an outer level, but it cannot repair the cause of the error and retry the failing operation (except by re-entering the offending piece of code from the top)."
msgstr ""
"Питон использует “ограничительную” модель обработки ошибок: обработчик "
"исключения может проанализировать ситуацию и продолжить исполнение за "
"пределами блока «:keyword:`try` ... :keyword:`except`» , но не может "
"исправить причину ошибки и всё-таки выполнить сбойную операцию (не считая "
"того, чтобы вызвать весь проблемный фрагмент с самого начала) ."

msgid "When an exception is not handled at all, the interpreter terminates execution of the program, or returns to its interactive main loop.  In either case, it prints a stack backtrace, except when the exception is :exc:`SystemExit`."
msgstr ""
"Если для какой-то ошибки вообще не оказалось обработчика - интерпретатор "
"прекращает выполнение данной программы или переходит к новому циклу - в "
"случае интерактивного общения. В любом случае он выдаёт обратную раскрутку "
"стека (“stack backtrace”) , кроме сучая исключения «:exc:`SystemExit`» ."

msgid "Exceptions are identified by class instances.  The :keyword:`except` clause is selected depending on the class of the instance: it must reference the class of the instance or a base class thereof.  The instance can be received by the handler and can carry additional information about the exceptional condition."
msgstr ""
"При исключительной ситуации для её обозначения создаётся экземпляр "
"соответствующего класса ошибки. Обработчик (ветвь «:keyword:`except`») "
"вызывается, если в нём указан класс или один из базовых классов произошедшей "
"ошибки. Экземпляр класса ошибки может быть получен обработчиком и может "
"содержать дополнительную информацию о ситуации ошибки."

msgid "Exception messages are not part of the Python API.  Their contents may change from one version of Python to the next without warning and should not be relied on by code which will run under multiple versions of the interpreter."
msgstr ""
"Сообщения о исключениях не являются частью API Питона. Их содержание может "
"меняться от одной версии Питона к другой без предупреждения и код, который "
"будет запускаться на разных версиях интерпретатора не должен полагаться на "
"них."

msgid "See also the description of the :keyword:`try` statement in section :ref:`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Также, смотрите разделы «Инструкция “:ref:`try`” » и «Инструкция "
"“:ref:`raise`” » ."

msgid "This limitation occurs because the code that is executed by these operations is not available at the time the module is compiled."
msgstr ""

msgid "Expressions"
msgstr "Выражения"

msgid "This chapter explains the meaning of the elements of expressions in Python."
msgstr "Этот раздел разъясняет значение элементов выражений на Питоне."

msgid "**Syntax Notes:** In this and the following chapters, extended BNF notation will be used to describe syntax, not lexical analysis.  When (one alternative of) a syntax rule has the form"
msgstr ""
"**Замечание о синтаксисе:** В этом и следующем разделах расширенная нотация "
"BNF будет использоваться для описания синтаксиса, а не для лексического "
"анализа. Когда (как одна из альтернатив) синтактическое правило имеет форму"

msgid "and no semantics are given, the semantics of this form of ``name`` are the same as for ``othername``."
msgstr ""
"и не даётся дальнейшей расшифровки, то такая формулировка подразумевает, что "
"``name`` значит то же, что и ``othername`` ."

msgid "Arithmetic conversions"
msgstr "Арифметические преобразования"

msgid "When a description of an arithmetic operator below uses the phrase \"the numeric arguments are converted to a common type,\" this means that the operator implementation for built-in types works that way:"
msgstr ""
"Когда далее в описании арифметического оператора используется фраза "
"“числовые аргументы преобразуются к общему типу” - это значит, что "
"реализация операторов для встроенных типов работает следующим образом:"

msgid "If either argument is a complex number, the other is converted to complex;"
msgstr ""
"Если любой из аргументов является комплексным числом, то другое "
"преобразуется к комплексному;"

msgid "otherwise, if either argument is a floating point number, the other is converted to floating point;"
msgstr ""
"иначе, если любой из аргументов является числом “с плавающею точкой” , то "
"другое преобразуется к этому типу;"

msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""
"иначе – оба числа неизбежно целые, и никакого преобразования не требуется."

#, fuzzy
msgid "Some additional rules apply for certain operators (e.g., a string left argument to the '%' operator).  Extensions must define their own conversion behavior."
msgstr ""
"К некоторым операторам применяются дополнительные правила. Расширения должны "
"определять свою собственную логику преобразований."

msgid "Atoms"
msgstr "Атомы"

msgid "Atoms are the most basic elements of expressions.  The simplest atoms are identifiers or literals.  Forms enclosed in parentheses, brackets or braces are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Атомы являются самыми базовыми (наименьшими) элементами выражений. "
"Простейшими атомами являются идентификаторы и непосредственная запись данных "
"(“литералы”) . Формации заключённые в круглые, квадратные или фигурные "
"скобки - тоже синтаксически относятся к атомам. Синтаксис атомов :"

msgid "Identifiers (Names)"
msgstr "Идентификаторы (имена)"

msgid "An identifier occurring as an atom is a name.  See section :ref:`identifiers` for lexical definition and section :ref:`naming` for documentation of naming and binding."
msgstr ""
"Идентификатор в роли атома является именем. Смотрите лексическое определение "
"в разделе “Идентификаторы и ключевые слова” :ref:`identifiers` , а также "
"документацию по именованию и связыванию в разделе “Именование и связывание” "
":ref:`naming` ."

msgid "When the name is bound to an object, evaluation of the atom yields that object. When a name is not bound, an attempt to evaluate it raises a :exc:`NameError` exception."
msgstr ""
"Когда данное имя назначено обьекту - интерпретация этого атома даёт этот "
"обьект. Когда имя не назначено чему-либо - попытка интерпретировать его "
"вызывает исключение «:exc:`NameError`» ."

msgid "**Private name mangling:** When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a :dfn:`private name` of that class. Private names are transformed to a longer form before code is generated for them.  The transformation inserts the class name in front of the name, with leading underscores removed, and a single underscore inserted in front of the class name.  For example, the identifier ``__spam`` occurring in a class named ``Ham`` will be transformed to ``_Ham__spam``.  This transformation is independent of the syntactical context in which the identifier is used.  If the transformed name is extremely long (longer than 255 characters), implementation defined truncation may happen.  If the class name consists only of underscores, no transformation is done."
msgstr ""
"Модифицирование локальных (частных) имён : Когда идентификатор, "
"встретившийся в тексте определения класса, начинается с двух или более "
"символов подчёркивания и не оканчивается двумя или более символами "
"подчёркивания – он считается частным именем («:dfn:`private name`») данного "
"класса. Частные имена заменяются на их длинную форму при генерации "
"соответствующего кода. Эти длинные формы образуются добавлением в начале "
"имени класса, у которого удаляются все подчёркивания в начале и ставится "
"одно подчёркивание. Например : идентификатор «``__spam``» в классе «``Ham``» "
"будет преобразован в «``_Ham__spam``» . Это преобразование не зависит от "
"синтаксического контекста, в котором идентификатор был использован. Следует "
"помнить, что в некоторых реализациях Питона может происходить обрезание "
"имён, больших определённой длинны. Имена, состоящие только из подчёркиваний "
"– не модифицируются."

msgid "Literals"
msgstr "Непосредственная запись данных (константы, “литералы”)"

msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Питон поддерживает явную запись значений (константы) для текстов, байтов и "
"различных типов чисел :"

msgid "Evaluation of a literal yields an object of the given type (string, bytes, integer, floating point number, complex number) with the given value.  The value may be approximated in the case of floating point and imaginary (complex) literals.  See section :ref:`literals` for details."
msgstr ""
"Интерпретирование явной записи даёт в результате объект соответствующего "
"типа (текст, байты, целое, с плавающей запятой, комплексное числа) с данным "
"значением. В случае констант дробных и комплексных чисел значение может быть "
"установлено приблизительно."

msgid "With the exception of bytes literals, these all correspond to immutable data types, and hence the object's identity is less important than its value. Multiple evaluations of literals with the same value (either the same occurrence in the program text or a different occurrence) may obtain the same object or a different object with the same value."
msgstr ""
"За исключением байтов – все они, по сути, соответствуют неизменяемым типам "
"данных, и поэтому контроль идентичности такого объекта менее важен, чем "
"значение объекта. Многократные упоминания явных записей с одинаковым "
"значением (будь то многократный проход одного места программы или в разных "
"местах) могут получать как тот же объект так и другой объект с таким же "
"значением."

msgid "Parenthesized forms"
msgstr "Формы в скобках"

msgid "A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""
"Формы в скобках – это необязательный список выражений, заключённый в скобки "
":"

msgid "A parenthesized expression list yields whatever that expression list yields: if the list contains at least one comma, it yields a tuple; otherwise, it yields the single expression that makes up the expression list."
msgstr ""

msgid "An empty pair of parentheses yields an empty tuple object.  Since tuples are immutable, the rules for literals apply (i.e., two occurrences of the empty tuple may or may not yield the same object)."
msgstr ""
"Пустая пара скобок даёт объект - пустй кортеж. Поскольку кортежи являются "
"неизменяемыми, то к ним применяются правила для констант (тоесть, два "
"упоминания пустых кортежей могут получать как тот же объект так и другой "
"объект с таким же значением) ."

msgid "Note that tuples are not formed by the parentheses, but rather by use of the comma operator.  The exception is the empty tuple, for which parentheses *are* required --- allowing unparenthesized \"nothing\" in expressions would cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"Заметьте, что кортежи образуются не скобками, а использованием оператора "
"запятая. Исключением является пустой кортеж, для которого пустые скобки "
"*обязательны* (без которых могли бы возникать неоднозначности, и опечатки "
"могли бы оставаться незамеченными) ."

msgid "Displays for lists, sets and dictionaries"
msgstr "Отображения для списков, наборов и словарей"

msgid "For constructing a list, a set or a dictionary Python provides special syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Для создания списков, наборов и словарей Питон предоставляет специальный "
"синтаксис, называемый отображения “:term:`display`s” , для каждого в двух "
"вариантах :"

msgid "either the container contents are listed explicitly, or"
msgstr "либо их содержимое перечисляется явно, либо"

#, fuzzy
msgid "they are computed via a set of looping and filtering instructions, called a :dfn:`comprehension`."
msgstr ""
"они вычисляются с помощью набора циклических и фильтрующих инструкций, что "
"называется “сборка (списка)” ( “генерация (списка)” , “компоновка (списка)” "
", “(list) :dfn:`comprehension`” ) ."

msgid "Common syntax elements for comprehensions are:"
msgstr "Общий синтаксис “сборок” :"

msgid "The comprehension consists of a single expression followed by at least one :keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` clauses. In this case, the elements of the new container are those that would be produced by considering each of the :keyword:`for` or :keyword:`if` clauses a block, nesting from left to right, and evaluating the expression to produce an element each time the innermost block is reached."
msgstr ""
"“Компоновка” состоит из одного выражения, после которого идёт минимум одно "
"ключевое слово «:keyword:`for`» после которого могут быть в любом количестве "
"ключевые слова «:keyword:`for`» или «:keyword:`if`» . В случае, если "
"таковые присутствуют, содержимое группы очередного из них – это то, что "
"получается, если считать каждую группу «:keyword:`for`» или «:keyword:`if`» "
"блоком, вложенным по отношению к тому, что левее, и интерпретировать это "
"выражение, получая очередной элемент каждый раз, дойдя до самого внутреннего "
"блока."

msgid "Note that the comprehension is executed in a separate scope, so names assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""
"Заметьте, что “компоновки” исполняются в отдельной области имён, поэтому "
"имена, которым были назначения в списке приёмников, не “просачиваются” во "
"внешнюю область."

#, fuzzy
msgid "List displays"
msgstr "Отображение (запись, формулировка) списков"

msgid "A list display is a possibly empty series of expressions enclosed in square brackets:"
msgstr ""
"Отображение списка – это последовательность выражений (может быть пустая), "
"заключённая в квадратные скобки :"

msgid "A list display yields a new list object, the contents being specified by either a list of expressions or a comprehension.  When a comma-separated list of expressions is supplied, its elements are evaluated from left to right and placed into the list object in that order.  When a comprehension is supplied, the list is constructed from the elements resulting from the comprehension."
msgstr ""
"Запись списка даёт в результате объект-список, содержание которого "
"определено или перечислением выражений, или конструкцией генерации "
"(компонования) списка (“comprehension”) . В первом варианте, когда дан "
"список выражений, разделённых запятой – его элементы интерпретируются слева "
"направо – и помещаются в объект-список в том же порядке. Во втором варианте, "
"когда дана конструкция компоновки списка – список составляется из "
"элементов, генерируемых этой конструкцией."

#, fuzzy
msgid "Set displays"
msgstr "Отображение (запись, формулировка) множеств"

msgid "A set display is denoted by curly braces and distinguishable from dictionary displays by the lack of colons separating keys and values:"
msgstr ""
"Запись множества обозначается фигурными скобками, и признаком, отличающим "
"его от словаря, является отсутствие двоеточий – разделителей ключей и "
"значений :"

msgid "A set display yields a new mutable set object, the contents being specified by either a sequence of expressions or a comprehension.  When a comma-separated list of expressions is supplied, its elements are evaluated from left to right and added to the set object.  When a comprehension is supplied, the set is constructed from the elements resulting from the comprehension."
msgstr ""
"Запись множества даёт в результате изменяемый объект-множество, содержание "
"которого определено или перечислением выражений, или конструкцией генерации "
"(компонования) списков (“comprehension”) . В первом варианте, когда дан "
"список выражений, разделённых запятой – его элементы интерпретируются слева "
"направо – и добавляются к объекту-множеству. Во втором варианте, когда дана "
"конструкция компоновки списков – множество составляется из элементов, "
"генерируемых этой конструкцией."

msgid "An empty set cannot be constructed with ``{}``; this literal constructs an empty dictionary."
msgstr ""
"Пустое множество не может быть создано с помощью обозначения «``{}``» – эта "
"запись создаёт пустой словарь."

#, fuzzy
msgid "Dictionary displays"
msgstr "Запись (обозначение, формулировка) словарей"

msgid "A dictionary display is a possibly empty series of key/datum pairs enclosed in curly braces:"
msgstr ""
"Запись словаря – это последовательность (может быть пустая) пар ключ – "
"данные, заключённая в фигурные скобки :"

msgid "A dictionary display yields a new dictionary object."
msgstr "Запись словаря даёт в результате новый объект-словарь."

msgid "If a comma-separated sequence of key/datum pairs is given, they are evaluated from left to right to define the entries of the dictionary: each key object is used as a key into the dictionary to store the corresponding datum.  This means that you can specify the same key multiple times in the key/datum list, and the final dictionary's value for that key will be the last one given."
msgstr ""
"Если дана последовательность разделённых запятой пар : ключ - данные, то они "
"интерпретируются с лева направо и множество всех ключей образуют множество "
"имён элементов словаря, а соответствующие им данные становятся значениями "
"этих элементов. При этом : если тот же ключ встречается в этой "
"последовательности несколько раз, то только последнее значение, "
"соответствующее ему, окажется в словаре-результате."

msgid "A dict comprehension, in contrast to list and set comprehensions, needs two expressions separated with a colon followed by the usual \"for\" and \"if\" clauses. When the comprehension is run, the resulting key and value elements are inserted in the new dictionary in the order they are produced."
msgstr ""
"В конструкции сборки (генерации) словаря, в отличие от таковых для списков и "
"множеств, должно присутствовать два выражения, разделённых двоеточием, за "
"которыми следуют обычные конструкции «:keyword:`for`» и «:keyword:`if`» . "
"При исполнении сборки каждая пара значений в качестве соответственно ключа и "
"его значения вставляется в словарь в порядке генерации."

msgid "Restrictions on the types of the key values are listed earlier in section :ref:`types`.  (To summarize, the key type should be :term:`hashable`, which excludes all mutable objects.)  Clashes between duplicate keys are not detected; the last datum (textually rightmost in the display) stored for a given key value prevails."
msgstr ""
"Ограничения того, каким типам могут принадлежать ключи (а не сопоставленные "
"им объекты) – перечислены выше, в разделе “Иерархия стандартных типов” "
":ref:`types` . (Коротко : ключ должен быть хешируемого (:term:`hashable`) "
"типа, что сразу исключает любые изменяемые типы. ) Коллизии между "
"одинаковыми ключами не детектируются – просто последнее значение (самое "
"правое, по тексту) , сохранённое под данным ключом, заменяет предыдущие "
"значения."

msgid "Generator expressions"
msgstr "Генераторные выражения"

msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"Генераторное выражение – это компактная форма записи генераторов в скобках :"

msgid "A generator expression yields a new generator object.  Its syntax is the same as for comprehensions, except that it is enclosed in parentheses instead of brackets or curly braces."
msgstr ""
"Генераторное выражение даёт в результате новый объект-генератор. Синтаксис у "
"этого выражения такой же, как и у генератора списка, за исключением того, "
"что оно заключено в круглые скобки вместо квадратных или фигурных."

msgid "Variables used in the generator expression are evaluated lazily when the :meth:`__next__` method is called for generator object (in the same fashion as normal generators).  However, the leftmost :keyword:`for` clause is immediately evaluated, so that an error produced by it can be seen before any other possible error in the code that handles the generator expression.  Subsequent :keyword:`for` clauses cannot be evaluated immediately since they may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in range(10) for y in bar(x))``."
msgstr ""
"Переменные, используемые в генераторных выражениях, вычисляются отложенно, "
"во время вызова метода «:meth:`__next__`» у объекта-генератора (так же, как "
"и для обычных генераторов) . Однако, самое левое выражение «:keyword:`for`» "
"вычисляется сразу же – поэтому ошибка в нём проявится раньше, чем в других "
"частях кода, контролируемых данным генераторным выражением. Следующие (в том "
"же генераторном выражении) «:keyword:`for`» – не могут интерпретироваться "
"сразу же, поскольку они могут зависеть от «:keyword:`for`» слева. (Например "
": «``(x*y for x in range(10) for y in bar(x))``» . )"

msgid "The parentheses can be omitted on calls with only one argument.  See section :ref:`calls` for the detail."
msgstr ""
"Скобки можно пропустить при вызове функции, у которой один аргумент. "
"(Смотрите раздел :ref:`calls` )"

#, fuzzy
msgid "Yield expressions"
msgstr "Выражения с «``yield``»"

msgid "The :keyword:`yield` expression is only used when defining a generator function, and can only be used in the body of a function definition.  Using a :keyword:`yield` expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function."
msgstr ""
"Ключевое слово «:keyword:`yield`» используется только для задания "
"генераторной функции и может использоваться только внутри определения "
"функции. Чтобы превратить определение обычной функции в определение "
"генераторной – достаточно использовать в этом определении инструкцию "
"«:keyword:`yield`» ."

#, fuzzy
msgid "When a generator function is called, it returns an iterator known as a generator.  That generator then controls the execution of a generator function. The execution starts when one of the generator's methods is called.  At that time, the execution proceeds to the first :keyword:`yield` expression, where it is suspended again, returning the value of :token:`expression_list` to generator's caller.  By suspended we mean that all local state is retained, including the current bindings of local variables, the instruction pointer, and the internal evaluation stack.  When the execution is resumed by calling one of the generator's methods, the function can proceed exactly as if the :keyword:`yield` expression was just another external call.  The value of the :keyword:`yield` expression after resuming depends on the method which resumed the execution."
msgstr ""
"Вызов генераторной функции возвращает в качестве результата объект-итератор, "
"называемый также генератор. И уже́ этот генератор управляет исполнением "
"генераторной функции. Собственно исполнение начинается, когда вызывается "
"один из методов этого объекта-итератора, и продолжается оно до первой "
"встреченной инструкции «:keyword:`yield`» , где исполнение опять "
"приостанавливается, и аргумент инструкции «:keyword:`yield`» возвращается в "
"качестве результата вызова соответствующего метода. Под приостановкой "
"подразумевается, что всё локальное состояние сохраняется, включая текущие "
"значения локальных переменных, указатель на инструкцию, с которой "
"продолжать, и внутренний стек вычислений. А когда, в результате следующего "
"вызова одного из методов этого итератора, исполнение возобновляется, то оно "
"продолжается точно так же, как если бы вместо «:keyword:`yield`» был вызов "
"обычной внешней функции. Значение выражения «:keyword:`yield`» зависит от "
"метода, возобновившего исполнение."

msgid "All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended.  The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transfered to the generator's caller."
msgstr ""
"Всё это делает генераторные функции похожими на со-процедуры (“coroutines”) "
": они выдают результат многократно, у них более одной точки входа и их "
"исполнение может быть приостановлено. Единственное отличие в том, что "
"генераторная функция не может управлять тем, что должно исполняться, после "
"того, как она приостанавливается – контроль всегда возвращается туда, откуда "
"этот генератор был вызван."

msgid "The :keyword:`yield` statement is allowed in the :keyword:`try` clause of a :keyword:`try` ...  :keyword:`finally` construct.  If the generator is not resumed before it is finalized (by reaching a zero reference count or by being garbage collected), the generator-iterator's :meth:`close` method will be called, allowing any pending :keyword:`finally` clauses to execute."
msgstr ""
"Инструкция «:keyword:`yield`» допустима в ветви «:keyword:`try`» конструкции "
"«:keyword:`try` ... :keyword:`finally`» . Если данный генератор не был "
"завершён до его “деструкции” (вследствие достижения ноля счётчиком ссылок "
"или действием “сборщика мусора”) , то будет вызван метод «:meth:`close`» "
"данного генератора, что позволяет исполниться незавершённым ветвям "
"«:keyword:`finally`» ."

msgid "The following generator's methods can be used to control the execution of a generator function:"
msgstr ""
"Генераторная функция для управления её исполнением имеет следующие методы :"

msgid "Starts the execution of a generator function or resumes it at the last executed :keyword:`yield` expression.  When a generator function is resumed with a :meth:`__next__` method, the current :keyword:`yield` expression always evaluates to :const:`None`.  The execution then continues to the next :keyword:`yield` expression, where the generator is suspended again, and the value of the :token:`expression_list` is returned to :meth:`next`'s caller. If the generator exits without yielding another value, a :exc:`StopIteration` exception is raised."
msgstr ""
"Начинает исполнение генераторной функции или продолжает его с последней "
"исполненной инструкции «:keyword:`yield`» . Если в результате вызова метода "
"«:meth:`__next__`» генераторная функция продолжает работу, которая была "
"приостановлена вызовом функции «:keyword:`yield`» , то эта "
"«:keyword:`yield`» завершается, выдавая результат «:const:`None`» . Затем "
"исполнение генератора продолжается до следующей инструкции "
"«:keyword:`yield`» , где оно опять приостанавливается, а значение "
"выражения-аргумента инструкции «:keyword:`yield`» возвращается в место "
"вызова функции «:meth:`next`» . Если происходит выход из генератора не по "
"инструкции «:keyword:`yield`» , то вызывается исключение "
"«:exc:`StopIteration`» ."

msgid "This method is normally called implicitly, e.g. by a :keyword:`for` loop, or by the built-in :func:`next` function."
msgstr ""
"В норме этот метод не вызывается прямо, а, например, косвенно циклом "
"«:keyword:`for`» или встроенной функцией «:func:`next`» ."

msgid "Resumes the execution and \"sends\" a value into the generator function.  The ``value`` argument becomes the result of the current :keyword:`yield` expression.  The :meth:`send` method returns the next value yielded by the generator, or raises :exc:`StopIteration` if the generator exits without yielding another value.  When :meth:`send` is called to start the generator, it must be called with :const:`None` as the argument, because there is no :keyword:`yield` expression that could receive the value."
msgstr ""
"Продолжает исполнение генераторной функции от последней исполненной "
"инструкции «:keyword:`yield`» , которая теперь наконец завершается, выдавая "
"в качестве своего результата аргумент ``value`` функции «:meth:`send`» . "
"Затем исполнение генератора продолжается до следующей инструкции "
"«:keyword:`yield`» , где оно опять приостанавливается, а значение "
"выражения-аргумента инструкции «:keyword:`yield`» возвращается в место "
"вызова функции «:meth:`send`» . Если происходит выход из генератора не по "
"инструкции «:keyword:`yield`» , то вызывается исключение "
"«:exc:`StopIteration`» (и возврат в «:meth:`send`» не происходит) . Если "
"функция «:meth:`send`» вызывается для генератора, который ещё не был запущен "
"и приостановлен посредством «:keyword:`yield`» , то она должна вызывается "
"только с аргументом «:const:`None`» (потому, что нет функции "
"«:keyword:`yield`» , ожидающей значение) ."

msgid "Raises an exception of type ``type`` at the point where generator was paused, and returns the next value yielded by the generator function.  If the generator exits without yielding another value, a :exc:`StopIteration` exception is raised.  If the generator function does not catch the passed-in exception, or raises a different exception, then that exception propagates to the caller."
msgstr ""
"Приводит к исключению типа «``type``» в том месте генератора, где он был "
"остановлен. Если генератор перехватывает это исключение, то : или функция "
"«:func:`throw`» возвращает следующее значение, выданное генератором, или, "
"если генератор завершается без инструкции «:keyword:`yield`» , то вызывается "
"исключение «:exc:`StopIteration`» . Если же генератор не перехватывает "
"переданное ему исключение, или генерирует какое-либо исключение сам, то "
"происходит возврат к функции «:func:`throw`» с этим исключением."

#, fuzzy
msgid "Raises a :exc:`GeneratorExit` at the point where the generator function was paused.  If the generator function then raises :exc:`StopIteration` (by exiting normally, or due to already being closed) or :exc:`GeneratorExit` (by not catching the exception), close returns to its caller.  If the generator yields a value, a :exc:`RuntimeError` is raised.  If the generator raises any other exception, it is propagated to the caller.  :meth:`close` does nothing if the generator has already exited due to an exception or normal exit."
msgstr ""
"Вызывает «:exc:`GeneratorExit`» в месте, где генератор был приостановлен. "
"Если генератор после этого вызывает «:exc:`StopIteration`» (путём "
"нормального выхода, или если уже был остановлен) или «:exc:`GeneratorExit`» "
"(путём неперехватывания этого исключения) , то происходит выход из "
"«:meth:`close`» с результатом «:const:`None`» . Если генератор вызывает "
"любое другое исключение, то оно возвращается в «:meth:`close`» . Если же "
"генератор выдаёт значение (кроме «:const:`None`» ) , то вызывается "
"«:exc:`RuntimeError`» ."

msgid "Here is a simple example that demonstrates the behavior of generators and generator functions::"
msgstr ""
"Простой пример, демонстрирующий поведение объектов-генераторов и "
"генераторных функций :"

msgid ">>> def echo(value=None): ...     print(\"Execution starts when 'next()' is called for the first time.\") ...     try: ...         while True: ...             try: ...                 value = (yield value) ...             except Exception as e: ...                 value = e ...     finally: ...         print(\"Don't forget to clean up when 'close()' is called.\") ... >>> generator = echo(1) >>> print(next(generator)) Execution starts when 'next()' is called for the first time. 1 >>> print(next(generator)) None >>> print(generator.send(2)) 2 >>> generator.throw(TypeError, \"spam\") TypeError('spam',) >>> generator.close() Don't forget to clean up when 'close()' is called."
msgstr ""
">>> def echo(value=None): ...     print(\"Execution starts when 'next()' is "
"called for the first time.\") ...     try: ...         while True: ... "
"            try: ...                 value = (yield value) ...             "
"except Exception as e: ...                 value = e ...     finally: ... "
"        print(\"Don't forget to clean up when 'close()' is called.\") ... >>> "
"generator = echo(1) >>> print(next(generator)) Execution starts when "
"'next()' is called for the first time. 1 >>> print(next(generator)) None >>> "
"print(generator.send(2)) 2 >>> generator.throw(TypeError, \"spam\") "
"TypeError('spam',) >>> generator.close() Don't forget to clean up when "
"'close()' is called."

msgid "The proposal for adding generators and the :keyword:`yield` statement to Python."
msgstr ""
"Предложение по добавлению в Питон генераторов и инструкции "
"«:keyword:`yield`» ."

msgid "The proposal to enhance the API and syntax of generators, making them usable as simple coroutines."
msgstr ""
"Предложение по улучшению API и синтаксиса генераторов, делающему их "
"пригодными для простейшего параллельного программирования."

msgid "Primaries"
msgstr "Первичные выражения"

msgid "Primaries represent the most tightly bound operations of the language. Their syntax is:"
msgstr ""
"Первичные выражения – это базовые понятия, операции языка, такие как : "
"взятие атрибута, взятие элемента(элементов) по индексу, вызов функции. У них "
"следующий синтаксис :"

msgid "Attribute references"
msgstr "Обращение к атрибутам"

msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""
"Обращение к атрибуту состоит из другого первичного выражения (в том числе "
"атома) после которого идёт точка и пото́м имя (атрибута) ."

msgid "The primary must evaluate to an object of a type that supports attribute references, which most objects do.  This object is then asked to produce the attribute whose name is the identifier (which can be customized by overriding the :meth:`__getattr__` method).  If this attribute is not available, the exception :exc:`AttributeError` is raised.  Otherwise, the type and value of the object produced is determined by the object.  Multiple evaluations of the same attribute reference may yield different objects."
msgstr ""
"Значением выражения «``primary``» должен быть объект, тип которого "
"поддерживает обращение к атрибутам (таких типов – большинство) . К этим "
"объектам делается запрос выдать атрибут с указанным именем "
"(«``identifier``») . Этот процесс может быть настроен переопределением "
"метода «:meth:`__getattr__`» . Тип и значение возвращаемого атрибута "
"задаётся объектом, которому тот принадлежит, причём каждое обращение к "
"атрибуту может выдавать уже́ новый объект. Если этот атрибут недоступен, то "
"вызывается исключение «:exc:`AttributeError`» ."

msgid "Subscriptions"
msgstr "Обращение к элементу по индексу"

msgid "A subscription selects an item of a sequence (string, tuple or list) or mapping (dictionary) object:"
msgstr ""
"Взятие по индексу выделяет определённый элемент из последовательности "
"(например, из строки, кортежа, списка) или из словаря :"

msgid "The primary must evaluate to an object that supports subscription, e.g. a list or dictionary.  User-defined objects can support subscription by defining a :meth:`__getitem__` method."
msgstr ""
"Значением выражения «``primary``» должен быть объект, тип которого "
"поддерживает взятие элемента по индексу. Определённые пользователем объекты "
"тоже могут поддерживать взятие элемента – определив метод "
"«:meth:`__getitem__`» ."

msgid "For built-in objects, there are two types of objects that support subscription:"
msgstr ""
"Есть два типа встроенных объектов, поддерживающих взятие элемента по индексу "
":"

msgid "If the primary is a mapping, the expression list must evaluate to an object whose value is one of the keys of the mapping, and the subscription selects the value in the mapping that corresponds to that key.  (The expression list is a tuple except if it has exactly one item.)"
msgstr ""
"Если «``primary``» является отображением (словарём) , то значением "
"«``expression_list``» должен быть объект, являющийся одним из ключей данного "
"отображения, и тогда извлекается значение, соответствующее данному ключу. "
"«``expression_list``» является кортежем, если только в списке не ровно одно "
"выражение."

msgid "If the primary is a sequence, the expression (list) must evaluate to an integer. If this value is negative, the length of the sequence is added to it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting value must be a nonnegative integer less than the number of items in the sequence, and the subscription selects the item whose index is that value (counting from zero)."
msgstr ""
"Если «``primary``» является последовательностью, то значением "
"«``expression_list``» должно быть целое число. Если это число негативное, то "
"к нему прибавляется длина последовательности (таким образом, «``x[-1]``» "
"указывает на последний элемент в «``x``» ) . Результирующее значение должно "
"быть неотрицательным целым меньшим длины данной последовательности. И в "
"качестве результата извлекается элемент, чьим индексом является это значение "
"(учитывая, что элементы номеруются с ноля) ."

msgid "A string's items are characters.  A character is not a separate data type but a string of exactly one character."
msgstr ""
"Элементами текстовых данных (“строк”) являются символы. Причём символ "
"является не отдельным типом данных, а такою же строкой, но только из одного "
"символа."

msgid "Slicings"
msgstr "“Срезы”"

msgid "A slicing selects a range of items in a sequence object (e.g., a string, tuple or list).  Slicings may be used as expressions or as targets in assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Срез выделяет диапазон элементов в объекте-последовательности (например в "
"строке, в кортеже) . Срезы могут использоваться и как выражения (дающие в "
"результате значение) и как цель для назначения или инструкции "
"«:keyword:`del`» . Синтаксис следующий :"

msgid "There is ambiguity in the formal syntax here: anything that looks like an expression list also looks like a slice list, so any subscription can be interpreted as a slicing.  Rather than further complicating the syntax, this is disambiguated by defining that in this case the interpretation as a subscription takes priority over the interpretation as a slicing (this is the case if the slice list contains no proper slice)."
msgstr ""
"В этом формальном синтаксисе есть неоднозначность : что-либо, выглядящее как "
"список выражений – одновременно выглядит как список срезов. Из-за этого "
"любое взятие по индексу может быть интерпретировано как срез. Вместо "
"дополнительного усложнения синтаксиса – двусмысленность снята тем, что в "
"такой ситуации интерпретирование как взятие по индексу приоритетнее, чем как "
"срез (именно это и происходит если в списке среза нет правильного среза) ."

msgid "The semantics for a slicing are as follows.  The primary must evaluate to a mapping object, and it is indexed (using the same :meth:`__getitem__` method as normal subscription) with a key that is constructed from the slice list, as follows.  If the slice list contains at least one comma, the key is a tuple containing the conversion of the slice items; otherwise, the conversion of the lone slice item is the key.  The conversion of a slice item that is an expression is that expression.  The conversion of a proper slice is a slice object (see section :ref:`types`) whose :attr:`start`, :attr:`stop` and :attr:`step` attributes are the values of the expressions given as lower bound, upper bound and stride, respectively, substituting ``None`` for missing expressions."
msgstr ""

msgid "Calls"
msgstr "Вызовы"

msgid "A call calls a callable object (e.g., a function) with a possibly empty series of arguments:"
msgstr ""
"При вызове вызывается (исполняется) вызываемый (исполнимый) объект (например "
"функция) , которому передаётся список параметров (может быть пустым) :"

msgid "A trailing comma may be present after the positional and keyword arguments but does not affect the semantics."
msgstr ""
"После позиционных и именованных аргументов может стоять конечная (лишняя) "
"запятая – она не имеет никакого значения и на смысл не влияет."

msgid "The primary must evaluate to a callable object (user-defined functions, built-in functions, methods of built-in objects, class objects, methods of class instances, and all objects having a :meth:`__call__` method are callable).  All argument expressions are evaluated before the call is attempted.  Please refer to section :ref:`function` for the syntax of formal parameter lists."
msgstr ""
"Значением «``primary``» должен быть вызываемый объект (определяемая "
"пользователем или встроенная функция, метод встроенного объекта, "
"объект-класс, метод экземпляра класса или любой объект с методом "
"«:meth:`__call__`» ) . Все выражения-аргументы вычисляются прежде, чем "
"делается попытка вызова. Синтаксис списка “формальных” параметров в "
"определении функции смотрите в разделе «Функции» :ref:`function` ."

msgid "If keyword arguments are present, they are first converted to positional arguments, as follows.  First, a list of unfilled slots is created for the formal parameters.  If there are N positional arguments, they are placed in the first N slots.  Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on).  If the slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, the value of the argument is placed in the slot, filling it (even if the expression is ``None``, it fills the slot).  When all arguments have been processed, the slots that are still unfilled are filled with the corresponding default value from the function definition.  (Default values are calculated, once, when the function is defined; thus, a mutable object such as a list or dictionary used as default value will be shared by all calls that don't specify an argument value for the corresponding slot; this should usually be avoided.)  If there are any unfilled slots for which no default value is specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of filled slots is used as the argument list for the call."
msgstr ""
"Если даны именованные аргументы, то они сначала преобразуются в позиционные "
"следующим образом. Сначала для “формальных” параметров создаётся список "
"незаполненных мест. Если дано *N* позиционных аргументов, то они помещаются "
"в *N* первых из этих мест. Далее для каждого именованного аргумента "
"определяется, каким по счёту он идёт в формальных параметрах определения "
"функции – и в такое же по счёту место помещается его значение (даже если это "
"значение ««:const:`None`»» ) . Если это место оказывается уже́ занятым, то "
"вызывается исключение «:exc:`TypeError`» . Когда все аргументы обработаны – "
"места, оставшиеся необработанными заполняются соответствующими значениями "
"по-умолчанию из определения функции. (Значения по-умолчанию вычисляются один "
"раз – когда выполняется определение функции – таким образом, изменяемый "
"объект, например список или словарь, использованный как значение "
"по-умолчанию, будет сохраняться между вызовами функции, и его предыдущее "
"значение будет доступно, если в него не будет передано значение в "
"соответствующем аргументе при вызове. ) Если останутся незаполненными места, "
"для которых нет значений по-умолчанию, то вызывается исключение "
"«:exc:`TypeError`» . Заполненный таким образом список используется как "
"список аргументов функции."

msgid "An implementation may provide built-in functions whose positional parameters do not have names, even if they are 'named' for the purpose of documentation, and which therefore cannot be supplied by keyword.  In CPython, this is the case for functions implemented in C that use :cfunc:`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"В какой-либо реализации могут быть встроенные функции, чьи позиционные "
"параметры не имеют имён (несмотря на то, что в ихней документации для "
"удобства используются некие “имена” ) и, таким образом, эти параметры не "
"могут быть переданы как именованные аргументы. Как пример – функции, "
"реализованные на “C” с использованием «:cfunc:`PyArg_ParseTuple`» для "
"разбора аргументов ."

msgid "If there are more positional arguments than there are formal parameter slots, a :exc:`TypeError` exception is raised, unless a formal parameter using the syntax ``*identifier`` is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments)."
msgstr ""
"Если дано больше аргументов, чем параметров в определении, то вызывается "
"исключение «:exc:`TypeError`» , если только в определении не присутствует "
"параметр с синтаксисом «``*identifier``» – в этом случае этот параметр "
"получает кортеж, содержащий лишние аргументы (или пустой кортеж, если нет "
"таковых) ."

msgid "If any keyword argument does not correspond to a formal parameter name, a :exc:`TypeError` exception is raised, unless a formal parameter using the syntax ``**identifier`` is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Если какой-либо именованный аргумент не соответствует имени параметра в "
"определении, то вызывается исключение «:exc:`TypeError`» , если только в "
"определении не присутствует параметр с синтаксисом «``**identifier``» – в "
"этом случае этот параметр получает словарь (или пустой словарь, если нет "
"лишних), содержащий лишние именованные аргументы, чьи имена становятся "
"ключами – и они получают соответствующие значения."

msgid "If the syntax ``*expression`` appears in the function call, ``expression`` must evaluate to a sequence.  Elements from this sequence are treated as if they were additional positional arguments; if there are positional arguments *x1*,..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, *y1*, ..., *yM*."
msgstr ""
"Если в вызове функции встречается синтаксис «``*expression``» , то значением "
"«``expression``» должна быть последовательность. Элементы из этой "
"последовательности извлекаются и воспринимаются как дополнительные "
"позиционные аргументы – тоесть, если в вызове даны позиционные аргументы "
"*x1*,..., *xN* и «``expression``» даёт элементы *y1*, ..., *yM* , то это "
"эквивалентно вызову с *M*+*N* штуками аргументов *x1*, ..., *xN*, *y1*, ..., "
"*yM* ."

msgid "A consequence of this is that although the ``*expression`` syntax may appear *after* some keyword arguments, it is processed *before* the keyword arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""
"Следствием из этого является то, что, хотя «``*expression``» может идти "
"*после* некоторых именованных аргументов, «``*expression``» обрабатывается "
"*раньше* них (и раньше аргумента «``**expression``» ) . Таким образом :"

msgid ">>> def f(a, b): ...  print(a, b) ... >>> f(b=1, *(2,)) 2 1 >>> f(a=1, *(2,)) Traceback (most recent call last):   File \"<stdin>\", line 1, in ? TypeError: f() got multiple values for keyword argument 'a' >>> f(1, *(2,)) 1 2"
msgstr ""
">>> def f(a, b): ...  print(a, b) ... >>> f(b=1, *(2,)) 2 1 >>> f(a=1, "
"*(2,)) Traceback (most recent call last):   File \"<stdin>\", line 1, in ? "
"TypeError: f() got multiple values for keyword argument 'a' >>> f(1, *(2,)) "
"1 2"

msgid "It is unusual for both keyword arguments and the ``*expression`` syntax to be used in the same call, so in practice this confusion does not arise."
msgstr ""
"Использование в вызове одновременно именованных аргументов и синтаксиса "
"«``*expression``» является редким – только поэтому на практике редко "
"возникают и соответствующие недоразумения."

msgid "If the syntax ``**expression`` appears in the function call, ``expression`` must evaluate to a mapping, the contents of which are treated as additional keyword arguments.  In the case of a keyword appearing in both ``expression`` and as an explicit keyword argument, a :exc:`TypeError` exception is raised."
msgstr ""
"Если в вызове функции встречается синтаксис «``**expression``» , то "
"значением «``expression``» должно быть отображение (словарь) . Элементы из "
"этого отображения извлекаются и воспринимаются как дополнительные "
"именованные аргументы. Если некий ключ (имя) присутствует и в "
"«``expression``» и как явный именованный аргумент, то вызывается исключение "
"«:exc:`TypeError`» ."

msgid "Formal parameters using the syntax ``*identifier`` or ``**identifier`` cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Параметры в определении, использующие синтаксис «``*identifier``» или "
"«``**identifier``» , не могут быть использованы как позиционные получатели "
"(как места́) или как имена именованных аргументов."

msgid "A call always returns some value, possibly ``None``, unless it raises an exception.  How this value is computed depends on the type of the callable object."
msgstr ""
"Вызов всегда возвращает какое-либо значение (в частности «:const:`None`» ) – "
"если только этот вызов не привёл к исключению. То, каким способом это "
"значение вычисляется – зависит от типа вызываемого объекта."

#, fuzzy
msgid "If it is---"
msgstr "Далее перечисленны типы и действия –"

msgid "The code block for the function is executed, passing it the argument list.  The first thing the code block will do is bind the formal parameters to the arguments; this is described in section :ref:`function`.  When the code block executes a :keyword:`return` statement, this specifies the return value of the function call."
msgstr ""
"Функции передаётся список аргументов, и её блок кода исполняется. Первое, "
"что происходит в блоке кода – это связывание имён “формальных” параметров с "
"предоставленными аргументами (подробнее в разделе «Определение функций» "
":ref:`function` ) . Если в блоке кода исполняется инструкция "
"«:keyword:`return`» , то она задаёт возвращаемое функцией значение – иначе, "
"по-умолчанию, – возвращается «:const:`None`» ."

msgid "The result is up to the interpreter; see :ref:`built-in-funcs` for the descriptions of built-in functions and methods."
msgstr ""
"Результат зависит от интерпретатора. Смотрите “Встроенные функции” :ref"
":`built-in-funcs`  ."

msgid "A new instance of that class is returned."
msgstr "Возвращается новый экземпляр этого класса."

msgid "The corresponding user-defined function is called, with an argument list that is one longer than the argument list of the call: the instance becomes the first argument."
msgstr ""
"Вызывается соответствующая пользовательская функция, к списку аргументов "
"которой в начале подставляется дополнительный аргумент – соответствующий "
"экземпляр (у которого вызывается метод) ."

msgid "The class must define a :meth:`__call__` method; the effect is then the same as if that method was called."
msgstr ""
"В классе должен быть определён метод «:meth:`__call__`» (одноимённый метод "
"определённый в самом экземпляре – игнорируется при простом вызове экземпляра "
") , в остальном – аналогично вызову *метода* экземпляра класса."

msgid "The power operator"
msgstr "Оператор возведения в степень"

msgid "The power operator binds more tightly than unary operators on its left; it binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"Оператор степени имеет бо́льший приоритет, чем однооперандные операторы "
"непосредственно слева, но меньший, чем однооперандные операторы "
"непосредственно справа. Его синтаксис :"

msgid "Thus, in an unparenthesized sequence of power and unary operators, the operators are evaluated from right to left (this does not constrain the evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Таким образом в последовательности без кавычек из степени и однооперандных "
"операторов вычисление выполняется с права налево (это не влияет на порядок "
"действий вутри выражений операндов) : «``-1**2``» даёт результат «``-1``» ."

msgid "The power operator has the same semantics as the built-in :func:`pow` function, when called with two arguments: it yields its left argument raised to the power of its right argument.  The numeric arguments are first converted to a common type, and the result is of that type."
msgstr ""
"Оператор степени имеет тот же смысл, что и встроенная функция «:func:`pow`» "
"– если вызывается с двумя аргументами : левый аргумент возводится в степень "
"правого. Числовые аргументы сначала преобразуются к общему типу, и результат "
"будет этого же типа."

msgid "For int operands, the result has the same type as the operands unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"Для целочисленных операндов результат тоже будет целым, если только второй "
"операнд не негативный – в таком случае все аргументы преобразуются в "
"дробные, и результат тоже будет дробный. Например : «``10**2``» даёт "
"«``100``» , но «``10**-2``» даёт «``0.01``» ."

msgid "Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. Raising a negative number to a fractional power results in a :class:`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Возведение «``0.0``» в негативную степень вызывает исключение "
"«:exc:`ZeroDivisionError`» . Возведение негативного числа в дробную степень "
"даёт комплексное число (в прошлых версиях вызывалось исключение "
"«:exc:`ValueError`» ) ."

msgid "Unary arithmetic and bitwise operations"
msgstr "Однооперандные арифметические и побитовые операци"

msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Все однооперандные арифметические и побитовые операци имеют одинаковый "
"приоритет :"

msgid "The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""
"«``-``» (минус) негативирует (умножает на «``-1``» ) свой числовой аргумент."

msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr "«``+``» (плюс) не изменяет свой числовой аргумент."

msgid "The unary ``~`` (invert) operator yields the bitwise inversion of its integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  It only applies to integral numbers."
msgstr ""
"Оператор «``~``» побитово инвертирует свой целочисленный аргумент, и для "
"аргумента «``x``» определяется как «``-(x+1)``» ."

msgid "In all three cases, if the argument does not have the proper type, a :exc:`TypeError` exception is raised."
msgstr ""
"Во всех трёх случаях – если аргумент не требуемого типа, то вызывается "
"исключение «:exc:`TypeError`» ."

msgid "Binary arithmetic operations"
msgstr "Двухоперандные арифметические операции"

msgid "The binary arithmetic operations have the conventional priority levels.  Note that some of these operations also apply to certain non-numeric types.  Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators:"
msgstr ""
"У двухоперандных арифметических операций уровни приоритета соответствуют "
"общепринятым. Заметьте, что некоторые из них также применяются для "
"нечисловых типов. Кроме операции степени – среди них есть только два уровня "
"приоритета : выше – для произведения и деления (одинаковый) , и ниже – для "
"суммы и вычитания (одинаковый) ."

msgid "The ``*`` (multiplication) operator yields the product of its arguments.  The arguments must either both be numbers, or one argument must be an integer and the other must be a sequence. In the former case, the numbers are converted to a common type and then multiplied together.  In the latter case, sequence repetition is performed; a negative repetition factor yields an empty sequence."
msgstr ""
"Оператор «``*``» (умножение) даёт произведение своих операндов. Операнды "
"должны быть или оба чи́сла, или один – число, а другой последовательность. В "
"первом случае – числа преобразуются к общему типу и перемножаются. Во "
"втором – последовательность повторяется количество раз равное другому "
"операнду, чьё отрицательное значение означает ноль повторений (пустая "
"последовательность) ."

msgid "The ``/`` (division) and ``//`` (floor division) operators yield the quotient of their arguments.  The numeric arguments are first converted to a common type. Integer division yields a float, while floor division of integers results in an integer; the result is that of mathematical division with the 'floor' function applied to the result.  Division by zero raises the :exc:`ZeroDivisionError` exception."
msgstr ""
"Операторы «``/``» (деление) и «``//``» (деление нацело) дают частное своих "
"операндов. Операнды должны быть оба числа и они преобразуются к общему типу. "
"Деление даёт в результате дробное число. Деление нацело даёт в результате "
"целое число, получающееся из соответствующего дробного результата "
"округлением функцией «:func:`floor`» . Деление на ноль вызывает исключение "
"«:exc:`ZeroDivisionError`» ."

msgid "The ``%`` (modulo) operator yields the remainder from the division of the first argument by the second.  The numeric arguments are first converted to a common type.  A zero right argument raises the :exc:`ZeroDivisionError` exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo operator always yields a result with the same sign as its second operand (or zero); the absolute value of the result is strictly smaller than the absolute value of the second operand [#]_."
msgstr ""
"Оператор «``%``» (остаток деления) даёт остаток деления первого операнда на "
"второй. Операнды должны быть оба числами и они преобразуются к общему типу. "
"При нолевом втором аргументе вызывается исключение "
"«:exc:`ZeroDivisionError`» . Аргументы могут быть дробными числами, "
"например, ``3.14%0.7`` равно ``0.34`` (поскольку ``3.14`` равно ``4*0.7 + "
"0.34`` ) . Результат всегда имеет знак, равный знаку делителя или же равен "
"нолю. Модуль результата строго меньше модуля делителя. [#]_"

msgid "The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//y, x%y)``. [#]_."
msgstr ""
"Операторы деления нацело и остатка связаны следующим равенством : «``x == "
"(x//y)*y + (x%y)``» . Также они связаны со встроенной функцией "
"«:func:`divmod`» : «``divmod(x, y) == (x//y, x%y)``» . [#]_"

msgid "In addition to performing the modulo operation on numbers, the ``%`` operator is also overloaded by string objects to perform old-style string formatting (also known as interpolation).  The syntax for string formatting is described in the Python Library Reference, section :ref:`old-string-formatting`."
msgstr ""
"В строковых объектах оператор «``%``» переопределён и используется для "
"старого стиля форматирования текста (так называемые “interpolation” ) . "
"Синтаксис такого форматирования определён в “Python Library Reference” "
"раздел :ref:`old-string-formatting` ."

msgid "The floor division operator, the modulo operator, and the :func:`divmod` function are not defined for complex numbers.  Instead, convert to a floating point number using the :func:`abs` function if appropriate."
msgstr ""
"Операторы деления нацело, взятие остатка и функция «:func:`divmod`» не "
"определены для комплексных чисел – требуется явное преобразование в дробные "
"функцией «:func:`abs`» ."

msgid "The ``+`` (addition) operator yields the sum of its arguments.  The arguments must either both be numbers or both sequences of the same type.  In the former case, the numbers are converted to a common type and then added together.  In the latter case, the sequences are concatenated."
msgstr ""
"Оператор «``+``» (сложение) даёт сумму своих аргументов. Аргументы должны "
"быть или оба числами, или оба последовательностями одинакового типа. В "
"первом случае – числа преобразуются к общему типу и складываются. Во втором "
"– последовательности соединяются ."

msgid "The ``-`` (subtraction) operator yields the difference of its arguments.  The numeric arguments are first converted to a common type."
msgstr ""
"Оператор «``-``» (вычитание) даёт разность своих аргументов. Числовые "
"аргументы сначала преобразуются к общему типу."

msgid "Shifting operations"
msgstr "Операции сдвига"

msgid "The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Операции сдвига имеют приоритет меньший, чем у арифметических операций :"

msgid "These operators accept integers as arguments.  They shift the first argument to the left or right by the number of bits given by the second argument."
msgstr ""
"Аргументы должны быть целыми числами. Затем производится сдвиг двоичного "
"представления первого аргумента соответственно влево или вправо на "
"количество бит равное второму аргументу."

# Как правильно вписывать символы > и < (больше и меньше) ? Судя по очерёдности этих предложений в оригинале, подозреваю, что и там не знали.
msgid "A right shift by *n* bits is defined as division by ``pow(2,n)``.  A left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"Сдвиг вправо определяется как целая часть от деления на 2 в степени второго "
"аргумента («``a>>b``» = «``a / pow(2, b)``») . Сдвиг влево определяется как "
"умножение на 2 в степени второго аргумента («``a<<b``» = «``a * pow(2, "
"b)``») ."

msgid "In the current implementation, the right-hand operand is required to be at most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""

msgid "Binary bitwise operations"
msgstr "Двоичные побитовые операции"

msgid "Each of the three bitwise operations has a different priority level:"
msgstr "Все эти три операции имеют разный приоритет :"

msgid "The ``&`` operator yields the bitwise AND of its arguments, which must be integers."
msgstr ""
"Оператор «``&``» производит побитовую операцию “И” (“AND”) над "
"целочисленными аргументами."

msgid "The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, which must be integers."
msgstr ""
"Оператор «``^``» производит побитовую операцию “исключающее ИЛИ” (“XOR”) над "
"целочисленными аргументами."

msgid "The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which must be integers."
msgstr ""
"Оператор «``|``» производит побитовую операцию “ИЛИ” (“OR”) над "
"целочисленными аргументами."

msgid "Comparisons"
msgstr "Сравнения"

msgid "Unlike C, all comparison operations in Python have the same priority, which is lower than that of any arithmetic, shifting or bitwise operation.  Also unlike C, expressions like ``a < b < c`` have the interpretation that is conventional in mathematics:"
msgstr ""
"В отличие от “C” – все операции сравнения в Питоне имеют одинаковый "
"приоритет, который ниже, чем у любых арифметических, сдвиговых или побитовых "
"операций. Также, в отличие от “C” , выражения типа «``a < b < c``» "
"интерпретируются, как это принято в математике."

msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""
"Сравнения дают в результате булевы значения : «:const:`True`» или "
"«:const:`False`» ."

msgid "Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in both cases ``z`` is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Сравнения могут соединяться в произвольные цепочки, например : «``x < y <= "
"z``» эквивалентно «``x < y and y <= z``» , за исключением того, что «``y``» "
"вычисляется только один раз (но в обоих вариантах «``z``» вообще не "
"вычисляется, если «``x < y``» не верно) ."

msgid "Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, *op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that each expression is evaluated at most once."
msgstr ""
"Общее правило : если *a*, *b*, *c*, ..., *y*, *z* – выражения, и *op1*, "
"*op2*, ..., *opN* – операторы сравнения, то «``a op1 b op2 c ... y opN z``» "
"является эквивалентом «``a op1 b and b op2 c and ... y opN z``» , за "
"исключением того, что каждое выражение вычисляется только один раз."

msgid "Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not pretty)."
msgstr ""
"Заметьте, что «``a op1 b op2 c``» не подразумевает никаких сравнений «``a``» "
"и «``c``» , так что, например, «``x < y > z``» абсолютно приемлемо (хотя и "
"не очень красиво) ."

msgid "The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the values of two objects.  The objects need not have the same type. If both are numbers, they are converted to a common type.  Otherwise, the ``==`` and ``!=`` operators *always* consider objects of different types to be unequal, while the ``<``, ``>``, ``>=`` and ``<=`` operators raise a :exc:`TypeError` when comparing objects of different types that do not implement these operators for the given pair of types.  You can control comparison behavior of objects of non-built-in types by defining rich comparison methods like :meth:`__gt__`, described in section :ref:`customization`."
msgstr ""
"Операторы «``<``» , «``>``» , «``==``» , «``>=``» , «``<=``» и «``!=``» "
"сравнивают значения двух объектов. Эти объекты не обязаны иметь одинаковый "
"тип. Если оба являются числами, то они преобразуются к общему типу. Если не "
"числа, то операторы «``==``» и «``!=``» всегда считают объекты отличающихся "
"типов неравными, а операторы «``<``» , «``>``» , «``>=``» и «``<=``» "
"вызывают «:exc:`TypeError`» для отличающихся типов, не имеющих реализации "
"соответствующих операторов для данной пары типов. Вы можете контролировать "
"поведение сравнения для объектов не встроенных типов, определяя методы "
"расширенного сравнения типа «:meth:`__gt__`» , как описано в разделе "
"“Основные средства настройки классов” :ref:`customization` ."

msgid "Comparison of objects of the same type depends on the type:"
msgstr "Сравнение объектов одинакового типа зависит от типа :"

msgid "Numbers are compared arithmetically."
msgstr "Числа сравниваются арифметически."

msgid "The values :const:`float('NaN')` and :const:`Decimal('NaN')` are special. The are identical to themselves, ``x is x`` but are not equal to themselves, ``x != x``.  Additionally, comparing any value to a not-a-number value will return ``False``.  For example, both ``3 < float('NaN')`` and ``float('NaN') < 3`` will return ``False``."
msgstr ""
"Значения «:const:`float('NaN')`» и «:const:`Decimal('NaN')`» являются "
"особыми. Они идентичны самим себе «``x is x``» , но не равны самим себе «``x "
"!= x``» . Более того, сравнение любого значения с “Not-a-Number” возвращает "
"«:const:`False`» . Например : и «``3 < float('NaN')``» и «``float('NaN') < "
"3``» вернут «:const:`False`» ."

msgid "Bytes objects are compared lexicographically using the numeric values of their elements."
msgstr ""
"«:term:`“Байты”<bytes>`» сравниваются поэлементно до первого несовпадения "
"(лексикографически) , с использованием числовых значений их элементов."

msgid "Strings are compared lexicographically using the numeric equivalents (the result of the built-in function :func:`ord`) of their characters. [#]_ String and bytes object can't be compared!"
msgstr ""
"“Строки” сравниваются посимвольно до первого несовпадения "
"(лексикографически) , с использованием числовых эквивалентов (возвращаемых "
"встроенной функцией «:func:`ord`» ) для их элементов-симвлов. [#]_ “Строки” "
"нельзя сравнивать с байтами."

msgid "Tuples and lists are compared lexicographically using comparison of corresponding elements.  This means that to compare equal, each element must compare equal and the two sequences must be of the same type and have the same length."
msgstr ""
"Кортежи и списки сравниваются поэлементно до первого несовпадения "
"(лексикографически) . Это подразумевает, что для равенства – все "
"соответствующие элементы должны быть равны и сами последовательности должны "
"быть одинакового типа и одинаковой длины."

msgid "If not equal, the sequences are ordered the same as their first differing elements.  For example, ``[1,2,x] <= [1,2,y]`` has the same value as ``x <= y``.  If the corresponding element does not exist, the shorter sequence is ordered first (for example, ``[1,2] < [1,2,3]``)."
msgstr ""
"Если последовательности не равны, то они упорядочиваются по первым "
"несовпадающим элементам. Например, «``[1,2,x] <= [1,2,y]``» имеет тот же "
"результат, что и «``x <= y``» . Если соответствующий элемент отсутствует, то "
"более короткая последовательность меньше (идёт раньше) , например : "
"«``[1,2]``» < «``[1,2,3]``» ."

msgid "Mappings (dictionaries) compare equal if and only if their sorted ``(key, value)`` lists compare equal. [#]_ Outcomes other than equality are resolved consistently, but are not otherwise defined. [#]_"
msgstr ""
"Отображения (словари) равны только если равны их отсортированные по ключу "
"списки пар ключ-значение (в данной реализации такое сравнение производится "
"эффективно – без реального конструирования списков или сортирования). [#]_ "
"Другие результаты сравнения, кроме равенства – решаются соответственно, (?) "
"но не определены иначе. [#]_ Предыдущие версии Питона использовали сравнение "
"таких отсортированных списков (из пар ключ-значение) по первому "
"несовпадающему элементу (тоесть, “лексикографически” ) , но это было слишком "
"затратно для наиболее распространенного случая – проверки только на "
"равенство. Ещё более ранние версии Питона сравнивали словари только по факту "
"того один и тот же ли это объект, но это приводило к неожиданностям – "
"поскольку люди ожидали иметь возможность проверять пуст ли словарь, "
"сравнивая его с «``{}``» (новым пустым словарём) ."

msgid "Sets and frozensets define comparison operators to mean subset and superset tests.  Those relations do not define total orderings (the two sets ``{1,2}`` and {2,3} are not equal, nor subsets of one another, nor supersets of one another).  Accordingly, sets are not appropriate arguments for functions which depend on total ordering.  For example, :func:`min`, :func:`max`, and :func:`sorted` produce undefined results given a list of sets as inputs."
msgstr ""
"Множества (“sets”) и фиксированные множества (“frozensets”) определяют "
"операторы сравнения для реализации понятий подмножества и надмножества. Эти "
"отношения не подразумевают определения полного упорядочивания (например, "
"множества «``{1,2}``» и «``{2,3}``» ни равны, ни подмножество или "
"надмножество одно для другого) . Соответственно – множества не являются "
"годными аргументами для функций, результат которых зависит от полного "
"упорядочивания. Например : «:func:`min`» , «:func:`max`» и «:func:`sorted`» "
"выдают неопределённый результат, получив список множеств."

msgid "Most other objects of built-in types compare unequal unless they are the same object; the choice whether one object is considered smaller or larger than another one is made arbitrarily but consistently within one execution of a program."
msgstr ""
"Большинство других объектов встроенных типов считаются неравными, за "
"исключением случая, когда это оказывается один и тот же объект. Выбор того, "
"считается ли один объект меньше другого, делается произвольно – но одинаково "
"в течение всего исполнения программы."

msgid "Comparison of objects of the differing types depends on whether either of the types provide explicit support for the comparison.  Most numeric types can be compared with one another, but comparisons of :class:`float` and :class:`Decimal` are not supported to avoid the inevitable confusion arising from representation issues such as ``float('1.1')`` being inexactly represented and therefore not exactly equal to ``Decimal('1.1')`` which is.  When cross-type comparison is not supported, the comparison method returns ``NotImplemented``.  This can create the illusion of non-transitivity between supported cross-type comparisons and unsupported comparisons.  For example, ``Decimal(2) == 2`` and `2 == float(2)`` but ``Decimal(2) != float(2)``."
msgstr ""
"Сравнение объектов различающихся типов зависит от того, предоставляет ли тип "
"кого-либо из них явную поддержку для такого сравнения. Большинство числовых "
"типов можно сравнивать друг с другом, но сравнение «:class:`float`» с "
"«:class:`Decimal`» не поддерживается – для избежания неустранимой неясности, "
"происходящей из особенностей представления (реализации) , например "
"«``float('1.1')``» , чьё машинное представление является приближённым и, как "
"следствие, является не строго равным «``Decimal('1.1')``» , чьё машинное "
"представление строго соответствует записи. Когда межтиповое сравнение не "
"поддерживается – возвращается «``NotImplemented``» . Это может создать "
"иллюзию нетранзитивности между поддерживаемыми и неподдерживаемыми "
"межтиповыми сравнениями. Например, «``Decimal(2) == 2``» и «``2 == "
"float(2)``» , но «``Decimal(2) != float(2)``» ."

msgid "The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x in s`` evaluates to true if *x* is a member of *s*, and false otherwise.  ``x not in s`` returns the negation of ``x in s``.  All built-in sequences and set types support this as well as dictionary, for which :keyword:`in` tests whether a the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Операторы «:keyword:`in`» и «:keyword:`not in`» проверяют на вхождение "
"(членство) . «``x in s``» даёт результат «:const:`True`» если «``x``» "
"является членом «``s``» – в остальных случаях – результат «:const:`False`» . "
"Все встроенные последовательности и множества поддерживают эти инструкции, "
"при этом для словаря подразумевается поиск во множестве его ключей. Для "
"контейнерных типов – таких как список, кортеж, множество, фиксированное "
"множество, словарь или «``collections.deque``» – выражение «``x in y``» "
"является эквивалентом «``any(x is e or x == e for e in y)``» ."

msgid "For the string and bytes types, ``x in y`` is true if and only if *x* is a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty strings are always considered to be a substring of any other string, so ``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"Для текстовых и байтовых типов «``x in y``» даёт результат «:const:`True`» "
"только если «``x``» является подстрокой для «``y``» . Эквивалентом является "
"«``y.find(x) != -1``» . Пустой текст считается подстрокой для любого текста, "
"тоесть : «``\"\" in \"abc\"``» вернёт «:const:`True`» ."

msgid "For user-defined classes which define the :meth:`__contains__` method, ``x in y`` is true if and only if ``y.__contains__(x)`` is true."
msgstr ""
"Для пользовательских классов, в которых определён метод "
"«:meth:`__contains__`» , результат операции «in» определяется исключительно "
"этим методом."

msgid "For user-defined classes which do not define :meth:`__contains__` but do define :meth:`__iter__`, ``x in y`` is true if some value ``z`` with ``x == z`` is produced while iterating over ``y``.  If an exception is raised during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""
"Для пользовательских классов, в которых не определён метод "
"«:meth:`__contains__`» , но определён метод «:meth:`__iter__`» , операция "
"«``x in y``» даёт результат «:const:`True`» , если при переборе элементов "
"«``y``» находится хотя бы одно такое значение «``z``» , что «``x == z``» . "
"Если при этом переборе происходит исключение, то эффект таков, как если бы "
"оно произошло в самой операции «:keyword:`in`» ."

msgid "Lastly, the old-style iteration protocol is tried: if a class defines :meth:`__getitem__`, ``x in y`` is true if and only if there is a non-negative integer index *i* such that ``x == y[i]``, and all lower integer indices do not raise :exc:`IndexError` exception.  (If any other exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"И, наконец, делается попытка использовать протокол перебора в старом стиле : "
"если в классе определён «:meth:`__getitem__`» , то «``x in y``» даёт в "
"результате «:const:`True`» только если есть такое неотрицательный целый "
"индекс «``i``» , что «``x == y[i]``» и все меньшие индексы не вызывают "
"исключение «:exc:`IndexError`» . Если происходит исключение любого другого "
"типа, то эффект таков, как если бы оно произошло в самой операции "
"«:keyword:`in`» ."

msgid "The operator :keyword:`not in` is defined to have the inverse true value of :keyword:`in`."
msgstr ""
"Оператор «:keyword:`not in`» определён как отрицание логического результата "
"«:keyword:`in`» (над теми же операндами) ."

msgid "The operators :keyword:`is` and :keyword:`is not` test for object identity: ``x is y`` is true if and only if *x* and *y* are the same object.  ``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Операторы «:keyword:`is`» и «:keyword:`is not`» проверяют на идентичность "
"объекта : «``x is y``» даёт в результате «:const:`True`» только если «``x``» "
"и «``y``» являются одним и тем же объектом. «``is not y``» даёт отрицание "
"логического результата оператора «``is``» (над теми же операндами) ."

msgid "Boolean operations"
msgstr "Логические операции"

msgid "In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: ``False``, ``None``, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets).  All other values are interpreted as true.  User-defined objects can customize their truth value by providing a :meth:`__bool__` method."
msgstr ""
"В контексте логических операций а также в выражениях-параметрах инструкций "
"управления потоком программы (ветвления, циклы) – следующие значения "
"интерпретируются как логическая ложь : «:const:`False`» , «:const:`None`» , "
"число ноль любого типа, пустые строки, пустые контейнеры. Все остальные "
"значения интерпретируются как логическая истина. Определённые пользователем "
"объекты могут задать значение истинности определив метод «:meth:`__bool__`» "
"."

msgid "The operator :keyword:`not` yields ``True`` if its argument is false, ``False`` otherwise."
msgstr ""
"Оператор «:keyword:`not`» даёт в результате «:const:`True`» , если его "
"аргумент является ложью, иначе – даёт в результате «:const:`False`» ."

msgid "The expression ``x and y`` first evaluates *x*; if *x* is false, its value is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Для выражения «``x and y``» сначала вычисляется значение выражения «``x``» – "
"если это значение ложно, то возвращается это значение (которое было до "
"приведения к логическому типу) , иначе дальше вычисляется значение выражения "
"«``y``» и оно возвращается (без приведения к логическому типу) в качестве "
"значения операции «``and``» ."

msgid "The expression ``x or y`` first evaluates *x*; if *x* is true, its value is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Для выражения «``x or y``» сначала вычисляется значение выражения «``x``» – "
"если это значение истинно, то возвращается это значение (которое было до "
"приведения к логическому типу) , иначе дальше вычисляется значение выражения "
"«``y``» и оно возвращается (без приведения к логическому типу) в качестве "
"значения операции «``or``» ."

msgid "(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and type they return to ``False`` and ``True``, but rather return the last evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string that should be replaced by a default value if it is empty, the expression ``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to invent a value anyway, it does not bother to return a value of the same type as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""
"Заметьте, что ни «:keyword:`and`» , ни «:keyword:`or`» не ограничивают "
"значение и тип результата значениями «:const:`False`» и «:const:`True`» , а "
"просто возвращают в неизменном виде значение операнда, взятого последним. "
"Это иногда может быть полезно – например, если «``s``» – текст, который, "
"если он пустой, должен быть заменён на текст по-умолчанию, то выражение «``s "
"or 'foo'``» даёт какраз такой эффект. Поскольку операция «:keyword:`not`» в "
"любом случае должна сгенерировать новое значение, то она не заботится о "
"том, чтобы вернуть значение того же типа, что и её аргумент, поэтому, "
"например, «``not 'foo'``» выдаёт «:const:`False`» , а не «``''``» ."

msgid "Conditional Expressions"
msgstr ""

msgid "Conditional expressions (sometimes called a \"ternary operator\") have the lowest priority of all Python operations."
msgstr ""

msgid "The expression ``x if C else y`` first evaluates the condition, *C* (*not* *x*); if *C* is true, *x* is evaluated and its value is returned; otherwise, *y* is evaluated and its value is returned."
msgstr ""

msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""

msgid "Lambdas"
msgstr "Ламбда-функции"

msgid "Lambda forms (lambda expressions) have the same syntactic position as expressions.  They are a shorthand to create anonymous functions; the expression ``lambda arguments: expression`` yields a function object.  The unnamed object behaves like a function object defined with ::"
msgstr ""
"Ламбда-выражения находятся в той же позиции, в которой ожидается обычное "
"выражение. Они являются сокращённой формой создания анонимных функций. "
"Выражение «``lambda arguments: expression``» возвращает вместо себя "
"объект-функцию. Этот безымянный объект-функция ведёт себя, как если бы был "
"определён так : ::"

msgid "def <lambda>(arguments):     return expression"
msgstr "def <lambda>(arguments):     return expression"

msgid "See section :ref:`function` for the syntax of parameter lists.  Note that functions created with lambda forms cannot contain statements or annotations."
msgstr ""
"Смотрите синтаксис списка параметров в разделе «Определение функций» "
":ref:`function` . Заметьте, что функции, созданные ламбда-выражением, не "
"могут содержать инструкций или аннотаций."

msgid "Expression lists"
msgstr "Списки выражений"

msgid "An expression list containing at least one comma yields a tuple.  The length of the tuple is the number of expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"Список выражений, содержащий как минимум одну запятую, даёт в результате "
"кортеж. Длинною кортежа считается количество его элементов (выражений в "
"соответствующем списке) . Эти выражения вычисляются поочерёдно с лева "
"направо."

msgid "The trailing comma is required only to create a single tuple (a.k.a. a *singleton*); it is optional in all other cases.  A single expression without a trailing comma doesn't create a tuple, but rather yields the value of that expression. (To create an empty tuple, use an empty pair of parentheses: ``()``.)"
msgstr ""
"Запятая в самом конце, после последнего элемента – требуется только для "
"создания одноэлементного кортежа (“singleton” , “одиночка”) – в других "
"случаях такая концевая запятая не требуется. Одиночное выражение без такой "
"концевой запятой после него не создаёт кортеж, а просто возвращает само "
"значение этого выражения. А для обозначения пустого кортежа используйте "
"пустую пару круглых скобок : «`` ( ) ``» ."

msgid "Evaluation order"
msgstr "Очерёдность вычисления"

msgid "Python evaluates expressions from left to right.  Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side."
msgstr ""
"Питон обрабатывает (вычисляет) выражения с лева направо. Заметьте, что при "
"обработке назначений – сначала обрабатывается правая часть (источник) , "
"потом левая (получатель) ."

msgid "In the following lines, expressions will be evaluated in the arithmetic order of their suffixes::"
msgstr ""
"В следующем коде числа на концах имён выражений соответствуют очерёдности их "
"обработки : ::"

msgid "expr1, expr2, expr3, expr4 (expr1, expr2, expr3, expr4) {expr1: expr2, expr3: expr4} expr1 + expr2 * (expr3 - expr4) expr1(expr2, expr3, *expr4, **expr5) expr3, expr4 = expr1, expr2"
msgstr ""
"expr1, expr2, expr3, expr4 (expr1, expr2, expr3, expr4) {expr1: expr2, "
"expr3: expr4} expr1 + expr2 * (expr3 - expr4) expr1(expr2, expr3, *expr4, "
"**expr5) expr3, expr4 = expr1, expr2"

msgid "Summary"
msgstr "Обобщение"

msgid "The following table summarizes the operator precedences in Python, from lowest precedence (least binding) to highest precedence (most binding).  Operators in the same box have the same precedence.  Unless the syntax is explicitly given, operators are binary.  Operators in the same box group left to right (except for comparisons, including tests, which all have the same precedence and chain from left to right --- see section :ref:`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""
"Следующая таблица показывает приоритетность операторов в Питоне – от "
"наименьшей приоритетности (слабейшая связь с операндами) к наивысшей "
"(сильнейшая связь) . Операторы в одной ячейке имеют одинаковую "
"приоритетность. Если синтаксис не указан явно – подразумеваются "
"двухоперандные операторы. Операторы из одной ячейки приоритетности, идущие в "
"коде подряд, исполняются с лева направо (кроме операторов сравнения и "
"возведения в степень, у которых обратный порядок исполнения – смотрите "
":ref:`comparisons` ) ."

msgid "Operator"
msgstr "Оператор"

msgid "Description"
msgstr "Описание"

msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

msgid "Lambda expression"
msgstr "Ламбда-выражение"

msgid ":keyword:`if` -- :keyword:`else`"
msgstr ":keyword:`if` -- :keyword:`else`"

msgid "Conditional expression"
msgstr "Выражение условия"

msgid ":keyword:`or`"
msgstr ":keyword:`or`"

msgid "Boolean OR"
msgstr "Логическое ИЛИ"

msgid ":keyword:`and`"
msgstr ":keyword:`and`"

msgid "Boolean AND"
msgstr "Логическое И"

msgid ":keyword:`not` *x*"
msgstr ":keyword:`not` *x*"

msgid "Boolean NOT"
msgstr "Логическое НЕ"

msgid ":keyword:`in`, :keyword:`not` :keyword:`in`, :keyword:`is`, :keyword:`is not`, ``<``, ``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not` :keyword:`in`, :keyword:`is`, :keyword:`is "
"not`, ``<``, ``<=``, ``>``, ``>=``, ``!=``, ``==``"

msgid "Comparisons, including membership tests and identity tests,"
msgstr "Сравнения, проверки на идентичность или вхождение"

msgid "``|``"
msgstr "``|``"

msgid "Bitwise OR"
msgstr "Побитовое ИЛИ"

msgid "``^``"
msgstr "``^``"

msgid "Bitwise XOR"
msgstr "Побитовое Исключающее ИЛИ (XOR)"

msgid "``&``"
msgstr "``&``"

msgid "Bitwise AND"
msgstr "Побитовое И"

msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

msgid "Shifts"
msgstr "Сдвиги"

msgid "``+``, ``-``"
msgstr "``+``, ``-``"

msgid "Addition and subtraction"
msgstr "Сложение и вычитание"

msgid "``*``, ``/``, ``//``, ``%``"
msgstr "``*``, ``/``, ``//``, ``%``"

msgid "Multiplication, division, remainder"
msgstr "Умножение, деление, остаток"

msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

msgid "Positive, negative, bitwise NOT"
msgstr "Позитивация, негативация, побитовое НЕ"

msgid "``**``"
msgstr "``**``"

msgid "Exponentiation [#]_"
msgstr "Степень [#]_"

msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

msgid "Subscription, slicing, call, attribute reference"
msgstr "Индексация, вызов, обращение к атрибуту"

msgid "``(expressions...)``, ``[expressions...]``, ``{key:datum...}``,"
msgstr "``(expressions...)``, ``[expressions...]``, ``{key:datum...}``,"

msgid "Binding or tuple display, list display, dictionary display,"
msgstr ""
"Записи (:term:`display`) : кортежа или списка получателей, списка, словаря, "
"множества"

msgid "While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be true numerically due to roundoff.  For example, and assuming a platform on which a Python float is an IEEE 754 double-precision number, in order that ``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is ``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  Function :func:`fmod` in the :mod:`math` module returns a result whose sign matches the sign of the first argument instead, and so returns ``-1e-100`` in this case. Which approach is more appropriate depends on the application."
msgstr ""

msgid "If x is very close to an exact integer multiple of y, it's possible for ``x//y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, Python returns the latter result, in order to preserve that ``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""

msgid "While comparisons between strings make sense at the byte level, they may be counter-intuitive to users.  For example, the strings ``\"\\u00C7\"`` and ``\"\\u0327\\u0043\"`` compare differently, even though they both represent the same unicode character (LATIN CAPITAL LETTER C WITH CEDILLA).  To compare strings in a human recognizable way, compare using :func:`unicodedata.normalize`."
msgstr ""

msgid "The implementation computes this efficiently, without constructing lists or sorting."
msgstr ""

msgid "Earlier versions of Python used lexicographic comparison of the sorted (key, value) lists, but this was very expensive for the common case of comparing for equality.  An even earlier version of Python compared dictionaries by identity only, but this caused surprises because people expected to be able to test a dictionary for emptiness by comparing it to ``{}``."
msgstr ""

msgid "Due to automatic garbage-collection, free lists, and the dynamic nature of descriptors, you may notice seemingly unusual behaviour in certain uses of the :keyword:`is` operator, like those involving comparisons between instance methods, or constants.  Check their documentation for more info."
msgstr ""

msgid "The power operator ``**`` binds less tightly than an arithmetic or bitwise unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"Оператор степени «``**``» имеет меньший приоритет, чем арифметические или "
"побитовые однооперандные операторы непосредственно справа от него, так, "
"например, «``2**-1``» даёт «``0.5``» ."

msgid "Full Grammar specification"
msgstr "Полная спецификация грамматики"

msgid "This is the full Python grammar, as it is read by the parser generator and used to parse Python source files:"
msgstr ""

msgid "The Python Language Reference"
msgstr ""

#, fuzzy
msgid "Release"
msgstr "Выпуск"

msgid "|version|"
msgstr ""

msgid "Date"
msgstr "Дата"

msgid "|today|"
msgstr ""

msgid "This reference manual describes the syntax and \"core semantics\" of the language. It is terse, but attempts to be exact and complete. The semantics of non-essential built-in object types and of the built-in functions and modules are described in :ref:`library-index`. For an informal introduction to the language, see :ref:`tutorial-index`. For C or C++ programmers, two additional manuals exist: :ref:`extending-index` describes the high-level picture of how to write a Python extension module, and the :ref:`c-api-index` describes the interfaces available to C/C++ programmers in detail."
msgstr ""

msgid "Introduction"
msgstr ""

msgid "This reference manual describes the Python programming language. It is not intended as a tutorial."
msgstr ""

msgid "While I am trying to be as precise as possible, I chose to use English rather than formal specifications for everything except syntax and lexical analysis. This should make the document more understandable to the average reader, but will leave room for ambiguities. Consequently, if you were coming from Mars and tried to re-implement Python from this document alone, you might have to guess things and in fact you would probably end up implementing quite a different language. On the other hand, if you are using Python and wonder what the precise rules about a particular area of the language are, you should definitely be able to find them here. If you would like to see a more formal definition of the language, maybe you could volunteer your time --- or invent a cloning machine :-)."
msgstr ""

msgid "It is dangerous to add too many implementation details to a language reference document --- the implementation may change, and other implementations of the same language may work differently.  On the other hand, CPython is the one Python implementation in widespread use (although alternate implementations continue to gain support), and its particular quirks are sometimes worth being mentioned, especially where the implementation imposes additional limitations. Therefore, you'll find short \"implementation notes\" sprinkled throughout the text."
msgstr ""

msgid "Every Python implementation comes with a number of built-in and standard modules.  These are documented in :ref:`library-index`.  A few built-in modules are mentioned when they interact in a significant way with the language definition."
msgstr ""

msgid "Alternate Implementations"
msgstr ""

msgid "Though there is one Python implementation which is by far the most popular, there are some alternate implementations which are of particular interest to different audiences."
msgstr ""

msgid "Known implementations include:"
msgstr ""

msgid "This is the original and most-maintained implementation of Python, written in C. New language features generally appear here first."
msgstr ""

msgid "Python implemented in Java.  This implementation can be used as a scripting language for Java applications, or can be used to create applications using the Java class libraries.  It is also often used to create tests for Java libraries. More information can be found at `the Jython website <http://www.jython.org/>`_."
msgstr ""

msgid "This implementation actually uses the CPython implementation, but is a managed .NET application and makes .NET libraries available.  It was created by Brian Lloyd.  For more information, see the `Python for .NET home page <http://pythonnet.sourceforge.net>`_."
msgstr ""

msgid "An alternate Python for .NET.  Unlike Python.NET, this is a complete Python implementation that generates IL, and compiles Python code directly to .NET assemblies.  It was created by Jim Hugunin, the original creator of Jython.  For more information, see `the IronPython website <http://www.ironpython.com/>`_."
msgstr ""

msgid "An implementation of Python written completely in Python. It supports several advanced features not found in other implementations like stackless support and a Just in Time compiler. One of the goals of the project is to encourage experimentation with the language itself by making it easier to modify the interpreter (since it is written in Python).  Additional information is available on `the PyPy project's home page <http://pypy.org/>`_."
msgstr ""

msgid "Each of these implementations varies in some way from the language as documented in this manual, or introduces specific information beyond what's covered in the standard Python documentation.  Please refer to the implementation-specific documentation to determine what else you need to know about the specific implementation you're using."
msgstr ""

msgid "Notation"
msgstr ""

msgid "The descriptions of lexical analysis and syntax use a modified BNF grammar notation.  This uses the following style of definition:"
msgstr ""

msgid "The first line says that a ``name`` is an ``lc_letter`` followed by a sequence of zero or more ``lc_letter``\\ s and underscores.  An ``lc_letter`` in turn is any of the single characters ``'a'`` through ``'z'``.  (This rule is actually adhered to for the names defined in lexical and grammar rules in this document.)"
msgstr ""

msgid "Each rule begins with a name (which is the name defined by the rule) and ``::=``.  A vertical bar (``|``) is used to separate alternatives; it is the least binding operator in this notation.  A star (``*``) means zero or more repetitions of the preceding item; likewise, a plus (``+``) means one or more repetitions, and a phrase enclosed in square brackets (``[ ]``) means zero or one occurrences (in other words, the enclosed phrase is optional).  The ``*`` and ``+`` operators bind as tightly as possible; parentheses are used for grouping.  Literal strings are enclosed in quotes.  White space is only meaningful to separate tokens. Rules are normally contained on a single line; rules with many alternatives may be formatted alternatively with each line after the first beginning with a vertical bar."
msgstr ""

msgid "In lexical definitions (as the example above), two more conventions are used: Two literal characters separated by three dots mean a choice of any single character in the given (inclusive) range of ASCII characters.  A phrase between angular brackets (``<...>``) gives an informal description of the symbol defined; e.g., this could be used to describe the notion of 'control character' if needed."
msgstr ""

msgid "Even though the notation used is almost the same, there is a big difference between the meaning of lexical and syntactic definitions: a lexical definition operates on the individual characters of the input source, while a syntax definition operates on the stream of tokens generated by the lexical analysis. All uses of BNF in the next chapter (\"Lexical Analysis\") are lexical definitions; uses in subsequent chapters are syntactic definitions."
msgstr ""

msgid "Lexical analysis"
msgstr "Лексический анализ"

msgid "A Python program is read by a *parser*.  Input to the parser is a stream of *tokens*, generated by the *lexical analyzer*.  This chapter describes how the lexical analyzer breaks a file into tokens."
msgstr ""

msgid "Python reads program text as Unicode code points; the encoding of a source file can be given by an encoding declaration and defaults to UTF-8, see :pep:`3120` for details.  If the source file cannot be decoded, a :exc:`SyntaxError` is raised."
msgstr ""

msgid "Line structure"
msgstr "Структура строк"

msgid "A Python program is divided into a number of *logical lines*."
msgstr "Программа на Питоне состоит из *условных (логических) строк*."

msgid "Logical lines"
msgstr "Условные строки"

msgid "The end of a logical line is represented by the token NEWLINE.  Statements cannot cross logical line boundaries except where NEWLINE is allowed by the syntax (e.g., between statements in compound statements). A logical line is constructed from one or more *physical lines* by following the explicit or implicit *line joining* rules."
msgstr ""
"Условные строки состоят из одной или нескольких *физических строк*, "
"объединённых по правилам явного или неявного *объединения строк*. Инструкции "
"не могут пересекать границы условных строк, за исключением специальных "
"случаев, предусмотренных синтаксисом (например, составные инструкции)."

msgid "Physical lines"
msgstr "Физические строки"

msgid "A physical line is a sequence of characters terminated by an end-of-line sequence.  In source files, any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character.  All of these forms can be used equally, regardless of platform."
msgstr ""

msgid "When embedding Python, source code strings should be passed to Python APIs using the standard C conventions for newline characters (the ``\\n`` character, representing ASCII LF, is the line terminator)."
msgstr ""
"При встраивании Питона в другое приложение, строки исходного кода на Питоне "
"следует передавать из этого приложения в API Питона, следуя стандартным "
"соглашениям языка “C” для символов новой строки (тоесть, символ «``\n"
"``» , обозначающий ASCII LF ) ."

msgid "Comments"
msgstr "Комментарии"

msgid "A comment starts with a hash character (``#``) that is not part of a string literal, and ends at the end of the physical line.  A comment signifies the end of the logical line unless the implicit line joining rules are invoked. Comments are ignored by the syntax; they are not tokens."
msgstr ""
"Комментарий начинается с символа «``#``» (“решётка”), если тот не является "
"частью записи текстовых данных, и продолжается до конца физической строки. "
"Комментарий также обозначает конец условной строки, кроме тех случаев, когда "
"происходит неявное объединение условных строк. Комментарии игнорируются при "
"анализе текста программы и не являются лексемами (токенами)."

msgid "Encoding declarations"
msgstr ""

msgid "If a comment in the first or second line of the Python script matches the regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed as an encoding declaration; the first group of this expression names the encoding of the source code file. The recommended forms of this expression are ::"
msgstr ""

msgid "# -*- coding: <encoding-name> -*-"
msgstr ""

msgid "which is recognized also by GNU Emacs, and ::"
msgstr ""

msgid "# vim:fileencoding=<encoding-name>"
msgstr ""

msgid "which is recognized by Bram Moolenaar's VIM."
msgstr ""

msgid "If no encoding declaration is found, the default encoding is UTF-8.  In addition, if the first bytes of the file are the UTF-8 byte-order mark (``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""

msgid "If an encoding is declared, the encoding name must be recognized by Python. The encoding is used for all lexical analysis, including string literals, comments and identifiers. The encoding declaration must appear on a line of its own."
msgstr ""

msgid "Explicit line joining"
msgstr "Явное объединение строк"

msgid "Two or more physical lines may be joined into logical lines using backslash characters (``\\``), as follows: when a physical line ends in a backslash that is not part of a string literal or comment, it is joined with the following forming a single logical line, deleting the backslash and the following end-of-line character.  For example::"
msgstr ""
"Две или более физических строк могут быть объединены в одну условную строку "
"при помощи символа бэкслэш (``\\``) следующим образом: когда строка "
"заканчивается бэкслэшем, не являющимся частью текстовых данных или "
"комментария, она объединяется со следующей, составляя единую условную "
"строку, не включающую бэкслэш и следующий за ним символ окончания строки. "
"Например:"

msgid "if 1900 < year < 2100 and 1 <= month <= 12 \\    and 1 <= day <= 31 and 0 <= hour < 24 \\    and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date         return 1"
msgstr ""
"if 1900 < year < 2100 and 1 <= month <= 12 \\    and 1 <= day <= 31 and 0 <= "
"hour < 24 \\    and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a "
"valid date         return 1"

msgid "A line ending in a backslash cannot carry a comment.  A backslash does not continue a comment.  A backslash does not continue a token except for string literals (i.e., tokens other than string literals cannot be split across physical lines using a backslash).  A backslash is illegal elsewhere on a line outside a string literal."
msgstr ""
"Строка, оканчивающаяся бэкслэшем, не может содержать комментарий. "
"Комментарий или другую лексему кроме текстовых данных, начатые на одной "
"строке, нельзя продолжить с помощью бэкслэша на другой строке. Кроме конца "
"физической строки бэкслэш допустим только внутри текстовых данных."

msgid "Implicit line joining"
msgstr "Неявное объединение строк"

msgid "Expressions in parentheses, square brackets or curly braces can be split over more than one physical line without using backslashes. For example::"
msgstr ""
"Выражения в скобках - круглых, квадратных либо фигурных - могут быть "
"разделены на несколько физических строк без использования бэкслэша. "
"Например:"

msgid "month_names = ['Januari', 'Februari', 'Maart',      # These are the                'April',   'Mei',      'Juni',       # Dutch names                'Juli',    'Augustus', 'September',  # for the months                'Oktober', 'November', 'December']   # of the year"
msgstr ""
"month_names = ['Januari', 'Februari', 'Maart',      # These are the "
"               'April',   'Mei',      'Juni',       # Dutch names "
"               'Juli',    'Augustus', 'September',  # for the months "
"               'Oktober', 'November', 'December']   # of the year"

msgid "Implicitly continued lines can carry comments.  The indentation of the continuation lines is not important.  Blank continuation lines are allowed. There is no NEWLINE token between implicit continuation lines.  Implicitly continued lines can also occur within triple-quoted strings (see below); in that case they cannot carry comments."
msgstr ""

msgid "Blank lines"
msgstr "Пустые строки"

msgid "A logical line that contains only spaces, tabs, formfeeds and possibly a comment, is ignored (i.e., no NEWLINE token is generated).  During interactive input of statements, handling of a blank line may differ depending on the implementation of the read-eval-print loop.  In the standard interactive interpreter, an entirely blank logical line (i.e. one containing not even whitespace or a comment) terminates a multi-line statement."
msgstr ""
"Условные строки, содержащие только пробелы, знаки табуляции или перевода "
"страницы и комментарии игнорируется (т.е. не создается лексемы “NEWLINE”). "
"Во время интерактивного ввода операторов обработка пустой последовательности "
"может отличаться в зависимости от реализации цикла чтение-вычисление-вывод. "
"В стандартном интерактивном интерпретаторе полностью пустая условная строка "
"(т.е. не содержащая даже пробел или комментарий) завершает многострочный "
"оператор."

msgid "Indentation"
msgstr "«:term:`Отступы`»"

msgid "Leading whitespace (spaces and tabs) at the beginning of a logical line is used to compute the indentation level of the line, which in turn is used to determine the grouping of statements."
msgstr ""

msgid "Tabs are replaced (from left to right) by one to eight spaces such that the total number of characters up to and including the replacement is a multiple of eight (this is intended to be the same rule as used by Unix).  The total number of spaces preceding the first non-blank character then determines the line's indentation.  Indentation cannot be split over multiple physical lines using backslashes; the whitespace up to the first backslash determines the indentation."
msgstr ""

msgid "Indentation is rejected as inconsistent if a source file mixes tabs and spaces in a way that makes the meaning dependent on the worth of a tab in spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"Отступы не принимаются из-за противоречивости, если исходный файл смешивает "
"табуляции и пробелы таким образом, что делает смысл зависящим от размера "
"табуляции в пробелах; в таком случае генерируется «:exc:`TabError`» ."

msgid "**Cross-platform compatibility note:** because of the nature of text editors on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for the indentation in a single source file.  It should also be noted that different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Замечание о кроссплатформенной совместимости:** из-за особенностей "
"текстовых редакторов на не-UNIX платформах - не следует использовать смесь "
"пробелов и табуляций для отступов в одном исодном файле. Также следует "
"отметить, что различные платформы могут явно ограничивать максимальный "
"уровень отступов."

msgid "A formfeed character may be present at the start of the line; it will be ignored for the indentation calculations above.  Formfeed characters occurring elsewhere in the leading whitespace have an undefined effect (for instance, they may reset the space count to zero)."
msgstr ""

msgid "The indentation levels of consecutive lines are used to generate INDENT and DEDENT tokens, using a stack, as follows."
msgstr ""

msgid "Before the first line of the file is read, a single zero is pushed on the stack; this will never be popped off again.  The numbers pushed on the stack will always be strictly increasing from bottom to top.  At the beginning of each logical line, the line's indentation level is compared to the top of the stack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token is generated.  If it is smaller, it *must* be one of the numbers occurring on the stack; all numbers on the stack that are larger are popped off, and for each number popped off a DEDENT token is generated.  At the end of the file, a DEDENT token is generated for each number remaining on the stack that is larger than zero."
msgstr ""
"Перед чтением первой строки файла в стек записывается значение «0», это "
"значение никогда не будет извлечено. Числа, заносимые в стек, будут строго "
"возрастать. В начале каждой условной строки уровень отступа сравнивается с "
"максимальным значением на верху стека; если они равны, то ничего не "
"происходит. Если уровень отступа больше, то он заносится в стек, и создается "
"одна лексема “INDENT” . Если уровень меньше, то это число уже должно быть в "
"стеке; все числа, которые больше, удаляются, и для каждого удаленного числа "
"создается лексема “DEDENT” . В конце файла лексемы “DEDENT” создаются для "
"всех оставшихся в стеке чисел больше ноля."

msgid "Here is an example of a correctly (though confusingly) indented piece of Python code::"
msgstr ""

msgid "def perm(l):         # Compute the list of all permutations of l     if len(l) <= 1:                   return [l]     r = []     for i in range(len(l)):              s = l[:i] + l[i+1:]              p = perm(s)              for x in p:               r.append(l[i:i+1] + x)     return r"
msgstr ""
"def perm(l):         # Compute the list of all permutations of l     if "
"len(l) <= 1:                   return [l]     r = []     for i in "
"range(len(l)):              s = l[:i] + l[i+1:]              p = perm(s) "
"             for x in p:               r.append(l[i:i+1] + x)     return r"

msgid "The following example shows various indentation errors::"
msgstr ""

msgid "def perm(l):                       # error: first line indented for i in range(len(l)):             # error: not indented     s = l[:i] + l[i+1:]         p = perm(l[:i] + l[i+1:])   # error: unexpected indent         for x in p:                 r.append(l[i:i+1] + x)             return r                # error: inconsistent dedent"
msgstr ""
"def perm(l):                       # error: first line indented for i in "
"range(len(l)):             # error: not indented     s = l[:i] + l[i+1:] "
"        p = perm(l[:i] + l[i+1:])   # error: unexpected indent         for "
"x in p:                 r.append(l[i:i+1] + x)             return r "
"               # error: inconsistent dedent"

msgid "(Actually, the first three errors are detected by the parser; only the last error is found by the lexical analyzer --- the indentation of ``return r`` does not match a level popped off the stack.)"
msgstr ""

msgid "Whitespace between tokens"
msgstr "Пробелы между лексемами"

msgid "Except at the beginning of a logical line or in string literals, the whitespace characters space, tab and formfeed can be used interchangeably to separate tokens.  Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens)."
msgstr ""
"Кроме начала логической строки или в записи текстовых данных символы "
"пробела, табуляции и перевода страницы могут быть взаимозаменяемы при "
"разделении лексем. Эти символы необходимы между двумя лексемами только, если "
"результат их объединения может быть интерпретирован как другая лексема "
"(например : «``ab``» - это одна лексема, но «``a b``» - две лексемы) ."

msgid "Other tokens"
msgstr "Другие лексемы"

msgid "Besides NEWLINE, INDENT and DEDENT, the following categories of tokens exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. Whitespace characters (other than line terminators, discussed earlier) are not tokens, but serve to delimit tokens. Where ambiguity exists, a token comprises the longest possible string that forms a legal token, when read from left to right."
msgstr ""
"Кроме “NEWLINE” , “INDENT” и “DEDENT” , существуют следующие категории "
"лексем: *идентификаторы*, *ключевые слова*, *литералы* (непосредственная "
"запись данных) , *операторы* и *разделители*. Символы пробелов (кроме знаков "
"конца строки, описанных ранее) не являются лексемами, а служат для их "
"разделения. Если появляется неопределенность, лексема включает самую длинную "
"возможную последовательность, представляющую собой действительную лексему "
"(чтение происходит слева направо) ."

msgid "Identifiers and keywords"
msgstr "Идентификаторы и ключевые слова"

msgid "Identifiers (also referred to as *names*) are described by the following lexical definitions."
msgstr "Идентификаторы (имена) имеют следующее лексическое определение."

msgid "The syntax of identifiers in Python is based on the Unicode standard annex UAX-31, with elaboration and changes as defined below; see also :pep:`3131` for further details."
msgstr ""
"Синтаксис идентификаторов в Питоне основывается на приложении “UAX-31” к "
"стандарту “Unicode” , с переработкой и изменениями описанными ниже. Также "
"смотрите дополнительные детали в :pep:`3131` ."

msgid "Within the ASCII range (U+0001..U+007F), the valid characters for identifiers are the same as in Python 2.x: the uppercase and lowercase letters ``A`` through ``Z``, the underscore ``_`` and, except for the first character, the digits ``0`` through ``9``."
msgstr ""
"В ASCII диапазоне (U+0001..U+007F) в идентификаторах допустимы только те же "
"символы, что и в Питоне 2.x : буквы с «``A``» по «``Z``» в верхнем и нижнем "
"регистре, подчеркивание «``_``» и, кроме первого символа идентификатора, – "
"цифры с «``0``» по «``9``» ."

msgid "Python 3.0 introduces additional characters from outside the ASCII range (see :pep:`3131`).  For these characters, the classification uses the version of the Unicode Character Database as included in the :mod:`unicodedata` module."
msgstr ""

msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""

msgid "The Unicode category codes mentioned above stand for:"
msgstr "Использованные выше обозначения категорий Юникода :"

msgid "*Lu* - uppercase letters"
msgstr ""

msgid "*Ll* - lowercase letters"
msgstr ""

msgid "*Lt* - titlecase letters"
msgstr ""

msgid "*Lm* - modifier letters"
msgstr ""

msgid "*Lo* - other letters"
msgstr ""

msgid "*Nl* - letter numbers"
msgstr ""

msgid "*Mn* - nonspacing marks"
msgstr ""

msgid "*Mc* - spacing combining marks"
msgstr ""

msgid "*Nd* - decimal numbers"
msgstr ""

msgid "*Pc* - connector punctuations"
msgstr ""

msgid "All identifiers are converted into the normal form NFC while parsing; comparison of identifiers is based on NFC."
msgstr ""
"Все идентификаторы при лексическом разборе конвертируются в нормализованную "
"форму NFC; и сравнение идентификаторов производится уже в форме NFC."

msgid "A non-normative HTML file listing all valid identifier characters for Unicode 4.1 can be found at http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html."
msgstr ""
"Ненормативный HTML файл со списком всех символов Юникода 4.1 , доступных для "
"использования в идентификаторах, представлен здесь: http://www.dcl.hpi.uni-"
"potsdam.de/home/loewis/table-3131.html ."

msgid "Keywords"
msgstr ""

msgid "The following identifiers are used as reserved words, or *keywords* of the language, and cannot be used as ordinary identifiers.  They must be spelled exactly as written here:"
msgstr ""

msgid "False      class      finally    is         return None       continue   for        lambda     try True       def        from       nonlocal   while and        del        global     not        with as         elif       if         or         yield assert     else       import     pass break      except     in         raise"
msgstr ""

msgid "Reserved classes of identifiers"
msgstr "Зарезервированные классы идентификаторов"

msgid "Certain classes of identifiers (besides keywords) have special meanings.  These classes are identified by the patterns of leading and trailing underscore characters:"
msgstr ""
"Определенные классы идентификаторов (помимо ключевых слов) имеют особое "
"значение. Эти классы определяются соответствующей комбинацией символов "
"подчеркивания в начале и в конце."

msgid "Not imported by ``from module import *``.  The special identifier ``_`` is used in the interactive interpreter to store the result of the last evaluation; it is stored in the :mod:`builtins` module.  When not in interactive mode, ``_`` has no special meaning and is not defined. See section :ref:`import`."
msgstr ""
"Не импортируются инструкцией «``from module import *``» . Специальный "
"идентификатор «``_``» используется интерактивным интерпретатором для "
"хранения результата последнего вычисления, хранится он в модуле "
"«:mod:`builtins`» . Не в интерактивном режиме «``_``» не имеет специального "
"значения, не определен. (Смотрите раздел “Объявление импорта” :ref:`import` "
") ."

msgid "The name ``_`` is often used in conjunction with internationalization; refer to the documentation for the :mod:`gettext` module for more information on this convention."
msgstr ""
"Имя «``_``» часто используется в связи с интернационализацией, смотрите "
"документацию модуля «:mod:`gettext`» для получения информации по этой "
"договоренности."

msgid "System-defined names.  These names are defined by the interpreter and its implementation (including the standard library); applications should not expect to define additional names using this convention.  The set of names of this class defined by Python may be extended in future versions. See section :ref:`specialnames`."
msgstr ""
"Определенные системой имена. Эти имена определяются интерпретатором и его "
"реализацией (включая стандартную библиотеку). Приложения не должны "
"определять дополнительные имена используя эту форму. Набор имен этого "
"класса, определенных в Питоне, может быть расширен в будущих версиях. "
"Смотрите раздел “Имена специальных методов” :ref:`specialnames` ."

msgid "Class-private names.  Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between \"private\" attributes of base and derived classes. See section :ref:`atom-identifiers`."
msgstr ""
"Частные имена класса. Имена этой категории, при использовании в рамках "
"определения класса, автоматически модифицируются, чтобы избежать конфликтов "
"имен между “частными” атрибутами базовых и производных классов. Смотрите в "
"разделе “Идентификаторы (Имена)” :ref:`atom-identifiers` ."

msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"“Литералы” - это непосредственная запись постоянных значений некоторых "
"встроенных типов данных."

msgid "String and Bytes literals"
msgstr "Текстовые (“String”) и байтовые (“Bytes”) “литералы”"

msgid "String literals are described by the following lexical definitions:"
msgstr ""
"Непосредственная запись текстовых данных имеет следующее лексическое "
"определение:"

msgid "One syntactic restriction not indicated by these productions is that whitespace is not allowed between the :token:`stringprefix` or :token:`bytesprefix` and the rest of the literal. The source character set is defined by the encoding declaration; it is UTF-8 if no encoding declaration is given in the source file; see section :ref:`encodings`."
msgstr ""
"Есть также одно синтаксическое ограничение, не отмеченное в этих "
"определениях: знаки пробелов (пробела, табуляции, перевода страницы) не "
"могут находится между строковым (:token:`stringprefix`) или байтовым "
"(:token:`bytesprefix`) префиксом и остальной частью “литерала” . Набор "
"символов кода программы определяется объявлением кодировки, по умолчанию: "
"UTF-8, смотрите раздел «Объявление кодировки» :ref:`encodings` ."

msgid "In plain English: Both types of literals can be enclosed in matching single quotes (``'``) or double quotes (``\"``).  They can also be enclosed in matching groups of three single or double quotes (these are generally referred to as *triple-quoted strings*).  The backslash (``\\``) character is used to escape characters that otherwise have a special meaning, such as newline, backslash itself, or the quote character."
msgstr ""
"Говоря проще : оба типа “литералов” обрамляются с двух сторон одинаковыми "
"кавычками : или по одной одинарной «``'``» , или по одной двойной «``\"``» , "
"или по три одинарных «``'''``» , или по три двойных «``\"\"\"``» (*утроенные "
"кавычки*) . Символ бэкслэш «``\\``» используется для “экранирования” (вставки "
"в качестве простых печатных) символов, которые иначе бы имели особое "
"значение, таких как знак новой строки, сам бэкслэш или кавычки и т.д. ."

msgid "Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an instance of the :class:`bytes` type instead of the :class:`str` type.  They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes."
msgstr ""
"Байтовым “литералам” должен предшествовать префикс «``'b'``» или «``'B'``» . "
"Они создают экземпляр типа «:class:`bytes`» вместо типа «:class:`str`» . "
"Этот тип может содержать только символы ASCII; байты с численным значением "
"больше 127 записываются с помощью особых последовательностей символов."

msgid "Both string and bytes literals may optionally be prefixed with a letter ``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat backslashes as literal characters.  As a result, in string literals, ``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially."
msgstr ""
"Строковые литералы могут опционально начинаться с букв «``'r'``» или "
"«``'R'``» ; такие строки называются “сырыми” («:dfn:`raw strings`»), и "
"считают бэкслэш обычным символом. В результате последовательности «``'\\U'``» "
"и «``'\\u'``» специального значения в “сырых” строках не имеют."

msgid "In triple-quoted strings, unescaped newlines and quotes are allowed (and are retained), except that three unescaped quotes in a row terminate the string.  (A \"quote\" is the character used to open the string, i.e. either ``'`` or ``\"``.)"
msgstr ""
"В текстовых данных в утроенных кавычках – могут присутствовать (и "
"сохраняются как есть) “неэкранированные” знаки новой строки и кавычки (не в "
"виде специальных последовательностей) , кроме трех “неэкранированных” "
"кавычек подряд (того же вида, как и открывавшие), которые завершают запись "
"текста."

msgid "Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings are interpreted according to rules similar to those used by Standard C.  The recognized escape sequences are:"
msgstr ""
"Если нет префикса «``'r'``» или «``'R'``» , специальные последовательности в "
"строках интерпретируются согласно правилам стандартного “C” . Опознаются "
"следующие специальные последовательности:"

msgid "Escape Sequence"
msgstr "Специальная последовательность"

msgid "Notes"
msgstr "Примечания"

msgid "``\\newline``"
msgstr "``\\newline``"

msgid "Backslash and newline ignored"
msgstr ""
"Следующая строка считается продолжением этой, а бэкслэш и перевод строки – "
"отбрасываются"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid "Backslash (``\\``)"
msgstr "Бэкслэш (``\\``)"

msgid "``\\'``"
msgstr "``\\'``"

msgid "Single quote (``'``)"
msgstr "Одинарная кавычка (``'``)"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid "Double quote (``\"``)"
msgstr "Двойная кавычка (``\"``)"

msgid "``\\a``"
msgstr "``\\a``"

msgid "ASCII Bell (BEL)"
msgstr "ASCII “Bell” (BEL)"

msgid "``\\b``"
msgstr "``\\b``"

msgid "ASCII Backspace (BS)"
msgstr "ASCII “Backspace” (BS)"

msgid "``\\f``"
msgstr "``\\f``"

msgid "ASCII Formfeed (FF)"
msgstr "ASCII “Formfeed” (FF)"

msgid "``\\n``"
msgstr "``\\n``"

msgid "ASCII Linefeed (LF)"
msgstr "ASCII “Linefeed” (LF)"

msgid "``\\r``"
msgstr "``\\r``"

msgid "ASCII Carriage Return (CR)"
msgstr "ASCII “Carriage Return” (CR)"

msgid "``\\t``"
msgstr "``\\t``"

msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII “Horizontal Tab” (TAB)"

msgid "``\\v``"
msgstr "``\\v``"

msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII “Vertical Tab” (VT)"

msgid "``\\ooo``"
msgstr "``\\ooo``"

msgid "Character with octal value *ooo*"
msgstr "Символ с восьмиричным значением *ooo*"

msgid "(1,3)"
msgstr "(1,3)"

msgid "``\\xhh``"
msgstr "``\\xhh``"

msgid "Character with hex value *hh*"
msgstr "Символ с 16-ричным значением *hh*"

msgid "(2,3)"
msgstr "(2,3)"

msgid "Escape sequences only recognized in string literals are:"
msgstr ""

msgid "``\\N{name}``"
msgstr ""

msgid "Character named *name* in the Unicode database"
msgstr ""

msgid "``\\uxxxx``"
msgstr ""

msgid "Character with 16-bit hex value *xxxx*"
msgstr ""

msgid "\\(4)"
msgstr ""

msgid "``\\Uxxxxxxxx``"
msgstr ""

msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr ""

msgid "\\(5)"
msgstr ""

msgid "Notes:"
msgstr "Примечания:"

msgid "As in Standard C, up to three octal digits are accepted."
msgstr "Как и в стандартном “C” , принимается до трех восьмеричных знаков."

msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "В отличие от стандартного “C” , принимается строго два 16-ричных знака."

msgid "In a bytes literal, hexadecimal and octal escapes denote the byte with the given value. In a string literal, these escapes denote a Unicode character with the given value."
msgstr ""
"В байтовых данных 16- и 8-ричные специальные последовательности обозначают "
"байт с данным значением. В текстовых данных они обозначают символ Юникода с "
"данным кодом."

msgid "Individual code units which form parts of a surrogate pair can be encoded using this escape sequence.  Exactly four hex digits are required."
msgstr ""
"Отдельные коды, составляющие части суррогатной пары, могут быть закодированы "
"при помощи специальных последовательностей. В отличие от стандартного “C” , "
"требуется строго два 16-ричных знака."

#, fuzzy
msgid "Any Unicode character can be encoded this way, but characters outside the Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if Python is compiled to use 16-bit code units (the default).  Exactly eight hex digits are required."
msgstr ""
"Этим способом могут быть закодированы любые символы Юникода, но символы вне "
"“Basic Multilingual Plane” (BMP) будут закодированы с помощью суррогатной "
"пары, если Питон скомпилирован под использование 16-битных элементов кода "
"Юникод (по умолчанию). Отдельные коды, составляющие части суррогатной пары, "
"могут быть закодированы при помощи специальных последовательностей. "
"Требуется строго восемь 16-ричных знаков."

msgid "Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., *the backslash is left in the string*.  (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.)  It is also important to note that the escape sequences only recognized in string literals fall into the category of unrecognized escapes for bytes literals."
msgstr ""
"В отличие от стандартного “C”, все неопознанные последовательности символов "
"оставляются в тексте неизменными, т. е. *бэкслэш остается в тексте*. (Такое "
"поведение полезно при отладке: если особая последовательность символов "
"написана неправильно, то в том, что появляется на выходе легче заметить "
"ошибку.) Кроме того, важно отметить, что управляющие последовательности "
"опознающиеся только в записи текста попадают в категорию неопознанных "
"последовательностей в записи байтовых данных."

msgid "Even in a raw string, string quotes can be escaped with a backslash, but the backslash remains in the string; for example, ``r\"\\\"\"`` is a valid string literal consisting of two characters: a backslash and a double quote; ``r\"\\\"`` is not a valid string literal (even a raw string cannot end in an odd number of backslashes).  Specifically, *a raw string cannot end in a single backslash* (since the backslash would escape the following quote character).  Note also that a single backslash followed by a newline is interpreted as those two characters as part of the string, *not* as a line continuation."
msgstr ""
"Даже в “сыром” тексте кавычки могут быть вставлены через бэкслэш, но бэкслэш "
"остается в строке, например, «``r\"\\\"\"``»является верной текстовой записью, "
"состоящей из двух символов: бэкслэш и двойные кавычки; «``r\"\\\"``» не "
"является допустимой записью (даже “сырой” текст не может заканчиваться "
"нечётным количеством бэкслэшей). В частности, *“сырой” текст не может "
"оканчиваться одним бэкслэшем* (поскольку бэкслэш превращает следующую за ним "
"кавычку в текст). Отметьте также, что один бэкслэш подряд, за которым сразу "
"следует переход на новую строку интерпретируется как эти два символа, "
"являющиеся частью строки, а *не* как продолжение строки."

msgid "String literal concatenation"
msgstr "Соединение текстовых записей (текстовых литералов)"

msgid "Multiple adjacent string or bytes literals (delimited by whitespace), possibly using different quoting conventions, are allowed, and their meaning is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is equivalent to ``\"helloworld\"``.  This feature can be used to reduce the number of backslashes needed, to split long strings conveniently across long lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Допустимы несколько идущих подряд текстовых записей, разделённых пробелами "
"(возможно, с использованием разных типов пар кавычек) - их значение "
"эквивалентно значению одной текстовой записи, являющейся их соединением. "
"Таким образом, «``\"hello\" 'world'``» эквивалентно «``\"helloworld\"``» . Эта "
"особенность позволяет уменьшать количество необходимых бэкслэшей, удобно "
"разделять длинные тексты на много физических строк, или даже добавлять "
"комментарии к отдельным фрагментам текста, например:"

msgid "re.compile(\"[A-Za-z_]\"       # letter or underscore            \"[A-Za-z0-9_]*\"   # letter, digit or underscore           )"
msgstr ""
"re.compile(\"[A-Za-z_]\"       # letter or underscore            "
"\"[A-Za-z0-9_]*\"   # letter, digit or underscore           )"

msgid "Note that this feature is defined at the syntactical level, but implemented at compile time.  The '+' operator must be used to concatenate string expressions at run time.  Also note that literal concatenation can use different quoting styles for each component (even mixing raw strings and triple quoted strings)."
msgstr ""
"Обратите внимание, что это свойство определено на синтаксическом уровне, а "
"реализуется во время компиляции. Для соединения фрагментов текста во время "
"исполнения – должен использоваться оператор «``+``» . Заметьте также, что "
"при соединении текста могут использоваться различные стили оформления для "
"каждого фрагмента (даже смешивание “сырого” текста и в тройных кавычках) ."

msgid "Numeric literals"
msgstr "Непосредственная запись чисел"

msgid "There are three types of numeric literals: integers, floating point numbers, and imaginary numbers.  There are no complex literals (complex numbers can be formed by adding a real number and an imaginary number)."
msgstr ""
"Существуют три формы непосредственной записи для чисел: целых, чисел с "
"плавающей точкой, и мнимых чисел. Не существует непосредственной записи для "
"комплексных чисел (они могут быть сформированы через операцию сложения "
"действительного числа с мнимым)."

msgid "Note that numeric literals do not include a sign; a phrase like ``-1`` is actually an expression composed of the unary operator '``-``' and the literal ``1``."
msgstr ""
"Заметьте, что знак не является частью записи числа - такая формулировка, как "
"«``-1``» , на самом деле является выражением, состоящим из однооперандного "
"оператора «``-``» и числа «``1``» ."

msgid "Integer literals"
msgstr "Запись целых чисел"

msgid "Integer literals are described by the following lexical definitions:"
msgstr "Запись целых чисел имеет следующее лексическое определение:"

msgid "There is no limit for the length of integer literals apart from what can be stored in available memory."
msgstr "Нет ограничения длины записи числа, кроме размера доступной памяти."

msgid "Note that leading zeros in a non-zero decimal number are not allowed. This is for disambiguation with C-style octal literals, which Python used before version 3.0."
msgstr ""
"Обратите внимание, что нули в начале ненулевого десятичного числа не "
"допускаются. Это сделано для отличения их от восьмеричной записи в стиле “C” "
", которая использовалась в Питоне до версии 3.0 ."

msgid "Some examples of integer literals::"
msgstr "Некоторые примеры записи целых чисел: ::"

msgid "7     2147483647                        0o177    0b100110111 3     79228162514264337593543950336     0o377    0x100000000       79228162514264337593543950336              0xdeadbeef"
msgstr ""
"7     2147483647                        0o177    0b100110111 3     "
"79228162514264337593543950336     0o377    0x100000000       "
"79228162514264337593543950336              0xdeadbeef"

#, fuzzy
msgid "Floating point literals"
msgstr "Запись дробных чисел (с плавающей запятой (точкой) )"

msgid "Floating point literals are described by the following lexical definitions:"
msgstr "Запись дробных чисел имеет следующее лексическое определение:"

msgid "Note that the integer and exponent parts are always interpreted using radix 10. For example, ``077e010`` is legal, and denotes the same number as ``77e10``. The allowed range of floating point literals is implementation-dependent. Some examples of floating point literals::"
msgstr ""
"Заметьте, что в целой и экспонентной частях всегда подразумевается основание "
"10 . Например, ``077e010`` является допустимым и значит то же, что и "
"``77e10`` . Допустимый диапазон дробных чисел может различаться в разных "
"реализациях. Примеры записи дробных чисел: ::"

msgid "3.14    10.    .001    1e100    3.14e-10    0e0"
msgstr "3.14    10.    .001    1e100    3.14e-10    0e0"

msgid "Note that numeric literals do not include a sign; a phrase like ``-1`` is actually an expression composed of the unary operator ``-`` and the literal ``1``."
msgstr ""
"Заметьте, что знак не является частью записи числа - такая формулировка, как "
"«``-1``» , на самом деле является выражением, состоящим из однооперандного "
"оператора «``-``» и числа «``1``» ."

msgid "Imaginary literals"
msgstr "Запись мнимых чисел"

msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "Запись мнимых чисел имеет следующее лексическое определение:"

msgid "An imaginary literal yields a complex number with a real part of 0.0.  Complex numbers are represented as a pair of floating point numbers and have the same restrictions on their range.  To create a complex number with a nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  Some examples of imaginary literals::"
msgstr ""
"Под мнимое число отводится комплексное число с действительной частью «0» . "
"Комплексные числа представлены в виде пары чисел с плавающей точкой, которые "
"имеют обычные ограничения диапазона их значений. Чтобы создать комплексное "
"число с ненулевой действительной частью, нужно сложить обычное дробное число "
"с мнимым числом, например, «``(3+4j)``» . Некоторые примеры записи мнимых "
"чисел: ::"

msgid "3.14j   10.j    10j     .001j   1e100j  3.14e-10j"
msgstr "3.14j   10.j    10j     .001j   1e100j  3.14e-10j"

msgid "Operators"
msgstr "Операторы"

msgid "The following tokens are operators::"
msgstr "Следующие лексемы являются операторами:"

msgid "+       -       *       **      /       //      % <<      >>      &       |       ^       ~ <       >       <=      >=      ==      !="
msgstr ""
"+       -       *       **      /       //      % <<      >>      &       | "
"      ^       ~ <       >       <=      >=      ==      !="

msgid "Delimiters"
msgstr "Разделители"

msgid "The following tokens serve as delimiters in the grammar::"
msgstr "Следующие лексемы выполняют роль грамматических разделителей: ::"

msgid "(       )       [       ]       {       } ,       :       .       ;       @       = +=      -=      *=      /=      //=     %= &=      |=      ^=      >>=     <<=     **="
msgstr ""
"(       )       [       ]       {       } ,       :       .       ;       @ "
"      = +=      -=      *=      /=      //=     %= &=      |=      ^=      "
">>=     <<=     **="

msgid "The period can also occur in floating-point and imaginary literals.  A sequence of three periods has a special meaning as an ellipsis literal. The second half of the list, the augmented assignment operators, serve lexically as delimiters, but also perform an operation."
msgstr ""
"Точка также встречается в записи дробных и мнимых чисел. Последовательность "
"из трех точек имеет особое значение - обозначение пропуска "
"(«:term:`ellipsis`»), вторая половина списка – расширенные операции "
"присваивания – служат в качестве лексического разделителя, и одновременно "
"выполняют операцию."

msgid "The following printing ASCII characters have special meaning as part of other tokens or are otherwise significant to the lexical analyzer::"
msgstr ""
"Следующие печатные символы ASCII имеют особое значение в качестве части "
"других лексем, и, таким образом, важны для лексического анализатора:"

msgid "'       \"       #       \\"
msgstr "'       \"       #       \\"

msgid "The following printing ASCII characters are not used in Python.  Their occurrence outside string literals and comments is an unconditional error::"
msgstr ""
"Следующие печатные символы ASCII не используются в Питоне. Их появление за "
"пределами записи текстовых данных или комментариев безусловно является "
"ошибкой:"

msgid "$       ?       `"
msgstr "$       ?       `"

msgid "Simple statements"
msgstr "Простые инструкции"

msgid "Simple statements are comprised within a single logical line. Several simple statements may occur on a single line separated by semicolons.  The syntax for simple statements is:"
msgstr ""
"Простые инструкции ограничены пределами одной условной строки. Но в одной "
"условной строке может помещаться несколько простых инструкций, разделённых "
"точкой с запятой «``;``» . Простые инструкции имеют следующий синтаксис :"

#, fuzzy
msgid "Expression statements"
msgstr "Выражения - инструкции"

msgid "Expression statements are used (mostly interactively) to compute and write a value, or (usually) to call a procedure (a function that returns no meaningful result; in Python, procedures return the value ``None``).  Other uses of expression statements are allowed and occasionally useful.  The syntax for an expression statement is:"
msgstr ""
"Выражение - инструкция используется (в основном интерактивно) для вычисления "
"и показа значения, или (обычно) для вызова процедуры (это такая функция, "
"которая не возвращает результата - а в Питоне возвращает формальный "
"результат «:const:`None`» ) . Другие применения выражений - инструкций также "
"возможны и бывают полезны. Выражения - инструкции имеют следующий синтаксис "
":"

msgid "An expression statement evaluates the expression list (which may be a single expression)."
msgstr ""
"Выражение - инструкция обрабатывает список выражений (в частности из одного "
"выражения) ."

msgid "In interactive mode, if the value is not ``None``, it is converted to a string using the built-in :func:`repr` function and the resulting string is written to standard output on a line by itself (except if the result is ``None``, so that procedure calls do not cause any output.)"
msgstr ""
"В интерактивном режиме, если его результат не «:const:`None`» , то результат "
"преобразуется в строку встроенной функцией «:func:`repr`» , и эта строка "
"выдаётся на стандартный вывод (а если результат «:const:`None`» , то ничего "
"не выводится) ."

#, fuzzy
msgid "Assignment statements"
msgstr "Инструкции назначения (связывания, присваивания)"

msgid "Assignment statements are used to (re)bind names to values and to modify attributes or items of mutable objects:"
msgstr ""
"Инструкции назначения используются для (пере)связывания имён со значениями и "
"для изменения атрибутов или элементов изменяемых объектов :"

msgid "(See section :ref:`primaries` for the syntax definitions for the last three symbols.)"
msgstr ""
"(Смотри определения синтаксиса последних трёх обозначений в разделе "
"«:ref:`primaries`» . )"

msgid "An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right."
msgstr ""
"Инструкция назначения последовательно назначает объект, получившийся в "
"результате вычисления очередного выражения из списка выражений (учитывая, "
"что этот список может содержать одно выражение или список, разделённый "
"запятыми) - соответственно очередной цели из списка целей, в обоих списках - "
"слева направо."

msgid "Assignment is defined recursively depending on the form of the target (list). When a target is part of a mutable object (an attribute reference, subscription or slicing), the mutable object must ultimately perform the assignment and decide about its validity, and may raise an exception if the assignment is unacceptable.  The rules observed by various types and the exceptions raised are given with the definition of the object types (see section :ref:`types`)."
msgstr ""
"Назначение определяется рекурсивно – в зависимости от структуры цели "
"назначения (например список) . Если цель является частью изменяемого объекта "
"(атрибут, элемент по индексу) , то сам этот изменяемый объект должен в "
"итоге выполнить назначение и решить допустимо ли оно и, если нужно, может "
"инициировать исключение. Правила, которых придерживаются различные типы, и "
"инициируемые ими исключения – определены в самих этих типах (смотрите раздел "
"«Иерархия стандартных типов» :ref:`types` ) ."

msgid "Assignment of an object to a target list, optionally enclosed in parentheses or square brackets, is recursively defined as follows."
msgstr ""
"Назначение объекта списку целей, который может быть заключён в круглые или "
"квадратные скобки, рекурсивно определяется следующим образом."

msgid "If the target list is a single target: The object is assigned to that target."
msgstr ""
"Если этот список целей фактически состоит из единственной цели, то данный "
"объект назначается этой цели."

msgid "If the target list is a comma-separated list of targets: The object must be an iterable with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets. (This rule is relaxed as of Python 1.5; in earlier versions, the object had to be a tuple.  Since strings are sequences, an assignment like ``a, b = \"xy\"`` is now legal as long as the string has the right length.)"
msgstr ""
"Если этот список целей является перечнем целей, разделённых запятыми, то "
"данный объект (источник) должен быть итерируемым и иметь столько же "
"элементов (сколько целей в списке целей), и эти элементы назначаются "
"соответствующим по счёту (слева направо) целям. (Это правило стало менее "
"ограниченным с версии Питона 1.5 (до этого объект источник обязан был быть "
"кортежем) . Теперь, поскольку текстовые данные являются "
"последовательностями, назначение вроде «``a, b = \"xy\"``» является "
"допустимым, при условии, что текст имеет строго соответствующую длину.)"

msgid "If the target list contains one target prefixed with an asterisk, called a \"starred\" target: The object must be a sequence with at least as many items as there are targets in the target list, minus one.  The first items of the sequence are assigned, from left to right, to the targets before the starred target.  The final items of the sequence are assigned to the targets after the starred target.  A list of the remaining items in the sequence is then assigned to the starred target (the list can be empty)."
msgstr ""
"Если в перечне целей присутствует цель, перед которой стоит одна звёздочка, "
"то объект-источник должен быть последовательностью, у которой количество "
"элементов больше или равно количеству целей минус один. Всем целям до цели "
"со звёздочкой назначаются соответствующие по счёту элементы источника. Всем "
"целям после цели со звёздочкой назначаются соответствующие по счёту с конца "
"элементы источника. Перечень оставшихся элементов в "
"последовательности-источнике назначается цели со звёздочкой (этот перечень "
"может быть пустым) ."

msgid "Else: The object must be a sequence with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets."
msgstr ""
"Иначе этот объект-источник должен быть последовательностью, у которой "
"количество элементов равно количеству целей, и эти элементы назначаются "
"соответствующим по счёту (слева направо) целям."

msgid "Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"Назначение объекта единственной цели определяется рекурсивно следующим "
"образом."

msgid "If the target is an identifier (name):"
msgstr "Если эта цель является идентификатором (именем) :"

msgid "If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` statement in the current code block: the name is bound to the object in the current local namespace."
msgstr ""
"Если это имя не упоминается в текущем блоке кода в инструкциях "
"«:keyword:`global`» или «:keyword:`nonlocal`» , то это имя связывается с "
"данным объектом в текущей области имён (тоесть, создаётся локальная "
"переменная с этим именем) ."

msgid "Otherwise: the name is bound to the object in the global namespace or the outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Иначе это имя связывается с данным объектом соответственно в глобальной "
"области имён или во внешней области имён, определённой «:keyword:`nonlocal`» "
"."

msgid "The name is rebound if it was already bound.  This may cause the reference count for the object previously bound to the name to reach zero, causing the object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"Данное имя переназначается, если оно уже было назначено. Это может привести "
"к тому, что счётчик ссылок на тот объект, который был связан с данным "
"именем, достигнет ноля, из-за чего у объекта будет вызван деструктор (если "
"имеется) – и объект будет удалён."

msgid "If the target is a target list enclosed in parentheses or in square brackets: The object must be an iterable with the same number of items as there are targets in the target list, and its items are assigned, from left to right, to the corresponding targets."
msgstr ""
"Если эта цель является перечнем целей, заключённым в круглые или квадратные "
"скобки, то данный объект (источник) должен быть итерируемым и с тем же "
"количеством элементов (как в перечне целей) , и эти элементы назначаются "
"соответствующим по счёту (слева направо) целям."

msgid "If the target is an attribute reference: The primary expression in the reference is evaluated.  It should yield an object with assignable attributes; if this is not the case, :exc:`TypeError` is raised.  That object is then asked to assign the assigned object to the given attribute; if it cannot perform the assignment, it raises an exception (usually but not necessarily :exc:`AttributeError`)."
msgstr ""
"Если эта цель является указанием (ссылкой) на атрибут, то первичное "
"выражение этой ссылки интерпретируется, что в результате должно дать объект "
"с атрибутами, допускающими назначение – иначе инициируется "
"«:exc:`TypeError`» . Этому полученному объекту предлагается назначить "
"объект-источник соответствующему (своему) атрибуту – если он не может "
"выполнить это назначение, то инициирует исключение (обычно, но не "
"обязательно – «:exc:`AttributeError`» ) ."

msgid "Note: If the object is a class instance and the attribute reference occurs on both sides of the assignment operator, the RHS expression, ``a.x`` can access either an instance attribute or (if no instance attribute exists) a class attribute.  The LHS target ``a.x`` is always set as an instance attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` do not necessarily refer to the same attribute: if the RHS expression refers to a class attribute, the LHS creates a new instance attribute as the target of the assignment::"
msgstr ""
"Замечание. Если объект является экземпляром класса и данная ссылка на "
"атрибут встречается с обеих сторон оператора назначения, то правое выражение "
"может обращаться как к атрибуту экземпляра так и (если того нет) к атрибуту "
"класса. А цель в левой части всегда подразумевает атрибут экземпляра – и "
"если его не было, то он создаётся. Таким образом два одинаковых упоминания "
"атрибута не обязательно обращаются к одному и тому же атрибуту : когда "
"выражение в правой части обращается к атрибуту класса – то в левой создаётся "
"новый атрибут экземпляра в качестве цели назначения : ::"

msgid "class Cls:     x = 3             # class variable inst = Cls() inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"
msgstr ""
"class Cls:     x = 3             # class variable inst = Cls() inst.x = "
"inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"

msgid "This description does not necessarily apply to descriptor attributes, such as properties created with :func:`property`."
msgstr ""
"Это не обязательно относится к атрибутам-дескрипторам, например, созданным с "
"помощью «:func:`property`» ."

msgid "If the target is a subscription: The primary expression in the reference is evaluated.  It should yield either a mutable sequence object (such as a list) or a mapping object (such as a dictionary).  Next, the subscript expression is evaluated."
msgstr ""
"Если цель является взятием (указанием) по индексу, то первичное выражение в "
"этом указателе вычисляется. Оно должно давать или объект - изменяемую "
"последовательность (например список) , или объект-отображение (например "
"словарь) . Затем вычисляется выражение, определяющее индекс."

msgid "If the primary is a mutable sequence object (such as a list), the subscript must yield an integer.  If it is negative, the sequence's length is added to it.  The resulting value must be a nonnegative integer less than the sequence's length, and the sequence is asked to assign the assigned object to its item with that index.  If the index is out of range, :exc:`IndexError` is raised (assignment to a subscripted sequence cannot add new items to a list)."
msgstr ""
"Если первичное выражение является изменяемой последовательностью (например "
"списком) , то выражение, определяющее индекс, должно давать в результате "
"целое число. Если это число отрицательное, то к нему прибавляется длина "
"данной последовательности. Получившееся в результате значение должно быть "
"неотрицательным целым, меньшим, чем длина данной последовательности. Затем к "
"данной последовательности следует запрос назначить объект-источник элементу "
"с данным значением индекса. Если индекс выходит за границы, то вызывается "
"исключение «:exc:`IndexError`» (назначение последовательности по индексу не "
"может добавлять новый элемент к списку) ."

msgid "If the primary is a mapping object (such as a dictionary), the subscript must have a type compatible with the mapping's key type, and the mapping is then asked to create a key/datum pair which maps the subscript to the assigned object.  This can either replace an existing key/value pair with the same key value, or insert a new key/value pair (if no key with the same value existed)."
msgstr ""
"Если первичное выражение является объектом-отображением (например словарём) "
", то индекс должен иметь тип совместимый с типом ключей данного отображения, "
"и данному отображению делается запрос создать пару ключ/данные, которая "
"будет ставить в соответствие исходный индекс объекту-источнику. При этом "
"может произойти как замещение уже существовавшей пары ключ/данные новой "
"парой с тем же значением ключа, так и добавление новой пары ключ/данные "
"(если не было ключа с таким значением) ."

msgid "For user-defined objects, the :meth:`__setitem__` method is called with appropriate arguments."
msgstr ""
"Для объектов, определённых пользователем, вызывается метод "
"«:meth:`__setitem__`» с соответствующими аргументами."

msgid "If the target is a slicing: The primary expression in the reference is evaluated.  It should yield a mutable sequence object (such as a list).  The assigned object should be a sequence object of the same type.  Next, the lower and upper bound expressions are evaluated, insofar they are present; defaults are zero and the sequence's length.  The bounds should evaluate to integers. If either bound is negative, the sequence's length is added to it.  The resulting bounds are clipped to lie between zero and the sequence's length, inclusive.  Finally, the sequence object is asked to replace the slice with the items of the assigned sequence.  The length of the slice may be different from the length of the assigned sequence, thus changing the length of the target sequence, if the object allows it."
msgstr ""
"Если цель является срезом, то первичное выражение в этом указателе "
"вычисляется. Оно должно давать в результате объект - изменяемую "
"последовательность (например список) . Объект-источник должен быть "
"объектом-последовательностью того же типа. Затем вычисляются выражения, "
"определяющие нижнюю и верхнюю границы (если таковые присутствуют) , которые "
"по умолчанию равны нолю и длине последовательности соответственно. Эти "
"границы должны иметь целое значение. Если какая-либо из них отрицательна, к "
"ней прибавляется длина последовательности. Получившиеся в результате границы "
"обрезаются так, чтобы они входили в диапазон с ноля по длину "
"последовательности. И, наконец, данному объекту-последовательности делается "
"запрос заменить элементы попадающие в срез на элементы последовательности "
"источника. Длина среза может отличаться от длины источника, если объект-цель "
"это позволяет – в этом случае длина последовательности-цели изменится."

msgid "In the current implementation, the syntax for targets is taken to be the same as for expressions, and invalid syntax is rejected during the code generation phase, causing less detailed error messages."
msgstr ""
"В текущей реализации синтаксис для целей взят точно таким же, как и для "
"выражений, и ошибочный синтаксис не принимается в фазе генерации кода, "
"приводя к менее детальным сообщениям об ошибках."

msgid "WARNING: Although the definition of assignment implies that overlaps between the left-hand side and the right-hand side are 'safe' (for example ``a, b = b, a`` swaps two variables), overlaps *within* the collection of assigned-to variables are not safe!  For instance, the following program prints ``[0, 2]``::"
msgstr ""
"Осторожно ! Хотя определение операции назначения подразумевает, что "
"упоминание одного и того же объекта и в левой и в правой частях "
"(“перекрытие”) является “безопасным” (например, «``a, b = b, a``» обменивает "
"значения двух переменных) , “перекрытие” внутри перечисления переменных - "
"целей назначения – не является “безопасным” ! Например, следующая программа "
"печатает «``[0, 2]``» : ::"

msgid "x = [0, 1] i = 0 i, x[i] = 1, 2 print(x)"
msgstr "x = [0, 1] i = 0 i, x[i] = 1, 2 print(x)"

msgid "The specification for the ``*target`` feature."
msgstr "Спецификация для «``*target``» ."

msgid "Augmented assignment statements"
msgstr "Расширенные инструкции назначения"

msgid "Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement:"
msgstr ""
"Расширенное назначение объединяет в одной инструкции операцию над двумя "
"операндами (т.н. “бинарную”) и инструкцию назначения :"

msgid "An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target.  The target is only evaluated once."
msgstr ""
"Расширенное назначение сначала определяет значение цели назначения (которая, "
"в отличие от случая обычной операции назначения, не может быть распаковкой) "
"и списка выражений, затем выполняет соответствующее двухоперандное "
"действие, и затем этот результат назначает цели назначения. Начальное "
"значение цели назначения вычисляется только один раз."

msgid "An augmented assignment expression like ``x += 1`` can be rewritten as ``x = x + 1`` to achieve a similar, but not exactly equal effect. In the augmented version, ``x`` is only evaluated once. Also, when possible, the actual operation is performed *in-place*, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead."
msgstr ""
"Выражение расширенного назначения вроде «``x += 1``» можно переписать как "
"«``x = x + 1``» , что даёт подобный, но не точно тот же эффект. В "
"“расширенной” версии – «``x``» вычисляется только один раз. Также, когда это "
"возможно, операция выполняется “*на месте*”, тоесть, вместо создания нового "
"объекта и потом назначения его цели – сразу используется “старый” объект."

msgid "With the exception of assigning to tuples and multiple targets in a single statement, the assignment done by augmented assignment statements is handled the same way as normal assignments. Similarly, with the exception of the possible *in-place* behavior, the binary operation performed by augmented assignment is the same as the normal binary operations."
msgstr ""
"С учётом указанных выше оговорок (о кортежах и множественных целях) – "
"назначения у расширенных назначений обрабатываются так же, как и обычные. "
"Также и (за исключением исполнения “*на месте*” ) двухоперандная операция у "
"расширенных назначений обрабатывается так же, как и обычная."

msgid "For targets which are attribute references, the same :ref:`caveat about class and instance attributes <attr-target-note>` applies as for regular assignments."
msgstr ""
"К целям, являющимся ссылками на атрибуты, относится то же самое "
":ref:`предостережение о атрибутах классов и экземпляров<attr-target-note>`, "
"как и для обычных назначений."

msgid "The :keyword:`assert` statement"
msgstr "Инструкция «:keyword:`assert`»"

msgid "Assert statements are a convenient way to insert debugging assertions into a program:"
msgstr ""
"Инструкция «:keyword:`assert`» (“подтверждение”) – это удобный способ "
"вставить в программу контроль (промежуточных результатов) для наладочных "
"целей."

msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr ""
"Для короткой формы – «``assert expression``» – эквивалентом является : ::"

msgid "if __debug__:    if not expression: raise AssertionError"
msgstr "if __debug__:    if not expression: raise AssertionError"

msgid "The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"А для расширенной формы – «``assert expression1, expression2``» – "
"эквивалентом является : ::"

msgid "if __debug__:    if not expression1: raise AssertionError(expression2)"
msgstr "if __debug__:    if not expression1: raise AssertionError(expression2)"

msgid "These equivalences assume that :const:`__debug__` and :exc:`AssertionError` refer to the built-in variables with those names.  In the current implementation, the built-in variable :const:`__debug__` is ``True`` under normal circumstances, ``False`` when optimization is requested (command line option -O).  The current code generator emits no code for an assert statement when optimization is requested at compile time.  Note that it is unnecessary to include the source code for the expression that failed in the error message; it will be displayed as part of the stack trace."
msgstr ""
"Эти эквиваленты полагаются на встроенные переменные «:const:`__debug__`» и "
"«:exc:`AssertionError`» . В текущей реализации Питона встроенная переменная "
"«:const:`__debug__`» – по умолчанию имеет значение «:const:`True`» , а "
"«:const:`False`» – в случае оптимизации командой «``-O``» . Нынешний "
"генератор кода не генерирует никакого кода для инструкций "
"«:keyword:`assert`» , когда запрошена компиляция с оптимизацией. Заметьте, "
"что необязательно вставлять исходный код выражения, вызвавшего ошибку, в "
"сообщение об ошибке – оно и так будет показано, как часть стека ."

msgid "Assignments to :const:`__debug__` are illegal.  The value for the built-in variable is determined when the interpreter starts."
msgstr ""
"Запись в переменную «:const:`__debug__`» – недопустима. Значение для этой "
"встроенной переменной определяется при запуске интерпретатора."

msgid "The :keyword:`pass` statement"
msgstr "Инструкция «:keyword:`pass`»"

msgid ":keyword:`pass` is a null operation --- when it is executed, nothing happens. It is useful as a placeholder when a statement is required syntactically, but no code needs to be executed, for example::"
msgstr ""
"«:keyword:`pass`» – это “пустой” оператор – при его исполнении ничего не "
"происходит. Он полезен как заместитель, когда какое либо выражение "
"необходимо по синтаксису, но там не нужно исполнять никакого кода. Например "
": ::"

msgid "def f(arg): pass    # a function that does nothing (yet)  class C: pass       # a class with no methods (yet)"
msgstr ""
"def f(arg): pass    # a function that does nothing (yet)  class C: pass "
"      # a class with no methods (yet)"

msgid "The :keyword:`del` statement"
msgstr "Инструкция «:keyword:`del`»"

msgid "Deletion is recursively defined very similar to the way assignment is defined. Rather that spelling it out in full details, here are some hints."
msgstr ""
"Удаление определяется рекурсивно – очень похоже на то, как определяется "
"назначение. Вместо расписывания деталей грамматики – далее даны только "
"некоторые подсказки."

msgid "Deletion of a target list recursively deletes each target, from left to right."
msgstr "Удаление списка целей – рекурсивно удаляет каждую цель слева направо."

msgid "Deletion of a name removes the binding of that name from the local or global namespace, depending on whether the name occurs in a :keyword:`global` statement in the same code block.  If the name is unbound, a :exc:`NameError` exception will be raised."
msgstr ""
"Удаление имени удаляет назначение этому имени из локальной или глобальной "
"области имён, в зависимости от того, объявлено ли это имя в инструкции "
"«:keyword:`global`» в этом же самом блоке. Если данное имя не было "
"назначенным (т.е. не было определено) , то инициируется исключение "
"«:exc:`NameError`» ."

msgid "It is illegal to delete a name from the local namespace if it occurs as a free variable in a nested block."
msgstr ""
"Недопустимо удаление имени из локальной области имён, если оно встречается в "
"качестве “свободной” переменной во вложенном блоке."

msgid "Deletion of attribute references, subscriptions and slicings is passed to the primary object involved; deletion of a slicing is in general equivalent to assignment of an empty slice of the right type (but even this is determined by the sliced object)."
msgstr ""
"Удаление ссылок на атрибуты, а также элементов по индексу и срезов – "
"передаётся (перепоручается) содержащему их объекту. Удаление среза – в целом "
"эквивалентно назначению пустого среза подходящего типа (но даже это "
"определяется (контролируется) объектом, подвергающимся срезу) ."

msgid "The :keyword:`return` statement"
msgstr "Инструкция «:keyword:`return`»"

msgid ":keyword:`return` may only occur syntactically nested in a function definition, not within a nested class definition."
msgstr ""
"«:keyword:`return`» может встречаться только синтаксически непосредственно "
"внутри определения функции, но не внутри вложенных определений классов."

msgid "If an expression list is present, it is evaluated, else ``None`` is substituted."
msgstr ""
"Если (в качестве параметров) дан список выражений, то он вычисляется – иначе "
"подразумевается «:const:`None`» ."

msgid ":keyword:`return` leaves the current function call with the expression list (or ``None``) as return value."
msgstr ""
"«:keyword:`return`» делает выход из текущего вызова функции с указанным "
"списком выражений (или «:const:`None`» ) в качестве возвращаемого этой "
"функцией значения."

msgid "When :keyword:`return` passes control out of a :keyword:`try` statement with a :keyword:`finally` clause, that :keyword:`finally` clause is executed before really leaving the function."
msgstr ""
"Когда «:keyword:`return`» передаёт управление изнутри инструкции "
"«:keyword:`try`» имеющей ветвь «:keyword:`finally`» , ветвь "
"«:keyword:`finally`» исполняется до фактического выхода из этой функции."

msgid "In a generator function, the :keyword:`return` statement is not allowed to include an :token:`expression_list`.  In that context, a bare :keyword:`return` indicates that the generator is done and will cause :exc:`StopIteration` to be raised."
msgstr ""
"В функции-генераторе инструкция «:keyword:`return`» не может иметь "
"синтаксический элемент «:token:`expression_list`» , тоесть вообще каких-либо "
"аргументов. В этом контексте «:keyword:`return`» без аргументов – является "
"сигналом того, что генератор завершил работу, и приведёт к вызову "
"«:exc:`StopIteration`» ."

msgid "The :keyword:`yield` statement"
msgstr "Инструкция «:keyword:`yield`»"

msgid "The :keyword:`yield` statement is only used when defining a generator function, and is only used in the body of the generator function. Using a :keyword:`yield` statement in a function definition is sufficient to cause that definition to create a generator function instead of a normal function. When a generator function is called, it returns an iterator known as a generator iterator, or more commonly, a generator.  The body of the generator function is executed by calling the :func:`next` function on the generator repeatedly until it raises an exception."
msgstr ""
"Инструкция «:keyword:`yield`» используется только при определении "
"функций-генераторов и встречается только внутри такой функции. Использование "
"инструкции «:keyword:`yield`» в какой-либо функции – является однозначным "
"сигналом, который приводит к тому, что данное определение вместо обычной "
"функции создаёт функцию-генератор. При вызове функции-генератора – она "
"возвращает итератор, также называемый : “итератор-генератор” , или просто : "
"“генератор” . Тело функции-генератора исполняется посредством вызова функции "
"«:func:`next`» , применённой к данному генератору, повторяясь до получения "
"исключения."

msgid "When a :keyword:`yield` statement is executed, the state of the generator is frozen and the value of :token:`expression_list` is returned to :meth:`next`'s caller.  By \"frozen\" we mean that all local state is retained, including the current bindings of local variables, the instruction pointer, and the internal evaluation stack: enough information is saved so that the next time :func:`next` is invoked, the function can proceed exactly as if the :keyword:`yield` statement were just another external call."
msgstr ""
"Когда исполняется инструкция «:keyword:`yield`» – состояние содержащей её "
"функции-генератора замораживается, а значение аргументов «:keyword:`yield`» "
"(«:token:`expression_list`») возвращается в место вызова функции "
"«:meth:`next`» . Под “замораживается” подразумевается то, что всё локальное "
"состояние сохраняется, включая текущие связывания (значения) локальных "
"переменных, указатель на инструкцию (с которой продолжать) и внутренний стек "
"вычислений. Тоесть сохраняется исчерпывающая информация для того, чтобы, "
"когда в следующий раз будет вызвана инструкция «:meth:`next`» , "
"функция-генератор могла продолжаться точно также, как если бы вместо "
"инструкции «:keyword:`yield`» был какой-либо вызов внешней функции."

msgid "The proposal that, among other generator enhancements, proposed allowing :keyword:`yield` to appear inside a :keyword:`try` ... :keyword:`finally` block."
msgstr ""
"Предложение, которое помимо других улучшений генератора, предполагает "
"разрешение инструкции «:keyword:`yield`» внутри блока «:keyword:`try` ... "
":keyword:`finally`» ."

msgid "The :keyword:`raise` statement"
msgstr "Инструкция «:keyword:`raise`»"

msgid "If no expressions are present, :keyword:`raise` re-raises the last exception that was active in the current scope.  If no exception is active in the current scope, a :exc:`TypeError` exception is raised indicating that this is an error (if running under IDLE, a :exc:`queue.Empty` exception is raised instead)."
msgstr ""
"Если не заданы выражения, то «:keyword:`raise`» перевызывает последнее "
"исключение, которое было активно в текущей области. А если в текущей области "
"нет активных исключений, то вызывается исключение «:exc:`TypeError`» , "
"сигнализирующее о неопределённой ошибке (при работе под “IDLE” вызывается "
"исключение «:exc:`queue.Empty`» ) ."

msgid "Otherwise, :keyword:`raise` evaluates the first expression as the exception object.  It must be either a subclass or an instance of :class:`BaseException`. If it is a class, the exception instance will be obtained when needed by instantiating the class with no arguments."
msgstr ""
"Если выражения заданы, то «:keyword:`raise`» расценивает первое как "
"объект-исключение – оно должно быть или экземпляром или подклассом "
"«:class:`BaseException`» . В последнем случае, если потребуется, "
"соответствующий экземпляр исключения будет сгенерирован из этого класса без "
"аргументов."

msgid "The :dfn:`type` of the exception is the exception instance's class, the :dfn:`value` is the instance itself."
msgstr ""
"Типом данного исключения является класс экземпляра данного исключения, а "
"значением является сам этот экземпляр."

msgid "A traceback object is normally created automatically when an exception is raised and attached to it as the :attr:`__traceback__` attribute, which is writable. You can create an exception and set your own traceback in one step using the :meth:`with_traceback` exception method (which returns the same exception instance, with its traceback set to its argument), like so::"
msgstr ""
"Объект трассировки в норме создаётся автоматически, когда инициируется "
"исключение, и присоединяется к этому исключению в качестве изменяемого "
"атрибута «:attr:`__traceback__`» . Вы можете создать исключение и установить "
"собственный объект трассировки за один шаг, используя метод исключения – "
"«:meth:`with_traceback`» (который возвращает тот же экземпляр исключения, но "
"с его объектом трассировки установленным в значение аргумента) . Например : "
"::"

msgid "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"
msgstr "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"

msgid "The ``from`` clause is used for exception chaining: if given, the second *expression* must be another exception class or instance, which will then be attached to the raised exception as the :attr:`__cause__` attribute (which is writable).  If the raised exception is not handled, both exceptions will be printed::"
msgstr ""
"Часть после ключевого слова «``from``» используется для связывания "
"исключений : если это второе выражение задано, оно должно быть ещё одним "
"классом или экземпляром исключения – этот объект будет присоединён к "
"вызываемому (основному) исключению как изменяемый атрибут "
"«:attr:`__cause__`» . Если вызванное исключение не обработано, то будут "
"напечатаны оба исключения : ::"

msgid ">>> try: ...     print(1 / 0) ... except Exception as exc: ...     raise RuntimeError(\"Something bad happened\") from exc ... Traceback (most recent call last):   File \"<stdin>\", line 2, in <module> ZeroDivisionError: int division or modulo by zero  The above exception was the direct cause of the following exception:  Traceback (most recent call last):   File \"<stdin>\", line 4, in <module> RuntimeError: Something bad happened"
msgstr ""
">>> try: ...     print(1 / 0) ... except Exception as exc: ...     raise "
"RuntimeError(\"Something bad happened\") from exc ... Traceback (most recent "
"call last):   File \"<stdin>\", line 2, in <module> ZeroDivisionError: int "
"division or modulo by zero  The above exception was the direct cause of the "
"following exception:  Traceback (most recent call last):   File \"<stdin>\", "
"line 4, in <module> RuntimeError: Something bad happened"

msgid "A similar mechanism works implicitly if an exception is raised inside an exception handler: the previous exception is then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""
"Подобный же механизм работает неявно, если исключение инициировано внутри "
"обработчика исключения : предыдущее исключение присоединяется как новый "
"атрибут «:attr:`__context__`» исключения :"

msgid ">>> try: ...     print(1 / 0) ... except: ...     raise RuntimeError(\"Something bad happened\") ... Traceback (most recent call last):   File \"<stdin>\", line 2, in <module> ZeroDivisionError: int division or modulo by zero  During handling of the above exception, another exception occurred:  Traceback (most recent call last):   File \"<stdin>\", line 4, in <module> RuntimeError: Something bad happened"
msgstr ""
">>> try: ...     print(1 / 0) ... except: ...     raise "
"RuntimeError(\"Something bad happened\") ... Traceback (most recent call "
"last):   File \"<stdin>\", line 2, in <module> ZeroDivisionError: int division "
"or modulo by zero  During handling of the above exception, another "
"exception occurred:  Traceback (most recent call last):   File \"<stdin>\", "
"line 4, in <module> RuntimeError: Something bad happened"

msgid "Additional information on exceptions can be found in section :ref:`exceptions`, and information about handling exceptions is in section :ref:`try`."
msgstr ""
"Дополнительную информацию об исключениях смотрите в разделе "
"“:ref:`exceptions`” , а об обработке исключений – в разделе “:ref:`try`” ."

msgid "The :keyword:`break` statement"
msgstr "Инструкция «:keyword:`break`»"

msgid ":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :keyword:`while` loop, but not nested in a function or class definition within that loop."
msgstr ""
"«:keyword:`break`» может встречаться только находясь синтаксически "
"непосредственно внутри цикла «:keyword:`for`» или «:keyword:`while`» , но не "
"внутри определения функции или класса, находящегося внутри этого цикла."

msgid "It terminates the nearest enclosing loop, skipping the optional :keyword:`else` clause if the loop has one."
msgstr ""
"Эта инструкция прекращает ближайший объемлющий цикл, пропуская его ветвь "
"«:keyword:`else`» , если она есть."

msgid "If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control target keeps its current value."
msgstr ""
"Если цикл «:keyword:`for`» прекращён инструкцией «:keyword:`break`», то "
"переменная-цель со значением текущего элемента перебираемого множества – "
"сохраняет своё значение."

msgid "When :keyword:`break` passes control out of a :keyword:`try` statement with a :keyword:`finally` clause, that :keyword:`finally` clause is executed before really leaving the loop."
msgstr ""
"Когда «:keyword:`break`» прекращает цикл, находясь внутри инструкции "
"«:keyword:`try`» , имеющей ветвь «:keyword:`finally`» , то эта ветвь "
"выполняется раньше выхода из цикла."

msgid "The :keyword:`continue` statement"
msgstr "Инструкция «:keyword:`continue`»"

msgid ":keyword:`continue` may only occur syntactically nested in a :keyword:`for` or :keyword:`while` loop, but not nested in a function or class definition or :keyword:`finally` clause within that loop.  It continues with the next cycle of the nearest enclosing loop."
msgstr ""
"«:keyword:`continue`» может встречаться только находясь синтаксически внутри "
"цикла «:keyword:`for`» или «:keyword:`while`» , но не внутри определения "
"функции или класса или внутри ветви «:keyword:`finally`», находящихся внутри "
"этого цикла. Эта инструкция продолжает выполнение ближайшего объемлющего "
"цикла с нового прохода."

msgid "When :keyword:`continue` passes control out of a :keyword:`try` statement with a :keyword:`finally` clause, that :keyword:`finally` clause is executed before really starting the next loop cycle."
msgstr ""
"Когда «:keyword:`continue`» исполняется внутри инструкции «:keyword:`try`» , "
"имеющей ветвь «:keyword:`finally`» , то эта ветвь выполняется раньше нового "
"прохода цикла."

msgid "The :keyword:`import` statement"
msgstr "Инструкция «:keyword:`import`»"

msgid "Import statements are executed in two steps: (1) find a module, and initialize it if necessary; (2) define a name or names in the local namespace (of the scope where the :keyword:`import` statement occurs). The statement comes in two forms differing on whether it uses the :keyword:`from` keyword. The first form (without :keyword:`from`) repeats these steps for each identifier in the list. The form with :keyword:`from` performs step (1) once, and then performs step (2) repeatedly. For a reference implementation of step (1), see the :mod:`importlib` module."
msgstr ""
"Инструкции «import» исполняются в два шага:1: находится модуль, и, если "
"необходимо, инициализируется;2: определяется имя (или имена) в данной "
"локальной области имён (тоесть, в той, где находится данная инструкция "
"«:keyword:`import`» ) .Инструкция бывает двух видов : с ключевым словом "
"«:keyword:`from`» и без. Форма без «:keyword:`from`» повторяет указанные два "
"шага для каждого идентификатора в списке. Форма с «:keyword:`from`» "
"исполняет шаг 1 однократно, а затем исполняет шаг 2 многократно. Подробнее "
"об реализации шага 1 смотрите в модуле «:mod:`importlib`» ."

msgid "To understand how step (1) occurs, one must first understand how Python handles hierarchical naming of modules. To help organize modules and provide a hierarchy in naming, Python has a concept of packages. A package can contain other packages and modules while modules cannot contain other modules or packages. From a file system perspective, packages are directories and modules are files. The original `specification for packages <http://www.python.org/doc/essays/packages.html>`_ is still available to read, although minor details have changed since the writing of that document."
msgstr ""
"Для понимания того, что происходит на первом шаге, нужно понимать, как Питон "
"управляется с иерархическим именованием модулей. Для удобства организации "
"модулей и возможности иерархического именования в Питоне есть своя концепция "
"пакетов. Пакет может содержать другие пакеты и модули, тогда как модули не "
"могут содержать ни других модулей ни пакетов. С точки зрения файловой "
"системы – пакеты являются директориями (“каталогами”, “папками”) , а модули "
"являются файлами. Оригинальная `спецификация "
"пакетов<http://www.python.org/doc/essays/packages.html>`_ ещё доступна для "
"чтения, хотя незначительные детали изменились со времени её написания."

msgid "Once the name of the module is known (unless otherwise specified, the term \"module\" will refer to both packages and modules), searching for the module or package can begin. The first place checked is :data:`sys.modules`, the cache of all modules that have been imported previously. If the module is found there then it is used in step (2) of import unless :keyword:`None` is found in :data:`sys.modules`, in which case :exc:`ImportError` is raised."
msgstr ""
"Когда имя модуля становится известно (когда не указано иное – термин "
"“модуль” будет подразумевать как модули, так и пакеты) – начинается поиск "
"этого модуля или пакета. Сначала проверяется «:data:`sys.modules`» – это кэш "
"всех модулей, которые уже́ были импортированы. Если искомый модуль там "
"найден, то он и используется на шаге 2 импортирования. Но если в "
"«:data:`sys.modules`» для этого имени найдено «:const:`None`» , то "
"вызывается «:exc:`ImportError`» ."

msgid "If the module is not found in the cache, then :data:`sys.meta_path` is searched (the specification for :data:`sys.meta_path` can be found in :pep:`302`). The object is a list of :term:`finder` objects which are queried in order as to whether they know how to load the module by calling their :meth:`find_module` method with the name of the module. If the module happens to be contained within a package (as denoted by the existence of a dot in the name), then a second argument to :meth:`find_module` is given as the value of the :attr:`__path__` attribute from the parent package (everything up to the last dot in the name of the module being imported). If a finder can find the module it returns a :term:`loader` (discussed later) or returns :keyword:`None`."
msgstr ""
"Если модуль не найден в кэше, то производится поиск в "
"«:data:`sys.meta_path`» (спецификацию «:data:`sys.meta_path`» можно "
"посмотреть в “:pep:`302`” ) . Этот объект является списком объектов "
"“:term:`finder`” , которые запрашиваются по порядку на предмет того, знают "
"ли они как загружать данный модуль, посредством вызова их метода "
"«:meth:`find_module`» с именем данного модуля. Если оказывается, что данный "
"модуль содержится внутри пакета (как следует из наличия точки в имени) , то "
"второй аргумент у «:meth:`find_module`» представляет собой значение атрибута "
"«:attr:`__path__`» из родительского пакета (всё вплоть до последней точки в "
"имени данного импортируемого модуля) . Если “:term:`finder`” может найти "
"модуль, то он возвращает “загрузчик” (будет рассмотрено далее) , иначе "
"возвращает «:const:`None`» ."

msgid "If none of the finders on :data:`sys.meta_path` are able to find the module then some implicitly defined finders are queried. Implementations of Python vary in what implicit meta path finders are defined. The one they all do define, though, is one that handles :data:`sys.path_hooks`, :data:`sys.path_importer_cache`, and :data:`sys.path`."
msgstr ""
"Если ни один из “:term:`finder`” в «:data:`sys.meta_path`» не оказался "
"способен найти модуль, тогда запрашиваются какие-либо не явно определённые "
"“:term:`finder`” . Реализации Питона различаются в том, каким неявным путём "
"определяются “:term:`finder`” . Однако, одно, что все они определяют – то, "
"что контролирует «:data:`sys.path_hooks`» , "
"«:data:`sys.path_importer_cache`» , «:data:`sys.path`» ."

msgid "The implicit finder searches for the requested module in the \"paths\" specified in one of two places (\"paths\" do not have to be file system paths). If the module being imported is supposed to be contained within a package then the second argument passed to :meth:`find_module`, :attr:`__path__` on the parent package, is used as the source of paths. If the module is not contained in a package then :data:`sys.path` is used as the source of paths."
msgstr ""

msgid "Once the source of paths is chosen it is iterated over to find a finder that can handle that path. The dict at :data:`sys.path_importer_cache` caches finders for paths and is checked for a finder. If the path does not have a finder cached then :data:`sys.path_hooks` is searched by calling each object in the list with a single argument of the path, returning a finder or raises :exc:`ImportError`. If a finder is returned then it is cached in :data:`sys.path_importer_cache` and then used for that path entry. If no finder can be found but the path exists then a value of :keyword:`None` is stored in :data:`sys.path_importer_cache` to signify that an implicit, file-based finder that handles modules stored as individual files should be used for that path. If the path does not exist then a finder which always returns :keyword:`None` is placed in the cache for the path."
msgstr ""

msgid "If no finder can find the module then :exc:`ImportError` is raised. Otherwise some finder returned a loader whose :meth:`load_module` method is called with the name of the module to load (see :pep:`302` for the original definition of loaders). A loader has several responsibilities to perform on a module it loads. First, if the module already exists in :data:`sys.modules` (a possibility if the loader is called outside of the import machinery) then it is to use that module for initialization and not a new module. But if the module does not exist in :data:`sys.modules` then it is to be added to that dict before initialization begins. If an error occurs during loading of the module and it was added to :data:`sys.modules` it is to be removed from the dict. If an error occurs but the module was already in :data:`sys.modules` it is left in the dict."
msgstr ""

msgid "The loader must set several attributes on the module. :data:`__name__` is to be set to the name of the module. :data:`__file__` is to be the \"path\" to the file unless the module is built-in (and thus listed in :data:`sys.builtin_module_names`) in which case the attribute is not set. If what is being imported is a package then :data:`__path__` is to be set to a list of paths to be searched when looking for modules and packages contained within the package being imported. :data:`__package__` is optional but should be set to the name of package that contains the module or package (the empty string is used for module not contained in a package). :data:`__loader__` is also optional but should be set to the loader object that is loading the module."
msgstr ""

msgid "If an error occurs during loading then the loader raises :exc:`ImportError` if some other exception is not already being propagated. Otherwise the loader returns the module that was loaded and initialized."
msgstr ""

msgid "When step (1) finishes without raising an exception, step (2) can begin."
msgstr ""

msgid "The first form of :keyword:`import` statement binds the module name in the local namespace to the module object, and then goes on to import the next identifier, if any.  If the module name is followed by :keyword:`as`, the name following :keyword:`as` is used as the local name for the module."
msgstr ""

msgid "The :keyword:`from` form does not bind the module name: it goes through the list of identifiers, looks each one of them up in the module found in step (1), and binds the name in the local namespace to the object thus found.  As with the first form of :keyword:`import`, an alternate local name can be supplied by specifying \":keyword:`as` localname\".  If a name is not found, :exc:`ImportError` is raised.  If the list of identifiers is replaced by a star (``'*'``), all public names defined in the module are bound in the local namespace of the :keyword:`import` statement.."
msgstr ""

msgid "The *public names* defined by a module are determined by checking the module's namespace for a variable named ``__all__``; if defined, it must be a sequence of strings which are names defined or imported by that module.  The names given in ``__all__`` are all considered public and are required to exist.  If ``__all__`` is not defined, the set of public names includes all names found in the module's namespace which do not begin with an underscore character (``'_'``). ``__all__`` should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module)."
msgstr ""

msgid "The :keyword:`from` form with ``*`` may only occur in a module scope.  The wild card form of import --- ``import *`` --- is only allowed at the module level. Attempting to use it in class or function definitions will raise a :exc:`SyntaxError`."
msgstr ""

msgid "When specifying what module to import you do not have to specify the absolute name of the module. When a module or package is contained within another package it is possible to make a relative import within the same top package without having to mention the package name. By using leading dots in the specified module or package after :keyword:`from` you can specify how high to traverse up the current package hierarchy without specifying exact names. One leading dot means the current package where the module making the import exists. Two dots means up one package level. Three dots is up two levels, etc. So if you execute ``from . import mod`` from a module in the ``pkg`` package then you will end up importing ``pkg.mod``. If you execute ``from ..subpkg2 imprt mod`` from within ``pkg.subpkg1`` you will import ``pkg.subpkg2.mod``. The specification for relative imports is contained within :pep:`328`."
msgstr ""

msgid ":func:`importlib.import_module` is provided to support applications that determine which modules need to be loaded dynamically."
msgstr ""

msgid "Future statements"
msgstr "Инструкция “future”"

msgid "A :dfn:`future statement` is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python.  The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language.  It allows use of the new features on a per-module basis before the release in which the feature becomes standard."
msgstr ""
"Инструкция “future” является особым случаем инструкции «:keyword:`import`» и "
"является указанием компилятору о том, что данный модуль нужно "
"компилировать, используя синтаксис либо семантику, которые будут доступны в "
"указанной будущей версии Питона. Инструкция “future” нацелена на облегчение "
"миграции на новые версии Питона, в которых будут введены несовместимые "
"изменения. Это позволяет использовать новые возможности (для этого "
"потребуется установить соответствующие модули) до версии языка, в которой "
"они станут стандартными."

msgid "A future statement must appear near the top of the module.  The only lines that can appear before a future statement are:"
msgstr ""
"Инструкция “future” должна располагаться перед кодом модуля. До неё могут "
"быть только следующие строки :"

msgid "the module docstring (if any),"
msgstr "строка документации модуля (если есть) ,"

msgid "comments,"
msgstr "коментарии,"

msgid "blank lines, and"
msgstr "пустые строки,"

msgid "other future statements."
msgstr "другие инструкции “future” ."

msgid "The features recognized by Python 3.0 are ``absolute_import``, ``division``, ``generators``, ``unicode_literals``, ``print_function``, ``nested_scopes`` and ``with_statement``.  They are all redundant because they are always enabled, and only kept for backwards compatibility."
msgstr ""
"Питон 3.0 знает следующие свойства : «``absolute_import``» , «``division``» "
", «``generators``» , «``unicode_literals``» , «``print_function``» , "
"«``nested_scopes``» , «``with_statement``» . Но все они уже́ устарели, "
"поскольку уже́ встроены в язык и всегда доступны, и сохранены только для "
"обратной совместимости."

msgid "A future statement is recognized and treated specially at compile time: Changes to the semantics of core constructs are often implemented by generating different code.  It may even be the case that a new feature introduces new incompatible syntax (such as a new reserved word), in which case the compiler may need to parse the module differently.  Such decisions cannot be pushed off until runtime."
msgstr ""
"Инструкция “future” распознаётся и обрабатывается особым образом на этапе "
"компиляции, поскольку изменения в семантике базовых конструкций зачастую "
"реализуются путём генерации и подстановки совсем другого кода "
"(соответствующего текущей версии языка) . Может даже быть так, что новое "
"свойство вводит новый несовместимый синтаксис (например, новое "
"зарезервированное слово) , в результате чего компилятору необходимо "
"интерпретировать данный модуль совсем по-другому. Такие меры не могут быть "
"отложены до этапа исполнения программы (“runtime”) ."

msgid "For any given release, the compiler knows which feature names have been defined, and raises a compile-time error if a future statement contains a feature not known to it."
msgstr ""
"Компилятор знает, какие имена будущих свойств определены в конкретной данной "
"версии и инициирует ошибку этапа компилирования, если инструкция “future” "
"содержит свойство, которое ему не известно."

msgid "The direct runtime semantics are the same as for any import statement: there is a standard module :mod:`__future__`, described later, and it will be imported in the usual way at the time the future statement is executed."
msgstr ""
"За исключением указанного выше – на этапе исполнения имеет тот же смысл, что "
"и любое выражение «:keyword:`import`» , тоесть : имеется стандартный модуль "
"«:mod:`__future__`» (описано далее) , и он будет импортирован обычным "
"образом в момент исполнения соответствующей инструкции “future” ."

msgid "The interesting runtime semantics depend on the specific feature enabled by the future statement."
msgstr ""
"Влияние на выполнение программы сильно зависит от того, какие свойства "
"задействованы."

msgid "Note that there is nothing special about the statement::"
msgstr ""
"Заметьте, что следующая инструкция не интерпретируется как-либо "
"исключительно : ::"

msgid "import __future__ [as name]"
msgstr "import __future__ [as name]"

msgid "That is not a future statement; it's an ordinary import statement with no special semantics or syntax restrictions."
msgstr ""
"Это не инструкция “future” – это обычная инструкция «:keyword:`import`» без "
"каких-либо исключительных смысла или синтаксиса."

msgid "Code compiled by calls to the built-in functions :func:`exec` and :func:`compile` that occur in a module :mod:`M` containing a future statement will, by default, use the new syntax or semantics associated with the future statement.  This can be controlled by optional arguments to :func:`compile` --- see the documentation of that function for details."
msgstr ""
"Код, компилируемый посредством встроенных функций «:func:`exec`» и "
"«:func:`compile`» , вызываемых из модуля, содержащего инструкцию “future” , "
"по-умолчанию тоже испытывает эффект этой инструкции – интерпретируется с "
"соответствующими новыми синтаксисом и смыслом. Для «:func:`compile`» этот "
"эффект можно контролировать через необязательный аргумент (подробности "
"смотрите в документации по данной функции) ."

msgid "A future statement typed at an interactive interpreter prompt will take effect for the rest of the interpreter session.  If an interpreter is started with the :option:`-i` option, is passed a script name to execute, and the script includes a future statement, it will be in effect in the interactive session started after the script is executed."
msgstr ""
"Инструкция “future” , введённая на запрос интерактивного интерпретатора, "
"будет оказывать эффект до конца работы интерпретатора. Если интерпретатор "
"был запущен с опцией «:option:`-i`» и именем скрипта, и этот скрипт содержит "
"инструкцию “future” , то она будет в силе и после перехода к интерактивной "
"сессии после завершения скрипта."

msgid "The original proposal for the __future__ mechanism."
msgstr "Исходное предложение по механизму «``__future__``» ."

msgid "The :keyword:`global` statement"
msgstr "Инструкция «:keyword:`global`»"

msgid "The :keyword:`global` statement is a declaration which holds for the entire current code block.  It means that the listed identifiers are to be interpreted as globals.  It would be impossible to assign to a global variable without :keyword:`global`, although free variables may refer to globals without being declared global."
msgstr ""
"Действие инструкции «:keyword:`global`» распространяется на весь текущий "
"блок кода. Она указывает, что перечисленные в ней идентификаторы должны "
"интерпретироваться как глобальные. Может оказаться невозможным получить "
"доступ к некой глобальной переменной без инструкции «:keyword:`global`» , но "
"переменные, не связанные в данной области имён, обращаются к глобальным "
"переменным – не будучи объявленными как глобальные."

msgid "Names listed in a :keyword:`global` statement must not be used in the same code block textually preceding that :keyword:`global` statement."
msgstr ""
"Идентификаторы, перечисленные в инструкции «:keyword:`global`» не должны "
"использоваться в том же блоке кода выше по тексту, чем эта инструкция."

msgid "Names listed in a :keyword:`global` statement must not be defined as formal parameters or in a :keyword:`for` loop control target, :keyword:`class` definition, function definition, or :keyword:`import` statement."
msgstr ""
"Идентификаторы, перечисленные в инструкции «:keyword:`global`» не должны "
"объявляться как параметры в определении функции, или как “цель” в "
"конструкции цикла «:keyword:`for`» , или в определениях класса или функции, "
"или в инструкции «:keyword:`import`» ."

msgid "The current implementation does not enforce the latter two restrictions, but programs should not abuse this freedom, as future implementations may enforce them or silently change the meaning of the program."
msgstr ""
"Текущая реализация не навязывает эти два последних ограничения, но всё-же "
"программам не следует злоупотреблять этой свободой, поскольку будущие "
"реализации могут ввести эти ограничения или, не выдавая сообщения об ошибке, "
"интерпретировать по-другому."

msgid "**Programmer's note:** the :keyword:`global` is a directive to the parser.  It applies only to code parsed at the same time as the :keyword:`global` statement. In particular, a :keyword:`global` statement contained in a string or code object supplied to the built-in :func:`exec` function does not affect the code block *containing* the function call, and code contained in such a string is unaffected by :keyword:`global` statements in the code containing the function call.  The same applies to the :func:`eval` and :func:`compile` functions."
msgstr ""
"**Замечание для программистов :** «:keyword:`global`» – это указание, "
"предназначенное анализатору текста (парсеру) . Оно относится только к коду, "
"обрабатываемому одновременно с этой инструкцией «:keyword:`global`» . В "
"норме – инструкция «:keyword:`global`» , содержащаяся в строке или в "
"объекте-коде, передаваемых во встроенную функцию «:func:`exec`» , не влияет "
"на блок кода, в котором этот вызов функции содержится. И обратно, код, "
"содержащийся в такого рода тексте, не испытывает действия инструкции "
"«:keyword:`global`» , находящейся в коде, из которого сделан вызов этой "
"функции с текстом. То же относится и к функциям «:func:`eval`» и "
"«:func:`compile`» ."

msgid "The :keyword:`nonlocal` statement"
msgstr "Инструкция «:keyword:`nonlocal`»"

msgid "The :keyword:`nonlocal` statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope.  This is important because the default behavior for binding is to search the local namespace first.  The statement allows encapsulated code to rebind variables outside of the local scope besides the global (module) scope."
msgstr ""
"Инструкция «:keyword:`nonlocal`» приводит к тому, что перечисленные в ней "
"идентификаторы будут указывать на объекты, на которые они указывали в "
"ближайшей внешней области имён. Это принципиально отличается от поведения "
"связывания по-умолчанию, при котором сначала происходит поиск в локальной "
"области имён. Эта инструкция позволяет изолированному (инкапсулированному) "
"коду возвращать связывание переменных, существовавшее у них за пределами "
"данной локальной области имён помимо того, что относится к глобальной (на "
"уровне модуля) области имён."

msgid "Names listed in a :keyword:`nonlocal` statement, unlike to those listed in a :keyword:`global` statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously)."
msgstr ""
"Имена, перечисленные в инструкции «:keyword:`nonlocal`» , в отличие от тех, "
"что перечислены в инструкции «:keyword:`global`» , обязаны указывать на уже́ "
"существующие назначения в непосредственно объемлющей области имён (та "
"область, в которой новые связывания могли бы быть созданы, не может быть "
"установлена однозначно) ."

msgid "Names listed in a :keyword:`nonlocal` statement must not collide with pre-existing bindings in the local scope."
msgstr ""
"Среди имён, перечисленных в инструкции «:keyword:`nonlocal`» не должно быть "
"тех, что уже́ существуют в этой локальной области имён."

msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "Спецификация инструкции «:keyword:`nonlocal`» ."

msgid "It may occur within an :keyword:`except` or :keyword:`else` clause.  The restriction on occurring in the :keyword:`try` clause is implementor's laziness and will eventually be lifted."
msgstr ""

msgid "Top-level components"
msgstr ""

msgid "The Python interpreter can get its input from a number of sources: from a script passed to it as standard input or as program argument, typed in interactively, from a module source file, etc.  This chapter gives the syntax used in these cases."
msgstr ""

msgid "Complete Python programs"
msgstr ""

msgid "While a language specification need not prescribe how the language interpreter is invoked, it is useful to have a notion of a complete Python program.  A complete Python program is executed in a minimally initialized environment: all built-in and standard modules are available, but none have been initialized, except for :mod:`sys` (various system services), :mod:`builtins` (built-in functions, exceptions and ``None``) and :mod:`__main__`.  The latter is used to provide the local and global namespace for execution of the complete program."
msgstr ""

msgid "The syntax for a complete Python program is that for file input, described in the next section."
msgstr ""

msgid "The interpreter may also be invoked in interactive mode; in this case, it does not read and execute a complete program but reads and executes one statement (possibly compound) at a time.  The initial environment is identical to that of a complete program; each statement is executed in the namespace of :mod:`__main__`."
msgstr ""

msgid "Under Unix, a complete program can be passed to the interpreter in three forms: with the :option:`-c` *string* command line option, as a file passed as the first command line argument, or as standard input.  If the file or standard input is a tty device, the interpreter enters interactive mode; otherwise, it executes the file as a complete program."
msgstr ""

msgid "File input"
msgstr ""

msgid "All input read from non-interactive files has the same form:"
msgstr ""

msgid "This syntax is used in the following situations:"
msgstr ""

msgid "when parsing a complete Python program (from a file or from a string);"
msgstr ""

msgid "when parsing a module;"
msgstr ""

msgid "when parsing a string passed to the :func:`exec` function;"
msgstr ""

msgid "Interactive input"
msgstr ""

msgid "Input in interactive mode is parsed using the following grammar:"
msgstr ""

msgid "Note that a (top-level) compound statement must be followed by a blank line in interactive mode; this is needed to help the parser detect the end of the input."
msgstr ""

msgid "Expression input"
msgstr ""

msgid "There are two forms of expression input.  Both ignore leading whitespace. The string argument to :func:`eval` must have the following form:"
msgstr ""

msgid "Note: to read 'raw' input line without interpretation, you can use the the :meth:`readline` method of file objects, including ``sys.stdin``."
msgstr ""
