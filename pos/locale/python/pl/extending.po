# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2010, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2010-06-30 14:00\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.7.0\n"

msgid "Building C and C++ Extensions with distutils"
msgstr "Budowanie Rozszerzeń C i C++ za pomocą distutils"

msgid "Starting in Python 1.4, Python provides, on Unix, a special make file for building make files for building dynamically-linked extensions and custom interpreters.  Starting with Python 2.0, this mechanism (known as related to Makefile.pre.in, and Setup files) is no longer supported. Building custom interpreters was rarely used, and extension modules can be built using distutils."
msgstr ""
"Poczynając od języka pytonowskiego w wersji 1.4 język pytonowski dostarcza w "
"Unixie, szczególny plik make-file dla budowania plików make-file dla "
"budowania dynamicznie-łączonych rozszerzeń i szczególnych programów "
"interpretujących. Poczynając od wersji języka pytonowskiego 2.0, ten "
"mechanizm (znany jako związany z Makefile.pre.in, i plikami instalacyjnymi) "
"nie jest już wspierany. Budowanie szczególnych programów interpretujących "
"było rzadko używane, i moduły rozszerzające mogą być budowane przy użyciu "
"distutils."

msgid "Building an extension module using distutils requires that distutils is installed on the build machine, which is included in Python 2.x and available separately for Python 1.5. Since distutils also supports creation of binary packages, users don't necessarily need a compiler and distutils to install the extension."
msgstr ""
"Budowanie modułu rozszerzającego przy użyciu distutils wymaga aby distutils "
"było zainstalowane na maszynie budującej, co jest załączone w wersjach "
"języka pytonowskiego 2.x i dostępne oddzielnie dla języka pytonowskiego w "
"wersji 1.5 Od kiedy distutils także wspiera tworzenie pakietów binarnych, "
"użytkownicy nie muszą koniecznie potrzebować kompilatora i distutils aby "
"zainstalować rozszerzenie."

msgid "A distutils package contains a driver script, :file:`setup.py`. This is a plain Python file, which, in the most simple case, could look like this::"
msgstr ""
"Pakiet distutils zawiera skrypt sterownika, :file:`setup.py`. To jest czysto "
"pytonowski plik, który w najprostszym przypadku, może wyglądać "
"następująco::"

msgid "from distutils.core import setup, Extension  module1 = Extension('demo',                     sources = ['demo.c'])  setup (name = 'PackageName',        version = '1.0',        description = 'This is a demo package',        ext_modules = [module1])"
msgstr ""
"from distutils.core import setup, Extension  module1 = Extension('demo', "
"                    sources = ['demo.c'])  setup (name = 'NazwaPakietu', "
"       version = '1.0',        description = 'To jest pakiet demo',        "
"ext_modules = [module1])"

msgid "With this :file:`setup.py`, and a file :file:`demo.c`, running ::"
msgstr ""
"Z tym plikiem :file:`setup.py`, i plikiem :file:`demo.c`, uruchomienie ::"

msgid "python setup.py build"
msgstr "python setup.py build"

msgid "will compile :file:`demo.c`, and produce an extension module named ``demo`` in the :file:`build` directory. Depending on the system, the module file will end up in a subdirectory :file:`build/lib.system`, and may have a name like :file:`demo.so` or :file:`demo.pyd`."
msgstr ""
"skompiluje plik :file:`demo.c`, i wytworzy moduł rozszerzający nazwany "
"``demo`` w katalogu :file:`build`. W zależności od systemu plik modułu "
"wyląduje w podkatalogu :file:`build/lib.system` i może mieć nazwę taką, jak "
":file:`demo.so` lub :file:`demo.pyd`."

msgid "In the :file:`setup.py`, all execution is performed by calling the ``setup`` function. This takes a variable number of keyword arguments, of which the example above uses only a subset. Specifically, the example specifies meta-information to build packages, and it specifies the contents of the package.  Normally, a package will contain of addition modules, like Python source modules, documentation, subpackages, etc. Please refer to the distutils documentation in :ref:`distutils-index` to learn more about the features of distutils; this section explains building extension modules only."
msgstr ""
"W pliku :file:`setup.py`, wszystkie operacje są wykonywane przez wywołanie "
"zadania ``setup``. To pobiera zmienną liczbę kluczowych parametrów, z "
"których przykład powyższy używa tylko podzbioru. Szczególnie, przykład "
"określa informacje pośrednie aby zbudować pakiety, i określa zawartość "
"pakietu. Zwykle pakiet będzie zawierał dodatek modułów takich jak moduły "
"źródłowe języka pytonowskiego, dokumentację, podpakiety, itp. Uprasza się o "
"zajrzenie do dokumentacji distutils do :ref:`distutils-index` aby dowiedzieć "
"się więcej o właściwościach distutils; ten rozdział wyjaśnia tylko "
"budowanie modułów rozszerzeń."

msgid "It is common to pre-compute arguments to :func:`setup`, to better structure the driver script. In the example above, the\\ ``ext_modules`` argument to :func:`setup` is a list of extension modules, each of which is an instance of the :class:`Extension`. In the example, the instance defines an extension named ``demo`` which is build by compiling a single source file, :file:`demo.c`."
msgstr ""
"Jest często spotykane aby uprzednio obliczać parametry dla zadania "
":func:`setup`, aby lepiej rozłożyć skrypt sterownika. W przykładzie "
"powyższym parametr \\ ``ext_modules`` dla zadania :func:`setup` jest listą "
"rozszerzających modułów, z których każdy jest przykładem uogólnienia "
":class:`Extension`. W tym przypadku, przykład definiuje rozszerzenie nazwane "
"``demo`` które jest budowane przez skompilowanie pojedynczego pliku "
"źródłowego, :file:`demo.c`."

msgid "In many cases, building an extension is more complex, since additional preprocessor defines and libraries may be needed. This is demonstrated in the example below. ::"
msgstr ""
"W wielu przypadkach, budowanie rozszerzenia jest bardziej skomplikowane, "
"gdyż dodatkowe definicje preprocesora i biblioteki mogą być potrzebne. To "
"jest demonstrowane w przykładzie poniżej. ::"

msgid "from distutils.core import setup, Extension  module1 = Extension('demo',                     define_macros = [('MAJOR_VERSION', '1'),                                      ('MINOR_VERSION', '0')],                     include_dirs = ['/usr/local/include'],                     libraries = ['tcl83'],                     library_dirs = ['/usr/local/lib'],                     sources = ['demo.c'])  setup (name = 'PackageName',        version = '1.0',        description = 'This is a demo package',        author = 'Martin v. Loewis',        author_email = 'martin@v.loewis.de',        url = 'http://docs.python.org/extending/building',        long_description = ''' This is really just a demo package. ''',        ext_modules = [module1])"
msgstr ""
"from distutils.core import setup, Extension  module1 = Extension('demo', "
"                    define_macros = [('MAJOR_VERSION', '1'), "
"                                     ('MINOR_VERSION', '0')], "
"                    include_dirs = ['/usr/local/include'], "
"                    libraries = ['tcl83'],                     library_dirs "
"= ['/usr/local/lib'],                     sources = ['demo.c'])  setup "
"(name = 'NazwaPakietu',        version = '1.0',        description = 'To "
"jest pakiet demo',        author = 'Martin v. Loewis',        author_email = "
"'martin@v.loewis.de',        url = "
"'http://docs.python.org/extending/building',        long_description = ''' "
"To jest na prawdę tylko pakiet demo. ''',        ext_modules = [module1])"

msgid "In this example, :func:`setup` is called with additional meta-information, which is recommended when distribution packages have to be built. For the extension itself, it specifies preprocessor defines, include directories, library directories, and libraries. Depending on the compiler, distutils passes this information in different ways to the compiler. For example, on Unix, this may result in the compilation commands ::"
msgstr ""
"W tym przykładzie, zadanie :func:`setup` jest wywoływane z dodatkowymi "
"informacjami pośrednimi, co jest zalecane gdy pakiety dystrybucji maja być "
"zbudowane. Dla tego rozszerzenia samego w sobie, określa ona definicje "
"preprocesora, katalogi załączane, katalogi bibliotek, i biblioteki. W "
"zależności od kompilatora, distutils przekazuje tą informację w różny sposób "
"kompilatorowi. Na przykład w Unix-ie, to może dawać rezultat poleceń "
"kompilacji ::"

msgid "gcc -DNDEBUG -g -O3 -Wall -Wstrict-prototypes -fPIC -DMAJOR_VERSION=1 -DMINOR_VERSION=0 -I/usr/local/include -I/usr/local/include/python2.2 -c demo.c -o build/temp.linux-i686-2.2/demo.o  gcc -shared build/temp.linux-i686-2.2/demo.o -L/usr/local/lib -ltcl83 -o build/lib.linux-i686-2.2/demo.so"
msgstr ""
"gcc -DNDEBUG -g -O3 -Wall -Wstrict-prototypes -fPIC -DMAJOR_VERSION=1 "
"-DMINOR_VERSION=0 -I/usr/local/include -I/usr/local/include/python2.2 -c "
"demo.c -o build/temp.linux-i686-2.2/demo.o  gcc -shared "
"build/temp.linux-i686-2.2/demo.o -L/usr/local/lib -ltcl83 -o "
"build/lib.linux-i686-2.2/demo.so"

msgid "These lines are for demonstration purposes only; distutils users should trust that distutils gets the invocations right."
msgstr ""
"Te linie są dla celów demonstracyjnych tylko i wyłącznie; użytkownicy "
"distutils powinni ufać że distutils wystosuje właściwe odwołania."

msgid "Distributing your extension modules"
msgstr "Rozprowadzanie swoich modułów rozszerzających"

msgid "When an extension has been successfully build, there are three ways to use it."
msgstr ""
"Kiedy rozszerzenie zostało z powodzeniem zbudowane, są trzy sposoby aby go "
"użyć."

msgid "End-users will typically want to install the module, they do so by running ::"
msgstr ""
"Użytkownicy końcowi będą najczęściej chcieć zainstalować moduł, będą mogli "
"to zrobić uruchamiając ::"

msgid "python setup.py install"
msgstr "python setup.py install"

msgid "Module maintainers should produce source packages; to do so, they run ::"
msgstr ""
"Zarządcy modułów powinni wyprodukować źródłowe pakiety; aby tego dokonać, "
"uruchomią oni ::"

msgid "python setup.py sdist"
msgstr "python setup.py sdist"

msgid "In some cases, additional files need to be included in a source distribution; this is done through a :file:`MANIFEST.in` file; see the distutils documentation for details."
msgstr ""
"W niektórych przypadkach, dodatkowe pliki są potrzebne w dystrybucji "
"źródłowej; tego dokonuje się przez plik :file:`MANIFEST.in`; sięgnij do "
"dokumentacji distutils po więcej szczegółów."

msgid "If the source distribution has been build successfully, maintainers can also create binary distributions. Depending on the platform, one of the following commands can be used to do so. ::"
msgstr ""
"Jeśli dystrybucja źródłowa została zbudowana szczęśliwie, zarządcy mogą "
"także tworzyć dystrybucje binarne. W zależności od środowiska/maszyny, jedna "
"z następujących komend może być użyta aby tego dokonać. ::"

msgid "python setup.py bdist_wininst python setup.py bdist_rpm python setup.py bdist_dumb"
msgstr ""
"python setup.py bdist_wininst python setup.py bdist_rpm python setup.py "
"bdist_dumb"

msgid "Embedding Python in Another Application"
msgstr "Załączanie języka pytonowskiego w innej aplikacji"

msgid "The previous chapters discussed how to extend Python, that is, how to extend the functionality of Python by attaching a library of C functions to it.  It is also possible to do it the other way around: enrich your C/C++ application by embedding Python in it.  Embedding provides your application with the ability to implement some of the functionality of your application in Python rather than C or C++. This can be used for many purposes; one example would be to allow users to tailor the application to their needs by writing some scripts in Python.  You can also use it yourself if some of the functionality can be written in Python more easily."
msgstr ""
"Poprzednie rozdziały opisywały jak rozszerzać język pytonowski, to jest, jak "
"rozszerzać zdolności działania języka pytonowskiego przez dołączanie "
"biblioteki zadań C do niego. Jest także możliwe robienie tego w drugą "
"stronę: wzbogacić twoją aplikcję C/C++ przez załączenie pytona w niej. "
"Załączanie dostarcza twojej aplikacji zdolność wypełnienia niektórych zadań "
"twojej aplikacji w języku pytonowskim zamiast w C lub C++. To może zostać "
"wykorzystane w wielu celach; jednym z przykładów byłoby pozwolenie innym "
"użytkownikom dostosowanie aplikacji do swoich potrzeb przez napisanie "
"pewnych skryptów w języku pytonowskim. Możesz też użyć tego samodzielnie "
"jeśli niektóre z zadań mogą być napisane w języku pytonowskim nieco łatwiej."

msgid "Embedding Python is similar to extending it, but not quite.  The difference is that when you extend Python, the main program of the application is still the Python interpreter, while if you embed Python, the main program may have nothing to do with Python --- instead, some parts of the application occasionally call the Python interpreter to run some Python code."
msgstr ""
"Załączanie języka pytonowskiego jest podobne do rozszerzania go, ale nie "
"całkiem. Różnica polega na tym, że gdy rozszerzasz język pytonowski, głównym "
"programem aplikacji jest wciąż program interpretujący polecenia języka "
"pytonowskiego, podczas gdy jeśli załączasz język pytonowski, główny program "
"może nie mieć nic wspólnego z językiem pytonowskim --- zamiast tego, "
"niektóre części aplikacji czasami wzywają program interpretujący polecenia "
"języka pytonowskiego aby uruchomić pewien kod języka pytonowskiego."

msgid "So if you are embedding Python, you are providing your own main program.  One of the things this main program has to do is initialize the Python interpreter.  At the very least, you have to call the function :cfunc:`Py_Initialize`.  There are optional calls to pass command line arguments to Python.  Then later you can call the interpreter from any part of the application."
msgstr ""
"Więc jeśli załączasz język pytonowski, dostarczasz wtedy swój własny program "
"główny. Jedną z rzeczy którą ten program główny musi zrobić jest "
"zainicjować program interpretujący polecenia języka pytonowskiego. Na sam "
"koniec, trzeba wywołać zadanie :cfunc:`Py_Initialize`. Istnieją opcjonalne "
"wywołania aby przekazać parametry wiersza polecenia dla języka "
"pytonowskiego. Potem później możesz odwołać się do programu interpretującego "
"polecenia języka pytonowskiego z każdej części aplikacji."

msgid "There are several different ways to call the interpreter: you can pass a string containing Python statements to :cfunc:`PyRun_SimpleString`, or you can pass a stdio file pointer and a file name (for identification in error messages only) to :cfunc:`PyRun_SimpleFile`.  You can also call the lower-level operations described in the previous chapters to construct and use Python objects."
msgstr ""
"Istnieje kilka różnych sposobów aby wywołać program interpretujący polecenia "
"języka pytonowskiego: możesz przekazać ciąg znaków zawierający wyrażenia "
"języka pytonowskiego do zadania :cfunc:`PyRun_SimpleString`, lub możesz "
"przekazać wskaźnik pliku stdio i nazwę pliku (tylko dla rozróżnienia w "
"wiadomościach o błędach) dla zadania :cfunc:`PyRun_SimpleFile`. Możesz także "
"wywołać nisko-poziomowe operacje opisane w poprzednich rozdziałach aby "
"tworzyć i używać przedmiotów języka pytonowskiego."

msgid "A simple demo of embedding Python can be found in the directory :file:`Demo/embed/` of the source distribution."
msgstr ""
"Proste demo załączania języka pytonowskiego może być znalezione w katalogu "
":file:`Demo/embed/` źródłowej dystrybucji."

msgid "See also"
msgstr "Zobacz także"

msgid "The details of Python's C interface are given in this manual. A great deal of necessary information can be found here."
msgstr ""
"Szczegóły sprzęgu C języka pytonowskiego są dane w tym podręczniku. "
"Większość koniecznych informacji może być znaleziona tutaj."

msgid "Very High Level Embedding"
msgstr "Bardzo wysokiego poziomu załączanie"

msgid "The simplest form of embedding Python is the use of the very high level interface. This interface is intended to execute a Python script without needing to interact with the application directly. This can for example be used to perform some operation on a file. ::"
msgstr ""
"Najprostszy sposób załączania języka pytonowskiego polega na tym, aby użyć "
"sprzęgu bardzo wysokiego poziomu. Ten sprzęg jest przeznaczony aby wykonać "
"skrypt języka pytonowskiego bez potrzeby współdziałania z aplikacją "
"bezpośrednio. To może dla przykładu być użyte aby wykonać pewne operacje na "
"pliku. ::"

msgid "#include <Python.h>  int main(int argc, char *argv[]) {   Py_Initialize();   PyRun_SimpleString(\"from time import time,ctime\\n\"                      \"print('Today is', ctime(time()))\\n\");   Py_Finalize();   return 0; }"
msgstr ""
"#include <Python.h>  int main(int argc, char *argv[]) {   Py_Initialize(); "
"  PyRun_SimpleString(\"from time import time,ctime\\n\"                      "
"\"print('Dziś jest', ctime(time()))\\n\");   Py_Finalize();   return 0; }"

msgid "The above code first initializes the Python interpreter with :cfunc:`Py_Initialize`, followed by the execution of a hard-coded Python script that print the date and time.  Afterwards, the :cfunc:`Py_Finalize` call shuts the interpreter down, followed by the end of the program.  In a real program, you may want to get the Python script from another source, perhaps a text-editor routine, a file, or a database.  Getting the Python code from a file can better be done by using the :cfunc:`PyRun_SimpleFile` function, which saves you the trouble of allocating memory space and loading the file contents."
msgstr ""
"Powyższy kod najpierw inicjuje program interpretujący polecenia języka "
"pytonowskiego za pomocą zadania :cfunc:`Py_Initialize` po którym następuje "
"wykonanie skryptu zakodowanego na sztywno który wypisuje datę i czas. Po "
"wszystkim, odwołanie :cfunc:`Py_Finalize` zamyka program interpretujący "
"polecenia języka pytonowskiego, po którym następuje koniec programu. W "
"rzeczywistym programie, możesz chcieć pobrać skrypt języka pytonowskiego z "
"innego źródła, być może ze sposobu postępowania edytora-tekstu, pliku, lub "
"bazy danych. Pobranie kodu języka pytonowskiego z pliku może być lepiej "
"zrobione przez użycie zadania :cfunc:`PyRun_SimpleFile`, które ratuje cię "
"przed trudami lokowania przestrzeni w pamięci i ładowania zawartości pliku."

msgid "Beyond Very High Level Embedding: An overview"
msgstr "Poza bardzo wysokiego poziomu załączaniem: Przegląd"

msgid "The high level interface gives you the ability to execute arbitrary pieces of Python code from your application, but exchanging data values is quite cumbersome to say the least. If you want that, you should use lower level calls. At the cost of having to write more C code, you can achieve almost anything."
msgstr ""
"Sprzęg wysokiego poziomu daje ci możliwość wykonania zadanych kawałków kodu "
"języka pytonowskiego ze swojej aplikacji, ale wymiana wartości danych jest "
"całkiem kłopotliwa, prawdę powiedziawszy. Jeśli tego oczekujesz powinieneś "
"użyć niższego poziomu wywołań. Kosztem konieczności pisania większej ilości "
"kodu C, możesz osiągnąć prawie wszystko."

msgid "It should be noted that extending Python and embedding Python is quite the same activity, despite the different intent. Most topics discussed in the previous chapters are still valid. To show this, consider what the extension code from Python to C really does:"
msgstr ""
"Powinno się zauważyć, że rozszerzanie języka pytonowskiego i wstawianie "
"języka pytonowskiego jest prawie całkiem taką samą działalnością, z "
"wyjątkiem odmienności celów. Większość tematów rozważanych w poprzednich "
"rozdziałach jest wciąż poprawna. Aby to pokazać, rozważ co kod rozszerzający "
"z języka pytonowskiego do C robi naprawdę:"

msgid "Convert data values from Python to C,"
msgstr "Konwertuj wartości danych z języka pytonowskiego do C"

msgid "Perform a function call to a C routine using the converted values, and"
msgstr "Wykonaj odwołanie do zadania C używając zamienionych wartości, i"

msgid "Convert the data values from the call from C to Python."
msgstr "Zamień wartości danych z wywołania z C do języka pytonowskiego."

msgid "When embedding Python, the interface code does:"
msgstr "Gdy załączasz język pytonowski, kod sprzęgający wykonuje:"

msgid "Convert data values from C to Python,"
msgstr "Zamienia wartości danych z C do języka pytonowskiego,"

msgid "Perform a function call to a Python interface routine using the converted values, and"
msgstr ""
"Wykonaj wywołanie zadania do sprzęgu języka pytonowskiego używając "
"zamienionych wartości, i"

msgid "Convert the data values from the call from Python to C."
msgstr "Zamień wartości danych z odwołania z języka pytonowskiego do C."

msgid "As you can see, the data conversion steps are simply swapped to accommodate the different direction of the cross-language transfer. The only difference is the routine that you call between both data conversions. When extending, you call a C routine, when embedding, you call a Python routine."
msgstr ""
"Jak możesz się zorientować, kroki zamiany danych są po prostu zamienione aby "
"umożliwić odwrócenie kierunku między-językowego transferu. Jedyną różnicą "
"jest zadanie które wywoływane jest pomiędzy obiema zamianami danych. Gdy "
"rozszerzasz, wywołujesz zadanie C, gdy załączasz, wywołujesz zadanie języka "
"pytonowskiego."

msgid "This chapter will not discuss how to convert data from Python to C and vice versa.  Also, proper use of references and dealing with errors is assumed to be understood.  Since these aspects do not differ from extending the interpreter, you can refer to earlier chapters for the required information."
msgstr ""
"Ten rozdział nie będzie rozważał jak zamienić dane z języka pytonowskiego do "
"C i w przeciwnym kierunku. Także właściwe użycie odniesień i obsługa błędów "
"zakłada się że jest znajoma. Jako że te sprawy nie różnią się od "
"rozszerzania programu interpretującego polecenia języka pytonowskiego, "
"możesz odnieść się do wcześniejszych rozdziałów po wymagane informacje."

msgid "Pure Embedding"
msgstr "Czyste załączanie"

msgid "The first program aims to execute a function in a Python script. Like in the section about the very high level interface, the Python interpreter does not directly interact with the application (but that will change in the next section)."
msgstr ""
"Pierwszy program ma na celu wykonanie zadania w skrypcie języka "
"pytonowskiego. Jak w rozdziale o sprzęgu bardzo wysokiego poziomu, program "
"interpretujący polecenia języka pytonowskiego bezpośrednio nie oddziałuje z "
"aplikacją (ale to się zmieni w następnym rozdziale)."

msgid "The code to run a function defined in a Python script is:"
msgstr ""
"Kod służący uruchomieniu zadania określonego w skrypcie języka pytonowskiego "
"to:"

msgid "#include <Python.h>  int main(int argc, char *argv[]) {     PyObject *pName, *pModule, *pDict, *pFunc;     PyObject *pArgs, *pValue;     int i;      if (argc < 3) {         fprintf(stderr,\"Usage: call pythonfile funcname [args]\\n\");         return 1;     }      Py_Initialize();     pName = PyUnicode_FromString(argv[1]);     /* Error checking of pName left out */      pModule = PyImport_Import(pName);     Py_DECREF(pName);      if (pModule != NULL) {         pFunc = PyObject_GetAttrString(pModule, argv[2]);         /* pFunc is a new reference */          if (pFunc && PyCallable_Check(pFunc)) {             pArgs = PyTuple_New(argc - 3);             for (i = 0; i < argc - 3; ++i) {                 pValue = PyLong_FromLong(atoi(argv[i + 3]));                 if (!pValue) {                     Py_DECREF(pArgs);                     Py_DECREF(pModule);                     fprintf(stderr, \"Cannot convert argument\\n\");                     return 1;                 }                 /* pValue reference stolen here: */                 PyTuple_SetItem(pArgs, i, pValue);             }             pValue = PyObject_CallObject(pFunc, pArgs);             Py_DECREF(pArgs);             if (pValue != NULL) {                 printf(\"Result of call: %ld\\n\", PyLong_AsLong(pValue));                 Py_DECREF(pValue);             }             else {                 Py_DECREF(pFunc);                 Py_DECREF(pModule);                 PyErr_Print();                 fprintf(stderr,\"Call failed\\n\");                 return 1;             }         }         else {             if (PyErr_Occurred())                 PyErr_Print();             fprintf(stderr, \"Cannot find function \\\"%s\\\"\\n\", argv[2]);         }         Py_XDECREF(pFunc);         Py_DECREF(pModule);     }     else {         PyErr_Print();         fprintf(stderr, \"Failed to load \\\"%s\\\"\\n\", argv[1]);         return 1;     }     Py_Finalize();     return 0; }"
msgstr ""
"#include <Python.h>  int main(int argc, char *argv[]) {     PyObject *pName, "
"*pModule, *pDict, *pFunc;     PyObject *pArgs, *pValue;     int i;      if "
"(argc < 3) {         fprintf(stderr,\"Użycie: wywołaj plikpytona nazwazadania "
"[parametry]\\n\");         return 1;     }      Py_Initialize();     pNazwa = "
"PyUnicode_FromString(argv[1]);     /* Sprawdzanie błędu pNazwy pomienięte "
"*/      pModule = PyImport_Import(pNazwa);     Py_DECREF(pNazwa);      if "
"(pModule != NULL) {         pFunc = PyObject_GetAttrString(pModule, "
"argv[2]);         /* pFunc jest nowym odniesieniem */          if (pFunc && "
"PyCallable_Check(pFunc)) {             pArgs = PyTuple_New(argc - 3); "
"            for (i = 0; i < argc - 3; ++i) {                 pValue = "
"PyLong_FromLong(atoi(argv[i + 3]));                 if (!pValue) { "
"                    Py_DECREF(pArgs);                     "
"Py_DECREF(pModule);                     fprintf(stderr, \"Nie mogę zamienić "
"parametrów\\n\");                     return 1;                 } "
"                /* odniesienie do pValue kradzione tutaj: */ "
"                PyTuple_SetItem(pArgs, i, pValue);             } "
"            pValue = PyObject_CallObject(pFunc, pArgs);             "
"Py_DECREF(pArgs);             if (pValue != NULL) {                 "
"printf(\"Wynik wywołania: %ld\\n\", PyLong_AsLong(pValue));                 "
"Py_DECREF(pValue);             }             else {                 "
"Py_DECREF(pFunc);                 Py_DECREF(pModule);                 "
"PyErr_Print();                 fprintf(stderr,\"Wywołanie zawiodło\\n\"); "
"                return 1;             }         }         else { "
"            if (PyErr_Occurred())                 PyErr_Print(); "
"            fprintf(stderr, \"Nie mogę znaleźć zadania \\\"%s\\\"\\n\", argv[2]); "
"        }         Py_XDECREF(pFunc);         Py_DECREF(pModule);     }     "
"else {         PyErr_Print();         fprintf(stderr, \"Nieudane ładowanie \\\""
"%s\\\"\\n\", argv[1]);         return 1;     }     Py_Finalize();     return 0; "
"}"

msgid "This code loads a Python script using ``argv[1]``, and calls the function named in ``argv[2]``.  Its integer arguments are the other values of the ``argv`` array.  If you compile and link this program (let's call the finished executable :program:`call`), and use it to execute a Python script, such as::"
msgstr ""
"Ten kod ładuje skrypt języka pytonowskiego używając ``argv[1]``, i wywołuje "
"zadanie nazwane w ``argv[2]``. Jego całkowitymi parametrami są inne wartości "
"tablicy ``argv``. Jeśli skompilujesz i podłączysz ten program (nazwijmy "
"skończony plik wykonywalny :program:`wywołaniem` - z ang. - :program:`call`) "
"i użyjemy go do wywołania skryptu języka pytonowskiego, takiego jak::"

msgid "def multiply(a,b):     print(\"Will compute\", a, \"times\", b)     c = 0     for i in range(0, a):         c = c + b     return c"
msgstr ""
"def mnozenie(a,b):     print(\"Policzy\", a, \"razy\", b)     c = 0     for i in "
"range(0, a):         c = c + b     return c"

msgid "then the result should be::"
msgstr "Wtedy wynik powinien być::"

msgid "$ call multiply multiply 3 2 Will compute 3 times 2 Result of call: 6"
msgstr "$ wywolanie mnozenie mnozenie 3 2 Policzy 3 razy 2 Wynik wywołania: 6"

msgid "Although the program is quite large for its functionality, most of the code is for data conversion between Python and C, and for error reporting.  The interesting part with respect to embedding Python starts with ::"
msgstr ""
"Chociaż program jest całkiem spory jak na jego skromne działanie, większość "
"kodu jest dla zamiany danych pomiędzy językiem pytonowskim i C, i dla "
"zgłaszania błędów. Interesująca część z punktu widzenia załączania języka "
"pytonowskiego zaczyna się od::"

msgid "Py_Initialize(); pName = PyString_FromString(argv[1]); /* Error checking of pName left out */ pModule = PyImport_Import(pName);"
msgstr ""
"Py_Initialize(); pNazwa = PyString_FromString(argv[1]); /* Sprawdzanie "
"błędów pNazwa pominięte */ pModule = PyImport_Import(pNazwa);"

msgid "After initializing the interpreter, the script is loaded using :cfunc:`PyImport_Import`.  This routine needs a Python string as its argument, which is constructed using the :cfunc:`PyString_FromString` data conversion routine. ::"
msgstr ""
"Po zainicjowaniu interpretera, skrypt jest ładowany używając "
":cfunc:`PyImport_Import`. To zadanie wymaga ciągu znaków języka  "
"pytonowskiego jako jego parametru, które są tworzone używając "
":cfunc:`PyString_FromString` zadania zamiany  danych. ::"

msgid "pFunc = PyObject_GetAttrString(pModule, argv[2]); /* pFunc is a new reference */  if (pFunc && PyCallable_Check(pFunc)) {     ... } Py_XDECREF(pFunc);"
msgstr ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]); /* pFunc jest nowym "
"odniesieniem */  if (pFunc && PyCallable_Check(pFunc)) {     ... } "
"Py_XDECREF(pFunc);"

msgid "Once the script is loaded, the name we're looking for is retrieved using :cfunc:`PyObject_GetAttrString`.  If the name exists, and the object returned is callable, you can safely assume that it is a function.  The program then proceeds by constructing a tuple of arguments as normal.  The call to the Python function is then made with::"
msgstr ""
"Gdy skrypt jest załadowany, nazwa na którą patrzymy jest pobierana używając "
":cfunc:`PyObject_GetAttrString`. Jeśli nazwa istnieje, i przedmiot zwracany "
"jest wywoływalny, można bezpiecznie założyć że jest on zadaniem. Program "
"potem postępuje naprzód tworząc dwójkę parametrów w zwyczajny sposób. "
"Wywołanie zadania języka pytonowskiego jest potem wykonywane za pomocą::"

msgid "pValue = PyObject_CallObject(pFunc, pArgs);"
msgstr "pValue = PyObject_CallObject(pFunc, pArgs);"

msgid "Upon return of the function, ``pValue`` is either *NULL* or it contains a reference to the return value of the function.  Be sure to release the reference after examining the value."
msgstr ""
"Na powrót z zadania, ``pValue`` jest albo *pusta* - z ang. - *NULL* albo "
"zawiera odniesienia do wartości zwracanej z zadania. Upewnij się że "
"uwalniasz odniesienie po przetestowaniu wartości."

msgid "Extending Embedded Python"
msgstr "Rozszerzanie załączonego języka pytonowskiego"

msgid "Until now, the embedded Python interpreter had no access to functionality from the application itself.  The Python API allows this by extending the embedded interpreter.  That is, the embedded interpreter gets extended with routines provided by the application. While it sounds complex, it is not so bad.  Simply forget for a while that the application starts the Python interpreter.  Instead, consider the application to be a set of subroutines, and write some glue code that gives Python access to those routines, just like you would write a normal Python extension.  For example::"
msgstr ""
"Jak dotąd, załączony program interpretujący polecenia języka pytonowskiego "
"nie miał dostępu do zadań samej aplikacji. Sprzęg języka pytonowskiego "
"pozwala na to przez rozszerzanie załączonego programu interpretującego "
"polecenia języka pytonowskiego. To jest, załączony program interpretujący "
"polecenia języka pytonowskiego poszerza się przez zadania dostarczone przez "
"aplikację. Podczas gdy brzmi to skomplikowanie, nie jest to takie straszne. "
"Po prostu zapomnij na chwilę, że aplikacja uruchamia program interpretujący "
"polecenia języka pytonowskiego. Zamiast tego, rozważ, że aplikacja jest "
"zbiorem podzadań i napisz trochę kodu lepiącego który daje dostęp do tych "
"zadań, tak jakbyś pisał zwykłe rozszerzenia. Dla przykładu::"

msgid "static int numargs=0;  /* Return the number of arguments of the application command line */ static PyObject* emb_numargs(PyObject *self, PyObject *args) {     if(!PyArg_ParseTuple(args, \":numargs\"))         return NULL;     return Py_BuildValue(\"i\", numargs); }  static PyMethodDef EmbMethods[] = {     {\"numargs\", emb_numargs, METH_VARARGS,      \"Return the number of arguments received by the process.\"},     {NULL, NULL, 0, NULL} };  static PyModuleDef EmbModule = {     PyModuleDef_HEAD_INIT, \"emb\", NULL, -1, EmbMethods,     NULL, NULL, NULL, NULL };  static PyObject* PyInit_emb(void) {     return PyModule_Create(&EmbModule); }"
msgstr ""
"static int numargs=0;  /* Zwróć liczbę parametrów wiersza poleceń aplikacji "
"*/ static PyObject* emb_numargs(PyObject *self, PyObject *args) {     "
"if(!PyArg_ParseTuple(args, \":numargs\"))         return NULL;     return "
"Py_BuildValue(\"i\", numargs); }  static PyMethodDef EmbMethods[] = {     "
"{\"numargs\", emb_numargs, METH_VARARGS,      \"Zwróć liczbę parametrów "
"otrzymaną przez proces.\"},     {NULL, NULL, 0, NULL} };  static PyModuleDef "
"EmbModule = {     PyModuleDef_HEAD_INIT, \"emb\", NULL, -1, EmbMethods,     "
"NULL, NULL, NULL, NULL };  static PyObject* PyInit_emb(void) {     return "
"PyModule_Create(&EmbModule); }"

msgid "Insert the above code just above the :cfunc:`main` function. Also, insert the following two statements before the call to :cfunc:`Py_Initialize`::"
msgstr ""
"Wstaw powyższy kod tuż powyżej zadania :cfunc:`main`. Także, wstaw "
"następujące dwa wyrażenia przed odwołaniem do :cfunc:`Py_Initialize`::"

msgid "numargs = argc; PyImport_AppendInittab(\"emb\", &PyInit_emb);"
msgstr "numargs = argc; PyImport_AppendInittab(\"emb\", &PyInit_emb);"

msgid "These two lines initialize the ``numargs`` variable, and make the :func:`emb.numargs` function accessible to the embedded Python interpreter. With these extensions, the Python script can do things like ::"
msgstr ""
"Te dwie linie inicjują zmienną ``numargs``, i czynią zadanie "
":func:`emb.numargs` dostępnym dla załączonego programu interpretującego "
"polecenia języka pytonowskiego. Z tymi rozszerzeniami, skrypt języka "
"pytonowskiego może zrobić rzeczy takie jak::"

msgid "import emb print(\"Number of arguments\", emb.numargs())"
msgstr "import emb print(\"Liczba parametrów\", emb.numargs())"

msgid "In a real application, the methods will expose an API of the application to Python."
msgstr ""
"W realnej aplikacji, sposoby postępowania wystawią sprzęg aplikacji dla "
"języka pytonowskiego."

msgid "Embedding Python in C++"
msgstr "Załączanie języka pytonowskiego w języku C++."

msgid "It is also possible to embed Python in a C++ program; precisely how this is done will depend on the details of the C++ system used; in general you will need to write the main program in C++, and use the C++ compiler to compile and link your program.  There is no need to recompile Python itself using C++."
msgstr ""
"Jest także możliwe załączanie języka pytonowskiego w programie C++; "
"dokładnie jak to jest robione zależy od szczegółów systemu C++ będącego w "
"użyciu; Co do zasady, będziesz musiał napisać program główny w C++, i użyć "
"kompilatora C++ aby skompilować i podłączyć twój program. Nie ma "
"konieczności ponownej kompilacji języka pytonowskiego samego w sobie przy "
"użyciu języka C++. "

msgid "Linking Requirements"
msgstr "Wymagania dołączania"

msgid "While the :program:`configure` script shipped with the Python sources will correctly build Python to export the symbols needed by dynamically linked extensions, this is not automatically inherited by applications which embed the Python library statically, at least on Unix.  This is an issue when the application is linked to the static runtime library (:file:`libpython.a`) and needs to load dynamic extensions (implemented as :file:`.so` files)."
msgstr ""
"Podczas gdy skrypt :program:`configure` dostarczony ze źródłowym kodem "
"języka pytonowskiego będzie poprawnie budował język pytonowski aby wystawiał "
"na zewnątrz symbole potrzebne dla dynamicznie dołączanych rozszerzeń, to "
"nie jest automatycznie dziedziczone przez aplikacje które załączają "
"bibliotekę języka pytonowskiego statycznie, przynajmniej w Unix-ie. To jest "
"problemem gdy aplikacja jest dołączana do statycznej biblioteki czasu "
"wykonania (:file:`libpython.a`) i potrzebuje załadować dynamiczne "
"rozszerzenia (wypełnione jako pliki :file:`.so`)."

msgid "The problem is that some entry points are defined by the Python runtime solely for extension modules to use.  If the embedding application does not use any of these entry points, some linkers will not include those entries in the symbol table of the finished executable.  Some additional options are needed to inform the linker not to remove these symbols."
msgstr ""
"Problem polega na tym, że niektóre punkty wejścia są definiowane przez "
"program języka pytonowskiego w czasie jego wykonania jedynie dla "
"rozszerzających modułów dla użycia. Jeśli załączająca aplikacja nie używa "
"żadnych z tych punktów wejścia, niektóre programy dołączające nie dołączą "
"tych wpisów w tabeli symboli ukończonego pliku programu. Niektóre dodatkowe "
"opcje są wymagane aby poinformować program łączący aby nie usuwać tych "
"symboli."

msgid "Determining the right options to use for any given platform can be quite difficult, but fortunately the Python configuration already has those values. To retrieve them from an installed Python interpreter, start an interactive interpreter and have a short session like this::"
msgstr ""
"Określenie właściwych opcji do użycia dla każdej danej maszyny/środowiska "
"może być raczej trudne, ale na szczęście konfiguracja języka pytonowskiego "
"od razu ma te wartości. Aby otrzymać je z zainstalowanego programu "
"interpretującego polecenia języka pytonowskiego, uruchom współdziałający z "
"użytkownikiem program interpretujący polecenia języka pytonowskiego i weź "
"krótką sesję taką jak ta::"

msgid ">>> import distutils.sysconfig >>> distutils.sysconfig.get_config_var('LINKFORSHARED') '-Xlinker -export-dynamic'"
msgstr ""
">>> import distutils.sysconfig >>> "
"distutils.sysconfig.get_config_var('LINKFORSHARED') '-Xlinker -export-"
"dynamic'"

msgid "The contents of the string presented will be the options that should be used. If the string is empty, there's no need to add any additional options.  The :const:`LINKFORSHARED` definition corresponds to the variable of the same name in Python's top-level :file:`Makefile`."
msgstr ""
"Zawartość ciągu znaków prezentowanego będzie opcjami które powinny być "
"użyte. Jeśli ciąg znaków jest pusty, nie ma potrzeby dodawać żadnych "
"dodatkowych opcji. Definicja :const:`LINKFORSHARED` odpowiada zmiennej o tej "
"samej nazwie w nadrzędnym pliku :file:`Makefile` języka pytonowskiego."

msgid "Extending Python with C or C++"
msgstr "Rozszerzanie języka pytonowskiego za pomocą C lub C++"

msgid "It is quite easy to add new built-in modules to Python, if you know how to program in C.  Such :dfn:`extension modules` can do two things that can't be done directly in Python: they can implement new built-in object types, and they can call C library functions and system calls."
msgstr ""
"Jest całkiem łatwo dodać nowe wbudowane moduły do języka pytonowskiego, "
"jeśli znasz się na programowaniu w C. Takie :dfn:`moduły rozszerzające` - z "
"ang. - :dfn:`extension modules` mogą zrobić dwie rzeczy których nie da się "
"zrobić bezpośrednio w języku pytonowskim: mogą wypełnić nowe wbudowane typy "
"przedmiotów i mogą odwołać się do zadań bibliotecznych C i odwołań "
"systemowych."

msgid "To support extensions, the Python API (Application Programmers Interface) defines a set of functions, macros and variables that provide access to most aspects of the Python run-time system.  The Python API is incorporated in a C source file by including the header ``\"Python.h\"``."
msgstr ""
"Aby wspierać rozszerzenia, sprzęg programowania języka pytonowskiego API - z "
"ang. (Application Programmers Interface) określa zbiór zadań, makropoleceń "
"i zmiennych które dostarczają dostęp do większości aspektów systemu czasu-"
"wykonania języka pytonowskiego. Sprzęg programowania języka pytonowskiego "
"jest załączany w źródłowym pliku C przez załączenie pliku nagłówkowego "
"``\"Python.h\"``."

msgid "The compilation of an extension module depends on its intended use as well as on your system setup; details are given in later chapters."
msgstr ""
"Kompilacja rozszerzających modułów zależy od jego zamierzonego użycia "
"zarówno jak też od ustawień twojego systemu; szczegóły są dane w "
"późniejszych rozdziałach."

msgid "Do note that if your use case is calling C library functions or system calls, you should consider using the :mod:`ctypes` module rather than writing custom C code. Not only does :mod:`ctypes` let you write Python code to interface with C code, but it is more portable between implementations of Python than writing and compiling an extension module which typically ties you to CPython."
msgstr ""
"Zauważ, że jeśli twoim przypadkiem użycia jest wezwanie zadania z biblioteki "
"lub wywołanie systemowe, powinieneś/powinnaś rozważyć użycie modułu "
":mod:`ctypes` raczej zamiast pisać dostosowawczy kod C. Moduł :mod:`ctypes` "
"pozwala nie tylko pisać kod w języku pytonowskim do sprzęgania się z kodem "
"C, ale także jest bardziej przenośny pomiędzy wypełnieniami języka "
"pytonowskiego niż pisanie i kompilowanie modułów rozszerzeń które typowo "
"łączą cię z CPythonem."

msgid "A Simple Example"
msgstr "Prosty przykład"

msgid "Let's create an extension module called ``spam`` (the favorite food of Monty Python fans...) and let's say we want to create a Python interface to the C library function :cfunc:`system`. [#]_ This function takes a null-terminated character string as argument and returns an integer.  We want this function to be callable from Python as follows::"
msgstr ""
"Stwórzmy rozszerzający moduł nazwany ``spam`` (ulubione danie fanów Monty "
"Pytona...) i powiedzmy że chcemy stworzyć sprzęg języka pytonowskiego z "
"bibliotecznym zadaniem C :cfunc:`system`. [#]_ To zadanie pobiera zakończony "
"zerem ciąg znaków jako parametr i zwraca liczbę całkowitą. Chcemy aby to "
"zadanie było wywoływane z poziomu języka pytonowskiego, w następujący "
"sposób::"

msgid ">>> import spam >>> status = spam.system(\"ls -l\")"
msgstr ">>> import spam >>> status = spam.system(\"ls -l\")"

msgid "Begin by creating a file :file:`spammodule.c`.  (Historically, if a module is called ``spam``, the C file containing its implementation is called :file:`spammodule.c`; if the module name is very long, like ``spammify``, the module name can be just :file:`spammify.c`.)"
msgstr ""
"Zaczynając od stworzenia pliku :file:`spammodule.c` (Historycznie, jeśli "
"moduł był nazwany ``spam``, plik C zawierający jego wypełnienie jest "
"nazywany :file:`spammodule.c`; jeśli nazwa modułu jest bardzo długa, jak np "
"``spammify``, nazwa modułu może być po prostu :file:`spammify.c`.)"

msgid "The first line of our file can be::"
msgstr "Pierwsza linia naszego pliku mogłaby być::"

msgid "#include <Python.h>"
msgstr "#include <Python.h>"

msgid "which pulls in the Python API (you can add a comment describing the purpose of the module and a copyright notice if you like)."
msgstr ""
"Które pociąga sprzęg programowania języka pytonowskiego (możesz dodać "
"komentarz opisujący powód modułu i uwagi praw autorskich jeśli wolisz)."

msgid "Since Python may define some pre-processor definitions which affect the standard headers on some systems, you *must* include :file:`Python.h` before any standard headers are included."
msgstr ""
"Odkąd język pytonowski może definiować pewne definicje preprocesora które "
"wpływają na standardowe nagłówki na niektórych maszynach/środowiskach, "
"*musisz* zawrzeć plik :file:`Python.h` przed załączeniem jakichkolwiek "
"standardowych plików nagłówkowych."

msgid "All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py`` or ``PY``, except those defined in standard header files. For convenience, and since they are used extensively by the Python interpreter, ``\"Python.h\"`` includes a few standard header files: ``<stdio.h>``, ``<string.h>``, ``<errno.h>``, and ``<stdlib.h>``.  If the latter header file does not exist on your system, it declares the functions :cfunc:`malloc`, :cfunc:`free` and :cfunc:`realloc` directly."
msgstr ""
"Wszystkie widoczne-dla-użytkownika symbole zdefiniowane przez "
":file:`Python.h` mają przedrostek ``Py`` lub ``PY``, z wyjątkiem tych  "
"zdefiniowanych w standardowym pliku nagłówkowym. Dla wygody, i ponieważ są "
"one użyte szeroko przez program interpretujący polecenia języka "
"pytonowskiego, ``\"Python.h\"`` zawiera kilka standardowych plików "
"nagłówkowych: ``<stdio.h>``, ``<string.h>``, ``<errno.h>``, i "
"``<stdlib.h>``. Jeśli ostatni plik nagłówkowy nie istnieje na twojej "
"maszynie/środowisku deklaruje zadania :cfunc:`malloc`, :cfunc:`free` i "
":cfunc:`realloc` bezpośrednio."

msgid "The next thing we add to our module file is the C function that will be called when the Python expression ``spam.system(string)`` is evaluated (we'll see shortly how it ends up being called)::"
msgstr ""
"Następną rzeczą którą dodajemy do naszego pliku modułu jest zadanie C które "
"będzie wzywane gdy wyrażenie języka pytonowskiego ``spam.system(string)`` "
"zostanie obliczone (zobaczymy niedługo, jak to się kończy wywołaniem)::"

msgid "static PyObject * spam_system(PyObject *self, PyObject *args) {     const char *command;     int sts;      if (!PyArg_ParseTuple(args, \"s\", &command))         return NULL;     sts = system(command);     return Py_BuildValue(\"i\", sts); }"
msgstr ""
"static PyObject * spam_system(PyObject *self, PyObject *args) {     const "
"char *command;     int sts;      if (!PyArg_ParseTuple(args, \"s\", &command)) "
"        return NULL;     sts = system(command);     return "
"Py_BuildValue(\"i\", sts); }"

msgid "There is a straightforward translation from the argument list in Python (for example, the single expression ``\"ls -l\"``) to the arguments passed to the C function.  The C function always has two arguments, conventionally named *self* and *args*."
msgstr ""
"Istnieje prosta zamiana nazw z listy parametrów w języku pytonowskim (dla "
"przykładu, pojedyncze wyrażenie ``\"ls -l\"``) do parametrów przekazanych do "
"zadania C. Zadanie C zawsze ma dwa parametry, dla wygody nazywane *sam* - z "
"ang. - *self* i *args*."

msgid "The *self* argument points to the module object for module-level functions; for a method it would point to the object instance."
msgstr ""
"Parametr *sam* - z ang. - *self* - wskazuje na przedmiot modułu dla zadań na "
"poziomie-modułu; dla sposobu postępowania wskazywałby na przykład "
"przedmiotu."

msgid "The *args* argument will be a pointer to a Python tuple object containing the arguments.  Each item of the tuple corresponds to an argument in the call's argument list.  The arguments are Python objects --- in order to do anything with them in our C function we have to convert them to C values.  The function :cfunc:`PyArg_ParseTuple` in the Python API checks the argument types and converts them to C values.  It uses a template string to determine the required types of the arguments as well as the types of the C variables into which to store the converted values.  More about this later."
msgstr ""
"Parametr *args* będzie wskaźnikiem do przedmiotu dwójki języka Pytonowskiego "
"zawierających parametry. Każdy element dwójki odpowiada parametrowi na "
"liście parametrów wywołania. Parametrami są przedmioty języka pytonowskiego "
"--- w celu aby zrobić cokolwiek z nimi w naszym zadaniu C musimy zamienić je "
"na wartości C. Zadanie :cfunc:`PyArg_ParseTuple` w sprzęgu języka "
"pytonowskiego sprawdza typy parametrów i zamienia je na wartości C. używa "
"ciągu znaków wzorcowego aby określić wymagane typy parametrów zarówno jak "
"też typy zmiennych C do których zapamiętuje zamienione wartości. Więcej o "
"tym później."

msgid ":cfunc:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the right type and its components have been stored in the variables whose addresses are passed.  It returns false (zero) if an invalid argument list was passed.  In the latter case it also raises an appropriate exception so the calling function can return *NULL* immediately (as we saw in the example)."
msgstr ""
":cfunc:`PyArg_ParseTuple` zwraca prawdę (nie-zero) jeśli wszystkie parametry "
"mają prawidłowy typ i ich komponenty zostały zapamiętane w zmiennych "
"których adresy są przekazywane. Zwraca fałsz (zero) jeśli nieprawidłowy "
"parametr był przekazany. W przypadku drugim podnosi też odpowiedni wyjątek "
"tak, że wywołanie zadania może zwrócić *NULL* natychmiast (jak widzieliśmy w "
"przykładzie)."

msgid "Intermezzo: Errors and Exceptions"
msgstr "Intermezzo: Błędy i Wyjątki"

msgid "An important convention throughout the Python interpreter is the following: when a function fails, it should set an exception condition and return an error value (usually a *NULL* pointer).  Exceptions are stored in a static global variable inside the interpreter; if this variable is *NULL* no exception has occurred.  A second global variable stores the \"associated value\" of the exception (the second argument to :keyword:`raise`).  A third variable contains the stack traceback in case the error originated in Python code.  These three variables are the C equivalents of the result in Python of :meth:`sys.exc_info` (see the section on module :mod:`sys` in the Python Library Reference).  It is important to know about them to understand how errors are passed around."
msgstr ""
"Istotną konwencją w programie interpretującym polecenia języka pytonowskiego "
"jest następująca: gdy zadanie zawiedzie, powinno ustawić warunek wyjątku i "
"zwrócić wartość błędu (zwykle pusty wskaźnik - z ang. - *NULL* ) Wyjątki są "
"przechowywane w statycznej nadrzędnej zmiennej wewnątrz programu "
"interpretującego polecenia języka pytonowskiego; jeśli ta zmienna jest "
"*NULL* żaden wyjątek nie nastąpił. Druga nadrzędna zmienna przechowuje "
"\"związaną wartość\" wyjątku (drugi parametr słowa kluczowego :keyword:`raise` "
"- z ang. zgłoś). Trzecia zmienna zawiera wypis śladu ze sterty w razie "
"gdyby błąd wypływał z kodu w języku pytonowskim. Te trzy zmienne są "
"równoważnikami C wyniku w języku pytonowskim sposobu postępowania "
":meth:`sys.exc_info` (zobacz sekcję o module :mod:`sys` w podręczniku "
"biblioteki języka pytonowskiego). Istotne jest wiedzieć o nich aby rozumieć "
"jak błędy są przekazywane."

msgid "The Python API defines a number of functions to set various types of exceptions."
msgstr ""
"Sprzęg języka pytonowskiego określa pewien zestaw zadań do ustawiania "
"różnych rodzajów  wyjątków."

msgid "The most common one is :cfunc:`PyErr_SetString`.  Its arguments are an exception object and a C string.  The exception object is usually a predefined object like :cdata:`PyExc_ZeroDivisionError`.  The C string indicates the cause of the error and is converted to a Python string object and stored as the \"associated value\" of the exception."
msgstr ""
"Najbardziej rozpowszechniony to :cfunc:`PyErr_SetString`. Jego parametry to "
"przedmiot wyjątku i ciąg znaków z języka C. Przedmiot wyjątku jest zwykle "
"predefiniowanym przedmiotem jak :cdata:`PyExc_ZeroDivisionError`. Ciąg znków "
"C wskazuje na powód błędu i jest zamieniany na przedmiot ciągu znaków "
"języka pytonowskiego i zachowywany jako \"wartość związana\" tego wyjątku."

msgid "Another useful function is :cfunc:`PyErr_SetFromErrno`, which only takes an exception argument and constructs the associated value by inspection of the global variable :cdata:`errno`.  The most general function is :cfunc:`PyErr_SetObject`, which takes two object arguments, the exception and its associated value.  You don't need to :cfunc:`Py_INCREF` the objects passed to any of these functions."
msgstr ""
"Innym użytecznym zadaniem jest :cfunc:`PyErr_SetFromErrno`, który pobiera "
"tylko parametr wyjątku i konstruuje związaną wartość przez podejrzenie "
"zmiennej nadrzędnej :cdata:`errno`. Najogólniejszym zadaniem jest "
":cfunc:`PyErr_SetObject` które pobiera dwa parametry przedmiotowe, wyjątek i "
"związaną wartość. Nie potrzebują one zwiększać ilości odniesień "
":cfunc:`Py_INCREF` przedmiotów przekazanych do którychkolwiek z tych zadań."

msgid "You can test non-destructively whether an exception has been set with :cfunc:`PyErr_Occurred`.  This returns the current exception object, or *NULL* if no exception has occurred.  You normally don't need to call :cfunc:`PyErr_Occurred` to see whether an error occurred in a function call, since you should be able to tell from the return value."
msgstr ""
"Możesz sprawdzić nie-destrukcyjnie czy wyjątek został ustawiony za pomocą "
"zadania :cfunc:`PyErr_Occured`. To zwraca przedmiot obecnego wyjątku, lub "
"*NULL* jeśli żaden wyjątek nie nastąpił. Zwykle nie musisz wywoływać zadania "
":cfunc:`PyErr_Occurred` aby zobaczyć czy błąd nastąpił w wywołaniu zadania, "
"ponieważ powinno się być w stanie określić na podstawie zwracanej wartości."

msgid "When a function *f* that calls another function *g* detects that the latter fails, *f* should itself return an error value (usually *NULL* or ``-1``).  It should *not* call one of the :cfunc:`PyErr_\\*` functions --- one has already been called by *g*. *f*'s caller is then supposed to also return an error indication to *its* caller, again *without* calling :cfunc:`PyErr_\\*`, and so on --- the most detailed cause of the error was already reported by the function that first detected it.  Once the error reaches the Python interpreter's main loop, this aborts the currently executing Python code and tries to find an exception handler specified by the Python programmer."
msgstr ""
"Gdy zadanie *f* które wywołuje inne zadanie *g* wykryje że to drugie "
"zawiedzie, *f* powinno samo zwrócić wartość błędu (zwykle *NULL* lub "
"``-1``). *Nie* powinno wywoływać jednego z zadań :cfunc:`PyErr_\\*` --- gdyż "
"jedno już zostało wywołane przez *g*. Wywołujący zadanie *f* jest potem "
"zobowiązany także zwrócić wskazanie błędu temu kto *je* wywołał, znów *bez* "
"wywoływania zadania :cfunc:`PyErr_\\*` itd --- najbardziej szczegółowy powód "
"błędu został już zaraportowany przez zadanie, które pierwsze wykryło go. Gdy "
"błąd dotrze do pętli głównej programu interpretującego polecenia języka "
"pytonowskiego, to przerywa obecne wykonanie kodu języka pytonowskiego i "
"próbuje znaleźć obsługę błędu określoną przez programistę języka "
"pytonowskiego."

msgid "(There are situations where a module can actually give a more detailed error message by calling another :cfunc:`PyErr_\\*` function, and in such cases it is fine to do so.  As a general rule, however, this is not necessary, and can cause information about the cause of the error to be lost: most operations can fail for a variety of reasons.)"
msgstr ""
"(Istnieją sytuacje gdy moduł może właściwie dawać bardziej szczegółową "
"wiadomość o błędzie przez wywołanie kolejnego zadania :cfunc:`PyErr_\\*` i w "
"takich przypadkach nie sprawia to kłopotu. Jako naczelna zasada, jednakże, "
"nie jest to konieczne, i może powodować utratę informacji o powodzie błędu: "
"większość operacji może zawieźć z różnych powodów.)"

msgid "To ignore an exception set by a function call that failed, the exception condition must be cleared explicitly by calling :cfunc:`PyErr_Clear`.  The only time C code should call :cfunc:`PyErr_Clear` is if it doesn't want to pass the error on to the interpreter but wants to handle it completely by itself (possibly by trying something else, or pretending nothing went wrong)."
msgstr ""
"Aby zignorować wyjątek ustanowiony przez wywołanie zadania które zawiodło, "
"warunek wyjątku musi być wyczyszczony jawnie przez wywołanie "
":cfunc:`PyErr_Clear`. Jedynym momentem gdy kod C powinien wzywać "
":cfunc:`PyErr_Clear` jest jeśli nie chce przekazać błędu dla programu "
"interpretującego polecenia języka pytonowskiego ale chce obsłużyć je "
"całkowicie samodzielnie (możliwie przez próbowanie czegoś innego, lub "
"udawanie że nic się nie stało)."

msgid "Every failing :cfunc:`malloc` call must be turned into an exception --- the direct caller of :cfunc:`malloc` (or :cfunc:`realloc`) must call :cfunc:`PyErr_NoMemory` and return a failure indicator itself.  All the object-creating functions (for example, :cfunc:`PyLong_FromLong`) already do this, so this note is only relevant to those who call :cfunc:`malloc` directly."
msgstr ""
"Każde zawodzące odwołanie :cfunc:`malloc` musi być zamienione na sytuację "
"wyjątkową --- bezpośrednio wołający :cfunc:`malloc` (lub :cfunc:`realloc`) "
"musi wywołać :cfunc:`PyErr_NoMemory` i zwrócić wskazanie o błędzie samo w "
"sobie. Wszystkie zadania tworzące-przedmioty (dla przykładu. "
":cfunc:`PyLong_FromLong`) już to robią więc ta notatka jest ważna tylko dla "
"tych którzy wzywają :cfunc:`malloc` bezpośrednio."

msgid "Also note that, with the important exception of :cfunc:`PyArg_ParseTuple` and friends, functions that return an integer status usually return a positive value or zero for success and ``-1`` for failure, like Unix system calls."
msgstr ""
"Zauważ także, że z istotnym wyjątkiem zadania :cfunc:`PyArg_ParseTuple` i "
"przyjaciół, zadania które zwracają status liczbą całkowitą zwykle zwracają "
"dodatnią wartość lub zero dla powodzenia i ``-1`` dla niepowodzenia, tak jak "
"odwołania systemowe Unix-a."

msgid "Finally, be careful to clean up garbage (by making :cfunc:`Py_XDECREF` or :cfunc:`Py_DECREF` calls for objects you have already created) when you return an error indicator!"
msgstr ""
"W końcu bądź ostrożny przy czyszczeniu śmieci (przez wywołania zadań "
":cfunc:`PyXDECREF` lub :cfunc:`Py_DECREF` dla przedmiotów które już "
"utworzyłeś) gdy zwracasz wskaźnik błędu!"

msgid "The choice of which exception to raise is entirely yours.  There are predeclared C objects corresponding to all built-in Python exceptions, such as :cdata:`PyExc_ZeroDivisionError`, which you can use directly. Of course, you should choose exceptions wisely --- don't use :cdata:`PyExc_TypeError` to mean that a file couldn't be opened (that should probably be :cdata:`PyExc_IOError`). If something's wrong with the argument list, the :cfunc:`PyArg_ParseTuple` function usually raises :cdata:`PyExc_TypeError`.  If you have an argument whose value must be in a particular range or must satisfy other conditions, :cdata:`PyExc_ValueError` is appropriate."
msgstr ""
"Wybór który wyjątek zgłosić jest całkowicie twój. Istnieją uprzednio "
"zadeklarowane przedmioty C odpowiadające wszystkim wbudowanym wyjątkom "
"języka pytonowskiego, takie, jak :cdata:`PyExc_ZeroDivisionError` którego "
"możesz użyć bezpośrednio. Oczywiście, powinieneś wybierać wyjątki rozsądnie "
"--- nie używaj :cdata:`PyExc_TypeError` aby oznaczyć że plik nie mógł być "
"otworzony (to powinno prawdopodobnie być :cdata:`PyExc_IOError`). Jeśli coś "
"jest nie wporządku z listą parametrów, zadanie :cfunc:`PyArg_ParseTuple` "
"zwykle zgłasza :cdata:`PyExc_TypeError`. Jeśli masz parametr którego wartość "
"musi być w szczególnym zakresie lub musi zaspokajać inne warunki "
":cdata:`PyExc_ValueError` jest odpowiednia."

msgid "You can also define a new exception that is unique to your module. For this, you usually declare a static object variable at the beginning of your file::"
msgstr ""
"Możesz też określić nowy wyjątek który jest niepowtarzalny dla twojego "
"modułu. Dla tego, zwykle deklarujesz przedmiot statycznej zmiennej na "
"początku pliku::"

msgid "static PyObject *SpamError;"
msgstr "static PyObject *SpamError;"

msgid "and initialize it in your module's initialization function (:cfunc:`PyInit_spam`) with an exception object (leaving out the error checking for now)::"
msgstr ""
"i zainicjować je w twoim zadaniu zainicjowania modułu (:cfunc:`PyInit_spam`) "
"przedmiotem wyjątku (pozostawiając na razie sprawdzanie błędów)::"

msgid "PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;      m = PyModule_Create(&spammodule);     if (m == NULL)         return NULL;      SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);     Py_INCREF(SpamError);     PyModule_AddObject(m, \"error\", SpamError);     return m; }"
msgstr ""
"PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;      m = "
"PyModule_Create(&spammodule);     if (m == NULL)         return NULL;      "
"SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);     "
"Py_INCREF(SpamError);     PyModule_AddObject(m, \"error\", SpamError);     "
"return m; }"

msgid "Note that the Python name for the exception object is :exc:`spam.error`.  The :cfunc:`PyErr_NewException` function may create a class with the base class being :exc:`Exception` (unless another class is passed in instead of *NULL*), described in :ref:`bltin-exceptions`."
msgstr ""
"Zauważ, że nazwa języka pytonowskiego dla przedmiotu wyjątku to "
":exc:`spam.error`. Zadanie :cfunc:`PyErr_NewException` może tworzyć "
"uogólnienie z bazowym uogólnieniem będącym :exc:`Exception` (chyba, że inne "
"uogólnienie jest przekazane zamiast *NULL*), opisane w :ref:`bltin-"
"exceptions`."

msgid "Note also that the :cdata:`SpamError` variable retains a reference to the newly created exception class; this is intentional!  Since the exception could be removed from the module by external code, an owned reference to the class is needed to ensure that it will not be discarded, causing :cdata:`SpamError` to become a dangling pointer. Should it become a dangling pointer, C code which raises the exception could cause a core dump or other unintended side effects."
msgstr ""
"Zauważ także, że zmienna :cdata:`SpamError` zachowuje odniesienie do nowo "
"utworzonego uogólnienia wyjątku; to jest specjalnie! Od kiedy wyjątek mógł "
"być zdjęty z modułu przez zewnętrzny kod, posiadane odniesienie do "
"uogólnienia jest konieczne aby zapewnić że nie będzie pominięte, powodując, "
"że :cdata:`SpamError` stanie się wiszącym wskaźnikiem. Jeśli by tak się "
"stało, kod C, który zgłasza wyjątek mógłby spowodować zrzucenie jądra lub "
"inne niezamierzone efekty uboczne."

msgid "We discuss the use of PyMODINIT_FUNC as a function return type later in this sample."
msgstr ""
"Rozważamy użycie PyMODINIT_FUNC jako typ zwracany później w tym przykładzie."

msgid "Back to the Example"
msgstr "Z powrotem do Przykładu"

msgid "Going back to our example function, you should now be able to understand this statement::"
msgstr ""
"Wracając do naszej przykładowego zadania, powinieneś już być w stanie "
"zrozumieć to wyrażenie::"

msgid "if (!PyArg_ParseTuple(args, \"s\", &command))     return NULL;"
msgstr "if (!PyArg_ParseTuple(args, \"s\", &command))     return NULL;"

msgid "It returns *NULL* (the error indicator for functions returning object pointers) if an error is detected in the argument list, relying on the exception set by :cfunc:`PyArg_ParseTuple`.  Otherwise the string value of the argument has been copied to the local variable :cdata:`command`.  This is a pointer assignment and you are not supposed to modify the string to which it points (so in Standard C, the variable :cdata:`command` should properly be declared as ``const char *command``)."
msgstr ""
"Zwraca ona *NULL* (wskaźnik błędu dla zadań zwracających przedmiotowe "
"wskaźniki) jeśli błąd został wykryty na liście parametrów, polegając na "
"wyjątku ustawionym przez :cfunc:`PyArg_ParseTuple`. Poza tym wartość ciągu "
"znaków parametru została skopiowana do zmiennej lokalnej :cdata:`command`. "
"To jest przypisanie wskaźnika i nie powinieneś zmieniać ciągu znaków na "
"który on wskazuje (więc w Standardowym C, zmienna :cdata:`command` powinna "
"odpowiednio być zadeklarowana jako ``const char *command``)."

msgid "The next statement is a call to the Unix function :cfunc:`system`, passing it the string we just got from :cfunc:`PyArg_ParseTuple`::"
msgstr ""
"Następne wyrażenie jest wezwaniem zadania Unix-a :cfunc:`system`, "
"przekazując mu ciąg znaków, który właśnie otrzymaliśmy z "
":cfunc:`PyArg_ParseTuple`::"

msgid "sts = system(command);"
msgstr "sts = system(command);"

msgid "Our :func:`spam.system` function must return the value of :cdata:`sts` as a Python object.  This is done using the function :cfunc:`Py_BuildValue`, which is something like the inverse of :cfunc:`PyArg_ParseTuple`: it takes a format string and an arbitrary number of C values, and returns a new Python object. More info on :cfunc:`Py_BuildValue` is given later. ::"
msgstr ""
"Nasze zadanie :func:`spam.system` musi zwracać wartość :cdata:`sts` jako "
"przedmiot języka pytonowskiego. To jest czynione używając zadania "
":cfunc:`Py_BuildValue`, która jest czymś podobnym do odwrotności "
":cfunc:`PyArg_ParseTuple`: bierze ona ciąg formatowania i dowolną liczbę "
"wartości C, i zwraca nowy przedmiot języka pytonowskiego. Więcej informacji "
"o :cfunc:`Py_BuildValue` jest podana później. ::"

msgid "return Py_BuildValue(\"i\", sts);"
msgstr "return Py_BuildValue(\"i\", sts);"

msgid "In this case, it will return an integer object.  (Yes, even integers are objects on the heap in Python!)"
msgstr ""
"W tym przypadku, zwróci przedmiot liczby całkowitej (Tak, nawet liczby "
"całkowite są przedmiotami na stercie w języku pytonowskim!)"

msgid "If you have a C function that returns no useful argument (a function returning :ctype:`void`), the corresponding Python function must return ``None``.   You need this idiom to do so (which is implemented by the :cmacro:`Py_RETURN_NONE` macro)::"
msgstr ""
"Jeśli masz zadanie C które nie zwraca żadnych użytecznych parametrów "
"(zadanie zwracające :ctype:`void`), odpowiadające zadanie języka "
"pytonowskiego musi zwracać ``None``. Potrzebujesz tego idiomu aby to uczynić "
"(który jest wypełniony przez makrodefinicję :cmacro:`Py_RETURN_NONE`)::"

msgid "Py_INCREF(Py_None); return Py_None;"
msgstr "Py_INCREF(Py_None); return Py_None;"

msgid ":cdata:`Py_None` is the C name for the special Python object ``None``.  It is a genuine Python object rather than a *NULL* pointer, which means \"error\" in most contexts, as we have seen."
msgstr ""
":cdata:`Py_None` jest nazwą C dla szczególnego przedmiotu języka "
"pytonowskiego ``None``. Jest to prawdziwy przedmiot języka pytonowskiego "
"zamiast pustego wskaźnika - z ang. - *NULL*, co oznacza \"błąd\" w większości "
"przypadków, jak już widzieliśmy."

msgid "The Module's Method Table and Initialization Function"
msgstr "Zadanie zainicjowania i tabela sposobów postępowania modułu."

msgid "I promised to show how :cfunc:`spam_system` is called from Python programs. First, we need to list its name and address in a \"method table\"::"
msgstr ""
"Obiecywałem pokazać jak :cfunc:`spam_system` jest wywoływana z programu "
"języka pytonowskiego. Najpierw musimy wypisać jej nazwę i adres w \"tabeli "
"sposobów postępowania\"::"

msgid "static PyMethodDef SpamMethods[] = {     ...     {\"system\",  spam_system, METH_VARARGS,      \"Execute a shell command.\"},     ...     {NULL, NULL, 0, NULL}        /* Sentinel */ };"
msgstr ""
"static PyMethodDef SpamMethods[] = {     ...     {\"system\",  spam_system, "
"METH_VARARGS,      \"Uruchom polecenie powłoki.\"},     ...     {NULL, NULL, "
"0, NULL}        /* pilnowacz */ };"

msgid "Note the third entry (``METH_VARARGS``).  This is a flag telling the interpreter the calling convention to be used for the C function.  It should normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a value of ``0`` means that an obsolete variant of :cfunc:`PyArg_ParseTuple` is used."
msgstr ""
"Zauważ trzeci wpis (``METH_VARARGS``). To jest flaga mówiąca programowi "
"interpretującemu polecenia języka pytonowskiego o konwencji która ma zostać "
"użyta dla zadania C. Zwykle zawsze powinna to być ``METH_VARARGS`` lub "
"``METH_VARARGS | METH_KEYWORDS``; wartość ``0`` oznacza że przestarzały "
"wariant zadania :cfunc:`PyArg_ParseTuple` jest używany."

msgid "When using only ``METH_VARARGS``, the function should expect the Python-level parameters to be passed in as a tuple acceptable for parsing via :cfunc:`PyArg_ParseTuple`; more information on this function is provided below."
msgstr ""
"Gdy w użyciu jest tylko ``METH_VARARGS``, zadanie powinno spodziewać się "
"parametrów na poziomie języka pytonowskiego aby były przekazywane jako "
"dwójka akceptowalna do wczytania przez :cfunc:`PyArg_ParseTuple`; więcej "
"informacji o tym zadaniu jest dostarczone poniżej."

msgid "The :const:`METH_KEYWORDS` bit may be set in the third field if keyword arguments should be passed to the function.  In this case, the C function should accept a third ``PyObject \\*`` parameter which will be a dictionary of keywords. Use :cfunc:`PyArg_ParseTupleAndKeywords` to parse the arguments to such a function."
msgstr ""
"Bit :const:`METH_KEYWORDS` może być ustawiany w trzecim polu jeśli parametry "
"słów kluczowych miałyby być przekazywane do zadania. W takim przypadku, "
"zadanie C powinno akceptować trzeci parametr ``PyObject \\*``, który będzie "
"słownikiem słów kluczowych. Użyj zadania "
":cfunc:`PyArg_ParseTupleAndKeywords` aby wczytać parametry takiego zadania."

msgid "The method table must be referenced in the module definition structure::"
msgstr ""
"Tabela sposobów postępowania musi być określona w strukturze definicji "
"modułu::"

msgid "static struct PyModuleDef spammodule = {    PyModuleDef_HEAD_INIT,    \"spam\",   /* name of module */    spam_doc, /* module documentation, may be NULL */    -1,       /* size of per-interpreter state of the module,                 or -1 if the module keeps state in global variables. */    SpamMethods };"
msgstr ""
"static struct PyModuleDef spammodule = { PyModuleDef_HEAD_INIT, \"spam\", "
"/*nazwa modułu */ spam_doc, /* dokumentacja modułu, może być pusta (NULL) */ "
"-1, /* rozmiar stanu modułu dla programu interpretującego polecenia języka "
"pytonowskiego, lub -1 jeśli moduł utrzymuje stan w nadrzędnych zmiennych. */ "
"SpamMethods };"

msgid "This structure, in turn, must be passed to the interpreter in the module's initialization function.  The initialization function must be named :cfunc:`PyInit_name`, where *name* is the name of the module, and should be the only non-\\ ``static`` item defined in the module file::"
msgstr ""
"Ta struktura, z kolei, musi być przekazana do programu interpretującego "
"polecenia języka pytonowskiego w zadaniu inicjującym moduł. Zadanie "
"inicjujące musi się nazywać :cfunc:`PyInit_nazwa`, gdzie *nazwa* jest nazwą "
"modułu, i powinna być jedynym nie-\\ ``statycznym`` elementem określonym w "
"pliku modułu::"

msgid "PyMODINIT_FUNC PyInit_spam(void) {     return PyModule_Create(&spammodule); }"
msgstr ""
"PyMODINIT_FUNC PyInit_spam(void) {     return PyModule_Create(&spammodule); "
"}"

msgid "Note that PyMODINIT_FUNC declares the function as ``PyObject *`` return type, declares any special linkage declarations required by the platform, and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"Zauważ że PyMODINIT_FUNC deklaruje zadanie jako zwrotny typ ``PyObject *``, "
"deklaruje wszelkie specjalne deklaracje połączeń wymagane przez "
"maszynę/środowisko, i dla C++ deklaruje zadanie jako ``extern \"C\"``."

msgid "When the Python program imports module :mod:`spam` for the first time, :cfunc:`PyInit_spam` is called. (See below for comments about embedding Python.) It calls :cfunc:`PyModule_Create`, which returns a module object, and inserts built-in function objects into the newly created module based upon the table (an array of :ctype:`PyMethodDef` structures) found in the module definition. :cfunc:`PyModule_Create` returns a pointer to the module object that it creates.  It may abort with a fatal error for certain errors, or return *NULL* if the module could not be initialized satisfactorily. The init function must return the module object to its caller, so that it then gets inserted into ``sys.modules``."
msgstr ""
"Gdy program języka pytonowskiego importuje moduł :mod:`spam` po raz "
"pierwszy, zadanie :cfunc:`PyInit_spam` jest wzywane. (Zobacz poniższe "
"komentarze o załączaniu języka pytonowskiego.) Wzywa zadanie "
":cfunc:`PyModule_Create`, które zwraca przedmiot modułu, i wstawia "
"przedmioty wbudowanych zadań do nowo utworzonego modułu w oparciu o tabelę "
"(rząd struktur :ctype:`PyMethodDef`) znajdujących się w definicji modułu. "
":cfunc:`PyModule_Create` zwraca wskaźnik do przedmiotu modułu który tworzy. "
"Może przerwać z krytycznym błędem dla pewnych błędów, lub zwrócić *NULL* "
"jeśli moduł nie mógł być zainicjowany satysfakcjonująco. Zadanie inicjujące "
"musi zwrócić przedmiot modułu do swojego wywołującego, tak żeby było "
"następnie wstawione do ``sys.modules``."

msgid "When embedding Python, the :cfunc:`PyInit_spam` function is not called automatically unless there's an entry in the :cdata:`PyImport_Inittab` table. To add the module to the initialization table, use :cfunc:`PyImport_AppendInittab`, optionally followed by an import of the module::"
msgstr ""
"Przy załączaniu języka pytonowskiego, zadanie :cfunc:`PyInit_spam` nie jest "
"wzywane automatycznie chyba, że istnieje wpis w tabeli "
":cdata:`PyImport_Inittab`. Aby dodać moduł do tabeli zainicjowania użyj "
":cfunc:`PyImport_AppendInittab`, z dodatkową możliwością następnie "
"importowania modułu::"

msgid "int main(int argc, char *argv[]) {     /* Add a built-in module, before Py_Initialize */     PyImport_AppendInittab(\"spam\", PyInit_spam);      /* Pass argv[0] to the Python interpreter */     Py_SetProgramName(argv[0]);      /* Initialize the Python interpreter.  Required. */     Py_Initialize();      /* Optionally import the module; alternatively,        import can be deferred until the embedded script        imports it. */     PyImport_ImportModule(\"spam\");"
msgstr ""
"int main(int argc, char *argv[]) { /* Dodaj wbudowany moduł, przed "
"Py_Initialize */ PyImport_AppendInittab(\"spam\", PyInit_spam); /* Przekaż "
"argv[0] do programu interpretującego polecenia języka pytonowskiego */ "
"Py_SetProgramName(argv[0]); /* Inicjuj program interpretujący polecenia "
"języka pytonowskiego. Wymagane. */ Py_Initialize(); /* Opcjonalnie importuj "
"moduł; alternatywnie, import może być opóźniony aż do momentu gdy załączony "
"skrypt go zaimportuje. */ PyImport_ImportModule(\"spam\");"

msgid "An example may be found in the file :file:`Demo/embed/demo.c` in the Python source distribution."
msgstr ""
"Przykład można znaleźć w pliku :file:`Demo/embed/demo.c` w dystrybucji "
"źródłowej języka pytonowskiego."

msgid "Removing entries from ``sys.modules`` or importing compiled modules into multiple interpreters within a process (or following a :cfunc:`fork` without an intervening :cfunc:`exec`) can create problems for some extension modules. Extension module authors should exercise caution when initializing internal data structures."
msgstr ""
"Usuwanie wpisów z ``sys.modules`` lub importowanie skompilowanych modułów do "
"wielu interpreterów wewnątrz procesu (lub postępując za rozwidleniem "
":cfunc:`fork` bez przerwy ze strony :cfunc:`exec`) może tworzyć problemy dla "
"niektórych modułów rozszerzających. Twórcy modułów rozszerzających powinni "
"wzmóc czujność podczas inicjowania wewnętrznych struktur danych."

msgid "A more substantial example module is included in the Python source distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  template or simply read as an example."
msgstr ""
"Bardziej konkretny przykład modułu jest załączony w dystrybucji źródeł "
"języka pytonowskiego jako plik :file:`Modules/xxmodule.c`. Ten plik może być "
"użyty jako wzór lub po prostu czytany jako przykład."

msgid "Compilation and Linkage"
msgstr "Kompilacja i łączenie"

msgid "There are two more things to do before you can use your new extension: compiling and linking it with the Python system.  If you use dynamic loading, the details may depend on the style of dynamic loading your system uses; see the chapters about building extension modules (chapter :ref:`building`) and additional information that pertains only to building on Windows (chapter :ref:`building-on-windows`) for more information about this."
msgstr ""
"Są jeszcze dwie rzeczy które trzeba zrobić zanim będzie można użyć nowego "
"rozszerzenia: skompilowanie go i podłączenie z systemem języka "
"pytonowskiego. Jeśli używasz dynamicznego ładowania, szczegóły mogą zależeć "
"od stylu dynamicznego ładowania którego twój system używa; zobacz rozdział o "
"budowaniu rozszerzających modułów (rozdział :ref:`budowanie`) i dodatkowe "
"informacje które odnoszą się tylko do budowania w Windows (rozdział "
":ref:`budowanie-w-windows`) po więcej informacji na ten temat."

msgid "If you can't use dynamic loading, or if you want to make your module a permanent part of the Python interpreter, you will have to change the configuration setup and rebuild the interpreter.  Luckily, this is very simple on Unix: just place your file (:file:`spammodule.c` for example) in the :file:`Modules/` directory of an unpacked source distribution, add a line to the file :file:`Modules/Setup.local` describing your file::"
msgstr ""
"Jeśli nie możesz użyć dynamicznego ładowania, lub jeśli chcesz uczynić swój "
"moduł trwałą częścią programu interpretującego polecenia języka "
"pytonowskiego, będziesz musiał zmienić ustawienia konfiguracyjne i "
"przebudować program interpretujący polecenia języka pytonowskiego. Na "
"szczęście jest to bardzo proste w Unix-ie: po prostu wstaw swój plik "
"(:file:`spammodule.c` dla przykładu) w katalogu :file:`Modules/` odpakowanej "
"dystrybucji źródłowej, dodaj linię do pliku :file:`Modules/Setup.local` "
"opisującą twój plik:: "

msgid "spam spammodule.o"
msgstr "spam spammodule.o"

msgid "and rebuild the interpreter by running :program:`make` in the toplevel directory.  You can also run :program:`make` in the :file:`Modules/` subdirectory, but then you must first rebuild :file:`Makefile` there by running ':program:`make` Makefile'.  (This is necessary each time you change the :file:`Setup` file.)"
msgstr ""
"i przebuduj program interpretujący przez uruchomienie programu "
":program:`make` w katalogu głównym instalacji. Możesz także uruchomić "
"program :program:`make` w podkatalogu :file:`Modules/`, ale wtedy musisz "
"najpierw przebudować plik :file:`Makefile` tam przez uruchomienie programu "
":program:`make` Makefile'. To jest konieczne za każdym razem gdy zmieniasz "
"plik :file:`Setup`.)"

msgid "If your module requires additional libraries to link with, these can be listed on the line in the configuration file as well, for instance::"
msgstr ""
"Jeśli twój moduł wymaga dodatkowych bibliotek do podłączenia, te mogą być "
"wymienione na liście w kolejce do pliku konfiguracyjnego na przykład::"

msgid "spam spammodule.o -lX11"
msgstr "spam spammodule.o -lX11"

msgid "Calling Python Functions from C"
msgstr "Wywoływanie zadań języka pytonowskiego z C"

msgid "So far we have concentrated on making C functions callable from Python.  The reverse is also useful: calling Python functions from C. This is especially the case for libraries that support so-called \"callback\" functions.  If a C interface makes use of callbacks, the equivalent Python often needs to provide a callback mechanism to the Python programmer; the implementation will require calling the Python callback functions from a C callback.  Other uses are also imaginable."
msgstr ""
"Jak do tej pory koncentrowaliśmy się na uczynieniu zadań C możliwymi do "
"wywołania z poziomu języka pytonowskiego. Odwrotna sytuacja jest także "
"użyteczna: wywoływanie zadań języka pytonowskiego z poziomu języka C. To w "
"szczególności odnosi się do bibliotek które wspierają tak zwane zadania "
"\"callback\" wstecznie wywołujące. Jeśli sprzęg C używa zadań wstecznie "
"wywołujących, odpowiednik języka pytonowskiego często potrzebuje dostarczyć "
"mechanizm wstecznego wywołania dla programisty języka pytonowskiego; "
"wypełnienie będzie potrzebowało wzywać zadania wywołania wstecznego z "
"poziomu wstecznego C. Inne przypadki są także możliwe do wyobrażenia."

msgid "Fortunately, the Python interpreter is easily called recursively, and there is a standard interface to call a Python function.  (I won't dwell on how to call the Python parser with a particular string as input --- if you're interested, have a look at the implementation of the :option:`-c` command line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"Szczęśliwie, program interpretujący polecenia języka pytonowskiego jest "
"łatwo wywoływany rekursywnie i istnieje standardowy sprzęg aby wywołać "
"zadanie języka pytonowskiego. (Nie będę rozpisywał się o tym jak wywołać "
"czytnik języka pytonowskiego z konkretnym ciągiem znaków na wejściu --- "
"jeśli jesteś zainteresowany, spójrz na wypełnienie opcji :option:`-c` "
"wiersza polecenia w :file:`Modules/main.c` z kodu źródłowego języka "
"pytonowskiego.)"

msgid "Calling a Python function is easy.  First, the Python program must somehow pass you the Python function object.  You should provide a function (or some other interface) to do this.  When this function is called, save a pointer to the Python function object (be careful to :cfunc:`Py_INCREF` it!) in a global variable --- or wherever you see fit. For example, the following function might be part of a module definition::"
msgstr ""
"Wywołanie zadania języka pytonowskiego jest łatwe. Po pierwsze program "
"języka pytonowskiego musi jakoś przekazać ci przedmiot zadania języka "
"pytonowskiego. Powinieneś dostarczyć zadanie (lub jakiś inny sprzęg) aby to "
"uczynić. Gdy to zadanie jest wzywane, zachowaj wskaźnik do przedmiotu "
"zadania języka pytonowskiego (uważaj aby zwiększyć ilość odniesień do niego "
":cfunc:`Py_INCREF`) w nadrzędnej zmiennej --- lub gdziekolwiek uznasz to za "
"stosowne. Dla przykładu, następujące zadanie może być częścią definicji "
"modułu::"

msgid "static PyObject *my_callback = NULL;  static PyObject * my_set_callback(PyObject *dummy, PyObject *args) {     PyObject *result = NULL;     PyObject *temp;      if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {         if (!PyCallable_Check(temp)) {             PyErr_SetString(PyExc_TypeError, \"parameter must be callable\");             return NULL;         }         Py_XINCREF(temp);         /* Add a reference to new callback */         Py_XDECREF(my_callback);  /* Dispose of previous callback */         my_callback = temp;       /* Remember new callback */         /* Boilerplate to return \"None\" */         Py_INCREF(Py_None);         result = Py_None;     }     return result; }"
msgstr ""
"static PyObject *my_callback = NULL;  static PyObject * "
"my_set_callback(PyObject *dummy, PyObject *args) {     PyObject *result = "
"NULL;     PyObject *temp;      if (PyArg_ParseTuple(args, \"O:set_callback\", "
"&temp)) {         if (!PyCallable_Check(temp)) {             "
"PyErr_SetString(PyExc_TypeError, \"parametr musi być możliwy do wywołania\"); "
"            return NULL;         }         Py_XINCREF(temp);         /* "
"Dodaj odniesienie do nowego wstecznie wywoływanego zadania */         "
"Py_XDECREF(my_callback);  /* Pozbądź się poprzedniego wstecznie wywołanego "
"zadania */         my_callback = temp;       /* Zapamiętaj nowe wstecznie "
"wywoływane zadanie */         /* talerzowanie aby zwrócić \"None\" */         "
"Py_INCREF(Py_None);         result = Py_None;     }     return result; }"

msgid "This function must be registered with the interpreter using the :const:`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The :cfunc:`PyArg_ParseTuple` function and its arguments are documented in section :ref:`parsetuple`."
msgstr ""
"To zadanie musi być zarejestrowane w programie interpretującym polecenia "
"języka pytonowskiego używając flagi :const:`METH_VARARGS`; to jest opisane w "
"rozdziale :ref:`methodtable` - :ref:`tabeli sposobów postępowania`. Zadanie "
":cfunc:`PyArg_ParseTuple` i jego parametry są dokumentowane w rozdziale "
":ref:`parsetuple` - ref:`wczytaj_dwójkę`."

msgid "The macros :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF` increment/decrement the reference count of an object and are safe in the presence of *NULL* pointers (but note that *temp* will not be  *NULL* in this context).  More info on them in section :ref:`refcounts`."
msgstr ""
"Makropolecenia :cfunc:`Py_XINCREF` i :cfunc:`Py_XDECREF` "
"zwiększają/zmniejszają liczbę odniesień przedmiotu i są bezpieczne w obliczu "
"pustych wskaźników *NULL* (ale zwróc uwagę, że *temp* nie będzie pusty - "
"*NULL* w tym kontekście). Więcej informacji na ten temat znajdziesz w sekcji "
":ref:`refcounts` - :ref:`zliczaniaodniesień`."

msgid "Later, when it is time to call the function, you call the C function :cfunc:`PyObject_CallObject`.  This function has two arguments, both pointers to arbitrary Python objects: the Python function, and the argument list.  The argument list must always be a tuple object, whose length is the number of arguments.  To call the Python function with no arguments, pass in NULL, or an empty tuple; to call it with one argument, pass a singleton tuple. :cfunc:`Py_BuildValue` returns a tuple when its format string consists of zero or more format codes between parentheses.  For example::"
msgstr ""
"Później gdy nadchodzi czas aby wywołać zadanie, wywołujesz zadanie C "
":cfunc:`PyObject_CallObject`. To zadanie ma dwa parametry, oba wskaźniki do "
"dowolnych przedmiotów języka pytonowskiego: zadania pytonowskiego i listy "
"parametrów. Lista parametrów musi zawsze być przedmiotem krotki, której "
"długością jest liczba parametrów. Aby wywołać zadanie języka pytonowskiego "
"bez parametrów, przekaż NULL, lub pustą krotkę; aby wywołać je z jednym "
"parametrem przekaż głupią krotkę. :cfunc:`Py_BuildValue` zwraca krotkę gdy "
"jego ciąg znaków formatujących składa się z zera lub więcej kodów "
"formatujących pomiędzy nawiasami. Dla przykładu::"

msgid "int arg; PyObject *arglist; PyObject *result; ... arg = 123; ... /* Time to call the callback */ arglist = Py_BuildValue(\"(i)\", arg); result = PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist);"
msgstr ""
"int arg; PyObject *arglist; PyObject *result; ... arg = 123; ... /* Czas "
"wywołać zadanie wstecznie */ arglist = Py_BuildValue(\"(i)\", arg); result = "
"PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist);"

msgid ":cfunc:`PyObject_CallObject` returns a Python object pointer: this is the return value of the Python function.  :cfunc:`PyObject_CallObject` is \"reference-count-neutral\" with respect to its arguments.  In the example a new tuple was created to serve as the argument list, which is :cfunc:`Py_DECREF`\\ -ed immediately after the call."
msgstr ""
":cfunc:`PyObject_CallObject` zwraca wskaźnik przedmiotowy języka "
"pytonowskiego: to jest wartość zwracana zadania języka pytonowskiego. "
":cfunc:`PyObject_CallObject` jest \"neutralne-pod-względem-zliczania-"
"odniesień\" względem jego parametrów. W przykładzie nowa krotka została "
"utworzona aby służyć jako lista parametrów, której liczba odniesień jest "
"zmniejszona (:cfunc:`Py_DECREF`) od razu po wywołaniu."

msgid "The return value of :cfunc:`PyObject_CallObject` is \"new\": either it is a brand new object, or it is an existing object whose reference count has been incremented.  So, unless you want to save it in a global variable, you should somehow :cfunc:`Py_DECREF` the result, even (especially!) if you are not interested in its value."
msgstr ""
"Wartość zwracana :cfunc:`PyObject_CallObject` jest \"nowa\": albo jest to "
"zupełnie nowy przedmiot, albo jest to istniejący przedmiot którego liczba "
"odniesień została zwiększona. Więc, z wyjątkiem sytuacji gdy chcesz zachować "
"ją w globalnej zmiennej, powinieneś jakoś zmniejszyć liczbę odniesień "
":cfunc:`Py_DECREF` rezultat, nawet (szczególnie!) jeśli nie jesteś "
"zainteresowany jego wartością."

msgid "Before you do this, however, it is important to check that the return value isn't *NULL*.  If it is, the Python function terminated by raising an exception. If the C code that called :cfunc:`PyObject_CallObject` is called from Python, it should now return an error indication to its Python caller, so the interpreter can print a stack trace, or the calling Python code can handle the exception. If this is not possible or desirable, the exception should be cleared by calling :cfunc:`PyErr_Clear`.  For example::"
msgstr ""
"Zanim to zrobisz, jednakże, jest istotne aby sprawdzić czy wartość zwracana "
"nie jest pusta - *NULL*. Jeśli jest, zadanie języka pytonowskiego zakończyło "
"się przez wzniesienie wyjątku. Jeśli kod w języku C który wywołał "
":cfunc:`PyObject_CallObject` jest wywoływany z języka pytonowskiego, "
"powinien teraz zwrócić błąd do swojego wywołującego z poziomu języka "
"pytonowskiego, tak by program interpretujący polecenia języka pytonowskiego "
"mógł wypisać ostatnie wywołania ze stosu, lub wywołanie kodu języak "
"pytonowskiego mogło obsłużyć wyjątek. Jeśli nie jest to możliwe albo nie "
"jest pożądane, wyjątek powinien zostać wyczyszczony przez wywołanie "
":cfunc:`PyErr_Clear`. Dla przykładu::"

msgid "if (result == NULL)     return NULL; /* Pass error back */ ...use result... Py_DECREF(result);"
msgstr ""
"if (result == NULL)     return NULL; /* Przakaź błąd wstecz */ ...użyj "
"wyniku... Py_DECREF(result);"

msgid "Depending on the desired interface to the Python callback function, you may also have to provide an argument list to :cfunc:`PyObject_CallObject`.  In some cases the argument list is also provided by the Python program, through the same interface that specified the callback function.  It can then be saved and used in the same manner as the function object.  In other cases, you may have to construct a new tuple to pass as the argument list.  The simplest way to do this is to call :cfunc:`Py_BuildValue`.  For example, if you want to pass an integral event code, you might use the following code::"
msgstr ""
"W zależności od oczekiwanego sprzęgu do wywoływanego wstecznie zadania, "
"możesz także potrzebować dostarczyć listę parametrów do zadania "
":cfunc:`PyObject_CallObject`. W niektórych przypadkach lista parametrów jest "
"także dostarczana przez program języka pytonowskiego, przez ten sam sprzęg "
"który określał zadanie wywołania wstecznego. Może potem być zachowane i "
"użyte w ten sam sposób jak przedmiot zadania. W innych przypadkach może być "
"konieczne stworzenie nowej krotki aby przekazać ją jako listę parametrów. "
"Najprostszym sposobem aby tego dokonać jest wywołanie :cfunc:`PyBuildValue`. "
"Dla przykładu, jeśli chcesz przekazać wewnętrzny kod zdarzenia możesz użyć "
"następującego kodu::"

msgid "PyObject *arglist; ... arglist = Py_BuildValue(\"(l)\", eventcode); result = PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist); if (result == NULL)     return NULL; /* Pass error back */ /* Here maybe use the result */ Py_DECREF(result);"
msgstr ""
"PyObject *arglist; ... arglist = Py_BuildValue(\"(l)\", eventcode); result = "
"PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist); if (result == "
"NULL)     return NULL; /* Przekaż błąd wstecz */ /* Tutaj być może użycie "
"wyniku */ Py_DECREF(result);"

msgid "Note the placement of ``Py_DECREF(arglist)`` immediately after the call, before the error check!  Also note that strictly speaking this code is not complete: :cfunc:`Py_BuildValue` may run out of memory, and this should be checked."
msgstr ""
"Zauważ położenie ``Py_DECREF(arglist)`` bezpośrednio po wywołaniu, przed "
"sprawdzeniem błędu! Zauważ też że ściśle mówiąc ten kod jest nie pełny: dla "
"zadania :cfunc:`Py_BuildValue` może skończyć się pamięć, i to powinno zostać "
"sprawdzone."

msgid "You may also call a function with keyword arguments by using :cfunc:`PyObject_Call`, which supports arguments and keyword arguments.  As in the above example, we use :cfunc:`Py_BuildValue` to construct the dictionary. ::"
msgstr ""
"Możesz także wywołać zadanie z parametrami kluczowymi przez użycie "
":cfunc:`PyObject_Call`, które wspiera parametry i parametry słów kluczowych. "
"Jak w powyższym przykładzie, używamy zadania :cfunc:`Py_BuildValue` aby "
"zbudować słownik. ::"

msgid "PyObject *dict; ... dict = Py_BuildValue(\"{s:i}\", \"name\", val); result = PyObject_Call(my_callback, NULL, dict); Py_DECREF(dict); if (result == NULL)     return NULL; /* Pass error back */ /* Here maybe use the result */ Py_DECREF(result);"
msgstr ""
"PyObject *dict; ... dict = Py_BuildValue(\"{s:i}\", \"name\", val); result = "
"PyObject_Call(my_callback, NULL, dict); Py_DECREF(dict); if (result == NULL) "
"    return NULL; /* Przekaż błąd wstecz */ /* Tutaj być może użyj wyniku */ "
"Py_DECREF(result);"

msgid "Extracting Parameters in Extension Functions"
msgstr "Wydobywanie parametrów w zadaniach rozszerzających"

msgid "The :cfunc:`PyArg_ParseTuple` function is declared as follows::"
msgstr "Zadanie :cfunc:`PyArg_ParseTuple` jest zadeklarowane jak następuje::"

msgid "int PyArg_ParseTuple(PyObject *arg, char *format, ...);"
msgstr "int PyArg_ParseTuple(PyObject *arg, char *format, ...);"

msgid "The *arg* argument must be a tuple object containing an argument list passed from Python to a C function.  The *format* argument must be a format string, whose syntax is explained in :ref:`arg-parsing` in the Python/C API Reference Manual.  The remaining arguments must be addresses of variables whose type is determined by the format string."
msgstr ""
"Parametr *arg* musi być przedmiotem - krotką zawierającym listę parametrów z "
"języka pytonowskiego dla zadania C. Parametr *format* musi być ciągiem "
"formatu, którego składnia jest wyjaśniona w :ref:`wczytywanie-parametrów` - "
":ref:`arg-parsing` w podręczniku użytkownika sprzęgów języka "
"pytonowskiego/C. Pozostałe parametry muszą być adresami zmiennych których "
"rodzaj jest określony przez ciąg formatujący."

msgid "Note that while :cfunc:`PyArg_ParseTuple` checks that the Python arguments have the required types, it cannot check the validity of the addresses of C variables passed to the call: if you make mistakes there, your code will probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
"Zauważ, że podczas gdy :cfunc:`PyArg_ParseTuple` sprawdza, że parametry "
"języka pytonowskiego mają wymagane rodzaje, nie może sprawdzić ważności "
"adresów zmiennych C przekazywanych do wywołania: jeśli popełnisz tu błędy, "
"twój kod prawdopodobnie wykona niedozwoloną operację lub przynajmniej "
"zapisze przypadkowe pola w pamięci. Więc bądź ostrożny!"

msgid "Note that any Python object references which are provided to the caller are *borrowed* references; do not decrement their reference count!"
msgstr ""
"Zauważ, że dowolne odniesienia do przedmiotów języka pytonowskiego, które są "
"dostarczone wołającemu są *pożyczonymi* odniesieniami; nie zmniejszaj "
"liczby tych odniesień."

msgid "Some example calls::"
msgstr "Pewne przykładowe wywołania::"

msgid "#define PY_SSIZE_T_CLEAN  /* Make \"s#\" use Py_ssize_t rather than int. */ #include <Python.h>"
msgstr ""
"#define PY_SSIZE_T_CLEAN  /* zrób \"s#\" użytek z Py_ssize_t raczej zamiast "
"int. */ #include <Python.h>"

msgid "int ok; int i, j; long k, l; const char *s; Py_ssize_t size;  ok = PyArg_ParseTuple(args, \"\"); /* No arguments */     /* Python call: f() */"
msgstr ""
"int ok; int i, j; long k, l; const char *s; Py_ssize_t size;  ok = "
"PyArg_ParseTuple(args, \"\"); /* Żadnych parametrów */     /* Wywołanie "
"pytonowskie: f() */"

msgid "ok = PyArg_ParseTuple(args, \"s\", &s); /* A string */     /* Possible Python call: f('whoops!') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* Ciąg znaków */     /* Możliwe "
"wywołanie pytonowskie: f('whoops!') */"

msgid "ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Two longs and a string */     /* Possible Python call: f(1, 2, 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Dwie liczby długie i ciąg "
"znaków */     /* Możliwe wywołanie pytonowskie: f(1, 2, 'three') */"

msgid "ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);     /* A pair of ints and a string, whose size is also returned */     /* Possible Python call: f((1, 2), 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);     /* Para liczb "
"całkowitych i ciąg znaków, którego rozmiar jest także zwracany */     /* "
"Możliwe wywołanie pytonowskie: f((1, 2), 'three') */"

msgid "{     const char *file;     const char *mode = \"r\";     int bufsize = 0;     ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);     /* A string, and optionally another string and an integer */     /* Possible Python calls:        f('spam')        f('spam', 'w')        f('spam', 'wb', 100000) */ }"
msgstr ""
"{     const char *file;     const char *mode = \"r\";     int bufsize = 0; "
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);     /* "
"Ciąg znaków, i opcjonalnie następny ciąg i liczba całkowita */     /* "
"Możliwe wywołania pytonowskie:        f('spam')        f('spam', 'w') "
"       f('spam', 'wb', 100000) */ }"

msgid "{     int left, top, right, bottom, h, v;     ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",              &left, &top, &right, &bottom, &h, &v);     /* A rectangle and a point */     /* Possible Python call:        f(((0, 0), (400, 300)), (10, 10)) */ }"
msgstr ""
"{     int left, top, right, bottom, h, v;     ok = PyArg_ParseTuple(args, "
"\"((ii)(ii))(ii)\",              &left, &top, &right, &bottom, &h, &v);     /* "
"Prostokąt i punkt */     /* Możliwe wywołania pytonowskie:        f(((0, "
"0), (400, 300)), (10, 10)) */ }"

msgid "{     Py_complex c;     ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);     /* a complex, also providing a function name for errors */     /* Possible Python call: myfunction(1+2j) */ }"
msgstr ""
"{     Py_complex c;     ok = PyArg_ParseTuple(args, \"D:myfunction\", &c); "
"    /* Zespolona, także dostarczająca nazwę zadania dla błędów */     /* "
"Możliwe wywołania pytonowskie: myfunction(1+2j) */ }"

msgid "Keyword Parameters for Extension Functions"
msgstr "Parametry kluczowe dla zadań rozszerzających"

msgid "The :cfunc:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ""
"Zadanie :cfunc:`PyArg_ParseTupleAndKeywords` jest zadeklarowane jak "
"następuje::"

msgid "int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,                                 char *format, char *kwlist[], ...);"
msgstr ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict, "
"                                char *format, char *kwlist[], ...);"

msgid "The *arg* and *format* parameters are identical to those of the :cfunc:`PyArg_ParseTuple` function.  The *kwdict* parameter is the dictionary of keywords received as the third parameter from the Python runtime.  The *kwlist* parameter is a *NULL*-terminated list of strings which identify the parameters; the names are matched with the type information from *format* from left to right.  On success, :cfunc:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns false and raises an appropriate exception."
msgstr ""
"Parametry *arg* i *format* są identyczne z tymi z zadania "
":cfunc:`PyArg_ParseTuple`. Parametr *kwdict* jest słownikiem słów kluczowych "
"otrzymywanych jako trzeci parametr w czasie wykonania. Parametr *kwlist* "
"jest zakończoną znakiem *NULL* listą ciągów znaków które identyfikują "
"parametry; Nazwy są dopasowywane z typem informacji z *formatu* od lewej do "
"prawej. Przy pomyślnym rozwiązaniu zadanie "
":cfunc:`PyArg_ParseTupleAndKeywords` zwraca prawdę, w innym przypadku zwraca "
"fałsz i zgłasza odpowiedni wyjątek."

msgid "Nested tuples cannot be parsed when using keyword arguments!  Keyword parameters passed in which are not present in the *kwlist* will cause :exc:`TypeError` to be raised."
msgstr ""
"Zagnieżdźone krotki nie mogą być wczytane gdy używane są parametry słów "
"kluczowych! Parametry słów kluczowych przekazane do zadania które nie są "
"obecne na liście *kwlist* spowodują że wyjątek :exc:`TypeError` zostanie "
"zgłoszony."

msgid "Here is an example module which uses keywords, based on an example by Geoff Philbrick (philbrick@hks.com)::"
msgstr ""
"Tu jest przykładowy moduł który używa słów kluczowych, oparty na przykładzie "
"Geoffa Philbricka (philbrick@hks.com)::"

msgid "#include \"Python.h\"  static PyObject * keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds) {     int voltage;     char *state = \"a stiff\";     char *action = \"voom\";     char *type = \"Norwegian Blue\";      static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", NULL};      if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,                                      &voltage, &state, &action, &type))         return NULL;      printf(\"-- This parrot wouldn't %s if you put %i Volts through it.\\n\",            action, voltage);     printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);      Py_INCREF(Py_None);      return Py_None; }  static PyMethodDef keywdarg_methods[] = {     /* The cast of the function is necessary since PyCFunction values      * only take two PyObject* parameters, and keywdarg_parrot() takes      * three.      */     {\"parrot\", (PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,      \"Print a lovely skit to standard output.\"},     {NULL, NULL, 0, NULL}   /* sentinel */ };"
msgstr ""
"#include \"Python.h\"  static PyObject * keywdarg_parrot(PyObject *self, "
"PyObject *args, PyObject *keywds) {     int napiecie;     char *stan = "
"\"sztywna\";     char *akcja = \"wyje\";     char *typ = \"Norweska Niebieska\"; "
"     static char *kwlist[] = {\"napiecie\", \"stan\", \"akcja\", \"typ\", NULL}; "
"     if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist, "
"                                     &napiecie, &stan, &akcja, &typ)) "
"        return NULL;      printf(\"-- Ta papuga nie %s nawet jeśli "
"przyłożysz %i Voltów do niej.\\n\",            action, voltage);     "
"printf(\"-- Piękne ubarwienie, %s -- jest %s!\\n\", type, state);      "
"Py_INCREF(Py_None);      return Py_None; }  static PyMethodDef "
"keywdarg_methods[] = {     /* Rzutowanie zadania jest konieczne odkąd "
"wartości PyCFunction      * pobierają tylko dwa parametery PyObject* , i "
"keywdarg_parrot() pobiera      * trzy.      */     {\"parrot\", "
"(PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,      \"Wypisz "
"ładny skecz na standardowe wyjście.\"},     {NULL, NULL, 0, NULL}   /* "
"ochroniarz */ };"

msgid "void initkeywdarg(void) {   /* Create the module and add the functions */   Py_InitModule(\"keywdarg\", keywdarg_methods); }"
msgstr ""
"void initkeywdarg(void) { /* Stwórz moduł i dodaj zadania */ "
"Py_InitModule(\"keywdarg\", keywdarg_methods); }"

msgid "Building Arbitrary Values"
msgstr "Budowanie Dowolnych Wartości"

msgid "This function is the counterpart to :cfunc:`PyArg_ParseTuple`.  It is declared as follows::"
msgstr ""
"To zadanie jest odpowiednikiem :cfunc:`PyArg_ParseTuple`. Jest deklarowane w "
"następujący sposób::"

msgid "PyObject *Py_BuildValue(char *format, ...);"
msgstr "PyObject *Py_BuildValue(char *format, ...);"

msgid "It recognizes a set of format units similar to the ones recognized by :cfunc:`PyArg_ParseTuple`, but the arguments (which are input to the function, not output) must not be pointers, just values.  It returns a new Python object, suitable for returning from a C function called from Python."
msgstr ""
"Rozpoznaje ono zestaw jednostek formatu podobnych do tych rozpoznawanych "
"przez :cfunc:`PyArg_ParseTuple`, ale parametry (które są wprowadzane do "
"funkcji, nie są wynikami) nie mogą być wskaźnikami, tylko wartościami. "
"Zwracają nowy przedmiot języka pytonowskiego, dostosowany do zwracania z "
"zadania C wzywanego przez język pytonowski."

msgid "One difference with :cfunc:`PyArg_ParseTuple`: while the latter requires its first argument to be a tuple (since Python argument lists are always represented as tuples internally), :cfunc:`Py_BuildValue` does not always build a tuple.  It builds a tuple only if its format string contains two or more format units. If the format string is empty, it returns ``None``; if it contains exactly one format unit, it returns whatever object is described by that format unit.  To force it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
"Jedna różnicą w zadaniu :cfunc:`PyArg_ParseTuple`: podczas gdy ta druga "
"wymaga jej pierwszego parametru aby był krotką (od kiedy listy parametrów "
"języka pytonowskiego są zawsze reprezentowane jeko krotki wewnętrznie), "
":cfunc:`Py_BuildValue` nie zawsze buduje krotkę. Buduje krotkę tylko jeśli "
"jej ciąg formatujący zawiera dwie lub więcej jednostki formatujące. Jeśli "
"ciąg formatujący jest pusty, zwraca ``Żaden`` - z ang. - ``None``; jeśli "
"zawiera dokładnie jedną jednostkę formatującą, zwraca ten przedmiot który "
"jest opisywany przez tą jednostkę formatującą. Aby zmusić ją aby zwracała "
"krotkę o rozmiarze 0 lub jeden, zawrzyj ciąg formatujący w nawiasy."

msgid "Examples (to the left the call, to the right the resulting Python value)::"
msgstr ""
"Przykłady (na lewo - wywołanie, na prawo - wynikająca wartość języka "
"pytonowskiego)::"

msgid "Py_BuildValue(\"\")                        None Py_BuildValue(\"i\", 123)                  123 Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789) Py_BuildValue(\"s\", \"hello\")              'hello' Py_BuildValue(\"y\", \"hello\")              b'hello' Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world') Py_BuildValue(\"s#\", \"hello\", 4)          'hell' Py_BuildValue(\"y#\", \"hello\", 4)          b'hell' Py_BuildValue(\"()\")                      () Py_BuildValue(\"(i)\", 123)                (123,) Py_BuildValue(\"(ii)\", 123, 456)          (123, 456) Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456) Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456] Py_BuildValue(\"{s:i,s:i}\",               \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456} Py_BuildValue(\"((ii)(ii)) (ii)\",               1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"
msgstr ""
"Py_BuildValue(\"\")                        None Py_BuildValue(\"i\", 123) "
"                 123 Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, "
"789) Py_BuildValue(\"s\", \"hello\")              'hello' Py_BuildValue(\"y\", "
"\"hello\")              b'hello' Py_BuildValue(\"ss\", \"hello\", \"world\")    "
"('hello', 'world') Py_BuildValue(\"s#\", \"hello\", 4)          'hell' "
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell' Py_BuildValue(\"()\") "
"                     () Py_BuildValue(\"(i)\", 123)                (123,) "
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456) Py_BuildValue(\"(i,i)\", "
"123, 456)         (123, 456) Py_BuildValue(\"[i,i]\", 123, 456)         [123, "
"456] Py_BuildValue(\"{s:i,s:i}\",               \"abc\", 123, \"def\", 456)    "
"{'abc': 123, 'def': 456} Py_BuildValue(\"((ii)(ii)) (ii)\",               1, "
"2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"

msgid "Reference Counts"
msgstr "Liczby odniesień"

msgid "In languages like C or C++, the programmer is responsible for dynamic allocation and deallocation of memory on the heap.  In C, this is done using the functions :cfunc:`malloc` and :cfunc:`free`.  In C++, the operators ``new`` and ``delete`` are used with essentially the same meaning and we'll restrict the following discussion to the C case."
msgstr ""
"W językach takich jak C lub C++, programujący jest odpowiedzialny za "
"dynamiczną alokację i dealokację pamięci na stercie. W C, to jest dokonywane "
"przy użyciu zadań :cfunc:`malloc` i :cfunc:`free`. W C++, operatory ``new`` "
"i ``delete`` są używane z w gruncie rzeczy jednakowym znaczeniem i "
"ograniczymy się w następującej dyskusji do przypadku C. "

msgid "Every block of memory allocated with :cfunc:`malloc` should eventually be returned to the pool of available memory by exactly one call to :cfunc:`free`. It is important to call :cfunc:`free` at the right time.  If a block's address is forgotten but :cfunc:`free` is not called for it, the memory it occupies cannot be reused until the program terminates.  This is called a :dfn:`memory leak`.  On the other hand, if a program calls :cfunc:`free` for a block and then continues to use the block, it creates a conflict with re-use of the block through another :cfunc:`malloc` call.  This is called :dfn:`using freed memory`. It has the same bad consequences as referencing uninitialized data --- core dumps, wrong results, mysterious crashes."
msgstr ""
"Każdy blok pamięci alokowany za pomocą zadania :cfunc:`malloc` powinien w "
"końcu być zwrócony do puli dostępnej pamięci przez dokładnie jedno odwołanie "
"do zadania :cfunc:`free`. Jest to istotne aby wywołać zadanie :cfunc:`free` "
"we właściwym momencie. Jeśli adres bloku został zapomniany, ale zadanie "
":cfunc:`free` nie zostanie wezwane dla niego, pamięć którą zajmuje nie może "
"być ponownie użyta dopóki program nie zakończy swojego działania. To "
"nazywane jest wyciekiem pamięci - z ang. - :dfn:`memory leak`. Z drugiej "
"strony, jeśli program wywołuje :cfunc:`free` dla bloku i potem nadal "
"korzysta z bloku, tworzy to konflikt z ponownym użyciem bloku przez inne "
"wywołanie zadania :cfunc:`malloc`. To jest zwane :dfn:`użyciem uwolnionej "
"pamięci` - z ang. - :dfn:`using freed memory`. Ma to tak samo złe "
"konsekwencje jak odwołanie się do niezainicjowanych danych --- zrzuty jądra, "
"złe wyniki, tajemnicze zatrzymania programu."

msgid "Common causes of memory leaks are unusual paths through the code.  For instance, a function may allocate a block of memory, do some calculation, and then free the block again.  Now a change in the requirements for the function may add a test to the calculation that detects an error condition and can return prematurely from the function.  It's easy to forget to free the allocated memory block when taking this premature exit, especially when it is added later to the code.  Such leaks, once introduced, often go undetected for a long time: the error exit is taken only in a small fraction of all calls, and most modern machines have plenty of virtual memory, so the leak only becomes apparent in a long-running process that uses the leaking function frequently.  Therefore, it's important to prevent leaks from happening by having a coding convention or strategy that minimizes this kind of errors."
msgstr ""
"Typowymi przyczynami wycieków pamięci są nietypowe ścieżki przejścia przez "
"kod. Dla przykładu, zadanie może zaalokować blok pamięci, wykonać pewne "
"obliczenia, a potem uwolnić ten blok jeszcze raz. Teraz zmiana w wymaganiach "
"dla zadania może dodać test do obliczenia który wykrywa warunek błędu i "
"może wrócić wcześniej z zadania. Łatwo jest zapomnieć aby uwolnić "
"zaalokowany blok pamięci podczas wybierania tej drogi wcześniejszego "
"zakończenia, szczególnie gdy jest dodawane później do kodu. Takie przecieki, "
"gdy raz wprowadzone, często uchodzą niewykryte przez długi czas: błędne "
"wyjście jest wybierane tylko w małym wycinku wszystkich wywołań, i większość "
"nowoczesnych maszyn ma mnóstwo wirtualnej pamięci, tak że wyciek staje się "
"widoczny tylko w długo działającym procesie który używa cieknącego zadania "
"często. Dlatego też, jest to ważne aby zapobiegać wyciekom przed ich "
"nastąpieniem, przez powzięcie konwencji kodowania lub strategii która "
"minimalizuje ten rodzaj błędu."

msgid "Since Python makes heavy use of :cfunc:`malloc` and :cfunc:`free`, it needs a strategy to avoid memory leaks as well as the use of freed memory.  The chosen method is called :dfn:`reference counting`.  The principle is simple: every object contains a counter, which is incremented when a reference to the object is stored somewhere, and which is decremented when a reference to it is deleted. When the counter reaches zero, the last reference to the object has been deleted and the object is freed."
msgstr ""
"Skoro język pytonowski często używa :cfunc:`malloc` i :cfunc:`free`, "
"wymagana jest strategia aby omijać wycieki pamięci zarówno jak też użycia "
"uwolnionej pamięci. Wybrana metoda jest zwana :dfn:`zliczaniem odniesień` - "
"z ang. :dfn:`reference counting`. Zasada jest prosta: każdy przedmiot "
"zawiera licznik, który jest zwiększany gdy odniesienie do przedmiotu jest "
"zachowywane gdzieś, i który jest zmniejszany gdy odniesienie do niego jest "
"kasowane. Gdy licznik dotrze do zera, ostatnie odniesienie do przedmiotu "
"zostało skasowane i przedmiot jest uwalniany."

msgid "An alternative strategy is called :dfn:`automatic garbage collection`. (Sometimes, reference counting is also referred to as a garbage collection strategy, hence my use of \"automatic\" to distinguish the two.)  The big advantage of automatic garbage collection is that the user doesn't need to call :cfunc:`free` explicitly.  (Another claimed advantage is an improvement in speed or memory usage --- this is no hard fact however.)  The disadvantage is that for C, there is no truly portable automatic garbage collector, while reference counting can be implemented portably (as long as the functions :cfunc:`malloc` and :cfunc:`free` are available --- which the C Standard guarantees). Maybe some day a sufficiently portable automatic garbage collector will be available for C. Until then, we'll have to live with reference counts."
msgstr ""
"Alternatywna strategia jest zwana :dfn:`automatyczną zbiórką śmieci`. "
"(Czasami, do zliczania odniesień także odnosimy się jako do strategii "
"zbierania śmieci, stąd moje użycie określenia \"automatycznej\" aby odróżnić "
"je między sobą.) Dużą zaletą automatycznej zbiórki śmieci jest to, że "
"użytkownik nie musi wzywać zadania :cfunc:`free` jawnie. (Inną utrzymywaną "
"zaletą jest usprawnienie w prędkości użycia pamięci --- nie jest to jednak "
"twardy fakt.) Wadą jest to że dla C nie ma prawdziwie przenośnego "
"automatycznego zbieracza śmieci, podczas gdy zliczanie odniesień może być "
"wypełnione przenośnie (tak długo, jak dostępne są zadania :cfunc:`malloc` i "
":cfunc:`free` --- co gwarantuje standard C). Może pewnego dnia wystarczająco "
"przenośny automatyczny zbieracz śmieci będzie dostępny dla C. Jednak do "
"tego czasu, będziemy musieli żyć ze zliczaniem odniesień."

msgid "While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles.  This allows applications to not worry about creating direct or indirect circular references; these are the weakness of garbage collection implemented using only reference counting.  Reference cycles consist of objects which contain (possibly indirect) references to themselves, so that each object in the cycle has a reference count which is non-zero.  Typical reference counting implementations are not able to reclaim the memory belonging to any objects in a reference cycle, or referenced from the objects in the cycle, even though there are no further references to the cycle itself."
msgstr ""
"Podczas gdy język pytonowski używa tradycyjnego wypełnienia zliczania "
"odniesień, on także oferuje wykrywanie cykli, które pracuje aby wykrywać "
"cykliczne odniesienia. To pozwala aplikacjom nie martwić się o tworzenie "
"bezpośrednich lub pośrednich cyklicznych odniesień; to są słabości "
"wypełnienia zbiórki śmieci opartego jedynie na zliczaniu odniesień. Cykle "
"odniesień składają się z przedmiotów które zawierają (możliwie pośrednio) "
"odniesienia do samych siebie, tak że każdy przedmiot w cyklu ma liczbę "
"odniesień która jest nie-zerowa. Typowe wypełnienia zliczające odniesienia "
"nie są w stanie przejąć z powrotem pamięci należącej do któregokolwiek z "
"przedmiotów w cyklu odniesień, ani do której odnosi się któryś z przedmiotów "
"w cyklu, nawet jeśli nie ma więcej odniesień do cyklu samego w sobie."

msgid "The cycle detector is able to detect garbage cycles and can reclaim them so long as there are no finalizers implemented in Python (:meth:`__del__` methods). When there are such finalizers, the detector exposes the cycles through the :mod:`gc` module (specifically, the ``garbage`` variable in that module).  The :mod:`gc` module also exposes a way to run the detector (the :func:`collect` function), as well as configuration interfaces and the ability to disable the detector at runtime.  The cycle detector is considered an optional component; though it is included by default, it can be disabled at build time using the :option:`--without-cycle-gc` option to the :program:`configure` script on Unix platforms (including Mac OS X).  If the cycle detector is disabled in this way, the :mod:`gc` module will not be available."
msgstr ""
"Wykrywacz cyklów jest w stanie wykryć cykle śmieci i przejąć je tak długo "
"jak nie ma sposobów postępowania zakańczających życie przedmiotów "
"wypełnionych w języku pytonowskim (sposobów postępowania :meth:`__del__`). "
"Gdy są takie sposoby postępowania zakańczające życie przedmiotów, wykrywacz "
"cyklów wystawia cykle przez moduł :mod:`gc` (szczególnie, przez zmienną "
"``śmieci`` w tym module). Moduł :mod:`gc` także wystawia sposób aby "
"uruchomić wykrywacz cykli (zadaniem :func:`collect`), zarówno, jak też "
"sprzęgi i możliwość wyłączenia wykrywacza w czasie wykonania programów. "
"Wykrywacz cykli jest uznawany za dodatkowy (ponadprogramowy) element; "
"chociaż jest załączony domyślnie, może być wyłączony w czasie budowania przy "
"użyciu opcji :option:`--without-cycle-gc` dla skryptu :program:`configure` "
"na maszynie/środowisku Unix-owym (włączając w to Mac OS X). Jeśli wykrywacz "
"cykli zostanie wyłączony w ten sposób, moduł :mod:`gc` nie będzie dostępny."

msgid "Reference Counting in Python"
msgstr "Zliczanie odniesień w języku pytonowskim"

msgid "There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle the incrementing and decrementing of the reference count. :cfunc:`Py_DECREF` also frees the object when the count reaches zero. For flexibility, it doesn't call :cfunc:`free` directly --- rather, it makes a call through a function pointer in the object's :dfn:`type object`.  For this purpose (and others), every object also contains a pointer to its type object."
msgstr ""
"Istnieją dwa makropolecenia, ``Py_INCREF(x)`` i ``Py_DECREF(x)``, które "
"obsługują zwiększanie i zmniejszanie liczby odniesień. :cfunc:`Py_DECREF` "
"uwalnia także przedmiot gdy liczba odniesień dotrze do zera. Dla "
"elastyczności, nie wzywa się zadania :cfunc:`free` bezpośrednio --- zamiast "
"tego, wykonuje się wywołanie zadania przez wskaźnik zadania, w :dfn:`typie "
"przedmiotu` - z ang. :dfn:`type object` należącym do przedmiotu. Dla tego "
"celu (i innych), każdy przedmiot także zawiera wskaźnik do swojego rodzaju "
"przedmiotu."

msgid "The big question now remains: when to use ``Py_INCREF(x)`` and ``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an object; however, you can :dfn:`own a reference` to an object.  An object's reference count is now defined as the number of owned references to it.  The owner of a reference is responsible for calling :cfunc:`Py_DECREF` when the reference is no longer needed.  Ownership of a reference can be transferred.  There are three ways to dispose of an owned reference: pass it on, store it, or call :cfunc:`Py_DECREF`. Forgetting to dispose of an owned reference creates a memory leak."
msgstr ""
"Wielkie pytanie teraz pozostaje: kiedy używać ``Py_INCREF(x)`` i "
"``Py_DECREF(x)``? Wprowadźmy najpierw kilka terminów. Nikt nie \"posiada\" "
"przedmiotu; jednakże można :dfn:`posiadać odniesienie` do przedmiotu. Liczba "
"odniesień do przedmiotu jest teraz określona jako liczba posiadanych "
"odniesień do niego. Właściciel odniesienia jest odpowiedzialny za wezwanie "
"zadania :cfunc:`Py_DECREF` gdy odniesienie nie jest już dłużej potrzebne. "
"Bycie właścicielem odniesienia może być przenoszone. Istnieją trzy sposoby "
"aby pozbyć się posiadanego odniesienia: przekazać je, zachować je lub "
"wywołać zadanie :cfunc:`Py_DECREF`. Zapominanie o pozbyciu się posiadanego "
"odniesienia tworzy wyciek pamięci."

msgid "It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The borrower of a reference should not call :cfunc:`Py_DECREF`.  The borrower must not hold on to the object longer than the owner from which it was borrowed. Using a borrowed reference after the owner has disposed of it risks using freed memory and should be avoided completely. [#]_"
msgstr ""
"Jest także możliwe :dfn:`pożyczanie` [#]_ - z ang. - :dfn:`borrow` [#]_ "
"odniesienia do przedmiotu. Pożyczający odniesienie nie powinien wzywać "
":cfunc:`Py_DECREF`. Pożyczającemu nie wolno trzymać się przedmiotu dłużej "
"niż właścicielowi od którego przedmiot został pożyczony. Używanie "
"pożyczonego odniesienia po tym jak właściciel się go pozbył ryzykuje "
"używaniem uwolnionej pamięci i powinno być unikane całkowicie. [#]_"

msgid "The advantage of borrowing over owning a reference is that you don't need to take care of disposing of the reference on all possible paths through the code --- in other words, with a borrowed reference you don't run the risk of leaking when a premature exit is taken.  The disadvantage of borrowing over owning is that there are some subtle situations where in seemingly correct code a borrowed reference can be used after the owner from which it was borrowed has in fact disposed of it."
msgstr ""
"Zaletą pożyczania ponad posiadaniem odniesienia jest to że nie potrzebujesz "
"zaprzątać swojej uwagi pozbyciem się odniesienia na wszystkich możliwych "
"ścieżkach przejścia przez kod --- innymi słowy, z pożyczonym odniesieniem "
"nie musisz ryzykować wycieku gdy nastąpi przedwczesne wyjście z programu. "
"Wadą pożyczania ponad posiadaniem jest to że istnieją pewne szczególne "
"sytuacje gdzie w wydawałoby się poprawnym kodzie pożyczone odniesienie może "
"być użyte po tym jak właściciel od którego zostało ono pożyczone faktycznie "
"pozbył się go."

msgid "A borrowed reference can be changed into an owned reference by calling :cfunc:`Py_INCREF`.  This does not affect the status of the owner from which the reference was borrowed --- it creates a new owned reference, and gives full owner responsibilities (the new owner must dispose of the reference properly, as well as the previous owner)."
msgstr ""
"Pożyczone odniesienie może być zamienione na posiadane odniesienie przez "
"wezwanie :cfunc:`Py_INCREF`. To nie wpływa na status właściciela od którego "
"odniesienie zostało pożyczone --- to tworzy nowe posiadane odniesienie, i "
"daje pełne prawa i obowiązki właścicielskie (nowy właściciel musi pozbyć się "
"odniesienia we właściwy sposób, tak jak poprzedni właściciel)."

msgid "Ownership Rules"
msgstr "Zasady właścicielskie"

msgid "Whenever an object reference is passed into or out of a function, it is part of the function's interface specification whether ownership is transferred with the reference or not."
msgstr ""
"Zawsze gdy odniesienie do przedmiotu jest przekazywane do lub z zadania, "
"jest częścią specyfiki sprzęgu zadania to czy własność jest przekazywana z "
"odniesieniem czy też nie."

msgid "Most functions that return a reference to an object pass on ownership with the reference.  In particular, all functions whose function it is to create a new object, such as :cfunc:`PyLong_FromLong` and :cfunc:`Py_BuildValue`, pass ownership to the receiver.  Even if the object is not actually new, you still receive ownership of a new reference to that object.  For instance, :cfunc:`PyLong_FromLong` maintains a cache of popular values and can return a reference to a cached item."
msgstr ""
"Większość zadań które zwracają odniesienie do przedmiotu przekazuje prawo "
"własności wraz z odniesieniem. W szczególności, wszystkie zadania których "
"celem jest tworzenie nowych przedmiotów, takich jak :cfunc:`PyLong_FromLong` "
"i :cfunc:`Py_BuildValue`, przekazują prawo własności do odbierającego. "
"Nawet jeśli przedmiot nie jest właściwie nowy, wciąż otrzymujesz własność "
"nowego odniesienia do tego przedmiotu. Dla przykładu, "
":cfunc:`PyLong_FromLong` utrzymuje pamięć podręczną popularnych wartości i "
"może zwrócić odniesienie do przedmiotów trzymanych w pamięci podręcznej."

msgid "Many functions that extract objects from other objects also transfer ownership with the reference, for instance :cfunc:`PyObject_GetAttrString`.  The picture is less clear, here, however, since a few common routines are exceptions: :cfunc:`PyTuple_GetItem`, :cfunc:`PyList_GetItem`, :cfunc:`PyDict_GetItem`, and :cfunc:`PyDict_GetItemString` all return references that you borrow from the tuple, list or dictionary."
msgstr ""
"Wiele zadań które wydobywają przedmioty z innych przedmiotów także "
"przekazuje własność z odniesieniem, na przykład "
":cfunc:`PyObject_GetAttrString`. Obraz jest mniej jasny, tutaj, jednakże, "
"gdyż kilka typowych zadań jest wyjątkami: :cfunc:`PyTuple_GetItem`, "
":cfunc:`PyList_GetItem`, :cfunc:`PyDict_GetItem`, i "
":cfunc:`PyDict_GetItemString` wszystkie zwracają odniesienia które pożyczasz "
"z krotki, listy lub słownika."

msgid "The function :cfunc:`PyImport_AddModule` also returns a borrowed reference, even though it may actually create the object it returns: this is possible because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
"Zadanie :cfunc:`PyImport_AddModule` także zwraca pożyczone odniesienia, "
"nawet jeśli może to właściwie tworzyć przedmiot który zwraca: jest to "
"możliwe, ponieważ posiadane odniesienie do przedmiotu jest przechowywane w "
"``sys.modules``."

msgid "When you pass an object reference into another function, in general, the function borrows the reference from you --- if it needs to store it, it will use :cfunc:`Py_INCREF` to become an independent owner.  There are exactly two important exceptions to this rule: :cfunc:`PyTuple_SetItem` and :cfunc:`PyList_SetItem`.  These functions take over ownership of the item passed to them --- even if they fail!  (Note that :cfunc:`PyDict_SetItem` and friends don't take over ownership --- they are \"normal.\")"
msgstr ""
"Gdy przekazujesz odniesienie do przedmiotu dla innego zadania, z reguły, "
"zadanie pożycza odniesienie od ciebie --- jeśli potrzebuje zachować je, "
"użyje :cfunc:`Py_INCREF` aby zostać niezależnym właścicielem. Istnieją "
"dokładnie dwa istotne wyjątki od tej reguły: zadania "
":cfunc:`PyTuple_SetItem` i :cfunc:`PyList_SetItem`. Te zadania przejmują "
"prawo własności przedmiotów przekazywanych im --- nawet jeśli zawiodą! "
"(Zauważ, że :cfunc:`PyDict_SetItem i jego przyjaciele nie przejmują "
"własności --- one są \"normalne.\")"

msgid "When a C function is called from Python, it borrows references to its arguments from the caller.  The caller owns a reference to the object, so the borrowed reference's lifetime is guaranteed until the function returns.  Only when such a borrowed reference must be stored or passed on, it must be turned into an owned reference by calling :cfunc:`Py_INCREF`."
msgstr ""
"Gdy zadanie C jest wzywane z poziomu języka pytonowskiego, pożycza ono "
"odniesienia do swoich parametrów od wzywającego. Wywołujący posiada "
"odniesienia do przedmiotu, tak więc istnienie pożyczonych odniesień jest "
"gwarantowane aż do powrotu z zadania. Tylko gdy tak pożyczone odniesienie "
"musi być zachowane lub przekazane, musi ono być zamienione w posiadane "
"odniesienie przez wywołanie makropolecenia :cfunc:`Py_INCREF`."

msgid "The object reference returned from a C function that is called from Python must be an owned reference --- ownership is transferred from the function to its caller."
msgstr ""
"Odniesienie do przedmiotu zwrócone z zadania C które jest wywołane z poziomu "
"języka pytonowskiego musi być posiadanym odniesieniem --- prawo własności "
"jest przekazywane z zadania do wywołującego to ostatnie."

msgid "Thin Ice"
msgstr "Cienki lód"

msgid "There are a few situations where seemingly harmless use of a borrowed reference can lead to problems.  These all have to do with implicit invocations of the interpreter, which can cause the owner of a reference to dispose of it."
msgstr ""
"Istnieje kilka sytuacji gdzie wydawałoby się nieszkodliwe użycie pożyczonych "
"odniesień może prowadzić do kłopotów. Wszystkie one mają do czynienia z "
"niejawnymi wezwaniami programu interpretującego polecenia języka "
"pytonowskiego, które mogą powodować że właściciel odniesienia pozbędzie się "
"go."

msgid "The first and most important case to know about is using :cfunc:`Py_DECREF` on an unrelated object while borrowing a reference to a list item.  For instance::"
msgstr ""
"Pierwszym i najbardziej istotnym przypadkiem o którym warto wiedzieć jest "
"użycie :cfunc:`Py_DECREF` na niezwiązanym przedmiocie podczas pożyczania "
"odniesienia do elementu listy. Na przykład::"

msgid "void bug(PyObject *list) {     PyObject *item = PyList_GetItem(list, 0);      PyList_SetItem(list, 1, PyLong_FromLong(0L));     PyObject_Print(item, stdout, 0); /* BUG! */ }"
msgstr ""
"void bug(PyObject *list) {     PyObject *element = PyList_GetItem(list, 0); "
"     PyList_SetItem(list, 1, PyLong_FromLong(0L));     "
"PyObject_Print(element, stdout, 0); /* BŁĄD! */ }"

msgid "This function first borrows a reference to ``list[0]``, then replaces ``list[1]`` with the value ``0``, and finally prints the borrowed reference. Looks harmless, right?  But it's not!"
msgstr ""
"To zadanie najpierw pożycza odniesienie do ``list[0]``, potem zamienia "
"``list[1] na wartość ``0``, i ostatecznie wypisuje pożyczone odniesienie. "
"Wydaje się nieszkodliwe, czyż nie? A jednak jest!"

msgid "Let's follow the control flow into :cfunc:`PyList_SetItem`.  The list owns references to all its items, so when item 1 is replaced, it has to dispose of the original item 1.  Now let's suppose the original item 1 was an instance of a user-defined class, and let's further suppose that the class defined a :meth:`__del__` method.  If this class instance has a reference count of 1, disposing of it will call its :meth:`__del__` method."
msgstr ""
"Prześledźmy przepływ wykonania wchodzący do :cfunc:`PyList_SetItem`. Lista "
"posiada odniesienia do wszystkich swoich elementów, więc gdy element "
"pierwszy jest zamieniany, musi pozbyć się pierwotnego elementu pierwszego. A "
"teraz załóżmy, że pierwotny element pierwszy był przykładem zdefiniowanego-"
"przez-użytkownika uogólnienia, i załóżmy także że uogólnienie określało "
"sposób postępowania :meth:`__del__`. Jeśli ten przykład uogólnienia miał "
"liczbę odniesień równą jeden, pozbywając się go wywoła on swój sposób "
"postępowania :meth:`__del__`."

msgid "Since it is written in Python, the :meth:`__del__` method can execute arbitrary Python code.  Could it perhaps do something to invalidate the reference to ``item`` in :cfunc:`bug`?  You bet!  Assuming that the list passed into :cfunc:`bug` is accessible to the :meth:`__del__` method, it could execute a statement to the effect of ``del list[0]``, and assuming this was the last reference to that object, it would free the memory associated with it, thereby invalidating ``item``."
msgstr ""
"Ponieważ jest to napisane w języku pytonowskim, sposób postępowania "
":meth:`__del__` może wykonać dowolny kod języka pytonowskiego. Mógłby być "
"może zrobić coś, co unieważniłoby odniesienie do ``elementu`` w zadaniu "
":cfunc:`bug`? Można się założyć że tak! Przyjmując założenie, że lista "
"przekazana do zadania :cfunc:`bug` jest dostępna dla sposobu postępowania "
":meth:`__del__, mogłoby wykonać wyrażenie efektywnego ``del list[0]`` i "
"zakładając że to było ostatnie odniesienie do tego przedmiotu, to uwolniłoby "
"pamięć związaną z nią, tym samym unieważniając ``element``."

msgid "The solution, once you know the source of the problem, is easy: temporarily increment the reference count.  The correct version of the function reads::"
msgstr ""
"Rozwiązanie, gdy znasz już źródło problemu, jest łatwe: tymczasowo zwiększyć "
"ilość odniesień. Poprawna wersja zadania równa jest::"

msgid "void no_bug(PyObject *list) {     PyObject *item = PyList_GetItem(list, 0);      Py_INCREF(item);     PyList_SetItem(list, 1, PyLong_FromLong(0L));     PyObject_Print(item, stdout, 0);     Py_DECREF(item); }"
msgstr ""
"void no_bug(PyObject *list) {     PyObject *element = PyList_GetItem(list, "
"0);      Py_INCREF(element);     PyList_SetItem(list, 1, "
"PyLong_FromLong(0L));     PyObject_Print(element, stdout, 0);     "
"Py_DECREF(element); }"

msgid "This is a true story.  An older version of Python contained variants of this bug and someone spent a considerable amount of time in a C debugger to figure out why his :meth:`__del__` methods would fail..."
msgstr ""
"To jest prawdziwa historia. Starsza wersja języka pytonowskiego zawierała "
"warianty tego błędu i ktoś spędził zdrowy kawałek czasu w debugerze C aby "
"dowiedzieć się czemu jegosposoby postępowania :meth:`__del__` zawodziły..."

msgid "The second case of problems with a borrowed reference is a variant involving threads.  Normally, multiple threads in the Python interpreter can't get in each other's way, because there is a global lock protecting Python's entire object space.  However, it is possible to temporarily release this lock using the macro :cmacro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it using :cmacro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O calls, to let other threads use the processor while waiting for the I/O to complete. Obviously, the following function has the same problem as the previous one::"
msgstr ""
"Drugim przypadkiem problemów z pożyczonym odniesieniem jest wariant "
"zajmujący się wątkami. Zwykle, wiele wątków w programie interpretującym "
"polecenia języka pytonowskiego nie może wchodzić sobie nawzajem w drogę, "
"ponieważ istnieje nadrzędna blokada chroniąca całą przestrzeń przedmiotów "
"języka pytonowskiego. Jednakże, jest możliwe tymczasowo zwolnić tą blokadę "
"używając makropolecenia :cmacro:`Py_BEGIN_ALLOW_THREADS`, i ponownie je "
"przejąć używając :cmacro:`Py_END_ALLOW_THREADS`. To jest częste przy "
"blokowaniu wywołań wejścia/wyjścia, aby pozwalać innym wątkom używać "
"procesora czekając na wejście/wyjście aby zostało zakończone. Oczywiste "
"jest, że następujące zadanie ma ten sam problem co poprzednie::"

msgid "void bug(PyObject *list) {     PyObject *item = PyList_GetItem(list, 0);     Py_BEGIN_ALLOW_THREADS     ...some blocking I/O call...     Py_END_ALLOW_THREADS     PyObject_Print(item, stdout, 0); /* BUG! */ }"
msgstr ""
"void bug(PyObject *list) {     PyObject *element = PyList_GetItem(list, 0); "
"    Py_BEGIN_ALLOW_THREADS     ...pewne operacje blokujące we/wy...     "
"Py_END_ALLOW_THREADS     PyObject_Print(element, stdout, 0); /* BŁĄD! */ }"

msgid "NULL Pointers"
msgstr "Puste wskaźniki (NULL)"

msgid "In general, functions that take object references as arguments do not expect you to pass them *NULL* pointers, and will dump core (or cause later core dumps) if you do so.  Functions that return object references generally return *NULL* only to indicate that an exception occurred.  The reason for not testing for *NULL* arguments is that functions often pass the objects they receive on to other function --- if each function were to test for *NULL*, there would be a lot of redundant tests and the code would run more slowly."
msgstr ""
"Zwykle, zadania, które pobierają odniesienia do przedmiotów jako parametry "
"nie oczekują abyś przekazywał im puste (*NULL*) wskaźniki, i zrzucą jądro "
"(lub spowodują późniejsze zrzucenie jądra) jeśli to wykonasz. Zadania które "
"zwracają odniesienia do przedmiotu zwykle zwracają *NULL* tylko aby "
"zaznaczyć że nastąpił wyjątek. Przyczyną nie sprawdzania parametrów czy są "
"*NULL* jest to, że zadania często przekazują przedmioty które otrzymują "
"dalej do innych zadań --- jeśli każde zadanie miałoby sprawdzać czy jego "
"parametry są *NULL*, byłoby mnóstwo nadmiarowych testów i kod działałby dużo "
"wolniej."

msgid "It is better to test for *NULL* only at the \"source:\" when a pointer that may be *NULL* is received, for example, from :cfunc:`malloc` or from a function that may raise an exception."
msgstr ""
"Jest lepiej sprawdzać czy jest *NULL* tylko u \"źródła:\" gdy wskaźnik, który "
"mógłby być *NULL* jest otrzymywany, na przykład, z :cfunc:`malloc` lub z "
"zadania które mogłoby zgłosić wyjątek."

msgid "The macros :cfunc:`Py_INCREF` and :cfunc:`Py_DECREF` do not check for *NULL* pointers --- however, their variants :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF` do."
msgstr ""
"Makropolecenia :cfunc:`Py_INCREF` i :cfunc:`Py_DECREF` nie sprawdzają "
"wskaźników *NULL* --- jednakże w ich odmianie :cfunc:Py_XINCREF` i "
":cfunc:`Py_XDECREF` sprawdzają."

msgid "The macros for checking for a particular object type (``Pytype_Check()``) don't check for *NULL* pointers --- again, there is much code that calls several of these in a row to test an object against various different expected types, and this would generate redundant tests.  There are no variants with *NULL* checking."
msgstr ""
"Makropolecenia dla sprawdzenia szczególnego rodzaju "
"przedmiotu(``Pytype_Check()``) nie sprawdzają pustych (*NULL*) wskaźników "
"--- znów, istnieje dużo kodu który wywołuje kilka z tych w rzędzie aby "
"sprawdzić czy przedmiot jest typu jednego z kilku różnych oczekiwanych, i to "
"powodowałoby nadmiarowe sprawdzenia. Nie ma wariantu ze sprawdzaniem "
"*NULL*."

msgid "The C function calling mechanism guarantees that the argument list passed to C functions (``args`` in the examples) is never *NULL* --- in fact it guarantees that it is always a tuple. [#]_"
msgstr ""
"Mechanizm wywołań zadań z języka C gwarantuje, że lista parametrów "
"przekazywana do zadania C (``args`` w przykładach) nigdy nie jest *NULL* --- "
"faktycznie gwarantuje że to zawsze jest krotka. [#]_  "

msgid "It is a severe error to ever let a *NULL* pointer \"escape\" to the Python user."
msgstr ""
"Jest to poważnym błędem aby pozwolić aby pusty *NULL* wskaźnik \"uciekł\" do "
"użytkownika języka pytonowskiego."

msgid "Writing Extensions in C++"
msgstr "Pisanie rozszerzeń w C++"

msgid "It is possible to write extension modules in C++.  Some restrictions apply.  If the main program (the Python interpreter) is compiled and linked by the C compiler, global or static objects with constructors cannot be used.  This is not a problem if the main program is linked by the C++ compiler.  Functions that will be called by the Python interpreter (in particular, module initialization functions) have to be declared using ``extern \"C\"``. It is unnecessary to enclose the Python header files in ``extern \"C\" {...}`` --- they use this form already if the symbol ``__cplusplus`` is defined (all recent C++ compilers define this symbol)."
msgstr ""
"Jest możliwe pisanie modułów rozszerzających w C++. Niektóre ograniczenia "
"obowiązują. Jeśli główny program (program interpretujący polecenia języka "
"pytonowskiego) jest kompilowany i łączony przez kompilator języka C, "
"nadrzędne lub statyczne przedmioty z konstruktorami nie mogą być używane. To "
"nie jest problemem jeśli główny program jest łączony przez kompilator C++. "
"Zadania które będą wezwane przez program interpretujący polecenia języka "
"pytonowskiego (w szczególności, zadania inicjujące moduł) muszą być "
"deklarowane używając ``extern \"C\"``. Nie jest to konieczne aby zawierać plik "
"nagłówkowy języka pytonowskiego w ``extern \"C\" {...}`` --- one używają już "
"tej formy jeśli symbol ``__cplusplus`` jest zdefiniowany (wszystkie niedawne "
"kompilatory C++ definiują ten symbol)."

msgid "Providing a C API for an Extension Module"
msgstr ""
"Dostarczanie sprzęgu programowania aplikacji (API) języka C dla modułu "
"rozszerzającego"

msgid "Many extension modules just provide new functions and types to be used from Python, but sometimes the code in an extension module can be useful for other extension modules. For example, an extension module could implement a type \"collection\" which works like lists without order. Just like the standard Python list type has a C API which permits extension modules to create and manipulate lists, this new collection type should have a set of C functions for direct manipulation from other extension modules."
msgstr ""
"Wiele modułów rozszerzających po prostu dostarcza nowych zadań i typów aby "
"były używane z języka pytonowskiego, ale czasami kod w module rozszerzającym "
"może być użyteczny dla innych rozszerzających modułów. Na przykład, moduł "
"rozszerzający mógłby wypełniać typ \"kolekcji\" który działałby jak lista bez "
"wprowadzonego porządku. Tak jak standardowy typ listy języka pytonowskiego "
"posiada sprzęg programowania aplikacji języka C, który pozwala modułom "
"rozszerzającym tworzenie i zmianę list, ten nowy typ kolekcji powinien mieć "
"zbiór zadań C dla bezpośrednich zmian z innych modułów rozszerzających."

msgid "At first sight this seems easy: just write the functions (without declaring them ``static``, of course), provide an appropriate header file, and document the C API. And in fact this would work if all extension modules were always linked statically with the Python interpreter. When modules are used as shared libraries, however, the symbols defined in one module may not be visible to another module. The details of visibility depend on the operating system; some systems use one global namespace for the Python interpreter and all extension modules (Windows, for example), whereas others require an explicit list of imported symbols at module link time (AIX is one example), or offer a choice of different strategies (most Unices). And even if symbols are globally visible, the module whose functions one wishes to call might not have been loaded yet!"
msgstr ""
"Na pierwszy rzut oka to wydaje się proste: napisać zadania (bez deklarowania "
"ich jako ``statycznych``, oczywiście), dostarczyć odpowiedni plik "
"nagłówkowy, i udokumentować sprzęg programowania aplikacji (API) C. I "
"faktycznie to mogłoby zadziałać jeśli wszystkie rozszerzające moduły byłyby "
"zawsze złączone statycznie z programem interpretującym polecenia języka "
"pytonowskiego. Gdy moduły są używane jako współdzielone biblioteki, "
"jednakże, symbole zdefiniowane w jednym module mogą nie być widoczne dla "
"innych modułów. Szczegóły widoczności zależą od systemu operacyjnego; "
"niektóre systemy używają jednej nadrzędnej przestrzeni nazw dla programu "
"interpretującego polecenia języka pytonowskiego i wszystkich modułów "
"rozszerzających (dla Windows, na przykład), podczas gdy inne wymagają jawnej "
"listy importowanych symboli w czasie łączenia modułów (AIX jest jednym z "
"przykładów), lub oferują wybór różnych strategii (większość Unix-ów). I "
"nawet jeśli symbole są widoczne nadrzędnie, moduł którego zadania ktoś "
"chciałby uruchomić mogły nie zostać jeszcze załadowane! "

msgid "Portability therefore requires not to make any assumptions about symbol visibility. This means that all symbols in extension modules should be declared ``static``, except for the module's initialization function, in order to avoid name clashes with other extension modules (as discussed in section :ref:`methodtable`). And it means that symbols that *should* be accessible from other extension modules must be exported in a different way."
msgstr ""
"Przenośność zatem wymaga aby nie czynić żadnych założeń o widoczności "
"symboli. To oznacza, że wszystkie symbole w rozszerzających modułach powinny "
"być deklarowane jako ``statyczne``, z wyjątkiem zadania zainicjowania "
"modułu, w celu ominięcia wojen nazw z innymi modułami rozszerzającymi (jak "
"określono w rozdziale :ref:`methodtable` - z ang. - :ref:`tabela sposobów "
"postępowania`). I to oznacza, że symbole, które *powinny* być dostępne z "
"innych rozszerzających modułów muszą być eksportowane w różny sposób."

msgid "Python provides a special mechanism to pass C-level information (pointers) from one extension module to another one: Capsules. A Capsule is a Python data type which stores a pointer (:ctype:`void \\*`).  Capsules can only be created and accessed via their C API, but they can be passed around like any other Python object. In particular,  they can be assigned to a name in an extension module's namespace. Other extension modules can then import this module, retrieve the value of this name, and then retrieve the pointer from the Capsule."
msgstr ""
"Język pytonowski dostarcza specjalny mechanizm aby przekazać informację na-"
"poziomie-języka-C (wskaźniki) z jednego rozszerzenia do innego: Kapsuły. "
"Kapsuły są typem danych języka pytonowskiego, które przechowują wskaźnik "
"(:ctype:`void \\*`). Kapsuły mogą tylko być tworzone i dostęp do nich może "
"tylko być otrzymywany przez ich sprzęg programowania aplikacji (API) C, ale "
"one nie mogą być przekazywane postronnie jak inne przedmioty języka "
"pytonowskiego. W szczególności, mogą być przypisane do nazwy w przestrzeni "
"nazw modułu rozszerzającego. Inne rozszerzające moduły mogą wtedy importować "
"ten moduł, odebrać wartość tej nazwy, i wtedy odebrać wskaźnik z kapsuły."

msgid "There are many ways in which Capsules can be used to export the C API of an extension module. Each function could get its own Capsule, or all C API pointers could be stored in an array whose address is published in a Capsule. And the various tasks of storing and retrieving the pointers can be distributed in different ways between the module providing the code and the client modules."
msgstr ""
"Istnieje wiele sposobów w jakie kapsuły mogą być używane aby wystawiać na "
"zewnątrz sprzęgi programowania aplikacji (API) języka C dla danego modułu "
"rozszerzającego. Każde zadanie mogłoby dostać swoją własną kapsułę, lub "
"wszystkie wskaźniki sprzęgu programowania aplikacji (API) języka C mogłyby "
"być zachowane w tabeli której adres byłby opublikowany w kapsule. A różne "
"zadania zachowania i odbioru wskaźników mogłyby być rozprowadzone na różne "
"sposoby pomiędzy moduły dostarczające kod i moduły odbierające."

msgid "Whichever method you choose, it's important to name your Capsules properly. The function :cfunc:`PyCapsule_New` takes a name parameter (:ctype:`const char \\*`); you're permitted to pass in a *NULL* name, but we strongly encourage you to specify a name.  Properly named Capsules provide a degree of runtime type-safety; there is no feasible way to tell one unnamed Capsule from another."
msgstr ""
"Którejkolwiek metody nie wybrałbyś, jest istotne aby nazywać swoje kapsuły "
"odpowiednio. Zadanie :cfunc:`PyCapsule_New` przyjmuje nazwę parametru "
"(:ctype:`const char \\*`); wolno Ci przekazać pustą nazwę *NULL*, ale silnie "
"zachęcamy Cię byś określił nazwę. Poprawnie nazwana kapsuła dostarcza pewien "
"poziom bezpieczeństwa-typów w czasie wykonania; nie ma żadnego możliwego "
"sposobu aby odróżnić jedną nienazwaną kapsułę od drugiej."

msgid "In particular, Capsules used to expose C APIs should be given a name following this convention::"
msgstr ""
"W szczególności, kapsułom używanym do wystawiania sprzęgów programowania "
"aplikacji języka C ( - z ang. - API) powinna być nadana nazwa stosująca się "
"do następującej konwencji::"

msgid "modulename.attributename"
msgstr "modulename.attributename"

msgid "The convenience function :cfunc:`PyCapsule_Import` makes it easy to load a C API provided via a Capsule, but only if the Capsule's name matches this convention.  This behavior gives C API users a high degree of certainty that the Capsule they load contains the correct C API."
msgstr ""
"Zadanie sprzyjania :cfunc:`PyCapsule_Import` czyni łatwym aby ładować sprzęg "
"programowania aplikacji w języku C dostarczony przez kapsułę, ale tylko "
"jeśli nazwa kapsuły pasuje do tej konwencji. To zachowanie daje użytkownikom "
"sprzęgu programowania aplikacji w języku C ( z ang. - API) wysokiego "
"poziomu pewność że kapsuła którą ładują zawiera poprawny sprzęg "
"programowania aplikcji w języku C."

msgid "The following example demonstrates an approach that puts most of the burden on the writer of the exporting module, which is appropriate for commonly used library modules. It stores all C API pointers (just one in the example!) in an array of :ctype:`void` pointers which becomes the value of a Capsule. The header file corresponding to the module provides a macro that takes care of importing the module and retrieving its C API pointers; client modules only have to call this macro before accessing the C API."
msgstr ""
"Następujący przykład demonstruje podejście które nakłada większość "
"obciążenia na piszącym wystawiający na zewnątrz moduł, który jest właściwy "
"dla wspólnie używanych modułów bibliotecznych. On przechowuje wszystkie "
"wskaźniki sprzęgu programowania aplikcaji w języku C ( - z ang. - C API) "
"(tylko jeden w tym przykładzie!) w tabeli wskaźników :ctype:`void`, które "
"stają się wartością kapsuły. Plik nagłówkowy, odpowiadający modułowi "
"dostarcza makropolecenie które zajmuje się  importowaniem modułu i "
"odbieraniem jego wskaźników sprzęgu programowania aplikacji w języku C ( - z "
"ang. - C API); Moduły korzystające muszą tylko wezwać to makropolecenie "
"przed dostępem do sprzęgu programowania aplikacji w języku C ( - z ang. - C "
"API)"

msgid "The exporting module is a modification of the :mod:`spam` module from section :ref:`extending-simpleexample`. The function :func:`spam.system` does not call the C library function :cfunc:`system` directly, but a function :cfunc:`PySpam_System`, which would of course do something more complicated in reality (such as adding \"spam\" to every command). This function :cfunc:`PySpam_System` is also exported to other extension modules."
msgstr ""
"Eksportujący moduł jest modyfikacją modułu :mod:`spam` z sekcji :ref"
":`prosty-przykład-rozszerzania` - z ang - :ref:`extending-simpleexample`. "
"Zadanie :func:`spam.system` nie wzywa zadania bibliotecznego z języka C "
":cfunc:`system` bezpośrednio, ale zadanie :cfunc:`PySpam_System`, który "
"zrobiłby oczywiście coś bardziej skomplikowanego w rzeczywistości (takiego, "
"jak dodanie \"spam\" do każdego polecenia). To zadanie :cfunc:`PySpam_System` "
"jest także wystawiane na zewnątrz do innych modułów rozszerzających."

msgid "The function :cfunc:`PySpam_System` is a plain C function, declared ``static`` like everything else::"
msgstr ""
"Zadanie :cfunc:`PySpam_System` jest czystym zadaniem C, zadeklarowanym "
"statycznie - z ang. - ``static`` jak wszystko inne::"

msgid "static int PySpam_System(const char *command) {     return system(command); }"
msgstr ""
"static int PySpam_System(const char *command) {     return system(command); "
"}"

msgid "The function :cfunc:`spam_system` is modified in a trivial way::"
msgstr "Zadanie :cfunc:`spam_system` jest zmodyfikowane w trywialny sposób::"

msgid "static PyObject * spam_system(PyObject *self, PyObject *args) {     const char *command;     int sts;      if (!PyArg_ParseTuple(args, \"s\", &command))         return NULL;     sts = PySpam_System(command);     return Py_BuildValue(\"i\", sts); }"
msgstr ""
"static PyObject * spam_system(PyObject *self, PyObject *args) {     const "
"char *command;     int sts;      if (!PyArg_ParseTuple(args, \"s\", &command)) "
"        return NULL;     sts = PySpam_System(command);     return "
"Py_BuildValue(\"i\", sts); }"

msgid "In the beginning of the module, right after the line ::"
msgstr "Na początku modułu, zaraz za linią ::"

msgid "#include \"Python.h\""
msgstr "#include \"Python.h\""

msgid "two more lines must be added::"
msgstr "muszą być dodane dwie linie::"

msgid "#define SPAM_MODULE #include \"spammodule.h\""
msgstr "#define SPAM_MODULE #include \"spammodule.h\""

msgid "The ``#define`` is used to tell the header file that it is being included in the exporting module, not a client module. Finally, the module's initialization function must take care of initializing the C API pointer array::"
msgstr ""
"``#define`` jest używane aby przekazać plikowi nagłówkowemu że jest "
"załączany w module wystawianym na zewnątrz, nie w module któremu wszystko "
"służy. Ostatecznie zadanie inicjowania musi zadbać o zainicjowanie tabeli "
"wskaźników sprzęgu programowania aplikacji języka C."

msgid "PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;     static void *PySpam_API[PySpam_API_pointers];     PyObject *c_api_object;      m = PyModule_Create(&spammodule);     if (m == NULL)         return NULL;      /* Initialize the C API pointer array */     PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;      /* Create a Capsule containing the API pointer array's address */     c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", NULL);      if (c_api_object != NULL)         PyModule_AddObject(m, \"_C_API\", c_api_object);     return m; }"
msgstr ""
"PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;     static void "
"*PySpam_API[PySpam_API_pointers];     PyObject *c_api_object;      m = "
"PyModule_Create(&spammodule);     if (m == NULL)         return NULL;      "
"/* Zainicjuj  tabelę wskaźników C API */     PySpam_API[PySpam_System_NUM] = "
"(void *)PySpam_System;      /* Utwórz kapsułę zawierającą adres tabeli "
"wskaźników API */     c_api_object = PyCapsule_New((void *)PySpam_API, "
"\"spam._C_API\", NULL);      if (c_api_object != NULL)         "
"PyModule_AddObject(m, \"_C_API\", c_api_object);     return m; }"

msgid "Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array would disappear when :func:`PyInit_spam` terminates!"
msgstr ""
"Zauważ, że ``PySpam_API`` jest zadeklarowane ``statycznie``; w innym "
"przypadku tabela wskaźników zniknęłaby gdy :func:`PyInit_spam` się zakończy!"

msgid "The bulk of the work is in the header file :file:`spammodule.h`, which looks like this::"
msgstr ""
"Większa część pracy jest wykonywana w pliku nagłówkowym "
":file:`spammodule.h`, który wygląda następująco::"

msgid "#ifndef Py_SPAMMODULE_H #define Py_SPAMMODULE_H #ifdef __cplusplus extern \"C\" { #endif  /* Header file for spammodule */  /* C API functions */ #define PySpam_System_NUM 0 #define PySpam_System_RETURN int #define PySpam_System_PROTO (const char *command)  /* Total number of C API pointers */ #define PySpam_API_pointers 1   #ifdef SPAM_MODULE /* This section is used when compiling spammodule.c */  static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;  #else /* This section is used in modules that use spammodule's API */  static void **PySpam_API;  #define PySpam_System \\  (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])  /* Return -1 on error, 0 on success.  * PyCapsule_Import will set an exception if there's an error.  */ static int import_spam(void) {     PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);     return (PySpam_API != NULL) ? 0 : -1; }  #endif  #ifdef __cplusplus } #endif  #endif /* !defined(Py_SPAMMODULE_H) */"
msgstr ""
"#ifndef Py_SPAMMODULE_H #define Py_SPAMMODULE_H #ifdef __cplusplus extern "
"\"C\" { #endif  /* Plik nagłówkowy dla spammodule */  /* Zadania sprzęgu "
"programowania aplikacji w języku C (API) */ #define PySpam_System_NUM 0 "
"#define PySpam_System_RETURN int #define PySpam_System_PROTO (const char "
"*command)  /* Całkowita liczba wskaźników C API */ #define "
"PySpam_API_pointers 1   #ifdef SPAM_MODULE /* Ten rozdział jest używany gdy "
"spammodule.c jest kompilowany*/  static PySpam_System_RETURN PySpam_System "
"PySpam_System_PROTO;  #else /* Ten rozdział jest używany w modułach które "
"używają  API spammodule*/  static void **PySpam_API;  #define PySpam_System "
"\\  (*(PySpam_System_RETURN (*)PySpam_System_PROTO) "
"PySpam_API[PySpam_System_NUM])  /* Zwróć -1 przy błędzie, 0 jako udane "
"działanie.  * PyCapsule_Import ustawi wyjątek jeśli zajdzie błąd.  */ static "
"int import_spam(void) {     PySpam_API = (void "
"**)PyCapsule_Import(\"spam._C_API\", 0);     return (PySpam_API != NULL) ? 0 : "
"-1; }  #endif  #ifdef __cplusplus } #endif  #endif /* "
"!defined(Py_SPAMMODULE_H) */"

msgid "All that a client module must do in order to have access to the function :cfunc:`PySpam_System` is to call the function (or rather macro) :cfunc:`import_spam` in its initialization function::"
msgstr ""
"Wszystkim co moduł klienta musi zrobić aby mieć dostęp do zadania "
":cfunc:`PySpam_System` jest wezwanie zadania (lub raczej makropolecenia) "
":cfunc:`import_spam` w jej zadaniu inicjującym::"

msgid "PyMODINIT_FUNC PyInit_client(void) {     PyObject *m;      m = PyModule_Create(&clientmodule);     if (m == NULL)         return NULL;     if (import_spam() < 0)         return NULL;     /* additional initialization can happen here */     return m; }"
msgstr ""
"PyMODINIT_FUNC PyInit_client(void) {     PyObject *m;      m = "
"PyModule_Create(&clientmodule);     if (m == NULL)         return NULL;     "
"if (import_spam() < 0)         return NULL;     /* dodatkowe zainicjowanie "
"może mieć miejsce tutaj */     return m; }"

msgid "The main disadvantage of this approach is that the file :file:`spammodule.h` is rather complicated. However, the basic structure is the same for each function that is exported, so it has to be learned only once."
msgstr ""
"Główną wadą tego podejścia jest to, że plik :file:`spammodule.h` jest raczej "
"skomplikowany. Jednakże podstawowa struktura jest taka sama dla każdego "
"zadania które jest wystawiane na zewnątrz więc trzeba się tego uczyć tylko "
"raz."

msgid "Finally it should be mentioned that Capsules offer additional functionality, which is especially useful for memory allocation and deallocation of the pointer stored in a Capsule. The details are described in the Python/C API Reference Manual in the section :ref:`capsules` and in the implementation of Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c` in the Python source code distribution)."
msgstr ""
"Ostatecznie warto wspomnieć że kapsuły dają dodatkowe możliwości działania, "
"które są szczególnie użyteczne dla umieszczania i zabierania miejsca w "
"pamięci wskaźników zachowywanych w kapsule. Szczegóły są opisane w "
"podręczniku użytkownika sprzęgu języków C i pytonowskiego w rozdziale "
":ref:`kapsuły` - z ang. - :ref:`capsules` i w wypełnieniu programowym kapsuł "
"(plików :file:`Include/pycapsule.h` i :file:`Objects/pycapsule.c` w "
"dystrybucji źródłowej kodu języka pytonowskiego)."

msgid "Footnotes"
msgstr "Przypisy dolne"

msgid "An interface for this function already exists in the standard module :mod:`os` --- it was chosen as a simple and straightforward example."
msgstr ""
"sprzęg dla tego zadania już istnieje w standardowym module :mod:`os` --- "
"został on wybrany jako prosty i przejrzysty przykład."

msgid "The metaphor of \"borrowing\" a reference is not completely correct: the owner still has a copy of the reference."
msgstr ""
"Metafora \"pożyczania\" odniesienia nie jest do końca poprawna: właściciel "
"wciąż ma kopię odniesienia."

msgid "Checking that the reference count is at least 1 **does not work** --- the reference count itself could be in freed memory and may thus be reused for another object!"
msgstr ""
"Sprawdzanie że liczba odniesień jest przynajmniej 1 **nie działa** --- "
"liczba odniesień sama w sobie może być w uwolnionej pamięci i dlatego może "
"być ponownie użyta dla innego przedmiotu!"

msgid "These guarantees don't hold when you use the \"old\" style calling convention --- this is still found in much existing code."
msgstr ""
"Te gwarancje nie są w mocy gdy używasz \"starego\" sposobu wywoływania --- to "
"jest wciąż znajdowane w dużej części istniejącego kodu."

msgid "Extending and Embedding the Python Interpreter"
msgstr ""
"Rozszerzanie i Załączanie programu interpretującego polecenia języka "
"pytonowskiego."

msgid "Release"
msgstr "Wydanie"

msgid "|version|"
msgstr "|wersja|"

msgid "Date"
msgstr "Data"

msgid "|today|"
msgstr "|dziś|"

msgid "This document describes how to write modules in C or C++ to extend the Python interpreter with new modules.  Those modules can define new functions but also new object types and their methods.  The document also describes how to embed the Python interpreter in another application, for use as an extension language. Finally, it shows how to compile and link extension modules so that they can be loaded dynamically (at run time) into the interpreter, if the underlying operating system supports this feature."
msgstr ""
"Ten dokument opisuje jak pisać moduły w C lub C++ aby rozszerzać program "
"interpretujący polecenia języka pytonowskiego nowymi modułami. Te moduły "
"mogą określać nowe zadania, ale także nowe rodzaje przedmiotów i ich sposoby "
"postępowania. Dokument także opisuje jak załączać program interpretujący "
"polecenia języka pytonowskiego w innej aplikacji, dla użycia jako "
"rozszerzający język. Ostatecznie pokazuje jak kompilować i łączyć "
"rozszerzające moduły tak żeby mogły być ładowane dynamicznie (w czasie "
"wykonania) do programu interpretującego polecenia języka pytonowskiego, "
"jeśli leżący u podstaw system operacyjny wspiera tą możliwość. "

msgid "This document assumes basic knowledge about Python.  For an informal introduction to the language, see :ref:`tutorial-index`.  :ref:`reference-index` gives a more formal definition of the language.  :ref:`library-index` documents the existing object types, functions and modules (both built-in and written in Python) that give the language its wide application range."
msgstr ""
"Ten dokument przyjmuje założenie że znane są podstawy wiedzy o języku "
"pytonowskim. Dla nieformalnego wprowadzenia do języka, zobacz :ref"
":`tutorial-index`. :ref:`reference-index` daje bardziej formalną definicję "
"języka. :ref:`library-index` dokumentuje istniejące typy przedmiotów, zadań "
"i modułów (zarówno wbudowanych jak i napisanych w języku pytonowskim) które "
"dają językowi jego szeroki zakres zastosowań."

msgid "For a detailed description of the whole Python/C API, see the separate :ref:`c-api-index`."
msgstr ""
"Dla szczegółowego opisu całego sprzęgu pomiędzy językami C i pytonowskim, "
"zobacz oddzielny :ref:`c-api-index`."

msgid "Defining New Types"
msgstr "Definiowanie nowych typów"

msgid "As mentioned in the last chapter, Python allows the writer of an extension module to define new types that can be manipulated from Python code, much like strings and lists in core Python."
msgstr ""
"Jak wspomniano w poprzednim rozdziale, język pytonowski pozwala piszącemu "
"moduły rozszerzające definiować nowe typy które mogą być zmieniane z kodu w "
"języku pytonowskim, tak jak ciągi i listy wewnątrz języka pytonowskiego."

msgid "This is not hard; the code for all extension types follows a pattern, but there are some details that you need to understand before you can get started."
msgstr ""
"To nie jest trudne; kod dla wszystkich rodzajów rozszerzeń podąża za "
"wzorcem, ale są pewne szczegóły, które musisz zrozumieć zanim będziesz mógł "
"zacząć."

msgid "The Basics"
msgstr "Podstawy"

msgid "The Python runtime sees all Python objects as variables of type :ctype:`PyObject\\*`.  A :ctype:`PyObject` is not a very magnificent object - it just contains the refcount and a pointer to the object's \"type object\".  This is where the action is; the type object determines which (C) functions get called when, for instance, an attribute gets looked up on an object or it is multiplied by another object.  These C functions are called \"type methods\" to distinguish them from things like ``[].append`` (which we call \"object methods\")."
msgstr ""
"Wykonujący się program języka pytonowskiego widzi wszystkie przedmioty "
"języka pytonowskiego jak zmienne typu :ctype:`PyObject\\*`. :ctype:`PyObject` "
"nie jest zbyt wspaniałym przedmiotem - zawiera on po prostu liczbę "
"odniesień i wskaźnik do \"typu przedmiotu\" przedmiotu. To jest miejsce gdzie "
"coś się dzieje; rodzaj przedmiotu określa które zadania (języka C) są "
"wywoływane kiedy, dla przykładu, atrybut będzie podejrzany na przedmiocie "
"lub będzie pomnożony przez inny przedmiot. Te zadania języka C są nazywane "
"\"sposobami postępowania właściwymi dla typu\" aby odróżnić je od rzeczy "
"takich jak ``[].append`` (które nazywamy \"sposobami postępowania "
"przedmiotów\")."

msgid "So, if you want to define a new object type, you need to create a new type object."
msgstr ""
"Więc, jeśli chcesz określić nowy typ przedmiotu musisz stworzyć nowy "
"przedmiot typu."

msgid "This sort of thing can only be explained by example, so here's a minimal, but complete, module that defines a new type:"
msgstr ""
"Tego rodzaju rzeczy można tylko wyjaśnić na przykładzie, więc tutaj jest "
"minimalny, ale kompletny, moduł który definiuje nowy typ:"

msgid "#include <Python.h>  typedef struct {     PyObject_HEAD     /* Type-specific fields go here. */ } noddy_NoddyObject;  static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */     0,                         /* tp_itemsize */     0,                         /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT,        /* tp_flags */     \"Noddy objects\",           /* tp_doc */ };  static PyModuleDef noddymodule = {     PyModuleDef_HEAD_INIT,     \"noddy\",     \"Example module that creates an extension type.\",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy(void)  {     PyObject* m;      noddy_NoddyType.tp_new = PyType_GenericNew;     if (PyType_Ready(&noddy_NoddyType) < 0)         return NULL;      m = PyModule_Create(&noddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&noddy_NoddyType);     PyModule_AddObject(m, \"Noddy\", (PyObject *)&noddy_NoddyType);     return m; }"
msgstr ""
"#include <Python.h>  typedef struct {     PyObject_HEAD     /* Szczególne-"
"dla-typu pola idą tutaj. */ } noddy_NoddyObject;  static PyTypeObject "
"noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\", "
"            /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */ "
"    0,                         /* tp_itemsize */     0, "
"                        /* tp_dealloc */     0,                         /* "
"tp_print */     0,                         /* tp_getattr */     0, "
"                        /* tp_setattr */     0,                         /* "
"tp_reserved */     0,                         /* tp_repr */     0, "
"                        /* tp_as_number */     0,                         "
"/* tp_as_sequence */     0,                         /* tp_as_mapping */     "
"0,                         /* tp_hash  */     0,                         /* "
"tp_call */     0,                         /* tp_str */     0, "
"                        /* tp_getattro */     0,                         /* "
"tp_setattro */     0,                         /* tp_as_buffer */     "
"Py_TPFLAGS_DEFAULT,        /* tp_flags */     \"Noddy objects\",           /* "
"tp_doc */ };  static PyModuleDef noddymodule = {     PyModuleDef_HEAD_INIT, "
"    \"noddy\",     \"Przykładowy moduł który tworzy typ rozszerzający.\",     "
"-1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy(void)  "
"{     PyObject* m;      noddy_NoddyType.tp_new = PyType_GenericNew;     if "
"(PyType_Ready(&noddy_NoddyType) < 0)         return NULL;      m = "
"PyModule_Create(&noddymodule);     if (m == NULL)         return NULL;      "
"Py_INCREF(&noddy_NoddyType);     PyModule_AddObject(m, \"Noddy\", (PyObject "
"*)&noddy_NoddyType);     return m; }"

msgid "Now that's quite a bit to take in at once, but hopefully bits will seem familiar from the last chapter."
msgstr ""
"To całkiem sporo aby strawić, jak na jeden raz, ale miejmy nadzieję że "
"niektóre fragmenty będą wyglądały znajomo z poprzedniego rozdziału."

msgid "The first bit that will be new is::"
msgstr "Pierwszy fragment który będzie nowy jest::"

msgid "typedef struct {     PyObject_HEAD } noddy_NoddyObject;"
msgstr "typedef struct {     PyObject_HEAD } noddy_NoddyObject;"

msgid "This is what a Noddy object will contain---in this case, nothing more than every Python object contains, namely a refcount and a pointer to a type object.  These are the fields the ``PyObject_HEAD`` macro brings in.  The reason for the macro is to standardize the layout and to enable special debugging fields in debug builds.  Note that there is no semicolon after the ``PyObject_HEAD`` macro; one is included in the macro definition.  Be wary of adding one by accident; it's easy to do from habit, and your compiler might not complain, but someone else's probably will!  (On Windows, MSVC is known to call this an error and refuse to compile the code.)"
msgstr ""
"To jest tym co przedmiot Noddy będzie zawierał --- w tym przypadku, nic "
"więcej poza tym co każdy przedmiot języka pytonowskiego posiada, to jest "
"liczba odniesień i wskaźnik do przedmiotu reprezentującego typ przedmiotu. "
"To są pola które makropolecenie ``PyObject_HEAD`` wprowadza. Powodem "
"makropolecenia jest standaryzacja rozkładu i umożliwienie szczególnych pól "
"dla odpluskwiania w budowach odpluskwiających. Zauważ, że nie ma średnika po "
"makropoleceniu ``PyObject_HEAD``; jeden jest zawarty w definicji "
"makropolecenia. Uważaj też na dodanie jednego przez przypadek; łatwo się "
"pomylić przez nawyk a kompilator nie będzie protestował ale ktoś inny "
"prawdopodobnie będzie! (W Windows, MSVC jest znany z nazywania tego błędem i "
"odmawiania kompilacji kodu.)"

msgid "For contrast, let's take a look at the corresponding definition for standard Python floats::"
msgstr ""
"Dla skontrastowania, zobaczmy odpowiadającą definicję standardowych liczb "
"zmiennoprzecinkowych języka pytonowskiego::"

msgid "typedef struct {     PyObject_HEAD     double ob_fval; } PyFloatObject;"
msgstr "typedef struct {     PyObject_HEAD     double ob_fval; } PyFloatObject;"

msgid "Moving on, we come to the crunch --- the type object. ::"
msgstr "Idąc dalej, dochodzimy do skurczu --- przedmiotu typu. ::"

msgid "static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */     0,                         /* tp_itemsize */     0,                         /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT,        /* tp_flags */     \"Noddy objects\",           /* tp_doc */ };"
msgstr ""
"static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0) "
"    \"noddy.Noddy\",             /* tp_name */     sizeof(noddy_NoddyObject), "
"/* tp_basicsize */     0,                         /* tp_itemsize */     0, "
"                        /* tp_dealloc */     0,                         /* "
"tp_print */     0,                         /* tp_getattr */     0, "
"                        /* tp_setattr */     0,                         /* "
"tp_reserved */     0,                         /* tp_repr */     0, "
"                        /* tp_as_number */     0,                         "
"/* tp_as_sequence */     0,                         /* tp_as_mapping */     "
"0,                         /* tp_hash  */     0,                         /* "
"tp_call */     0,                         /* tp_str */     0, "
"                        /* tp_getattro */     0,                         /* "
"tp_setattro */     0,                         /* tp_as_buffer */     "
"Py_TPFLAGS_DEFAULT,        /* tp_flags */     \"Przedmioty Noddy\",           "
"/* tp_doc */ };"

msgid "Now if you go and look up the definition of :ctype:`PyTypeObject` in :file:`object.h` you'll see that it has many more fields that the definition above.  The remaining fields will be filled with zeros by the C compiler, and it's common practice to not specify them explicitly unless you need them."
msgstr ""
"Teraz jeśli pójdziesz i sprawdzisz definicję :ctype:`PyTypeObject` w pliku "
":file:`object.h` zobaczysz że ma ona dużo więcej pól niż powyższa definicja. "
"Pozostałe pola będą wypełnione zerami przez kompilator języka C, i jest to "
"częstą praktyką nie określać ich jawnie chyba że się ich potrzebuje."

msgid "This is so important that we're going to pick the top of it apart still further::"
msgstr ""
"To jest tak istotne że mamy zamiar rozebrać na części górę tego jeszcze "
"bardziej::"

msgid "PyVarObject_HEAD_INIT(NULL, 0)"
msgstr "PyVarObject_HEAD_INIT(NULL, 0)"

msgid "This line is a bit of a wart; what we'd like to write is::"
msgstr "Ta linia jest nieco jak pryszcz; to co chcielibyśmy napisać to::"

msgid "PyVarObject_HEAD_INIT(&PyType_Type, 0)"
msgstr "PyVarObject_HEAD_INIT(&PyType_Type, 0)"

msgid "as the type of a type object is \"type\", but this isn't strictly conforming C and some compilers complain.  Fortunately, this member will be filled in for us by :cfunc:`PyType_Ready`. ::"
msgstr ""
"jako że typ przedmiotu typu jest \"typem\" ale to nie jest ściśle stosowanie "
"się do C i niektóre kompilatory będą narzekać. Szczęśliwie ten członek "
"będzie wypełniony dla nas przez :cfunc:`PyType_Ready`.::"

msgid "\"noddy.Noddy\",              /* tp_name */"
msgstr "\"noddy.Noddy\",              /* tp_name */"

msgid "The name of our type.  This will appear in the default textual representation of our objects and in some error messages, for example::"
msgstr ""
"Nazwa naszego typu. To pojawi się w domyślnej tekstowej reprezentacji "
"naszego przedmiotu i w niektórych wiadomościach o błędzie, na przykład::"

msgid ">>> \"\" + noddy.new_noddy() Traceback (most recent call last):   File \"<stdin>\", line 1, in ? TypeError: cannot add type \"noddy.Noddy\" to string"
msgstr ""
">>> \"\" + noddy.new_noddy() Wypis śledzenia (najbardziej niedawne wywołanie "
"ostatnie):   File \"<stdin>\", line 1, in ? Błąd Typu: nie można dodać typu "
"\"noddy.Noddy\" do ciągu znaków"

msgid "Note that the name is a dotted name that includes both the module name and the name of the type within the module. The module in this case is :mod:`noddy` and the type is :class:`Noddy`, so we set the type name to :class:`noddy.Noddy`. ::"
msgstr ""
"Zauważ, że nazwa jest nazwą po kropce która zawiera zarówno nazwę modułu i "
"nazwę typu wewnątrz modułu. Modułem w tym przypadku jest  :mod:`noddy` i "
"typem jest :class:`Noddy`, więc ustawiamy nazwę typu uogólnienia na "
":class:`noddy.Noddy`. ::"

msgid "sizeof(noddy_NoddyObject),  /* tp_basicsize */"
msgstr "sizeof(noddy_NoddyObject),  /* tp_basicsize */"

msgid "This is so that Python knows how much memory to allocate when you call :cfunc:`PyObject_New`."
msgstr ""
"To tak, aby język pytonowski wiedział jak dużo pamięci przydzielić gdy "
"wywoływane jest zadanie :cfunc:`PyObject_New`."

msgid "If you want your type to be subclassable from Python, and your type has the same :attr:`tp_basicsize` as its base type, you may have problems with multiple inheritance.  A Python subclass of your type will have to list your type first in its :attr:`__bases__`, or else it will not be able to call your type's :meth:`__new__` method without getting an error.  You can avoid this problem by ensuring that your type has a larger value for :attr:`tp_basicsize` than its base type does.  Most of the time, this will be true anyway, because either your base type will be :class:`object`, or else you will be adding data members to your base type, and therefore increasing its size."
msgstr ""
"Jeśli chcesz aby twój typ uogólnienia był możliwy do wyciągnięcia "
"uogólnienia pochodnego w języku pytonowskim, i twój typ ma ten sam "
":attr:`tp_basicsize` jako jego typ bazowy, możesz mieć problemy z "
"wielokrotnym dziedziczeniem. Podrzędne uogólnienie twojego typu będzie "
"musiało wypisać twój typ na początku w swojej listy :attr:`__bases__`, bo w "
"przeciwnym razie nie będzie w stanie wywołać sposobu postępowania "
":meth:`__new__` należącego do twojego typu bez spowodowania błędu. Można "
"uniknąć tego problemu przez zapewnienie, że twój typ ma większą wartość dla "
":attr:`tp_basicsize` niż jego typ bazowy. W większości przypadków będzie to "
"prawdą tak czy inaczej, gdyż albo twoje uogólnienie bazowe będzie "
"uogólnieniem :class:`object`, lub w przeciwnym wypadku będziesz dodawał "
"członki danych do typu bazowego, i w ten sposób zwiększał jego rozmiar."

msgid "0,                          /* tp_itemsize */"
msgstr "0,                          /* tp_itemsize */"

msgid "This has to do with variable length objects like lists and strings. Ignore this for now."
msgstr ""
"To ma do czynienia ze zmienną długością przedmiotów takich jak listy i ciągi "
"znaków. Pomińmy to na razie."

msgid "Skipping a number of type methods that we don't provide, we set the class flags to :const:`Py_TPFLAGS_DEFAULT`. ::"
msgstr ""
"Pomijając pewną liczbę sposobów postępowania należących do typu których nie "
"dostarczamy, ustawiamy flagi uogólnienia na :const:`Py_TPFLAGS_DEFAULT`. ::"

msgid "Py_TPFLAGS_DEFAULT,        /* tp_flags */"
msgstr "Py_TPFLAGS_DEFAULT,        /* tp_flags */"

msgid "All types should include this constant in their flags.  It enables all of the members defined by the current version of Python."
msgstr ""
"Wszystkie typy powinny zawierać tą stałą w swoich flagach. Ona włącza "
"wszystkie członki określone przez obecną wersję języka pytonowskiego. "

msgid "We provide a doc string for the type in :attr:`tp_doc`. ::"
msgstr ""
"Dostarczamy ciąg znaków dokumentacji dla tego typu uogólnienia w "
":attr:`tp_doc`. ::"

msgid "\"Noddy objects\",           /* tp_doc */"
msgstr "\"Przedmioty Noddy\", /* tp_doc */"

msgid "Now we get into the type methods, the things that make your objects different from the others.  We aren't going to implement any of these in this version of the module.  We'll expand this example later to have more interesting behavior."
msgstr ""
"Teraz zabierzemy się za sposoby postępowania rodzaju uogólnienia, rzeczy "
"które sprawiają że twoje przedmioty są wyjątkowe na tle pozostałych. Nie "
"wypełnimy żadnej z tych w tej wersji modułu. Rozszerzymy ten przykład "
"później aby mieć bardziej interesujące zachowanie."

msgid "For now, all we want to be able to do is to create new :class:`Noddy` objects. To enable object creation, we have to provide a :attr:`tp_new` implementation. In this case, we can just use the default implementation provided by the API function :cfunc:`PyType_GenericNew`.  We'd like to just assign this to the :attr:`tp_new` slot, but we can't, for portability sake, On some platforms or compilers, we can't statically initialize a structure member with a function defined in another C module, so, instead, we'll assign the :attr:`tp_new` slot in the module initialization function just before calling :cfunc:`PyType_Ready`::"
msgstr ""
"Na razie, wszystko czego chcemy, to mieć możliwość tworzyć nowe przedmioty "
"uogólnienia :class:`Noddy`. Aby umożliwić tworzenie przedmiotów, musimy "
"dostarczyć wypełnienie sposobu postępowania dla :attr:`tp_new`. W tym "
"przypadku możemy po prostu użyć domyślnego wypełnienia dostarczonego przez "
"zadanie sprzęgu programowania aplikacji :cfunc:`PyType_GenericNew`. "
"Wolelibyśmy po prostu przypisać to do gniazda :attr:`tp_new`, ale nie "
"możemy, z powodu umożliwienia przenośności, Na niektórych "
"maszynach/środowiskach lub kompilatorach, nie możemy statycznie inicjować "
"członka struktury z zadaniem zdefiniowanym w innym module C, więc, zamiast "
"tego, przypiszemy gniazdo :attr:`tp_new` w zadaniu inicjującym moduł tuż "
"przed wywołaniem :cfunc:`PyType_Ready`::"

msgid "noddy_NoddyType.tp_new = PyType_GenericNew; if (PyType_Ready(&noddy_NoddyType) < 0)     return;"
msgstr ""
"noddy_NoddyType.tp_new = PyType_GenericNew; if "
"(PyType_Ready(&noddy_NoddyType) < 0)     return;"

msgid "All the other type methods are *NULL*, so we'll go over them later --- that's for a later section!"
msgstr ""
"Wszystkie inne sposoby postępowania są *NULL*, więc przyjrzymy się im "
"później --- to jest dla późniejszej sekcji!"

msgid "Everything else in the file should be familiar, except for some code in :cfunc:`PyInit_noddy`::"
msgstr ""
"Wszystko inne w pliku powinno być znajome, z wyjątkiem pewnych kodów w "
":cfunc:`PyInit_noddy`::"

msgid "if (PyType_Ready(&noddy_NoddyType) < 0)     return;"
msgstr "if (PyType_Ready(&noddy_NoddyType) < 0)     return;"

msgid "This initializes the :class:`Noddy` type, filing in a number of members, including :attr:`ob_type` that we initially set to *NULL*. ::"
msgstr ""
"To inicjuje typ :class:`Noddy`, wypełniając pewną liczbę członków, "
"zawierającą :attr:`ob_type` które początkowo ustawiamy na *NULL*. ::"

msgid "PyModule_AddObject(m, \"Noddy\", (PyObject *)&noddy_NoddyType);"
msgstr "PyModule_AddObject(m, \"Noddy\", (PyObject *)&noddy_NoddyType);"

msgid "This adds the type to the module dictionary.  This allows us to create :class:`Noddy` instances by calling the :class:`Noddy` class::"
msgstr ""
"To dodaje typ do słownika modułu. To pozwala nam tworzyć przykłady "
"uogólnienia :class:`Noddy` przez odwołanie się do uogólnienia :class:`Noddy` "
"::"

msgid ">>> import noddy >>> mynoddy = noddy.Noddy()"
msgstr ">>> import noddy >>> mynoddy = noddy.Noddy()"

msgid "That's it!  All that remains is to build it; put the above code in a file called :file:`noddy.c` and ::"
msgstr ""
"To wszystko! Wszystko co pozostaje to zbudować to; umieść powyższy kod w "
"pliku nazwanym :file:`noddy.c` i ::"

msgid "from distutils.core import setup, Extension setup(name=\"noddy\", version=\"1.0\",       ext_modules=[Extension(\"noddy\", [\"noddy.c\"])])"
msgstr ""
"from distutils.core import setup, Extension setup(name=\"noddy\", "
"version=\"1.0\",       ext_modules=[Extension(\"noddy\", [\"noddy.c\"])])"

msgid "in a file called :file:`setup.py`; then typing ::"
msgstr "w pliku nazwanym :file:`setup.py`; potem wpisując ::"

msgid "$ python setup.py build"
msgstr "$ python setup.py build"

msgid "at a shell should produce a file :file:`noddy.so` in a subdirectory; move to that directory and fire up Python --- you should be able to ``import noddy`` and play around with Noddy objects."
msgstr ""
"w powłoce, powinno to wyprodukować plik :file:`noddy.so` w podkatalogu; "
"przejdź do tego katalogu i uruchom program interpretujący polecenia języka "
"pytonowskiego --- powinieneś móc ``import noddy`` - importować noddy-ego i "
"posługiwać się przedmiotami Noddy-ego."

msgid "That wasn't so hard, was it?"
msgstr "To nie było takie trudne, nieprawdaż?"

msgid "Of course, the current Noddy type is pretty uninteresting. It has no data and doesn't do anything. It can't even be subclassed."
msgstr ""
"Oczywiście obecny typ uogólnienia Noddy nie jest zbyt interesujący. Nie ma w "
"ogóle danych i nic nie robi. Nie może nawet być odziedziczony."

msgid "Adding data and methods to the Basic example"
msgstr "Dodawanie danych i sposobów postępowania do podstawowego przykładu"

msgid "Let's expend the basic example to add some data and methods.  Let's also make the type usable as a base class. We'll create a new module, :mod:`noddy2` that adds these capabilities:"
msgstr ""
"Rozwińmy podstawowy przykład i dodajmy trochę danych i sposobów "
"postępowania. Uczyńmy też typ używalnym jako uogólnienie bazowe. Stworzymy "
"nowy moduł :mod:`noddy2`, który dodaje te możliwości:"

msgid "#include <Python.h> #include \"structmember.h\"  typedef struct {     PyObject_HEAD     PyObject *first; /* first name */     PyObject *last;  /* last name */     int number; } Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self->first);     Py_XDECREF(self->last);     Py_TYPE(self)->tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) {         self->first = PyUnicode_FromString(\"\");         if (self->first == NULL)           {             Py_DECREF(self);             return NULL;           }                  self->last = PyUnicode_FromString(\"\");         if (self->last == NULL)           {             Py_DECREF(self);             return NULL;           }          self->number = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,                                        &first, &last,                                        &self->number))         return -1;       if (first) {         tmp = self->first;         Py_INCREF(first);         self->first = first;         Py_XDECREF(tmp);     }      if (last) {         tmp = self->last;         Py_INCREF(last);         self->last = last;         Py_XDECREF(tmp);     }      return 0; }   static PyMemberDef Noddy_members[] = {     {\"first\", T_OBJECT_EX, offsetof(Noddy, first), 0,      \"first name\"},     {\"last\", T_OBJECT_EX, offsetof(Noddy, last), 0,      \"last name\"},     {\"number\", T_INT, offsetof(Noddy, number), 0,      \"noddy number\"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString(\"%s %s\");         if (format == NULL)             return NULL;     }      if (self->first == NULL) {         PyErr_SetString(PyExc_AttributeError, \"first\");         return NULL;     }      if (self->last == NULL) {         PyErr_SetString(PyExc_AttributeError, \"last\");         return NULL;     }      args = Py_BuildValue(\"OO\", self->first, self->last);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {\"name\", (PyCFunction)Noddy_name, METH_NOARGS,      \"Return the name, combining the first and last name\"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     \"Noddy objects\",           /* tp_doc */     0,		               /* tp_traverse */     0,		               /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     0,                         /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy2module = {     PyModuleDef_HEAD_INIT,     \"noddy2\",     \"Example module that creates an extension type.\",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy2(void)  {     PyObject* m;      if (PyType_Ready(&NoddyType) < 0)         return NULL;      m = PyModule_Create(&noddy2module);     if (m == NULL)         return NULL;      Py_INCREF(&NoddyType);     PyModule_AddObject(m, \"Noddy\", (PyObject *)&NoddyType);     return m; }"
msgstr ""
"#include <Python.h> #include \"structmember.h\"  typedef struct {     "
"PyObject_HEAD     PyObject *imie; /* Imię */     PyObject *nazwisko;  /* "
"nazwisko */     int numer; } Noddy;  static void Noddy_dealloc(Noddy* self) "
"{     Py_XDECREF(self->imie);     Py_XDECREF(self->nazwisko);     "
"Py_TYPE(self)->tp_free((PyObject*)self); }  static PyObject * "
"Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy "
"*self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) { "
"        self->imie = PyUnicode_FromString(\"\");         if (self->imie == "
"NULL)           {             Py_DECREF(self);             return NULL; "
"          }                  self->nazwisko = PyUnicode_FromString(\"\"); "
"        if (self->nazwisko == NULL)           {             "
"Py_DECREF(self);             return NULL;           }          self->numer = "
"0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy "
"*self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, "
"*last=NULL, *tmp;      static char *kwlist[] = {\"imie\", \"nazwisko\", \"numer\", "
"NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist, "
"                                       &imie, &nazwisko, "
"                                       &self->numer))         return -1; "
"      if (imie) {         tmp = self->imie;         Py_INCREF(imie); "
"        self->imie = imie;         Py_XDECREF(tmp);     }      if "
"(nazwisko) {         tmp = self->nazwisko;         Py_INCREF(nazwisko); "
"        self->nazwisko = nazwisko;         Py_XDECREF(tmp);     }      "
"return 0; }   static PyMemberDef Noddy_members[] = {     {\"imie\", "
"T_OBJECT_EX, offsetof(Noddy, imie), 0,      \"imię\"},     {\"nazwisko\", "
"T_OBJECT_EX, offsetof(Noddy, nazwisko), 0,      \"nazwisko\"},     {\"numer\", "
"T_INT, offsetof(Noddy, numer), 0,      \"noddy numer\"},     {NULL}  /* "
"Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static "
"PyObject *format = NULL;     PyObject *args, *result;      if (format == "
"NULL) {         format = PyUnicode_FromString(\"%s %s\");         if (format "
"== NULL)             return NULL;     }      if (self->imie == NULL) { "
"        PyErr_SetString(PyExc_AttributeError, \"imie\");         return NULL; "
"    }      if (self->nazwisko == NULL) {         "
"PyErr_SetString(PyExc_AttributeError, \"nazwisko\");         return NULL;     "
"}      args = Py_BuildValue(\"OO\", self->imie, self->nazwisko);     if (args "
"== NULL)         return NULL;      result = PyUnicode_Format(format, args); "
"    Py_DECREF(args);          return result; }  static PyMethodDef "
"Noddy_methods[] = {     {\"imie\", (PyCFunction)Noddy_name, METH_NOARGS,      "
"\"Return the name, combining the first and last name\"     },     {NULL}  /* "
"Sentinel */ };  static PyTypeObject NoddyType = {     "
"PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */ "
"    sizeof(Noddy),             /* tp_basicsize */     0, "
"                        /* tp_itemsize */     (destructor)Noddy_dealloc, /* "
"tp_dealloc */     0,                         /* tp_print */     0, "
"                        /* tp_getattr */     0,                         /* "
"tp_setattr */     0,                         /* tp_reserved */     0, "
"                        /* tp_repr */     0,                         /* "
"tp_as_number */     0,                         /* tp_as_sequence */     0, "
"                        /* tp_as_mapping */     0,                         "
"/* tp_hash  */     0,                         /* tp_call */     0, "
"                        /* tp_str */     0,                         /* "
"tp_getattro */     0,                         /* tp_setattro */     0, "
"                        /* tp_as_buffer */     Py_TPFLAGS_DEFAULT | "
"        Py_TPFLAGS_BASETYPE,   /* tp_flags */     \"Noddy objects\", "
"          /* tp_doc */     0,\t\t\t               /* tp_traverse */     0,"
"\t\t               /* tp_clear */     0,\t\t               /* tp_richcompare */ "
"    0,\t\t               /* tp_weaklistoffset */     0,\t\t               /* "
"tp_iter */     0,\t\t               /* tp_iternext */     Noddy_methods, "
"            /* tp_methods */     Noddy_members,             /* tp_members "
"*/     0,                         /* tp_getset */     0, "
"                        /* tp_base */     0,                         /* "
"tp_dict */     0,                         /* tp_descr_get */     0, "
"                        /* tp_descr_set */     0,                         "
"/* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0, "
"                        /* tp_alloc */     Noddy_new,                 /* "
"tp_new */ };  static PyModuleDef noddy2module = {     PyModuleDef_HEAD_INIT, "
"    \"noddy2\",     \"Przykładowy moduł który tworzy rozszerzający typ "
"uogólnienia.\",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC "
"PyInit_noddy2(void)  {     PyObject* m;      if (PyType_Ready(&NoddyType) < "
"0)         return NULL;      m = PyModule_Create(&noddy2module);     if (m "
"== NULL)         return NULL;      Py_INCREF(&NoddyType);     "
"PyModule_AddObject(m, \"Noddy\", (PyObject *)&NoddyType);     return m; }"

msgid "This version of the module has a number of changes."
msgstr "Ta wersja modułu ma parę zmian."

msgid "We've added an extra include::"
msgstr "Dodaliśmy dodatkową formułę załączenia - include::"

msgid "#include <structmember.h>"
msgstr "#include <structmember.h>"

msgid "This include provides declarations that we use to handle attributes, as described a bit later."
msgstr ""
"Ta dyrektywa załączania (include) dostarcza deklaracje których używamy do "
"obsługi własności jak opisano kawałek później."

msgid "The name of the :class:`Noddy` object structure has been shortened to :class:`Noddy`.  The type object name has been shortened to :class:`NoddyType`."
msgstr ""
"Nazwa struktury przedmiotu :class:`Noddy` została skrócona do "
":class:`Noddy`. Nazwa przedmiotu typu została skrócona do "
":class:`NoddyType`."

msgid "The  :class:`Noddy` type now has three data attributes, *first*, *last*, and *number*.  The *first* and *last* variables are Python strings containing first and last names. The *number* attribute is an integer."
msgstr ""
"Typ uogólnienia teraz ma trzy własności danych, *imie*, *nazwisko* i "
"*numer*. Zmienne *imie* i *nazwisko* są ciągami znaków języka pytonowskiego "
"zawierającymi imię i nazwisko. Własność *numer* jest liczbą całkowitą."

msgid "The object structure is updated accordingly::"
msgstr "Struktura przedmiotu jest uaktualniona podobnie::"

msgid "typedef struct {     PyObject_HEAD     PyObject *first;     PyObject *last;     int number; } Noddy;"
msgstr ""
"typedef struct {     PyObject_HEAD     PyObject *imie;     PyObject "
"*nazwisko;     int numer; } Noddy;"

msgid "Because we now have data to manage, we have to be more careful about object allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Ponieważ teraz mamy dane do zarządzania, musimy być bardziej ostrożni w "
"kwestii umieszczania w pamięci i odbierania miejsca. Jako minimum, "
"potrzebujemy sposobu zwalniania miejsca w pamięci::"

msgid "static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self->first);     Py_XDECREF(self->last);     Py_TYPE(self)->tp_free((PyObject*)self); }"
msgstr ""
"static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self->imie);     "
"Py_XDECREF(self->nazwisko);     Py_TYPE(self)->tp_free((PyObject*)self); }"

msgid "which is assigned to the :attr:`tp_dealloc` member::"
msgstr "które jest przypisany do członka :attr:`tp_dealloc`::"

msgid "(destructor)Noddy_dealloc, /*tp_dealloc*/"
msgstr "(destructor)Noddy_dealloc, /*tp_dealloc*/"

msgid "This method decrements the reference counts of the two Python attributes. We use :cfunc:`Py_XDECREF` here because the :attr:`first` and :attr:`last` members could be *NULL*.  It then calls the :attr:`tp_free` member of the object's type to free the object's memory.  Note that the object's type might not be :class:`NoddyType`, because the object may be an instance of a subclass."
msgstr ""
"Ten sposób postępowania zmniejsza liczbę odniesień do dwóch własności języka "
"pytonowskiego. Używamy :cfunc:`Py_XDECREF` tutaj ponieważ :attr:`imie` i "
":attr:`nazwisko` mogą być *NULL*. Potem uruchamia członka :attr:`tp_free` "
"typu przedmiotu aby zwolnić pamięć przedmiotu. Zauważ, że typ przedmiotu "
"może nie być :class:`NoddyType`, ponieważ przedmiot może być przykładem "
"podrzędnego uogólnienia."

msgid "We want to make sure that the first and last names are initialized to empty strings, so we provide a new method::"
msgstr ""
"Chcemy upewnić się że imię i nazwisko są zainicjowane do pustych ciągów "
"znaków, więc dostarczamy sposób postępowania nowości::"

msgid "static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) {         self->first = PyString_FromString(\"\");         if (self->first == NULL)           {             Py_DECREF(self);             return NULL;           }          self->last = PyString_FromString(\"\");         if (self->last == NULL)           {             Py_DECREF(self);             return NULL;           }          self->number = 0;     }      return (PyObject *)self; }"
msgstr ""
"static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject "
"*kwds) {     Noddy *self;      self = (Noddy *)type->tp_alloc(type, 0);     "
"if (self != NULL) {         self->imie = PyString_FromString(\"\");         if "
"(self->imie == NULL)           {             Py_DECREF(self);             "
"return NULL;           }          self->nazwisko = PyString_FromString(\"\"); "
"        if (self->nazwisko == NULL)           {             "
"Py_DECREF(self);             return NULL;           }          self->numer = "
"0;     }      return (PyObject *)self; }"

msgid "and install it in the :attr:`tp_new` member::"
msgstr "i zainstaluj go w elemencie :attr:`tp_new`::"

msgid "Noddy_new,                 /* tp_new */"
msgstr "Noddy_new,                 /* tp_new */"

msgid "The new member is responsible for creating (as opposed to initializing) objects of the type.  It is exposed in Python as the :meth:`__new__` method.  See the paper titled \"Unifying types and classes in Python\" for a detailed discussion of the :meth:`__new__` method.  One reason to implement a new method is to assure the initial values of instance variables.  In this case, we use the new method to make sure that the initial values of the members :attr:`first` and :attr:`last` are not *NULL*. If we didn't care whether the initial values were *NULL*, we could have used :cfunc:`PyType_GenericNew` as our new method, as we did before.  :cfunc:`PyType_GenericNew` initializes all of the instance variable members to *NULL*."
msgstr ""
"członek new jest odpowiedzialny za tworzenie (w przeciwieństwie do "
"inicjowania) przedmiotów o określonym typie. Jest wystawiony w języku "
"pytonowskim jako sposób postępowania :meth:`__new__`. Zobacz dokument "
"\"Unifikacja typów i uogólnień w języku pytonowskim\" dla pogłębionej dyskusji "
"o sposobie postępowania :meth:`__new__`. Jednym z powodów do wypełnienia "
"sposobu postępowania \"nowy\" - z ang. - new jest zapewnienie wartości "
"początkowych zmiennych przykładu. W tym przypadku, używamy sposobu "
"postępowania \"new\" aby zapewnić, że wartości początkowe członków "
":attr:`first` i :attr:`last` nie są puste (*NULL*). Jeśli nie "
"troszczylibyśmy się, czy początkowe wartości były *NULL*, moglibyśmy użyć "
":cfunc:`PyType_GenericNew` jako naszego sposobu postępowania \"new\", tak jak "
"poprzednio. :cfunc:`PyType_GenericNew` inicjuje wszystkie członki zmienne "
"przykładu na *NULL*."

msgid "The new method is a static method that is passed the type being instantiated and any arguments passed when the type was called, and that returns the new object created. New methods always accept positional and keyword arguments, but they often ignore the arguments, leaving the argument handling to initializer methods. Note that if the type supports subclassing, the type passed may not be the type being defined.  The new method calls the tp_alloc slot to allocate memory. We don't fill the :attr:`tp_alloc` slot ourselves. Rather :cfunc:`PyType_Ready` fills it for us by inheriting it from our base class, which is :class:`object` by default.  Most types use the default allocation."
msgstr ""
"Sposób postępowania \"new\" jest sposobem postępowania statycznym, któremu "
"przekazywany jest typ uogólnienia którego przykład dajemy i jakiekolwiek "
"parametry przekazywane gdy typ został wywołany, i który zwraca nowo "
"utworzony przedmiot. Metoda \"Nowy\" - z ang. - \"new\" zawsze akceptuje "
"parametry pozycyjne i słów kluczowych, ale często pomija parametry, "
"pozostawiając obsługę parametrów dla sposobów postępowania inicjujących. "
"Zauważ, że jeśli typ wspiera tworzenie uogólnień  podrzędnych, przekazywany "
"typ nie może być typem który jest definiowany. Sposób postępowania \"nowy\" - "
"z ang. - \"new\"  wzywa gniazdo tp_alloc aby alokować pamięć. Nie wypełniamy "
"własnoręcznie :attr:`tp_alloc`. Raczej :cfunc:`PyType_Ready` wypełnia go za "
"nas przez odziedziczenie go z naszego bazowego uogólnienia, którym jest "
":class:`object` - z ang. - przedmiot domyślnie. Większość typów używa "
"domyślnego przydzielania pamięci."

msgid "If you are creating a co-operative :attr:`tp_new` (one that calls a base type's :attr:`tp_new` or :meth:`__new__`), you must *not* try to determine what method to call using method resolution order at runtime.  Always statically determine what type you are going to call, and call its :attr:`tp_new` directly, or via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of your type that also inherit from other Python-defined classes may not work correctly. (Specifically, you may not be able to create instances of such subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Jeśli tworzysz ko-operujący :attr:`tp_new` (taki, który wywołuje sposób "
"postępowania :attr:`tp_new` lub :meth:`__new__` typu bazowego), *nie* możesz "
"próbować określić którą metodę wywołać przy użyciu ustalania kolejności "
"sposobów postępowania w czasie wykonania. Zawsze określaj statycznie do "
"którego typu będziesz się odwoływał, i wzywaj jego :attr:`tp_new` "
"bezpośrednio, lub przez ``type->tp_base->tp_new``. Jeśli tego nie zrobisz, "
"podrzędne uogólnienia języka pytonowskiego twojego typu, który także "
"dziedziczy po innych określonych przez język pytonowski uogólnieniach może "
"nie działać prawidłowo. (Szczególnie, być może nie będziesz mógł tworzyć "
"przykładów takich podrzędnych uogólnień bez otrzymania sytuacji wyjątkowej "
":exc:`TypeError`.)"

msgid "We provide an initialization function::"
msgstr "Dostarczamy zadanie inicjujące::"

msgid "static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,                                       &first, &last,                                       &self->number))         return -1;      if (first) {         tmp = self->first;         Py_INCREF(first);         self->first = first;         Py_XDECREF(tmp);     }      if (last) {         tmp = self->last;         Py_INCREF(last);         self->last = last;         Py_XDECREF(tmp);     }      return 0; }"
msgstr ""
"static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     "
"PyObject *imie=NULL, *nazwisko=NULL, *tmp;      static char *kwlist[] = "
"{\"imie\", \"nazwisko\", \"numer\", NULL};      if (! "
"PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist, "
"                                      &imie, &nazwisko, "
"                                      &self->numer))         return -1; "
"     if (imie) {         tmp = self->imie;         Py_INCREF(imie); "
"        self->imie = imie;         Py_XDECREF(tmp);     }      if "
"(nazwisko) {         tmp = self->nazwisko;         Py_INCREF(nazwisko); "
"        self->nazwisko = nazwisko;         Py_XDECREF(tmp);     }      "
"return 0; }"

msgid "by filling the :attr:`tp_init` slot. ::"
msgstr "przez wypełnienie gniazda :attr:`tp_init`. ::"

msgid "(initproc)Noddy_init,         /* tp_init */"
msgstr "(initproc)Noddy_init, /* tp_init */"

msgid "The :attr:`tp_init` slot is exposed in Python as the :meth:`__init__` method. It is used to initialize an object after it's created. Unlike the new method, we can't guarantee that the initializer is called.  The initializer isn't called when unpickling objects and it can be overridden.  Our initializer accepts arguments to provide initial values for our instance. Initializers always accept positional and keyword arguments."
msgstr ""
"Gniazdo :attr:`tp_init` jest wystawione w języku pytonowskim jako sposób "
"postępowania :meth:`__init__`. Jest używany do inicjowania przedmiotu po "
"jego utworzeniu. W przeciwieństwie do sposobu postępowania \"nowy\", nie "
"możemy zagwarantować że sposób postępowania inicjujący będzie uruchomiony. "
"Sposób postępowania inicjujący nie jest uruchamiany gdy przedmiot jest "
"odpakowywany i może być zastąpiony. Sposób postępowania inicjujący akceptuje "
"parametry aby dostarczyć wartości początkowych dla naszego przykładu. "
"Sposoby postępowania inicjujące zawsze akceptują parametry pozycyjne i słów "
"kluczowych."

msgid "Initializers can be called multiple times.  Anyone can call the :meth:`__init__` method on our objects.  For this reason, we have to be extra careful when assigning the new values.  We might be tempted, for example to assign the :attr:`first` member like this::"
msgstr ""
"Sposoby postępowania inicjujące mogą być wzywane kilkukrotnie. Ktokolwiek "
"może wezwać :meth:`__init__` na naszych przedmiotach. Z tego powodu, musimy "
"być szczególnie ostrożni gdy przypisujemy nowe wartości. Możemy pokusić się, "
"dla przykładu na przypisanie członka :attr:`imie` jak następuje::"

msgid "if (first) {     Py_XDECREF(self->first);     Py_INCREF(first);     self->first = first; }"
msgstr ""
"if (imie) {     Py_XDECREF(self->imie);     Py_INCREF(imie);     self->imie "
"= imie; }"

msgid "But this would be risky.  Our type doesn't restrict the type of the :attr:`first` member, so it could be any kind of object.  It could have a destructor that causes code to be executed that tries to access the :attr:`first` member.  To be paranoid and protect ourselves against this possibility, we almost always reassign members before decrementing their reference counts.  When don't we have to do this?"
msgstr ""
"Ale to byłoby ryzykowne. Nasz typ nie ogranicza typu członka :attr:`imie`, "
"więc może być jakiegokolwiek rodzaju przedmiotem. Może mieć destruktor, "
"który powoduje że kod uruchamiany próbuje uzyskać dostęp do członka "
":attr:`imie`. Aby być paranoikami i bronić się przed tą możliwością, prawie "
"zawsze przepisujemy członki przed zmniejszeniem ich liczby odniesień. Kiedy "
"nie musimy tego robić?"

msgid "when we absolutely know that the reference count is greater than 1"
msgstr "gdy absolutnie wiemy że liczba odniesień jest większa niż 1"

msgid "when we know that deallocation of the object [#]_ will not cause any calls back into our type's code"
msgstr ""
"gdy wiemy że zabranie miejsca w pamięci na przedmiot [#]_ nie spowoduje "
"żadnych powrotnych wywołań do kodu naszego typu"

msgid "when decrementing a reference count in a :attr:`tp_dealloc` handler when garbage-collections is not supported [#]_"
msgstr ""
"gdy zmniejszajamy liczbę odniesień w obsłudze :attr:`tp_dealloc` gdy "
"zbiórka-śmieci nie jest dostępna [#]_"

msgid "We want to expose our instance variables as attributes. There are a number of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Chcemy wystawić zmienne naszego przykładu jako własności. Istnieje kilka "
"dróg do tego. Najprościej jest zdefiniować definicje członków::"

msgid "static PyMemberDef Noddy_members[] = {     {\"first\", T_OBJECT_EX, offsetof(Noddy, first), 0,      \"first name\"},     {\"last\", T_OBJECT_EX, offsetof(Noddy, last), 0,      \"last name\"},     {\"number\", T_INT, offsetof(Noddy, number), 0,      \"noddy number\"},     {NULL}  /* Sentinel */ };"
msgstr ""
"static PyMemberDef Noddy_members[] = {     {\"imie\", T_OBJECT_EX, "
"offsetof(Noddy, imie), 0,      \"imię\"},     {\"nazwisko\", T_OBJECT_EX, "
"offsetof(Noddy, nazwisko), 0,      \"nazwisko\"},     {\"numer\", T_INT, "
"offsetof(Noddy, numer), 0,      \"numer noddy-ego\"},     {NULL}  /* Ochrona "
"*/ };"

msgid "and put the definitions in the :attr:`tp_members` slot::"
msgstr "i wstawić definicje do gniazda :attr:`tp_members`::"

msgid "Noddy_members,             /* tp_members */"
msgstr "Noddy_members,             /* tp_members */"

msgid "Each member definition has a member name, type, offset, access flags and documentation string. See the :ref:`Generic-Attribute-Management` section below for details."
msgstr ""
"Każda definicja członka ma nazwę członka, rodzaj, odstęp w pamięci, flagi "
"dostępu i ciąg dokumentacji. Zobacz sekcję :ref:`Zarządzanie-"
"zamiennymi-własnościami` - z ang. - :ref:`Generic-Attribute-Management` po "
"więcej szczegółów na ten temat."

msgid "A disadvantage of this approach is that it doesn't provide a way to restrict the types of objects that can be assigned to the Python attributes.  We expect the first and last names to be strings, but any Python objects can be assigned. Further, the attributes can be deleted, setting the C pointers to *NULL*.  Even though we can make sure the members are initialized to non-*NULL* values, the members can be set to *NULL* if the attributes are deleted."
msgstr ""
"Wadą tego podejścia jest to, że nie dostarcza ono sposobu aby ograniczyć "
"rodzaje przedmiotów, które można przypisywać do \"własności\" języka "
"pytonowskiego. Oczekujemy że imię i nazwisko będą ciągami znaków, ale "
"wszystkie przedmioty języka pytonowskiego mogą być przypisywane. Dalej "
"własności mogą być usunięte, ustawiając wskaźniki C na *NULL*. Nawet chociaż "
"możemy się upewnić, że członki są inicjowane na niepuste (z ang. - "
"non-*NULL*) wartości, członki mogą być ustawione na *NULL* jeśli własności "
"będą kasowane."

msgid "We define a single method, :meth:`name`, that outputs the objects name as the concatenation of the first and last names. ::"
msgstr ""
"Określamy pojedynczy sposób postępowania, :meth:`name`, która wystawia nazwę "
"przedmiotów jako sklejenia imienia i nazwiska. ::"

msgid "static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyString_FromString(\"%s %s\");         if (format == NULL)             return NULL;     }      if (self->first == NULL) {         PyErr_SetString(PyExc_AttributeError, \"first\");         return NULL;     }      if (self->last == NULL) {         PyErr_SetString(PyExc_AttributeError, \"last\");         return NULL;     }      args = Py_BuildValue(\"OO\", self->first, self->last);     if (args == NULL)         return NULL;      result = PyString_Format(format, args);     Py_DECREF(args);      return result; }"
msgstr ""
"static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = "
"NULL;     PyObject *args, *result;      if (format == NULL) {         format "
"= PyString_FromString(\"%s %s\");         if (format == NULL)             "
"return NULL;     }      if (self->imie == NULL) {         "
"PyErr_SetString(PyExc_AttributeError, \"imie\");         return NULL;     } "
"     if (self->last == NULL) {         "
"PyErr_SetString(PyExc_AttributeError, \"nazwisko\");         return NULL;     "
"}      args = Py_BuildValue(\"OO\", self->imie, self->nazwisko);     if (args "
"== NULL)         return NULL;      result = PyString_Format(format, args); "
"    Py_DECREF(args);      return result; }"

msgid "The method is implemented as a C function that takes a :class:`Noddy` (or :class:`Noddy` subclass) instance as the first argument.  Methods always take an instance as the first argument. Methods often take positional and keyword arguments as well, but in this cased we don't take any and don't need to accept a positional argument tuple or keyword argument dictionary. This method is equivalent to the Python method::"
msgstr ""
"Sposób postępowania jest wypełniony jako zadanie C które przyjmuje przykład "
"uogólnienia :class:`Noddy` (lub podrzędnego uogólnienia względem uogólnienia "
":class:`Noddy`) jako pierwszy parametr. Sposoby postępowania zawsze "
"przyjmują przykład jako pierwszy argument. Sposoby postępowania często "
"przyjmują pozycyjne jak i kluczowe parametry zarówno, ale w tym przypadku "
"nie pobieramy żadnych i nie potrzebujemy akceptować pozycyjne parametry "
"krotki pozycyjne lub parametrów słów kluczowych słownika. Ten sposób "
"postępowania jest równoważny sposobowi postępowania języka pytonowskiego::"

msgid "def name(self):    return \"%s %s\" % (self.first, self.last)"
msgstr "def name(self):    return \"%s %s\" % (self.imie, self.nazwisko)"

msgid "Note that we have to check for the possibility that our :attr:`first` and :attr:`last` members are *NULL*.  This is because they can be deleted, in which case they are set to *NULL*.  It would be better to prevent deletion of these attributes and to restrict the attribute values to be strings.  We'll see how to do that in the next section."
msgstr ""
"Zauważ, że musimy sprawdzić możliwość, że nasze własności :attr:`imie` i "
":attr:`nazwisko` są puste - z ang. - *NULL*. To jest dlatego że mogą być one "
"skasowane, w którym przypadku zostaną one ustawione na *NULL*. Lepiej "
"byłoby zapobiec skasowaniu tych własności i ograniczyć wartości właściwości "
"aby były ciągami znaków. Zobaczymy jak to zrobić w następnym rozdziale."

msgid "Now that we've defined the method, we need to create an array of method definitions::"
msgstr ""
"Teraz gdy określiliśmy sposób postępowania, musimy stworzyć tabelę definicji "
"sposobów postępowania::"

msgid "static PyMethodDef Noddy_methods[] = {     {\"name\", (PyCFunction)Noddy_name, METH_NOARGS,      \"Return the name, combining the first and last name\"     },     {NULL}  /* Sentinel */ };"
msgstr ""
"static PyMethodDef Noddy_methods[] = {     {\"name\", (PyCFunction)Noddy_name, "
"METH_NOARGS,      \"Zwróć nazwę, łącząc imię i nazwisko\"     },     {NULL}  "
"/* Ochrona */ };"

msgid "and assign them to the :attr:`tp_methods` slot::"
msgstr "i przypisz je do gniazda :attr:`tp_methods`::"

msgid "Noddy_methods,             /* tp_methods */"
msgstr "Noddy_methods,             /* tp_methods */"

msgid "Note that we used the :const:`METH_NOARGS` flag to indicate that the method is passed no arguments."
msgstr ""
"Zauważ, że używaliśmy flagi :const:`METH_NOARGS` aby wskazać który sposób "
"postępowania nie dostaje żadnych parametrów."

msgid "Finally, we'll make our type usable as a base class.  We've written our methods carefully so far so that they don't make any assumptions about the type of the object being created or used, so all we need to do is to add the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Ostatecznie czynimy nasz typ użytecznym jako uogólnienie bazowe. Napisaliśmy "
"nasze sposoby postępowania uważnie tak że nie czynią one żadnych założeń o "
"rodzaju przedmiotu który jest utworzony lub użyty, więc wszystko, co musimy "
"uczynić to dodać :const:`Py_TPFLAGS_BASETYPE` do naszej definicji flag "
"uogólnienia::"

msgid "Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/"
msgstr "Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/"

msgid "We rename :cfunc:`PyInit_noddy` to :cfunc:`PyInit_noddy2` and update the module name in the :ctype:`PyModuleDef` struct."
msgstr ""
"Zmieniamy nazwę :cfunc:`PyInit_noddy` na :cfunc:`PyInit_noddy2` i uaktualnić "
"nazwę modułu w strukturze :ctype:`PyModuleDef`"

msgid "Finally, we update our :file:`setup.py` file to build the new module::"
msgstr ""
"Ostatecznie uaktualniamy nasz plik :file:`setup.py` do budowania nowego "
"modułu::"

msgid "from distutils.core import setup, Extension setup(name=\"noddy\", version=\"1.0\",       ext_modules=[          Extension(\"noddy\", [\"noddy.c\"]),          Extension(\"noddy2\", [\"noddy2.c\"]),          ])"
msgstr ""
"from distutils.core import setup, Extension setup(name=\"noddy\", "
"version=\"1.0\",       ext_modules=[          Extension(\"noddy\", [\"noddy.c\"]), "
"         Extension(\"noddy2\", [\"noddy2.c\"]),          ])"

msgid "Providing finer control over data attributes"
msgstr "Dostarczając dokładniejszej kontroli ponad własnościami danych"

msgid "In this section, we'll provide finer control over how the :attr:`first` and :attr:`last` attributes are set in the :class:`Noddy` example. In the previous version of our module, the instance variables :attr:`first` and :attr:`last` could be set to non-string values or even deleted. We want to make sure that these attributes always contain strings."
msgstr ""
"W tym rozdziale, dostarczymy dokładniejszej kontroli ponad tym jak własności "
":attr:`imie` i :attr:`nazwisko` są ustawiane w przykładzie :class:`Noddy`. "
"W poprzedniej wersji naszego modułu, zmienne przykładu :attr:`imie` i "
":attr:`nazwisko` mogły być ustawione na wartości nie-ciągu-znaków lub nawet "
"skasowane. Chcemy się upewnić że te własności zawsze zawierają ciągi znaków."

msgid "#include <Python.h> #include \"structmember.h\"  typedef struct {     PyObject_HEAD     PyObject *first;     PyObject *last;     int number; } Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self->first);     Py_XDECREF(self->last);     Py_TYPE(self)->tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) {         self->first = PyUnicode_FromString(\"\");         if (self->first == NULL)           {             Py_DECREF(self);             return NULL;           }                  self->last = PyUnicode_FromString(\"\");         if (self->last == NULL)           {             Py_DECREF(self);             return NULL;           }          self->number = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|SSi\", kwlist,                                        &first, &last,                                        &self->number))         return -1;       if (first) {         tmp = self->first;         Py_INCREF(first);         self->first = first;         Py_DECREF(tmp);     }      if (last) {         tmp = self->last;         Py_INCREF(last);         self->last = last;         Py_DECREF(tmp);     }      return 0; }  static PyMemberDef Noddy_members[] = {     {\"number\", T_INT, offsetof(Noddy, number), 0,      \"noddy number\"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_getfirst(Noddy *self, void *closure) {     Py_INCREF(self->first);     return self->first; }  static int Noddy_setfirst(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");     return -1;   }      if (! PyUnicode_Check(value)) {     PyErr_SetString(PyExc_TypeError,                      \"The first attribute value must be a string\");     return -1;   }          Py_DECREF(self->first);   Py_INCREF(value);   self->first = value;        return 0; }  static PyObject * Noddy_getlast(Noddy *self, void *closure) {     Py_INCREF(self->last);     return self->last; }  static int Noddy_setlast(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, \"Cannot delete the last attribute\");     return -1;   }      if (! PyUnicode_Check(value)) {     PyErr_SetString(PyExc_TypeError,                      \"The last attribute value must be a string\");     return -1;   }          Py_DECREF(self->last);   Py_INCREF(value);   self->last = value;        return 0; }  static PyGetSetDef Noddy_getseters[] = {     {\"first\",       (getter)Noddy_getfirst, (setter)Noddy_setfirst,      \"first name\",      NULL},     {\"last\",       (getter)Noddy_getlast, (setter)Noddy_setlast,      \"last name\",      NULL},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString(\"%s %s\");         if (format == NULL)             return NULL;     }      args = Py_BuildValue(\"OO\", self->first, self->last);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {\"name\", (PyCFunction)Noddy_name, METH_NOARGS,      \"Return the name, combining the first and last name\"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     \"Noddy objects\",           /* tp_doc */     0,		               /* tp_traverse */     0,		               /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     Noddy_getseters,           /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy3module = {     PyModuleDef_HEAD_INIT,     \"noddy3\",     \"Example module that creates an extension type.\",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy3(void)  {     PyObject* m;      if (PyType_Ready(&NoddyType) < 0)         return NULL;      m = PyModule_Create(&noddy3module);     if (m == NULL)         return NULL;      Py_INCREF(&NoddyType);     PyModule_AddObject(m, \"Noddy\", (PyObject *)&NoddyType);     return m; }"
msgstr ""
"#include <Python.h> #include \"structmember.h\"  typedef struct {     "
"PyObject_HEAD     PyObject *imie;     PyObject *nazwisko;     int numer; } "
"Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self->imie); "
"    Py_XDECREF(self->nazwisko);     "
"Py_TYPE(self)->tp_free((PyObject*)self); }  static PyObject * "
"Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy "
"*self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) { "
"        self->imie = PyUnicode_FromString(\"\");         if (self->imie == "
"NULL)           {             Py_DECREF(self);             return NULL; "
"          }                  self->nazwisko = PyUnicode_FromString(\"\"); "
"        if (self->nazwisko == NULL)           {             "
"Py_DECREF(self);             return NULL;           }          self->numer = "
"0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy "
"*self, PyObject *args, PyObject *kwds) {     PyObject *imie=NULL, "
"*nazwisko=NULL, *tmp;      static char *kwlist[] = {\"imie\", \"nazwisko\", "
"\"numer\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|SSi\", "
"kwlist,                                        &imie, &nazwisko, "
"                                       &self->numer))         return -1; "
"      if (imie) {         tmp = self->imie;         Py_INCREF(imie); "
"        self->imie = imie;         Py_DECREF(tmp);     }      if (nazwisko) "
"{         tmp = self->nazwisko;         Py_INCREF(nazwisko);         "
"self->nazwisko = nazwisko;         Py_DECREF(tmp);     }      return 0; }  "
"static PyMemberDef Noddy_members[] = {     {\"numer\", T_INT, offsetof(Noddy, "
"numer), 0,      \"noddy numer\"},     {NULL}  /* Ochrona */ };  static "
"PyObject * Noddy_getfirst(Noddy *self, void *closure) {     "
"Py_INCREF(self->imie);     return self->imie; }  static int "
"Noddy_setimie(Noddy *self, PyObject *value, void *closure) {   if (value == "
"NULL) {     PyErr_SetString(PyExc_TypeError, \"Nie można usunąć właściwości "
"imienia\");     return -1;   }      if (! PyUnicode_Check(value)) {     "
"PyErr_SetString(PyExc_TypeError,                      \"Wartość własności "
"imienia musi być ciągiem znaków\");     return -1;   }          "
"Py_DECREF(self->imie);   Py_INCREF(value);   self->imie = value;        "
"return 0; }  static PyObject * Noddy_getlast(Noddy *self, void *closure) { "
"    Py_INCREF(self->nazwisko);     return self->nazwisko; }  static int "
"Noddy_setnazwisko(Noddy *self, PyObject *value, void *closure) {   if (value "
"== NULL) {     PyErr_SetString(PyExc_TypeError, \"Nie można usunąć własności "
"nazwiska\");     return -1;   }      if (! PyUnicode_Check(value)) {     "
"PyErr_SetString(PyExc_TypeError,                      \"Wartość własności "
"nazwiska musi być ciągiem znaków\");     return -1;   }          "
"Py_DECREF(self->nazwisko);   Py_INCREF(value);   self->nazwisko = value; "
"       return 0; }  static PyGetSetDef Noddy_getseters[] = {     {\"imie\", "
"      (getter)Noddy_getimie, (setter)Noddy_setimie,      \"imię\",      "
"NULL},     {\"nazwisko\",       (getter)Noddy_getnazwisko, "
"(setter)Noddy_setnazwisko,      \"nazwisko\",      NULL},     {NULL}  /* "
"Ochrona */ };  static PyObject * Noddy_name(Noddy* self) {     static "
"PyObject *format = NULL;     PyObject *args, *result;      if (format == "
"NULL) {         format = PyUnicode_FromString(\"%s %s\");         if (format "
"== NULL)             return NULL;     }      args = Py_BuildValue(\"OO\", "
"self->imie, self->nazwisko);     if (args == NULL)         return NULL; "
"     result = PyUnicode_Format(format, args);     Py_DECREF(args); "
"         return result; }  static PyMethodDef Noddy_methods[] = {     "
"{\"nazwa\", (PyCFunction)Noddy_nazwa, METH_NOARGS,      \"Zwróć nazwisko, "
"łącząc imię i nazwisko\"     },     {NULL}  /* Ochrona */ };  static "
"PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "
"\"noddy.Noddy\",             /* tp_name */     sizeof(Noddy),             /* "
"tp_basicsize */     0,                         /* tp_itemsize */     "
"(destructor)Noddy_dealloc, /* tp_dealloc */     0,                         "
"/* tp_print */     0,                         /* tp_getattr */     0, "
"                        /* tp_setattr */     0,                         /* "
"tp_reserved */     0,                         /* tp_repr */     0, "
"                        /* tp_as_number */     0,                         "
"/* tp_as_sequence */     0,                         /* tp_as_mapping */     "
"0,                         /* tp_hash  */     0,                         /* "
"tp_call */     0,                         /* tp_str */     0, "
"                        /* tp_getattro */     0,                         /* "
"tp_setattro */     0,                         /* tp_as_buffer */     "
"Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     "
"\"przedmioty Noddy\",           /* tp_doc */     0,\t\t\t               /* "
"tp_traverse */     0,\t\t               /* tp_clear */     0,\t\t               "
"/* tp_richcompare */     0,\t\t               /* tp_weaklistoffset */     0,"
"\t\t               /* tp_iter */     0,\t\t               /* tp_iternext */     "
"Noddy_methods,             /* tp_methods */     Noddy_members,             "
"/* tp_members */     Noddy_getseters,           /* tp_getset */     0, "
"                        /* tp_base */     0,                         /* "
"tp_dict */     0,                         /* tp_descr_get */     0, "
"                        /* tp_descr_set */     0,                         "
"/* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0, "
"                        /* tp_alloc */     Noddy_new,                 /* "
"tp_new */ };  static PyModuleDef noddy3module = {     PyModuleDef_HEAD_INIT, "
"    \"noddy3\",     \"Przykładowy moduł który tworzy typ rozszerzający.\",     "
"-1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy3(void) "
" {     PyObject* m;      if (PyType_Ready(&NoddyType) < 0)         return "
"NULL;      m = PyModule_Create(&noddy3module);     if (m == NULL)         "
"return NULL;      Py_INCREF(&NoddyType);     PyModule_AddObject(m, \"Noddy\", "
"(PyObject *)&NoddyType);     return m; }"

msgid "To provide greater control, over the :attr:`first` and :attr:`last` attributes, we'll use custom getter and setter functions.  Here are the functions for getting and setting the :attr:`first` attribute::"
msgstr ""
"Aby zapewnić większą kontrolę, nad właściwościami :attr:`imie` i "
":attr:`nazwisko` użyjemy własnych zadań pobrania i ustawiania. Tu są zadania "
"dla pobierania i ustawiania (getter i setter - z ang.) właściwości "
":attr:`imie`::"

msgid "Noddy_getfirst(Noddy *self, void *closure) {     Py_INCREF(self->first);     return self->first; }  static int Noddy_setfirst(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, \"Cannot delete the first attribute\");     return -1;   }    if (! PyString_Check(value)) {     PyErr_SetString(PyExc_TypeError,                     \"The first attribute value must be a string\");     return -1;   }    Py_DECREF(self->first);   Py_INCREF(value);   self->first = value;    return 0; }"
msgstr ""
"Noddy_getimie(Noddy *self, void *closure) {     Py_INCREF(self->imie);     "
"return self->imie; }  static int Noddy_setimie(Noddy *self, PyObject *value, "
"void *closure) {   if (value == NULL) {     "
"PyErr_SetString(PyExc_TypeError, \"Nie można usunąć właściwości imienia\"); "
"    return -1;   }    if (! PyString_Check(value)) {     "
"PyErr_SetString(PyExc_TypeError,                     \"Wartość pierwszej "
"właściwości musi być ciągiem znaków\");     return -1;   }    "
"Py_DECREF(self->imie);   Py_INCREF(value);   self->imie = value;    return "
"0; }"

msgid "The getter function is passed a :class:`Noddy` object and a \"closure\", which is void pointer. In this case, the closure is ignored. (The closure supports an advanced usage in which definition data is passed to the getter and setter. This could, for example, be used to allow a single set of getter and setter functions that decide the attribute to get or set based on data in the closure.)"
msgstr ""
"Zadaniu pobierającemu jest przekazywany przedmiot uogólnienia :class:`Noddy` "
"i \"domknięcie\" - ang. - \"closure\", które jest pustym wskaźnikiem. W tym "
"przypadku \"domknięcie\" jest ignorowane. (domknięcie wspiera zaawansowane "
"użycie w którym dane definicji są przekazywane dla zadania pobierającego i "
"ustawiającego (getter i setter). To mogłoby, dla przykładu, być użyte aby "
"pozwolić pojedynczemu zbiorowi zadań pobierających i ustawiających "
"decydować, że własność będzie wzięta lub ustawiona w oparciu o dane w "
"domknięciu.)"

msgid "The setter function is passed the :class:`Noddy` object, the new value, and the closure. The new value may be *NULL*, in which case the attribute is being deleted.  In our setter, we raise an error if the attribute is deleted or if the attribute value is not a string."
msgstr ""
"Zadaniu ustawiającemu jest przekazywany przedmiot uogólnienia "
":class:`Noddy`, nowa wartość i domknięcie. Nowa wartość może być *NULL*, w "
"którym to przypadku własność zostanie usunięta. W naszym zadaniu "
"ustawiającym, zgłaszamy błąd jeśli właściwość jest kasowana lub jeśli "
"własność nie jest ciągiem znaków."

msgid "We create an array of :ctype:`PyGetSetDef` structures::"
msgstr "Tworzymy tabelę struktur :ctype:`PyGetSetDef`::"

msgid "static PyGetSetDef Noddy_getseters[] = {     {\"first\",      (getter)Noddy_getfirst, (setter)Noddy_setfirst,      \"first name\",      NULL},     {\"last\",      (getter)Noddy_getlast, (setter)Noddy_setlast,      \"last name\",      NULL},     {NULL}  /* Sentinel */ };"
msgstr ""
"static PyGetSetDef Noddy_getseters[] = {     {\"imie\",      "
"(getter)Noddy_getfirst, (setter)Noddy_setfirst,      \"imię\",      NULL}, "
"    {\"nazwisko\",      (getter)Noddy_getlast, (setter)Noddy_setlast,      "
"\"nazwisko\",      NULL},     {NULL}  /* Ochrona */ };"

msgid "and register it in the :attr:`tp_getset` slot::"
msgstr "i rejestrujemy je w gnieździe :attr:`tp_getset`::"

msgid "Noddy_getseters,           /* tp_getset */"
msgstr "Noddy_getseters,           /* tp_getset */"

msgid "to register our attribute getters and setters."
msgstr "aby zarejestrować nasze zadania pobierania i ustawiania właściwości."

msgid "The last item in a :ctype:`PyGetSetDef` structure is the closure mentioned above. In this case, we aren't using the closure, so we just pass *NULL*."
msgstr ""
"Ostatnim elementem w strukturze :ctype:`PyGetSetDef` jest domknięcie "
"wspomniane powyżej. W tym przypadku, nie używamy domknięcia, więc przekażemy "
"po prostu *NULL*."

msgid "We also remove the member definitions for these attributes::"
msgstr "Zdejmujemy także definicje członków dla tych własności::"

msgid "static PyMemberDef Noddy_members[] = {     {\"number\", T_INT, offsetof(Noddy, number), 0,      \"noddy number\"},     {NULL}  /* Sentinel */ };"
msgstr ""
"static PyMemberDef Noddy_members[] = {     {\"numer\", T_INT, offsetof(Noddy, "
"numer), 0,      \"noddy numer\"},     {NULL}  /* Ochrona */ };"

msgid "We also need to update the :attr:`tp_init` handler to only allow strings [#]_ to be passed::"
msgstr ""
"Musimy także uaktualnić obsługę :attr:`tp_init` aby tylko akceptowała ciągi "
"znaków [#]_ aby były przekazywane::"

msgid "static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|SSi\", kwlist,                                       &first, &last,                                       &self->number))         return -1;      if (first) {         tmp = self->first;         Py_INCREF(first);         self->first = first;         Py_DECREF(tmp);     }      if (last) {         tmp = self->last;         Py_INCREF(last);         self->last = last;         Py_DECREF(tmp);     }      return 0; }"
msgstr ""
"static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     "
"PyObject *imie=NULL, *nazwisko=NULL, *tmp;      static char *kwlist[] = "
"{\"imie\", \"nazwisko\", \"numer\", NULL};      if (! "
"PyArg_ParseTupleAndKeywords(args, kwds, \"|SSi\", kwlist, "
"                                      &imie, &nazwisko, "
"                                      &self->numer))         return -1; "
"     if (imie) {         tmp = self->imie;         Py_INCREF(imie); "
"        self->imie = imie;         Py_DECREF(tmp);     }      if (nazwisko) "
"{         tmp = self->nazwisko;         Py_INCREF(nazwisko);         "
"self->nazwisko = nazwisko;         Py_DECREF(tmp);     }      return 0; }"

msgid "With these changes, we can assure that the :attr:`first` and :attr:`last` members are never *NULL* so we can remove checks for *NULL* values in almost all cases. This means that most of the :cfunc:`Py_XDECREF` calls can be converted to :cfunc:`Py_DECREF` calls. The only place we can't change these calls is in the deallocator, where there is the possibility that the initialization of these members failed in the constructor."
msgstr ""
"Z tymi zmianami, możemy zapewnić, że członki :attr:`imie` i :attr:`nazwisko` "
"nigdy nie są *NULL* więc możemy zdjąć sprawdzenia wartości *NULL* w "
"większości przypadków. To oznacza, że większość z wywołań "
":cfunc:`Py_XDECREF` może być zamienionych na wywołania :cfunc:`Py_DECREF`. "
"Jedynym miejscem w którym nie możemy zmienić tych wywołań jest dealokator, "
"gdzie istnieje możliwość, że inicjacja tych członków zawiodła w "
"konstruktorze."

msgid "We also rename the module initialization function and module name in the initialization function, as we did before, and we add an extra definition to the :file:`setup.py` file."
msgstr ""
"Zmieniamy także zadanie inicjujące moduł i nazwę modułu w zadaniu "
"inicjującym, tak jak poprzednio, i dodajemy dodatkową definicję do pliku "
":file:`setup.py`."

msgid "Supporting cyclic garbage collection"
msgstr "Wsparcie dla cyklicznej zbiórki śmieci."

msgid "Python has a cyclic-garbage collector that can identify unneeded objects even when their reference counts are not zero. This can happen when objects are involved in cycles.  For example, consider::"
msgstr ""
"Język pytonowski ma cykliczną zbiórkę śmieci, która może identyfikować "
"niepotrzebne przedmioty nawet gdy ich liczby odniesień nie są równe zero. To "
"może się zdarzyć gdy przedmioty odnoszą się do siebie cyklicznie. Na "
"przykład, załóżmy::"

msgid ">>> l = [] >>> l.append(l) >>> del l"
msgstr ">>> l = [] >>> l.append(l) >>> del l"

msgid "In this example, we create a list that contains itself. When we delete it, it still has a reference from itself. Its reference count doesn't drop to zero. Fortunately, Python's cyclic-garbage collector will eventually figure out that the list is garbage and free it."
msgstr ""
"W tym przykładzie, tworzymy listę, która zawiera samą siebie. Gdy kasujemy "
"ją, to wciąż ma ona odniesienie do niej ze środka. Jej liczba odniesień nie "
"spada do zera. Na szczęście cykliczna-zbiórka śmieci języka pytonowskiego "
"ostatecznie że cała lista jest śmieciem i uwolni ją."

msgid "In the second version of the :class:`Noddy` example, we allowed any kind of object to be stored in the :attr:`first` or :attr:`last` attributes. [#]_ This means that :class:`Noddy` objects can participate in cycles::"
msgstr ""
"W drugiej wersji przykładu uogólnienia :class:`Noddy`, pozwoliliśmy "
"dowolnego rodzaju przedmiotowi aby był zachowany we własnościach "
":attr:`imie` lub :attr:`nazwisko`. [#]_ To oznacza że przedmioty "
":class:`Noddy` mogą brać udział w cyklicznych odwołaniach::"

msgid ">>> import noddy2 >>> n = noddy2.Noddy() >>> l = [n] >>> n.first = l"
msgstr ">>> import noddy2 >>> n = noddy2.Noddy() >>> l = [n] >>> n.first = l"

msgid "This is pretty silly, but it gives us an excuse to add support for the cyclic-garbage collector to the :class:`Noddy` example.  To support cyclic garbage collection, types need to fill two slots and set a class flag that enables these slots:"
msgstr ""
"To jest raczej głupie, ale daje nam wymówkę aby dodać wsparcie dla "
"cyklicznej zbiórki śmieci do przykładu uogólnienia :class:`Noddy`. Aby "
"wspierać cykliczną zbiórkę śmieci, typy potrzebują wypełniać dwa gniazda i "
"ustawić flagę uogólnienia która włącza te gniazda:"

msgid "#include <Python.h> #include \"structmember.h\"  typedef struct {     PyObject_HEAD     PyObject *first;     PyObject *last;     int number; } Noddy;  static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int vret;      if (self->first) {         vret = visit(self->first, arg);         if (vret != 0)             return vret;     }     if (self->last) {         vret = visit(self->last, arg);         if (vret != 0)             return vret;     }      return 0; }  static int  Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self->first;     self->first = NULL;     Py_XDECREF(tmp);      tmp = self->last;     self->last = NULL;     Py_XDECREF(tmp);      return 0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     Py_TYPE(self)->tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) {         self->first = PyUnicode_FromString(\"\");         if (self->first == NULL)           {             Py_DECREF(self);             return NULL;           }                  self->last = PyUnicode_FromString(\"\");         if (self->last == NULL)           {             Py_DECREF(self);             return NULL;           }          self->number = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,                                        &first, &last,                                        &self->number))         return -1;       if (first) {         tmp = self->first;         Py_INCREF(first);         self->first = first;         Py_XDECREF(tmp);     }      if (last) {         tmp = self->last;         Py_INCREF(last);         self->last = last;         Py_XDECREF(tmp);     }      return 0; }   static PyMemberDef Noddy_members[] = {     {\"first\", T_OBJECT_EX, offsetof(Noddy, first), 0,      \"first name\"},     {\"last\", T_OBJECT_EX, offsetof(Noddy, last), 0,      \"last name\"},     {\"number\", T_INT, offsetof(Noddy, number), 0,      \"noddy number\"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString(\"%s %s\");         if (format == NULL)             return NULL;     }      if (self->first == NULL) {         PyErr_SetString(PyExc_AttributeError, \"first\");         return NULL;     }      if (self->last == NULL) {         PyErr_SetString(PyExc_AttributeError, \"last\");         return NULL;     }      args = Py_BuildValue(\"OO\", self->first, self->last);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {\"name\", (PyCFunction)Noddy_name, METH_NOARGS,      \"Return the name, combining the first and last name\"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE |         Py_TPFLAGS_HAVE_GC,    /* tp_flags */     \"Noddy objects\",           /* tp_doc */     (traverseproc)Noddy_traverse,   /* tp_traverse */     (inquiry)Noddy_clear,           /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     0,                         /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy4module = {     PyModuleDef_HEAD_INIT,     \"noddy4\",     \"Example module that creates an extension type.\",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy4(void)  {     PyObject* m;      if (PyType_Ready(&NoddyType) < 0)         return NULL;      m = PyModule_Create(&noddy4module);     if (m == NULL)         return NULL;      Py_INCREF(&NoddyType);     PyModule_AddObject(m, \"Noddy\", (PyObject *)&NoddyType);     return m; }"
msgstr ""
"#include <Python.h> #include \"structmember.h\"  typedef struct {     "
"PyObject_HEAD     PyObject *imie;     PyObject *nazwisko;     int numer; } "
"Noddy;  static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) { "
"    int vret;      if (self->imie) {         vret = visit(self->imie, arg); "
"        if (vret != 0)             return vret;     }     if "
"(self->nazwisko) {         vret = visit(self->nazwisko, arg);         if "
"(vret != 0)             return vret;     }      return 0; }  static int  "
"Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self->imie;     "
"self->imie = NULL;     Py_XDECREF(tmp);      tmp = self->nazwisko;     "
"self->nazwisko = NULL;     Py_XDECREF(tmp);      return 0; }  static void "
"Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     "
"Py_TYPE(self)->tp_free((PyObject*)self); }  static PyObject * "
"Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy "
"*self;      self = (Noddy *)type->tp_alloc(type, 0);     if (self != NULL) { "
"        self->imie = PyUnicode_FromString(\"\");         if (self->imie == "
"NULL)           {             Py_DECREF(self);             return NULL; "
"          }                  self->nazwisko = PyUnicode_FromString(\"\"); "
"        if (self->nazwisko == NULL)           {             "
"Py_DECREF(self);             return NULL;           }          self->numer = "
"0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy "
"*self, PyObject *args, PyObject *kwds) {     PyObject *imie=NULL, "
"*nazwisko=NULL, *tmp;      static char *kwlist[] = {\"imie\", \"nazwisko\", "
"\"numer\", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", "
"kwlist,                                        &imie, &nazwisko, "
"                                       &self->numer))         return -1; "
"      if (imie) {         tmp = self->imie;         Py_INCREF(imie); "
"        self->imie = imie;         Py_XDECREF(tmp);     }      if "
"(nazwisko) {         tmp = self->nazwisko;         Py_INCREF(nazwisko); "
"        self->nazwisko = nazwisko;         Py_XDECREF(tmp);     }      "
"return 0; }   static PyMemberDef Noddy_members[] = {     {\"imie\", "
"T_OBJECT_EX, offsetof(Noddy, imie), 0,      \"imie\"},     {\"nazwisko\", "
"T_OBJECT_EX, offsetof(Noddy, last), 0,      \"nazwisko\"},     {\"numer\", "
"T_INT, offsetof(Noddy, numer), 0,      \"numer noddy\"},     {NULL}  /* "
"Ochrona */ };  static PyObject * Noddy_name(Noddy* self) {     static "
"PyObject *format = NULL;     PyObject *args, *result;      if (format == "
"NULL) {         format = PyUnicode_FromString(\"%s %s\");         if (format "
"== NULL)             return NULL;     }      if (self->imie == NULL) { "
"        PyErr_SetString(PyExc_AttributeError, \"imie\");         return NULL; "
"    }      if (self->nazwisko == NULL) {         "
"PyErr_SetString(PyExc_AttributeError, \"nazwisko\");         return NULL;     "
"}      args = Py_BuildValue(\"OO\", self->imie, self->nazwisko);     if (args "
"== NULL)         return NULL;      result = PyUnicode_Format(format, args); "
"    Py_DECREF(args);          return result; }  static PyMethodDef "
"Noddy_methods[] = {     {\"nazwisko\", (PyCFunction)Noddy_name, METH_NOARGS, "
"     \"Zwróć nazwisko, sklejając imię i nazwisko\"     },     {NULL}  /* "
"Ochrona */ };  static PyTypeObject NoddyType = {     "
"PyVarObject_HEAD_INIT(NULL, 0)     \"noddy.Noddy\",             /* tp_name */ "
"    sizeof(Noddy),             /* tp_basicsize */     0, "
"                        /* tp_itemsize */     (destructor)Noddy_dealloc, /* "
"tp_dealloc */     0,                         /* tp_print */     0, "
"                        /* tp_getattr */     0,                         /* "
"tp_setattr */     0,                         /* tp_reserved */     0, "
"                        /* tp_repr */     0,                         /* "
"tp_as_number */     0,                         /* tp_as_sequence */     0, "
"                        /* tp_as_mapping */     0,                         "
"/* tp_hash  */     0,                         /* tp_call */     0, "
"                        /* tp_str */     0,                         /* "
"tp_getattro */     0,                         /* tp_setattro */     0, "
"                        /* tp_as_buffer */     Py_TPFLAGS_DEFAULT | "
"        Py_TPFLAGS_BASETYPE |         Py_TPFLAGS_HAVE_GC,    /* tp_flags */ "
"    \"przedmioty Noddy\",           /* tp_doc */     "
"(traverseproc)Noddy_traverse,   /* tp_traverse */     (inquiry)Noddy_clear, "
"          /* tp_clear */     0,\t\t\t               /* tp_richcompare */     "
"0,\t\t               /* tp_weaklistoffset */     0,\t\t               /* tp_iter "
"*/     0,\t\t               /* tp_iternext */     Noddy_methods,             "
"/* tp_methods */     Noddy_members,             /* tp_members */     0, "
"                        /* tp_getset */     0,                         /* "
"tp_base */     0,                         /* tp_dict */     0, "
"                        /* tp_descr_get */     0,                         "
"/* tp_descr_set */     0,                         /* tp_dictoffset */     "
"(initproc)Noddy_init,      /* tp_init */     0,                         /* "
"tp_alloc */     Noddy_new,                 /* tp_new */ };  static "
"PyModuleDef noddy4module = {     PyModuleDef_HEAD_INIT,     \"noddy4\",     "
"\"Przykładowy moduł który tworzy typ rozszerzający.\",     -1,     NULL, NULL, "
"NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy4(void)  {     PyObject* m; "
"     if (PyType_Ready(&NoddyType) < 0)         return NULL;      m = "
"PyModule_Create(&noddy4module);     if (m == NULL)         return NULL; "
"     Py_INCREF(&NoddyType);     PyModule_AddObject(m, \"Noddy\", (PyObject "
"*)&NoddyType);     return m; }"

msgid "The traversal method provides access to subobjects that could participate in cycles::"
msgstr ""
"Sposób postępowania trawersujący dostarcza dostęp do podrzędnych przedmiotów "
"które mogą brać udział w cyklach::"

msgid "static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int vret;      if (self->first) {         vret = visit(self->first, arg);         if (vret != 0)             return vret;     }     if (self->last) {         vret = visit(self->last, arg);         if (vret != 0)             return vret;     }      return 0; }"
msgstr ""
"static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int "
"vret;      if (self->imie) {         vret = visit(self->imie, arg); "
"        if (vret != 0)             return vret;     }     if "
"(self->nazwisko) {         vret = visit(self->nazwisko, arg);         if "
"(vret != 0)             return vret;     }      return 0; }"

msgid "For each subobject that can participate in cycles, we need to call the :cfunc:`visit` function, which is passed to the traversal method. The :cfunc:`visit` function takes as arguments the subobject and the extra argument *arg* passed to the traversal method.  It returns an integer value that must be returned if it is non-zero."
msgstr ""
"Dla każdego podrzędnego przedmiotu który może brać udział w cyklach, "
"potrzebujemy wezwać zadanie :cfunc:`visit`, które jest przekazywane do "
"sposobu postępowania trawersującego. Zadanie :cfunc:`visit` pobiera jako "
"parametry podrzędne przedmioty i dodatkowy parametr *arg* przekazywany do "
"zadania trawersującego. Zwraca liczbę całkowitą która musi być zwrócona "
"jeśli jest nie-zerowa. "

msgid "Python provides a :cfunc:`Py_VISIT` macro that automates calling visit functions.  With :cfunc:`Py_VISIT`, :cfunc:`Noddy_traverse` can be simplified::"
msgstr ""
"Język pytonowski dostarcza makropolecenie :cfunc:`Py_VISIT` które "
"automatyzuje wzywania zadania wizytowania. Za pomocą :cfunc:`Py_VISIT` "
"zadanie :cfunc:`Noddy_traverse` może zostać uproszczona::"

msgid "static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     Py_VISIT(self->first);     Py_VISIT(self->last);     return 0; }"
msgstr ""
"static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     "
"Py_VISIT(self->imie);     Py_VISIT(self->nazwisko);     return 0; }"

msgid "Note that the :attr:`tp_traverse` implementation must name its arguments exactly *visit* and *arg* in order to use :cfunc:`Py_VISIT`.  This is to encourage uniformity across these boring implementations."
msgstr ""
"Zauważ, że wypełnienie własności :attr:`tp_traverse` musi nazywać swoje "
"argumenty dokładnie *visit* i *arg* w celu użycia zadania :cfunc:`Py_VISIT`. "
"To jest w celu zachęcenia do jednakowości pośród tych nudnych wypełnień."

msgid "We also need to provide a method for clearing any subobjects that can participate in cycles.  We implement the method and reimplement the deallocator to use it::"
msgstr ""
"My także potrzebujemy dostarczyć sposób postępowania dla czyszczenia "
"podrzędnych przedmiotów które mogą brać udział w cyklach. Wypełniamy sposób "
"postępowania i ponownie wypełniamy sposób postępowania uwalniający pamięć "
"aby go użyć::"

msgid "static int Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self->first;     self->first = NULL;     Py_XDECREF(tmp);      tmp = self->last;     self->last = NULL;     Py_XDECREF(tmp);      return 0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     Py_TYPE(self)->tp_free((PyObject*)self); }"
msgstr ""
"static int Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = "
"self->imie;     self->imie = NULL;     Py_XDECREF(tmp);      tmp = "
"self->nazwisko;     self->nazwisko = NULL;     Py_XDECREF(tmp);      return "
"0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     "
"Py_TYPE(self)->tp_free((PyObject*)self); }"

msgid "Notice the use of a temporary variable in :cfunc:`Noddy_clear`. We use the temporary variable so that we can set each member to *NULL* before decrementing its reference count.  We do this because, as was discussed earlier, if the reference count drops to zero, we might cause code to run that calls back into the object.  In addition, because we now support garbage collection, we also have to worry about code being run that triggers garbage collection.  If garbage collection is run, our :attr:`tp_traverse` handler could get called. We can't take a chance of having :cfunc:`Noddy_traverse` called when a member's reference count has dropped to zero and its value hasn't been set to *NULL*."
msgstr ""
"Zauważ użycie tymczasowej zmiennej w :cfunc:`Noddy_clear`. Używamy zmiennej "
"tymczasowej tak aby móc ustawić każdego członka na *NULL* zanim zmniejszymy "
"jego liczbę odniesień. Robimy to dlatego, że, jak wyjaśniono wcześniej, "
"jeśli liczba odniesień spadnie do zera, moglibyśmy spowodować, że kod "
"uruchomiłby się, który wywołuje wstecz do wnętrza przedmiotu. W dodatku, "
"ponieważ my teraz wspieramy zbieranie śmieci, musimy także martwić się o kod "
"który uruchamia się i wyzwala zbieranie śmieci. Jeśli zbieranie śmieci "
"zostanie uruchomione, nasza obsługa :attr:`tp_traverse` mogłaby być "
"wywołana. Nie możemy ryzykować wywołania :cfunc:`Noddy_traverse` gdy liczba "
"odniesień do członka spadła do zera i jego wartość nie została ustawiona na "
"*NULL*."

msgid "Python provides a :cfunc:`Py_CLEAR` that automates the careful decrementing of reference counts.  With :cfunc:`Py_CLEAR`, the :cfunc:`Noddy_clear` function can be simplified::"
msgstr ""
"Python dostarcza zadanie :cfunc:`Py_CLEAR` które automatyzuje ostrożne "
"zmniejszanie liczby odniesień.  Z zadaniem :cfunc:`Py_CLEAR`, zadanie "
":cfunc:`Noddy_clear` może zostać uproszczone::"

msgid "static int Noddy_clear(Noddy *self) {     Py_CLEAR(self->first);     Py_CLEAR(self->last);     return 0; }"
msgstr ""
"static int Noddy_clear(Noddy *self) {     Py_CLEAR(self->imie);     "
"Py_CLEAR(self->nazwisko);     return 0; }"

msgid "Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"Ostatecznie dodajemy flagę :const:`Py_TPFLAGS_HAVE_GC` do flag uogólnienia::"

msgid "Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */"
msgstr ""
"Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags "
"*/"

msgid "That's pretty much it.  If we had written custom :attr:`tp_alloc` or :attr:`tp_free` slots, we'd need to modify them for cyclic-garbage collection. Most extensions will use the versions automatically provided."
msgstr ""
"To z grubsza wszystko. Jeśli napisalibyśmy szczególne sposoby postępowania "
":attr:`tp_alloc` lub :attr:`tp_free` w gniazdach, potrzebowalibyśmy "
"zmodyfikować je dla cyklicznego zbierania śmieci. Większość rozszerzeń "
"będzie używać wersji dostarczonych automatycznie."

msgid "Subclassing other types"
msgstr "Tworzenie podrzędnych uogólnień innych typów"

msgid "It is possible to create new extension types that are derived from existing types. It is easiest to inherit from the built in types, since an extension can easily use the :class:`PyTypeObject` it needs. It can be difficult to share these :class:`PyTypeObject` structures between extension modules."
msgstr ""
"Jest możliwe tworzenie nowych typów rozszerzeń które są pochodnymi "
"istniejących typów. Najłatwiej jest dziedziczyć z typów wbudowanych od kiedy "
"rozszerzenie może łatwo używać uogólnienia :class:`PyTypeObject`, którego "
"potrzebuje. Może być trudno dzielić struktury uogólnienia "
":class:`PyTypeObject` pomiędzy moduły rozszerzające."

msgid "In this example we will create a :class:`Shoddy` type that inherits from the built-in :class:`list` type. The new type will be completely compatible with regular lists, but will have an additional :meth:`increment` method that increases an internal counter. ::"
msgstr ""
"W tym przykładzie utworzymy typ uogólnienie :class:`Shoddy` który będzie "
"dziedziczył po wbudowanych typach uogólnienia :class:`list`. Nowy typ będzie "
"kompletnie zgodny z regularnymi listami, ale będzie miał dodatkowy sposób "
"postępowania :meth:`increment` który zwiększa wewnętrzny licznik. ::"

msgid ">>> import shoddy >>> s = shoddy.Shoddy(range(3)) >>> s.extend(s) >>> print(len(s)) 6 >>> print(s.increment()) 1 >>> print(s.increment()) 2"
msgstr ""
">>> import shoddy >>> s = shoddy.Shoddy(range(3)) >>> s.extend(s) >>> "
"print(len(s)) 6 >>> print(s.increment()) 1 >>> print(s.increment()) 2"

msgid "#include <Python.h>  typedef struct {     PyListObject list;     int state; } Shoddy;   static PyObject * Shoddy_increment(Shoddy *self, PyObject *unused) {     self->state++;     return PyLong_FromLong(self->state); }   static PyMethodDef Shoddy_methods[] = {     {\"increment\", (PyCFunction)Shoddy_increment, METH_NOARGS,      PyDoc_STR(\"increment state counter\")},     {NULL,	NULL}, };  static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)         return -1;     self->state = 0;     return 0; }   static PyTypeObject ShoddyType = {     PyObject_HEAD_INIT(NULL)     \"shoddy.Shoddy\",         /* tp_name */     sizeof(Shoddy),          /* tp_basicsize */     0,                       /* tp_itemsize */     0,                       /* tp_dealloc */     0,                       /* tp_print */     0,                       /* tp_getattr */     0,                       /* tp_setattr */     0,                       /* tp_reserved */     0,                       /* tp_repr */     0,                       /* tp_as_number */     0,                       /* tp_as_sequence */     0,                       /* tp_as_mapping */     0,                       /* tp_hash */     0,                       /* tp_call */     0,                       /* tp_str */     0,                       /* tp_getattro */     0,                       /* tp_setattro */     0,                       /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE, /* tp_flags */     0,                       /* tp_doc */     0,                       /* tp_traverse */     0,                       /* tp_clear */     0,                       /* tp_richcompare */     0,                       /* tp_weaklistoffset */     0,                       /* tp_iter */     0,                       /* tp_iternext */     Shoddy_methods,          /* tp_methods */     0,                       /* tp_members */     0,                       /* tp_getset */     0,                       /* tp_base */     0,                       /* tp_dict */     0,                       /* tp_descr_get */     0,                       /* tp_descr_set */     0,                       /* tp_dictoffset */     (initproc)Shoddy_init,   /* tp_init */     0,                       /* tp_alloc */     0,                       /* tp_new */ };  static PyModuleDef shoddymodule = {     PyModuleDef_HEAD_INIT,     \"shoddy\",     \"Shoddy module\",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      ShoddyType.tp_base = &PyList_Type;     if (PyType_Ready(&ShoddyType) < 0)         return NULL;      m = PyModule_Create(&shoddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&ShoddyType);     PyModule_AddObject(m, \"Shoddy\", (PyObject *) &ShoddyType);     return m; }"
msgstr ""
"#include <Python.h>  typedef struct {     PyListObject list;     int stan; } "
"Shoddy;   static PyObject * Shoddy_increment(Shoddy *self, PyObject "
"*unused) {     self->stan++;     return PyLong_FromLong(self->stan); }   "
"static PyMethodDef Shoddy_methods[] = {     {\"increment\", "
"(PyCFunction)Shoddy_increment, METH_NOARGS,      PyDoc_STR(\"zwiększ licznik "
"stanu\")},     {NULL,\t\tNULL}, };  static int Shoddy_init(Shoddy *self, "
"PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject "
"*)self, args, kwds) < 0)         return -1;     self->stan = 0;     return "
"0; }   static PyTypeObject ShoddyType = {     PyObject_HEAD_INIT(NULL)     "
"\"shoddy.Shoddy\",         /* tp_name */     sizeof(Shoddy),          /* "
"tp_basicsize */     0,                       /* tp_itemsize */     0, "
"                      /* tp_dealloc */     0,                       /* "
"tp_print */     0,                       /* tp_getattr */     0, "
"                      /* tp_setattr */     0,                       /* "
"tp_reserved */     0,                       /* tp_repr */     0, "
"                      /* tp_as_number */     0,                       /* "
"tp_as_sequence */     0,                       /* tp_as_mapping */     0, "
"                      /* tp_hash */     0,                       /* tp_call "
"*/     0,                       /* tp_str */     0,                       "
"/* tp_getattro */     0,                       /* tp_setattro */     0, "
"                      /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         "
"Py_TPFLAGS_BASETYPE, /* tp_flags */     0,                       /* tp_doc "
"*/     0,                       /* tp_traverse */     0, "
"                      /* tp_clear */     0,                       /* "
"tp_richcompare */     0,                       /* tp_weaklistoffset */     "
"0,                       /* tp_iter */     0,                       /* "
"tp_iternext */     Shoddy_methods,          /* tp_methods */     0, "
"                      /* tp_members */     0,                       /* "
"tp_getset */     0,                       /* tp_base */     0, "
"                      /* tp_dict */     0,                       /* "
"tp_descr_get */     0,                       /* tp_descr_set */     0, "
"                      /* tp_dictoffset */     (initproc)Shoddy_init,   /* "
"tp_init */     0,                       /* tp_alloc */     0, "
"                      /* tp_new */ };  static PyModuleDef shoddymodule = { "
"    PyModuleDef_HEAD_INIT,     \"shoddy\",     \"Moduł shoddy\",     -1,     "
"NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_shoddy(void) {     "
"PyObject *m;      ShoddyType.tp_base = &PyList_Type;     if "
"(PyType_Ready(&ShoddyType) < 0)         return NULL;      m = "
"PyModule_Create(&shoddymodule);     if (m == NULL)         return NULL; "
"     Py_INCREF(&ShoddyType);     PyModule_AddObject(m, \"Shoddy\", (PyObject "
"*) &ShoddyType);     return m; }"

msgid "As you can see, the source code closely resembles the :class:`Noddy` examples in previous sections. We will break down the main differences between them. ::"
msgstr ""
"Jak widać, kod źródłowy blisko przypomina przykład uogólnienia "
":class:`Noddy` z poprzednich rozdziałów. Podzielimy główne różnice pomiędzy "
"nimi. ::"

msgid "typedef struct {     PyListObject list;     int state; } Shoddy;"
msgstr "typedef struct {     PyListObject list;     int stan; } Shoddy;"

msgid "The primary difference for derived type objects is that the base type's object structure must be the first value. The base type will already include the :cfunc:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"Główna różnica dla odziedziczonych przedmiotów typu jest tym że struktura "
"przedmiotu typu bazowego musi być pierwszą wartością. Typ bazowy będzie już "
"zawierał :cfunc:`PyObject_HEAD` na początku struktury."

msgid "When a Python object is a :class:`Shoddy` instance, its *PyObject\\** pointer can be safely cast to both *PyListObject\\** and *Shoddy\\**. ::"
msgstr ""
"Gdy przedmiot języka pytonowskiego jest przykładem uogólnienia "
":class:`Shoddy`, jego wskaźnik *PyObject\\** może być bezpiecznie zrzutować "
"na zarówno *PyListObject\\** i *Shoddy\\**. ::"

msgid "static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)        return -1;     self->state = 0;     return 0; }"
msgstr ""
"static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     "
"if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)        return -1; "
"    self->stan = 0;     return 0; }"

msgid "In the :attr:`__init__` method for our type, we can see how to call through to the :attr:`__init__` method of the base type."
msgstr ""
"W sposobie postępowania :attr:`__init__` dla naszego typu, możemy zobaczyć "
"jak wywołać sposób postępowania :attr:`__init__` typu bazowego."

msgid "This pattern is important when writing a type with custom :attr:`new` and :attr:`dealloc` methods. The :attr:`new` method should not actually create the memory for the object with :attr:`tp_alloc`, that will be handled by the base class when calling its :attr:`tp_new`."
msgstr ""
"Ten wzorzec jest istotny gdy pisze się typ z szczególnym wypełnieniem "
"sposobów postępowania :attr:`new` i :attr:`dealloc`. Sposób postępowania "
":attr:`new` nie powinien właściwie tworzyć pamięci dla przedmiotu z "
":attr:`tp_alloc`, który będzie obsługiwany przez uogólnienie bazowe gdy "
"wywoływany będzie jego sposób postępowania :attr:`tp_new`"

msgid "When filling out the :cfunc:`PyTypeObject` for the :class:`Shoddy` type, you see a slot for :cfunc:`tp_base`. Due to cross platform compiler issues, you can't fill that field directly with the :cfunc:`PyList_Type`; it can be done later in the module's :cfunc:`init` function. ::"
msgstr ""
"Gdy wypełniany jest :cfunc:`PyTypeObject` dla typu :class:`Shoddy`, "
"zobaczysz gniazdo dla :cfunc:`tp_base`. W związku z problemami krzyżowej "
"kompilacji na różnych maszynach/środowiskach, nie możesz wypełnić tego pola "
"bezpośrednio za pomocą :cfunc:`PyList_Type`; można to zrobić później w "
"zadaniu inicjującym modułu :cfunc:`init`. ::"

msgid "PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      ShoddyType.tp_base = &PyList_Type;     if (PyType_Ready(&ShoddyType) < 0)         return NULL;      m = PyModule_Create(&shoddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&ShoddyType);     PyModule_AddObject(m, \"Shoddy\", (PyObject *) &ShoddyType);     return m; }"
msgstr ""
"PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      "
"ShoddyType.tp_base = &PyList_Type;     if (PyType_Ready(&ShoddyType) < 0) "
"        return NULL;      m = PyModule_Create(&shoddymodule);     if (m == "
"NULL)         return NULL;      Py_INCREF(&ShoddyType);     "
"PyModule_AddObject(m, \"Shoddy\", (PyObject *) &ShoddyType);     return m; }"

msgid "Before calling :cfunc:`PyType_Ready`, the type structure must have the :attr:`tp_base` slot filled in. When we are deriving a new type, it is not necessary to fill out the :attr:`tp_alloc` slot with :cfunc:`PyType_GenericNew` -- the allocate function from the base type will be inherited."
msgstr ""
"Przed wywołaniem :cfunc:`PyType_Ready`, struktura typu musi mieć gniazdo "
":attr:`tp_base` zapełnione. Gdy nowy typ pochodzi od istniejącego, nie jest "
"konieczne wypełnianie gniazda :attr:`tp_alloc` za pomocą "
":cfunc:`PyType_GenericNew` -- zadanie umieszczania w pamięci zostanie "
"odziedziczone po typie bazowym."

msgid "After that, calling :cfunc:`PyType_Ready` and adding the type object to the module is the same as with the basic :class:`Noddy` examples."
msgstr ""
"Po tym, wezwanie :cfunc:`PyType_Ready` i dodanie przedmiotu typu do modułu "
"będzie tym samym jak w podstawowych przykładach uogólnienia :class:`Noddy`."

msgid "Type Methods"
msgstr "Sposoby postępowania typu"

msgid "This section aims to give a quick fly-by on the various type methods you can implement and what they do."
msgstr ""
"Ten rozdział ma na celu szybko oblecieć różne sposoby postępowania typów "
"które możesz wypełnić i omówić co one robią."

msgid "Here is the definition of :ctype:`PyTypeObject`, with some fields only used in debug builds omitted:"
msgstr ""
"Tu jest definicja :ctype:`PyTypeObject`, z pewnymi polami tylko używanymi w "
"budowach odpluskwiania zazwyczaj pomijanych:"

msgid "typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* For printing, in format \"<module>.<name>\" */     int tp_basicsize, tp_itemsize; /* For allocation */      /* Methods to implement standard operations */      destructor tp_dealloc;     printfunc tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void *tp_reserved;     reprfunc tp_repr;      /* Method suites for standard classes */      PyNumberMethods *tp_as_number;     PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping;      /* More standard operations (here for binary compatibility) */      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Functions to access object as input/output buffer */     PyBufferProcs *tp_as_buffer;      /* Flags to define presence of optional/expanded features */     long tp_flags;      char *tp_doc; /* Documentation string */      /* call function for all accessible objects */     traverseproc tp_traverse;      /* delete references to contained objects */     inquiry tp_clear;      /* rich comparisons */     richcmpfunc tp_richcompare;      /* weak reference enabler */     long tp_weaklistoffset;      /* Iterators */     getiterfunc tp_iter;     iternextfunc tp_iternext;      /* Attribute descriptor and subclassing stuff */     struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc tp_free; /* Low-level free-memory routine */     inquiry tp_is_gc; /* For PyObject_IS_GC */     PyObject *tp_bases;     PyObject *tp_mro; /* method resolution order */     PyObject *tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;"
msgstr ""
"typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* Dla "
"wypisywania, w formacie \"<moduł>.<nazwa>\" */     int tp_basicsize, "
"tp_itemsize; /* Dla lokowania w pamięci */      /* Sposoby postępowania aby "
"wypełnić standardowe operacje */      destructor tp_dealloc;     printfunc "
"tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void "
"*tp_reserved;     reprfunc tp_repr;      /* Zestawy sposobów postępowania "
"dla uogólnień standardowych */      PyNumberMethods *tp_as_number;     "
"PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping; "
"     /* Więcej standardowych operacji (tutaj tylko dla binarnej zgodności) "
"*/      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     "
"getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Zadania aby "
"uzyskać przedmiot dostępu jako wejściowo/wyjściową przestrzenią wymiany */ "
"    PyBufferProcs *tp_as_buffer;      /* Flagi aby zdefiniować obecność "
"opcjonalnych/rozszerzonych właściwości */     long tp_flags;      char "
"*tp_doc; /* Ciągi dokumentacji */      /* wywołanie zadania dla wszystkich "
"dostępnych przedmiotów */     traverseproc tp_traverse;      /* skasować "
"odniesienia do zawartych tam przedmiotów */     inquiry tp_clear;      /* "
"bogate porównania */     richcmpfunc tp_richcompare;      /* umożliwianie "
"słabych odniesień */     long tp_weaklistoffset;      /* iteratory */     "
"getiterfunc tp_iter;     iternextfunc tp_iternext;      /* deskryptor "
"właściwości i sprawy dziedziczenia */     struct PyMethodDef *tp_methods; "
"    struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     "
"struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc "
"tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     "
"initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc "
"tp_free; /* Nisko-poziomowe zadanie zwalniające pamięć */     inquiry "
"tp_is_gc; /* Dla PyObject_IS_GC */     PyObject *tp_bases;     PyObject "
"*tp_mro; /* kolejność rozwiązywania sposobów postępowania */     PyObject "
"*tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } "
"PyTypeObject;"

msgid "Now that's a *lot* of methods.  Don't worry too much though - if you have a type you want to define, the chances are very good that you will only implement a handful of these."
msgstr ""
"Cóż, to jest *dużo* sposobów postępowania. Nie martw się za bardzo jednak - "
"jeśli masz typ który chcesz zdefiniować, szanse są bardzo dobre, że będziesz "
"wypełniał tylko kilka z nich."

msgid "As you probably expect by now, we're going to go over this and give more information about the various handlers.  We won't go in the order they are defined in the structure, because there is a lot of historical baggage that impacts the ordering of the fields; be sure your type initialization keeps the fields in the right order!  It's often easiest to find an example that includes all the fields you need (even if they're initialized to ``0``) and then change the values to suit your new type. ::"
msgstr ""
"Jak już pewnie spodziewasz się teraz, przejdziemy się ponad tym i podamy "
"więcej informacji o różnych obsługach. Nie będziemy wdawać się w kolejność w "
"której są one zdefiniowane w strukturze ponieważ jest mnóstwo historycznego "
"bagażu który wpływa na poszeregowanie pól; upewnij się że twoje inicjowanie "
"typu utrzymuje pola we właściwym porządku! Czasem najłatwiej jest znaleźć "
"przykład, który zawiera wszystkie pola których potrzebujesz (nawet jeśli są "
"one zainicjowane ``0``) i potem zmienić wartości aby odpowiadały twojemu "
"nowemu typowi. ::"

msgid "char *tp_name; /* For printing */"
msgstr "char *tp_name; /* Dla wypisywania */"

msgid "The name of the type - as mentioned in the last section, this will appear in various places, almost entirely for diagnostic purposes. Try to choose something that will be helpful in such a situation! ::"
msgstr ""
"Nazwa typu - jak wymieniono w poprzednim rozdziale, to będzie pojawiało się "
"w różnych miejscach, prawie całkowicie dla celów diagnostycznych. Spróbuj "
"wybrać coś co będzie pomocne w takiej sytuacji! ::"

msgid "int tp_basicsize, tp_itemsize; /* For allocation */"
msgstr "int tp_basicsize, tp_itemsize; /* Dla umieszczania w pamięci */"

msgid "These fields tell the runtime how much memory to allocate when new objects of this type are created.  Python has some built-in support for variable length structures (think: strings, lists) which is where the :attr:`tp_itemsize` field comes in.  This will be dealt with later. ::"
msgstr ""
"Te pola mówią dla programu uruchomionego jak dużo pamięci przeznaczyć kiedy "
"nowe przedmioty tego typu są tworzone. Język pytonowski ma pewne wbudowane "
"wsparcie dla różnej długości struktur (mam na myśli: ciągi znaków, listy) "
"które jest tam, gdzie pole :attr:`tp_itemsize` pojawia się. Tym zajmiemy się "
"później. ::"

msgid "char *tp_doc;"
msgstr "char *tp_doc;"

msgid "Here you can put a string (or its address) that you want returned when the Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"Tu możesz wstawić ciąg znaków (lub jego adres) który chcesz zwrócić gdy "
"skrypt języka pytonowskiego odnosi się do ``obj.__doc__`` aby otrzymać ciąg "
"znaków dokumentacji."

msgid "Now we come to the basic type methods---the ones most extension types will implement."
msgstr ""
"A teraz dochodzimy do podstawowego typu sposobów postępowania---te których "
"większość typów rozszerzeń będzie wypełniać."

msgid "Finalization and De-allocation"
msgstr "Finalizowanie i Zwalnianie-miejsca"

msgid "destructor tp_dealloc;"
msgstr "destructor tp_dealloc;"

msgid "This function is called when the reference count of the instance of your type is reduced to zero and the Python interpreter wants to reclaim it.  If your type has memory to free or other clean-up to perform, put it here.  The object itself needs to be freed here as well.  Here is an example of this function::"
msgstr ""
"To zadanie jest wywoływane gdy liczba odniesień przykładu twojego typu jest "
"zredukowana do zera i program interpretujący polecenia języka pytonowskiego "
"chce przejąć je na powrót. Jeśli twój typ ma pamięć do zwolnienia lub inne "
"czyszczenie do wykonania, wstaw je tutaj. Przedmiot sam potrzebuje być "
"zwolniony także tutaj. Tu jest przykład tego zadania::"

msgid "static void newdatatype_dealloc(newdatatypeobject * obj) {     free(obj->obj_UnderlyingDatatypePtr);     Py_TYPE(obj)->tp_free(obj); }"
msgstr ""
"static void newdatatype_dealloc(newdatatypeobject * obj) {     "
"free(obj->obj_UnderlyingDatatypePtr);     Py_TYPE(obj)->tp_free(obj); }"

msgid "One important requirement of the deallocator function is that it leaves any pending exceptions alone.  This is important since deallocators are frequently called as the interpreter unwinds the Python stack; when the stack is unwound due to an exception (rather than normal returns), nothing is done to protect the deallocators from seeing that an exception has already been set.  Any actions which a deallocator performs which may cause additional Python code to be executed may detect that an exception has been set.  This can lead to misleading errors from the interpreter.  The proper way to protect against this is to save a pending exception before performing the unsafe action, and restoring it when done.  This can be done using the :cfunc:`PyErr_Fetch` and :cfunc:`PyErr_Restore` functions::"
msgstr ""
"Jednym istotnym wymaganiem zadania zwalniania pamięci jest to, że pozostawia "
"jakiekolwiek oczekujące wyjątki same sobie. To jest istotne odkąd zadania "
"zwalniające pamięć są często wywoływane gdy program interpretujący odwija "
"stertę programu interpretującego polecenia języka pytonowskiego; gdy sterta "
"jest odwinięta z powodu wyjątku (zamiast normalnych powrotów), nic nie jest "
"robione aby bronić zadania uwalniające miejsca w pamięci przed zobaczeniem "
"że wyjątek już został zgłoszony. Jakiekolwiek akcje które zadanie zwalniania "
"pamięci wykonają które mogą spowodować wykonanie dodatkowego kodu języka "
"pytonowskiego mogą wykryć że wyjątek został ustawiony. To może prowadzić do "
"wprowadzających zamieszanie błędów ze strony programu interpretującego. "
"Właściwą drogą aby bronić się przeciwko temu jest zapamiętać oczekujący "
"wyjątek przed wykonaniem niebezpiecznego działania, a potem odtworzyć je gdy "
"się skończy to ostatnie. To może być wykonywane używając zadań "
":cfunc:`PyErr_Fetch` i :cfunc:`PyErr_Restore`::"

msgid "static void my_dealloc(PyObject *obj) {     MyObject *self = (MyObject *) obj;     PyObject *cbresult;      if (self->my_callback != NULL) {         PyObject *err_type, *err_value, *err_traceback;         int have_error = PyErr_Occurred() ? 1 : 0;          if (have_error)             PyErr_Fetch(&err_type, &err_value, &err_traceback);          cbresult = PyObject_CallObject(self->my_callback, NULL);         if (cbresult == NULL)             PyErr_WriteUnraisable(self->my_callback);         else             Py_DECREF(cbresult);          if (have_error)             PyErr_Restore(err_type, err_value, err_traceback);          Py_DECREF(self->my_callback);     }     Py_TYPE(obj)->tp_free((PyObject*)self); }"
msgstr ""
"static void my_dealloc(PyObject *obj) {     MyObject *self = (MyObject *) "
"obj;     PyObject *cbresult;      if (self->my_callback != NULL) {         "
"PyObject *err_type, *err_value, *err_traceback;         int have_error = "
"PyErr_Occurred() ? 1 : 0;          if (have_error)             "
"PyErr_Fetch(&err_type, &err_value, &err_traceback);          cbresult = "
"PyObject_CallObject(self->my_callback, NULL);         if (cbresult == NULL) "
"            PyErr_WriteUnraisable(self->my_callback);         else "
"            Py_DECREF(cbresult);          if (have_error)             "
"PyErr_Restore(err_type, err_value, err_traceback);          "
"Py_DECREF(self->my_callback);     }     "
"Py_TYPE(obj)->tp_free((PyObject*)self); }"

msgid "Object Presentation"
msgstr "Prezentacja Przedmiotów"

msgid "In Python, there are two ways to generate a textual representation of an object: the :func:`repr` function, and the :func:`str` function.  (The :func:`print` function just calls :func:`str`.)  These handlers are both optional."
msgstr ""
"w języku pytonowskim, istnieją dwa sposoby aby wygenerować tekstową "
"reprezentację przedmiotu: zadanie :func:`repr`, i zadanie :func:`str`. "
"(Zadanie :func:`print` po prostu wywołuje zadanie :func:`str`.) Ta zadania "
"obsługi są oba opcjonalne."

msgid "reprfunc tp_repr; reprfunc tp_str;"
msgstr "reprfunc tp_repr; reprfunc tp_str;"

msgid "The :attr:`tp_repr` handler should return a string object containing a representation of the instance for which it is called.  Here is a simple example::"
msgstr ""
"Sposób postępowania obsługi :attr:`tp_repr` powinien zwrócić przedmiot ciągu "
"znaków zawierający reprezentację przykładu dla którego został wywołany. Tu "
"jest prosty przykład::"

msgid "static PyObject * newdatatype_repr(newdatatypeobject * obj) {     return PyString_FromFormat(\"Repr-ified_newdatatype{{size:\\%d}}\",                                obj->obj_UnderlyingDatatypePtr->size); }"
msgstr ""
"static PyObject * newdatatype_repr(newdatatypeobject * obj) {     return "
"PyString_FromFormat(\"Repr-ified_newdatatype{{size:\\%d}}\", "
"                               obj->obj_UnderlyingDatatypePtr->size); }"

msgid "If no :attr:`tp_repr` handler is specified, the interpreter will supply a representation that uses the type's :attr:`tp_name` and a uniquely-identifying value for the object."
msgstr ""
"Jeśli żadna :attr:`tp_repr` obsługa nie jest określona, program "
"interpretujący polecenia języka pytonowskiego dostarczy reprezentację, która "
"używa :attr:`tp_name` należącego do typu i jednoznacznie-identyfikującą "
"wartość dla przedmiotu."

msgid "The :attr:`tp_str` handler is to :func:`str` what the :attr:`tp_repr` handler described above is to :func:`repr`; that is, it is called when Python code calls :func:`str` on an instance of your object.  Its implementation is very similar to the :attr:`tp_repr` function, but the resulting string is intended for human consumption.  If :attr:`tp_str` is not specified, the :attr:`tp_repr` handler is used instead."
msgstr ""
"Obsługa :attr:`tp_str` jest dla zadania :func:`str` tym, czym obsługa "
":attr:`tp_repr` opisywana powyżej dla zadania :func:`repr`; to jest, jest "
"wzywana gdy kod języka pytonowskiego wywołuje :func:`str` na przykładzie "
"twojego przedmiotu. Jego wypełnienie jest bardzo podobne do zadania "
":attr:`tp_repr`, ale wynikający ciąg znaków jest przeznaczony do "
"przeczytania dla człowieka. Jeśli :attr:`tp_str` jest nieokreślona, obsługa "
":attr:`tp_repr` jest używana zamiast tego."

msgid "Here is a simple example::"
msgstr "Tu jest prosty przykład::"

msgid "static PyObject * newdatatype_str(newdatatypeobject * obj) {     return PyString_FromFormat(\"Stringified_newdatatype{{size:\\%d}}\",                                obj->obj_UnderlyingDatatypePtr->size); }"
msgstr ""
"static PyObject * newdatatype_str(newdatatypeobject * obj) {     return "
"PyString_FromFormat(\"Stringified_newdatatype{{size:\\%d}}\", "
"                               obj->obj_UnderlyingDatatypePtr->size); }"

msgid "Attribute Management"
msgstr "Zarządzanie własnościami"

msgid "For every object which can support attributes, the corresponding type must provide the functions that control how the attributes are resolved.  There needs to be a function which can retrieve attributes (if any are defined), and another to set attributes (if setting attributes is allowed).  Removing an attribute is a special case, for which the new value passed to the handler is *NULL*."
msgstr ""
"Dla każdego przedmiotu który może wspierać własności, odpowiadający typ musi "
"dostarczać zadań które kontrolują jak właściwości są rozwiązywane. "
"Potrzebne jest zadanie, które może przechwytywać właściwości (jeśli "
"jakiekolwiek są określone), i następny, aby ustawiać właściwości (jeśli "
"ustawianie właściwości jest dozwolone). Usunięcie właściwości jest "
"szczególnym przypadkiem, dla którego nowa wartość przekazywana do obsługi "
"jest *NULL*."

msgid "Python supports two pairs of attribute handlers; a type that supports attributes only needs to implement the functions for one pair.  The difference is that one pair takes the name of the attribute as a :ctype:`char\\*`, while the other accepts a :ctype:`PyObject\\*`.  Each type can use whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"Język pytonowski wspiera dwie pary zadań obsługujących właściwości; typ "
"który wspiera właściwości potrzebuje tylko wypełnić zadania dla jednej pary. "
"Różnica polega na tym, że jedna para przyjmuje nazwę właściwości jako "
":ctype:`char\\*`, podczas gdy inne akceptują :ctype:`PyObject\\*`. Każdy typ "
"może użyć którejkolwiek z par, która ma więcej sensu dla możliwego "
"wypełnienia. ::"

msgid "getattrfunc  tp_getattr;        /* char * version */ setattrfunc  tp_setattr; /* ... */ getattrofunc tp_getattro;       /* PyObject * version */ setattrofunc tp_setattro;"
msgstr ""
"getattrfunc  tp_getattr;        /* wersja char * */ setattrfunc  tp_setattr; "
"/* ... */ getattrofunc tp_getattro;       /* wersja PyObject * */ "
"setattrofunc tp_setattro;"

msgid "If accessing attributes of an object is always a simple operation (this will be explained shortly), there are generic implementations which can be used to provide the :ctype:`PyObject\\*` version of the attribute management functions. The actual need for type-specific attribute handlers almost completely disappeared starting with Python 2.2, though there are many examples which have not been updated to use some of the new generic mechanism that is available."
msgstr ""
"Jeśli dostawanie dostępu do własności przedmiotu jest zawsze prostą operacją "
"(to zostanie wyjaśnione niedługo), to istnieją proste wypełnienia, które "
"mogą być użyte aby dostarczyć wersję :ctype:`PyObject\\*` zadań "
"zarządzających własnościami. Właściwa potrzeba dla szczególnego-dla-typu "
"zadania obsługi własności prawie przestała istnieć poczynając od języka "
"pytonowskiego w wersji 2.2, chociaż istnieje wiele przykładów, które nie "
"zostały uaktualnione do używania nowego zastępczego mechanizmu chociaż jest "
"on dostępny."

msgid "Generic Attribute Management"
msgstr "Zastępcze zarządzanie właściwościami"

msgid "Most extension types only use *simple* attributes.  So, what makes the attributes simple?  There are only a couple of conditions that must be met:"
msgstr ""
"Większość typów rozszerzeń używa tylko *prostych* właściwości. Więc, co "
"sprawia że właściwości są proste? Istnieje tylko kilka warunków które należy "
"spełnić:"

msgid "The name of the attributes must be known when :cfunc:`PyType_Ready` is called."
msgstr ""
"Nazwa właściwości musi być znana gdy zadanie :cfunc:`PyType_Ready` jest "
"wzywane."

msgid "No special processing is needed to record that an attribute was looked up or set, nor do actions need to be taken based on the value."
msgstr ""
"Żadne szczególne przetwarzanie nie jest potrzebne aby zarejestrować, że "
"właściwość została pobrana lub ustawiona, ani też działania nie muszą być "
"podejmowane w oparciu o wartość."

msgid "Note that this list does not place any restrictions on the values of the attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"Zauważ że ta lista nie umieszcza żadnych ograniczeń na wartościach "
"właściwości, gdy wartości są obliczane, lub jak istotne dane są "
"przechowywane."

msgid "When :cfunc:`PyType_Ready` is called, it uses three tables referenced by the type object to create :term:`descriptor`\\s which are placed in the dictionary of the type object.  Each descriptor controls access to one attribute of the instance object.  Each of the tables is optional; if all three are *NULL*, instances of the type will only have attributes that are inherited from their base type, and should leave the :attr:`tp_getattro` and :attr:`tp_setattro` fields *NULL* as well, allowing the base type to handle attributes."
msgstr ""
"Gdy zadanie :cfunc:`PyType_Ready` jest wywoływane, używa trzech tabeli "
"określonych przez przedmiot typu aby tworzyć :term:`element opisujący`\\e "
"które są umieszczane w słowniku typu przedmiotu. Każdy element opisujący "
"kontroluje dostęp do jednej właściwości przykładu przedmiotu. Każda z tabel "
"jest opcjonalna; jeśli wszystkie trzy są *NULL*, przykłady typu będą miały "
"właściwości, które są dziedziczone z ich typu bazowego, i powinny pozostawić "
"pola :attr:`tp_getattro` i :attr:`tp_setattro` na *NULL* zarówno, "
"pozwalając aby typ bazowy obsługiwał właściwości."

msgid "The tables are declared as three fields of the type object::"
msgstr "Tabele są zadeklarowane jako trzy pola przedmiotu typu::"

msgid "struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members; struct PyGetSetDef *tp_getset;"
msgstr ""
"struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members; struct "
"PyGetSetDef *tp_getset;"

msgid "If :attr:`tp_methods` is not *NULL*, it must refer to an array of :ctype:`PyMethodDef` structures.  Each entry in the table is an instance of this structure::"
msgstr ""
"Jeśli :attr:`tp_methods` nie jest *NULL*, wtedy musi odnosić się do tabeli "
"struktur :ctype:`PyMethodDef`. Każdy wpis w tabeli jest przykładem tej "
"struktury::"

msgid "typedef struct PyMethodDef {     char        *ml_name;       /* method name */     PyCFunction  ml_meth;       /* implementation function */     int          ml_flags;      /* flags */     char        *ml_doc;        /* docstring */ } PyMethodDef;"
msgstr ""
"typedef struct PyMethodDef {     char        *ml_name;       /* nazwa "
"sposobu postępowania */     PyCFunction  ml_meth;       /* zadanie "
"wypełnienia */     int          ml_flags;      /* flagi */     char        "
"*ml_doc;        /* ciąg dokumentacji */ } PyMethodDef;"

msgid "One entry should be defined for each method provided by the type; no entries are needed for methods inherited from a base type.  One additional entry is needed at the end; it is a sentinel that marks the end of the array.  The :attr:`ml_name` field of the sentinel must be *NULL*."
msgstr ""
"Jeden wpis powinien być określony dla każdego sposobu postępowania "
"dostarczonego przez typ; żadne wpisy nie są potrzebne dla sposobów "
"postępowania odziedziczonych z typu bazowego. Jeden dodatkowy wpis jest "
"konieczny na końcu; jest to ochroniarz który oznacza koniec tabeli. Pole "
":attr:`ml_name` ochroniarza musi być *NULL*."

msgid "XXX Need to refer to some unified discussion of the structure fields, shared with the next section."
msgstr ""
"XXX Potrzeba odniesienia do pewnych systematycznych dyskusji pól struktury, "
"dzielonych z następną sekcją."

msgid "The second table is used to define attributes which map directly to data stored in the instance.  A variety of primitive C types are supported, and access may be read-only or read-write.  The structures in the table are defined as::"
msgstr ""
"Druga tabela jest używana aby określać właściwości które odnoszą się "
"bezpośrednio do danych przechowywanych w przykładzie. Różnorodne podstawowe "
"typy C są wspierane, i dostęp może być albo tylko-do-odczytu lub "
"odczyt-i-zapis. Struktury w tabeli są określone jako::"

msgid "typedef struct PyMemberDef {     char *name;     int   type;     int   offset;     int   flags;     char *doc; } PyMemberDef;"
msgstr ""
"typedef struct PyMemberDef {     char *name;     int   type;     int   "
"offset;     int   flags;     char *doc; } PyMemberDef;"

msgid "For each entry in the table, a :term:`descriptor` will be constructed and added to the type which will be able to extract a value from the instance structure.  The :attr:`type` field should contain one of the type codes defined in the :file:`structmember.h` header; the value will be used to determine how to convert Python values to and from C values.  The :attr:`flags` field is used to store flags which control how the attribute can be accessed."
msgstr ""
"Dla każdego wpisu w tabeli, zostanie skonstruowany :term:`element opisujący` "
"- z ang. - :term:`descriptor` i dodany do typu, który będzie mógł wydobyć "
"wartość ze struktury przykładu. Pole :attr:`type` powinno zawierać jeden z "
"kodów typu określonych w nagłówku :file:`structmember.h`; wartość będzie "
"użyta do określenia jak zamienić wartości języka pytonowskiego z i na "
"wartości C. Pole :attr:`flags` jest używane do przechowywania flag które "
"kontrolują, jak można uzyskać dostęp do właściwości."

msgid "XXX Need to move some of this to a shared section!"
msgstr "XXX Potrzeba przełożyć część z tego do współdzielonego rozdziału!"

msgid "The following flag constants are defined in :file:`structmember.h`; they may be combined using bitwise-OR."
msgstr ""
"Następujące stałe flag są określone w pliku :file:`structmember.h`; mogą "
"złączone przy użyciu bitowego-LUB."

msgid "Constant"
msgstr "Stała"

msgid "Meaning"
msgstr "Znaczenie"

msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

msgid "Never writable."
msgstr "Nigdy nie do wpisywania."

msgid ":const:`READ_RESTRICTED`"
msgstr ":const:`READ_RESTRICTED`"

msgid "Not readable in restricted mode."
msgstr "Nie do czytania w trybie z ograniczeniami."

msgid ":const:`WRITE_RESTRICTED`"
msgstr ":const:`WRITE_RESTRICTED`"

msgid "Not writable in restricted mode."
msgstr "Nie do pisania w trybie z ograniczeniami."

msgid ":const:`RESTRICTED`"
msgstr ":const:`RESTRICTED`"

msgid "Not readable or writable in restricted mode."
msgstr "Nie do czytania ani pisania w trybie z ograniczeniami."

msgid "An interesting advantage of using the :attr:`tp_members` table to build descriptors that are used at runtime is that any attribute defined this way can have an associated doc string simply by providing the text in the table.  An application can use the introspection API to retrieve the descriptor from the class object, and get the doc string using its :attr:`__doc__` attribute."
msgstr ""
"Interesującą zaletą używania tabeli :attr:`tp_members` do budowania "
"elementów opisujących ( - z ang. - descriptors), które są używane w czasie "
"wykonania programu jest to, że jakiekolwiek właściwości określone w ten "
"sposób mogą mieć dołączony ciąg znaków dokumentacji po prostu przez "
"dostarczenie tekstu w tabeli. Aplikacja może używać sprzęgu wglądu "
"wewnętrznego aby odbierać element opisujący z przedmiotu uogólnienia, i "
"pobierać ciąg znaków używając jego właściwości :attr:`__doc__`."

msgid "As with the :attr:`tp_methods` table, a sentinel entry with a :attr:`name` value of *NULL* is required."
msgstr ""
"Tak, jak w tabeli :attr:`tp_methods`, wpis ochroniarza z właściwością "
":attr:`name` o wartości *NULL* jest wymagany."

msgid "Type-specific Attribute Management"
msgstr "Szczególne-dla-typu-przedmiotu zarządzanie właściwościami"

msgid "For simplicity, only the :ctype:`char\\*` version will be demonstrated here; the type of the name parameter is the only difference between the :ctype:`char\\*` and :ctype:`PyObject\\*` flavors of the interface. This example effectively does the same thing as the generic example above, but does not use the generic support added in Python 2.2.  It explains how the handler functions are called, so that if you do need to extend their functionality, you'll understand what needs to be done."
msgstr ""
"Dla prostoty, tylko wersja :ctype:`char\\*` będzie zademonstrowana tutaj; typ "
"parametru nazwy jest jedyną różnicą pomiędzy odcieniami sprzęgu "
":ctype:`char\\*` i :ctype:`PyObject\\*`. Ten przykład efektywnie czyni tę samą "
"rzecz, jak zastępcze przykłady powyżej, ale nie używa zastępczego wsparcia "
"dodanego w wersji języka pytonowskiego 2.2. To wyjaśnia, jak zadania obsługi "
"są wywoływane, tak że jeśli potrzebujesz rozszerzyć ich możliwości, "
"będziesz rozumiał co trzeba zrobić."

msgid "The :attr:`tp_getattr` handler is called when the object requires an attribute look-up.  It is called in the same situations where the :meth:`__getattr__` method of a class would be called."
msgstr ""
"Sposób postępowania obsługi właściwości :attr:`tp_getattr` jest wzywany gdy "
"przedmiot wymaga podejrzenia wartości właściwości. Jest wzywany w tych "
"samych sytuacjach, gdzie sposób postępowania :meth:`__getattr__` byłoby "
"wezwane."

msgid "Here is an example::"
msgstr "Tu jest przykład::"

msgid "static PyObject * newdatatype_getattr(newdatatypeobject *obj, char *name) {     if (strcmp(name, \"data\") == 0)     {         return PyInt_FromLong(obj->data);     }      PyErr_Format(PyExc_AttributeError,                  \"'%.50s' object has no attribute '%.400s'\",                  tp->tp_name, name);     return NULL; }"
msgstr ""
"static PyObject * newdatatype_getattr(newdatatypeobject *obj, char *name) { "
"    if (strcmp(name, \"data\") == 0)     {         return "
"PyInt_FromLong(obj->data);     }      PyErr_Format(PyExc_AttributeError, "
"                 \"'%.50s' przedmiot nie ma właściwości '%.400s'\", "
"                 tp->tp_name, name);     return NULL; }"

msgid "The :attr:`tp_setattr` handler is called when the :meth:`__setattr__` or :meth:`__delattr__` method of a class instance would be called.  When an attribute should be deleted, the third parameter will be *NULL*.  Here is an example that simply raises an exception; if this were really all you wanted, the :attr:`tp_setattr` handler should be set to *NULL*. ::"
msgstr ""
"Obsługa właściwości :attr:`tp_setattr` jest wywoływana gdy sposoby "
"postępowania :meth:`__setattr__` lub :meth:`__delattr__` przykładu "
"uogólnienia byłyby wzywane. Gdy właściwość powinna być skasowana, trzeci "
"parametr będzie *NULL*. Tutaj jest przykład, który prosto wywołuje wyjątek; "
"jeśli to byłoby wszystkim czego potrzebujesz, obsługa :attr:`tp_setattr` "
"powinna być ustawiona na *NULL*. ::"

msgid "static int newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v) {     (void)PyErr_Format(PyExc_RuntimeError, \"Read-only attribute: \\%s\", name);     return -1; }"
msgstr ""
"static int newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject "
"*v) {     (void)PyErr_Format(PyExc_RuntimeError, \"właściwość tylko-do-"
"odczytu: \\%s\", name);     return -1; }"

msgid "Object Comparison"
msgstr "Porównywanie przedmiotów"

msgid "richcmpfunc tp_richcompare;"
msgstr "richcmpfunc tp_richcompare;"

msgid "The :attr:`tp_richcompare` handler is called when comparisons are needed.  It is analogous to the :ref:`rich comparison methods <richcmpfuncs>`, like :meth:`__lt__`, and also called by :cfunc:`PyObject_RichCompare` and :cfunc:`PyObject_RichCompareBool`."
msgstr ""
"sposób postępowania obsługi :attr:`tp_richcompare` jest wywoływany gdy "
"porównania są oczekiwane. Jest to analogiczne z :ref:`sposobami postępowania "
"bogatego porównywania <richcmpfuncs>` - z ang. - :ref:`rich comparison "
"methods <richcmpfuncs>`, jak :meth:`__lt__` i także wzywane przez "
":cfunc:`PyObject_RichCompare` i :cfunc:`PyObject_RichCompareBool`."

msgid "This function is called with two Python objects and the operator as arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, ``Py_GT``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with respect to the specified operator and return ``Py_True`` or ``Py_False`` if the comparison is successfull, ``Py_NotImplemented`` to indicate that comparison is not implemented and the other object's comparison method should be tried, or *NULL* if an exception was set."
msgstr ""
"To zadanie jest wzywane z dwoma przedmiotami języka pytonowskiego i "
"operatorem jako parametrami, gdzie operator jest jednym z ``Py_EQ``, "
"``Py_NE``, ``Py_LE``, ``Py_GT``, ``Py_LT`` lub ``Py_GT``. Powinno porównywać "
"dwa przedmioty z uwzględnieniem wyszczególnionego operatora i zwracać "
"``Py_True`` lub ``Py_False`` jeśli porównanie jest udane, "
"``Py_NotImplemented`` aby zaznaczyć że porównanie nie jest wypełnione i że "
"inny sposób porównania przedmiotów powinien być wypróbowany, lub *NULL* "
"jeśli wyjątek został ustawiony."

msgid "Here is a sample implementation, for a datatype that is considered equal if the size of an internal pointer is equal::"
msgstr ""
"Tu jest przykładowe wypełnienie, dla typu danych który jest uznawany za "
"równy, jeśli rozmiar wewnętrznego wskaźnika jest równy::"

msgid "static int newdatatype_richcmp(PyObject *obj1, PyObject *obj2, int op) {     PyObject *result;     int c, size1, size2;      /* code to make sure that both arguments are of type        newdatatype omitted */      size1 = obj1->obj_UnderlyingDatatypePtr->size;     size2 = obj2->obj_UnderlyingDatatypePtr->size;      switch (op) {     case Py_LT: c = size1 <  size2; break;     case Py_LE: c = size1 <= size2; break;     case Py_EQ: c = size1 == size2; break;     case Py_NE: c = size1 != size2; break;     case Py_GT: c = size1 >  size2; break;     case Py_GE: c = size1 >= size2; break;     }     result = c ? Py_True : Py_False;     Py_INCREF(result);     return result;  }"
msgstr ""
"static int newdatatype_richcmp(PyObject *obj1, PyObject *obj2, int op) { "
"    PyObject *result;     int c, size1, size2;      /* kod do upewnienia "
"się że oba parametry są typu        newdatatype pominięty */      size1 = "
"obj1->obj_UnderlyingDatatypePtr->size;     size2 = "
"obj2->obj_UnderlyingDatatypePtr->size;      switch (op) {     case Py_LT: c "
"= size1 <  size2; break;     case Py_LE: c = size1 <= size2; break;     case "
"Py_EQ: c = size1 == size2; break;     case Py_NE: c = size1 != size2; "
"break;     case Py_GT: c = size1 >  size2; break;     case Py_GE: c = size1 "
">= size2; break;     }     result = c ? Py_True : Py_False;     "
"Py_INCREF(result);     return result;  }"

msgid "Abstract Protocol Support"
msgstr "Wsparcie protokołu abstrakcyjnego"

msgid "Python supports a variety of *abstract* 'protocols;' the specific interfaces provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Język pytonowski wspiera różne *abstrakcyjne* 'protokoły;' szczegółowe "
"sprzęgi dostarczone do użycia tych sprzęgów są udokumentowane w "
":ref:`abstract` - z ang. - :ref:`abstrakt`."

msgid "A number of these abstract interfaces were defined early in the development of the Python implementation.  In particular, the number, mapping, and sequence protocols have been part of Python since the beginning.  Other protocols have been added over time.  For protocols which depend on several handler routines from the type implementation, the older protocols have been defined as optional blocks of handlers referenced by the type object.  For newer protocols there are additional slots in the main type object, with a flag bit being set to indicate that the slots are present and should be checked by the interpreter.  (The flag bit does not indicate that the slot values are non-*NULL*. The flag may be set to indicate the presence of a slot, but a slot may still be unfilled.) ::"
msgstr ""
"Pewna część z tych abstrakcyjnych sprzęgów została zdefiniowana wcześnie w "
"czasie tworzenia wypełnienia języka pytonowskiego. W szczególności protokoły "
"liczbowy, mapowania i sekwencyjny były częścią języka pytonowskiego od "
"początku. Inne protokoły były dodawane później. Dla protokołów, które zależą "
"od kilku sposobów postępowania z wypełnienia typu, starsze protokoły "
"zostały zdefiniowane jako opcjonalne bloki uchwytów obsługi do których "
"odnosi się przedmiot typu. Dla nowszych protokołów istnieją dodatkowe "
"gniazda w głównym przedmiocie typu, z bitem flagi ustawionym aby wskazywać "
"że gniazda są obecne i powinny być sprawdzane przez program interpretujący "
"polecenia języka pytonowskiego. (Bit flagi nie wskazuje, że wartości gniazd "
"są niepuste - (non-*NULL*). Flaga może zostać ustawiona aby wskazać obecność "
"gniazda, ale gniazdo wciąż może być niezapełnione.) ::"

msgid "PyNumberMethods   tp_as_number; PySequenceMethods tp_as_sequence; PyMappingMethods  tp_as_mapping;"
msgstr ""
"PyNumberMethods   tp_as_number; PySequenceMethods tp_as_sequence; "
"PyMappingMethods  tp_as_mapping;"

msgid "If you wish your object to be able to act like a number, a sequence, or a mapping object, then you place the address of a structure that implements the C type :ctype:`PyNumberMethods`, :ctype:`PySequenceMethods`, or :ctype:`PyMappingMethods`, respectively. It is up to you to fill in this structure with appropriate values. You can find examples of the use of each of these in the :file:`Objects` directory of the Python source distribution. ::"
msgstr ""
"Jeśli wolisz aby twój przedmiot był w stanie działać jak liczba, sekwencja, "
"lub przedmiot mapujący, wtedy umieszczasz adres struktury która wypełnia "
"zadania typu C :ctype:`PyNumberMethods`, :ctype:`PySequenceMethods`, lub "
":ctype:`PyMappingMethods`, odpowiednio. To już zależy od Ciebie, aby "
"wypełnić tą strukturę odpowiednimi wartościami. Można znaleźć przykłady "
"użycia każdego z tych w katalogu :file:`Objects` dystrybucji źródłowej "
"języka pytonowskiego. ::"

msgid "hashfunc tp_hash;"
msgstr "hashfunc tp_hash;"

msgid "This function, if you choose to provide it, should return a hash number for an instance of your data type. Here is a moderately pointless example::"
msgstr ""
"To zadanie, jeśli wybierzesz aby je dostarczyć, powinno zwrócić numer hash "
"dla przykładu twojego typu danych. Tu jest umiarkowanie bezużyteczny "
"przykład::"

msgid "static long newdatatype_hash(newdatatypeobject *obj) {     long result;     result = obj->obj_UnderlyingDatatypePtr->size;     result = result * 3;     return result; }"
msgstr ""
"static long newdatatype_hash(newdatatypeobject *obj) {     long result;     "
"result = obj->obj_UnderlyingDatatypePtr->size;     result = result * 3;     "
"return result; }"

msgid "ternaryfunc tp_call;"
msgstr "ternaryfunc tp_call;"

msgid "This function is called when an instance of your data type is \"called\", for example, if ``obj1`` is an instance of your data type and the Python script contains ``obj1('hello')``, the :attr:`tp_call` handler is invoked."
msgstr ""
"To zadanie jest wzywane gdy przykład twojego typu danych jest \"wzywany\", dla "
"przykładu, jeśli ``obj1`` jest przykładem twojego typu danych i skrypt "
"języka pytonowskiego zawiera ``obj1('hello')``, uchwyt obsługi "
":attr:`tp_call` jest wywoływany."

msgid "This function takes three arguments:"
msgstr "To zadanie pobiera trzy parametry:"

msgid "*arg1* is the instance of the data type which is the subject of the call. If the call is ``obj1('hello')``, then *arg1* is ``obj1``."
msgstr ""
"*arg1* jest przykładem typu danych który jest przedmiotem wywołania. Jeśli "
"wywołanie jest ``obj1('hello')``, wtedy *arg1* jest ``obj1``."

msgid "*arg2* is a tuple containing the arguments to the call.  You can use :cfunc:`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*arg2* jest krotką zawierającą parametry wywołania. Można użyć "
":cfunc:`PyArg_ParseTuple` aby wydobyć parametry."

msgid "*arg3* is a dictionary of keyword arguments that were passed. If this is non-*NULL* and you support keyword arguments, use :cfunc:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want to support keyword arguments and this is non-*NULL*, raise a :exc:`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*arg3* jest słownikiem parametrów słów kluczowych które zostały przekazane. "
"Jeśli to jest niepuste ( - z ang. - non-*NULL*) a ty wspierasz parametry "
"słów kluczowych, użyj :cfunc:`PyArg_ParseTupleAndKeywords` aby wydobyć "
"parametry. Jeśli nie chcesz wspierać parametrów słów kluczowych i to jest "
"niepuste (non-*NULL*), zgłoś :exc:`TypeError` z wiadomością mówiącą że "
"parametry słów kluczowych nie są wspierane."

msgid "Here is a desultory example of the implementation of the call function. ::"
msgstr "Tu jest niepełny przykład wypełnienia wywołania zadania. ::"

msgid "/* Implement the call function.  *    obj1 is the instance receiving the call.  *    obj2 is a tuple containing the arguments to the call, in this  *         case 3 strings.  */ static PyObject * newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *other) {     PyObject *result;     char *arg1;     char *arg2;     char *arg3;      if (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {         return NULL;     }     result = PyString_FromFormat(         \"Returning -- value: [\\%d] arg1: [\\%s] arg2: [\\%s] arg3: [\\%s]\\n\",         obj->obj_UnderlyingDatatypePtr->size,         arg1, arg2, arg3);     printf(\"\\%s\", PyString_AS_STRING(result));     return result; }"
msgstr ""
"/* Wypełnienie zadania wywołania.  *    obj1 jest przykładem otrzymującym "
"wywołanie.  *    obj2 jest krotką zawierającą parametry wywołania, w tym "
"przypadku 3 ciągi znaków.  */ static PyObject * "
"newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *other) { "
"    PyObject *result;     char *arg1;     char *arg2;     char *arg3;      "
"if (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {         "
"return NULL;     }     result = PyString_FromFormat(         \"Powrotne -- "
"wartość: [\\%d] arg1: [\\%s] arg2: [\\%s] arg3: [\\%s]\\n\",         "
"obj->obj_UnderlyingDatatypePtr->size,         arg1, arg2, arg3);     "
"printf(\"\\%s\", PyString_AS_STRING(result));     return result; }"

msgid "XXX some fields need to be added here... ::"
msgstr "XXX niektóre pola powinny być tu dodane... ::"

msgid "/* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext;"
msgstr "/* Iteratory */ getiterfunc tp_iter; iternextfunc tp_iternext;"

msgid "These functions provide support for the iterator protocol.  Any object which wishes to support iteration over its contents (which may be generated during iteration) must implement the ``tp_iter`` handler.  Objects which are returned by a ``tp_iter`` handler must implement both the ``tp_iter`` and ``tp_iternext`` handlers. Both handlers take exactly one parameter, the instance for which they are being called, and return a new reference.  In the case of an error, they should set an exception and return *NULL*."
msgstr ""
"Te zadania dostarczają wsparcia dla protokołu iteratora. Każdy przedmiot "
"który chce wspierać iterację po swojej zawartości (która może być tworzona w "
"czasie iteracji) musi wypełnić uchwyt obsługi ``tp_iter``. Przedmioty, "
"które są zwracane przez obsługę ``tp_iter`` muszą wypełniać uchwyty obsługi "
"zarówno ``tp_iter``, jak i ``tp_iternext``. Oba uchwyty obsługi pobierają "
"dokładnie jeden parametr, przykład dla którego zostały wywołane, i zwracają "
"nowe odniesienie. W przypadku błędu, powinny ustawiać wyjątek i zwracać "
"*NULL*."

msgid "For an object which represents an iterable collection, the ``tp_iter`` handler must return an iterator object.  The iterator object is responsible for maintaining the state of the iteration.  For collections which can support multiple iterators which do not interfere with each other (as lists and tuples do), a new iterator should be created and returned.  Objects which can only be iterated over once (usually due to side effects of iteration) should implement this handler by returning a new reference to themselves, and should also implement the ``tp_iternext`` handler.  File objects are an example of such an iterator."
msgstr ""
"Dla przedmiotu który reprezentuje możliwą do iterowania kolekcję, uchwyt "
"obsługi ``tp_iter`` musi zwracać przedmiot iterujący. Przedmiot iterujący "
"jest odpowiedzialny za utrzymywanie stanu iteracji. Dla kolekcji które mogą "
"wspierać wiele przedmiotów iterujących, które nie nachodzą na siebie (tak "
"jak listy i krotki), nowy przedmiot iterujący powinien być utworzony i "
"zwrócony. Przedmioty które mogą tylko być iterowane raz (zwykle z powodu "
"efektów ubocznych iteracji) powinny wypełniać ten uchwyt obsługi, przez "
"zwrócenie nowego odniesienia do nich samych i powinny także wypełniać uchwyt "
"obsługi ``tp_iternext``. Przedmioty pliku są przykładami takich przedmiotów "
"iterujących."

msgid "Iterator objects should implement both handlers.  The ``tp_iter`` handler should return a new reference to the iterator (this is the same as the ``tp_iter`` handler for objects which can only be iterated over destructively).  The ``tp_iternext`` handler should return a new reference to the next object in the iteration if there is one.  If the iteration has reached the end, it may return *NULL* without setting an exception or it may set :exc:`StopIteration`; avoiding the exception can yield slightly better performance.  If an actual error occurs, it should set an exception and return *NULL*."
msgstr ""
"Przedmioty iterujące powinny wypełniać oba uchwyty obsługujące. Uchwyt "
"obsługi ``tp_iter`` powinien zwracać nowe odniesienie do przedmiotu "
"iterującego (to jest tak samo jak dla uchwytu obsługi ``tp_iter`` dla "
"przedmiotów, które mogą tylko iterować destrukcyjnie). Uchwyt obsługi "
"``tp_iternext`` powinien zwracać nowe odniesienie do następnego przedmiotu w "
"iteracji jeśli jest taki. Jeśli iteracja dobiegła końca, może zwrócić "
"*NULL* bez ustawiania wyjątku lub może ustawić wyjątek :exc:`StopIteration`; "
"pominięcie wyjątku może dawać nieco lepsze wyniki czasu działania. Jeśli "
"właściwe błędy nastąpią, powinno się ustawić wyjątek i zwrócić *NULL*."

msgid "Weak Reference Support"
msgstr "Wsparcie dla słabych odniesień"

msgid "One of the goals of Python's weak-reference implementation is to allow any type to participate in the weak reference mechanism without incurring the overhead on those objects which do not benefit by weak referencing (such as numbers)."
msgstr ""
"Jednym z celów wypełnienia słabych odniesień języka pytonowskiego jest "
"pozwolenie aby jakikolwiek typ brał udział w mechanizmie słabych odniesień "
"bez powodowania nadwyżki obliczeń na tych przedmiotach które nie korzystają "
"ze słabych odniesień (takich jak liczby).  "

msgid "For an object to be weakly referencable, the extension must include a :ctype:`PyObject\\*` field in the instance structure for the use of the weak reference mechanism; it must be initialized to *NULL* by the object's constructor.  It must also set the :attr:`tp_weaklistoffset` field of the corresponding type object to the offset of the field. For example, the instance type is defined with the following structure::"
msgstr ""
"Dla przedmiotu aby można było słabo się do niego odnieść, rozszerzenie musi "
"zawierać pole :ctype:`PyObject\\*` w strukturze przykładu dla użycia "
"mechanizmu słabych odniesień; musi być zainicjowane na *NULL* przez "
"konstruktor przedmiotu. Musi też ustawiać pole :attr:`tp_weaklistoffset` "
"odpowiadającego przedmiotu typu na przesunięcie względne pola. Dla "
"przykładu, typ przykładu jest określony z następującą strukturą::"

msgid "typedef struct {     PyObject_HEAD     PyClassObject *in_class;       /* The class object */     PyObject      *in_dict;        /* A dictionary */     PyObject      *in_weakreflist; /* List of weak references */ } PyInstanceObject;"
msgstr ""
"typedef struct {     PyObject_HEAD     PyClassObject *in_class;       /* "
"Przedmiot uogólnienia */     PyObject      *in_dict;        /* Słownik */ "
"    PyObject      *in_weakreflist; /* Lista słabych odniesień */ } "
"PyInstanceObject;"

msgid "The statically-declared type object for instances is defined this way::"
msgstr ""
"Statycznie-określony typ przedmiotu dla przykładów jest określony w ten "
"sposób::"

msgid "PyTypeObject PyInstance_Type = {     PyVarObject_HEAD_INIT(&PyType_Type, 0)     0,     \"module.instance\",      /* Lots of stuff omitted for brevity... */      Py_TPFLAGS_DEFAULT,                         /* tp_flags */     0,                                          /* tp_doc */     0,                                          /* tp_traverse */     0,                                          /* tp_clear */     0,                                          /* tp_richcompare */     offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */ };"
msgstr ""
"PyTypeObject PyInstance_Type = {     PyVarObject_HEAD_INIT(&PyType_Type, 0) "
"    0,     \"module.instance\",      /* Mnóstwo rzeczy pominięte dla "
"skrótowości... */      Py_TPFLAGS_DEFAULT,                         /* "
"tp_flags */     0,                                          /* tp_doc */ "
"    0,                                          /* tp_traverse */     0, "
"                                         /* tp_clear */     0, "
"                                         /* tp_richcompare */     "
"offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */ };"

msgid "The type constructor is responsible for initializing the weak reference list to *NULL*::"
msgstr ""
"Konstruktor jest odpowiedzialny za zainicjowanie listy słabych odniesień na "
"*NULL*::"

msgid "static PyObject * instance_new() {     /* Other initialization stuff omitted for brevity */      self->in_weakreflist = NULL;      return (PyObject *) self; }"
msgstr ""
"static PyObject * instance_new() {     /* Inne sprawy inicjowania pominięte "
"dla skrótowości */      self->in_weakreflist = NULL;      return (PyObject "
"*) self; }"

msgid "The only further addition is that the destructor needs to call the weak reference manager to clear any weak references.  This should be done before any other parts of the destruction have occurred, but is only required if the weak reference list is non-*NULL*::"
msgstr ""
"Jedyny dalszy dodatek jest tym że destruktor potrzebuje wezwać zarządcę "
"słabych odniesień aby wyczyścił jakiekolwiek słabe odniesienia. To powinno "
"być zrobione przed tym jak jakiekolwiek inne części destrukcji nastąpiły, "
"ale jest wymagane tylko jeśli lista słabych odniesień jest nie pusta - z "
"ang. - non-*NULL*::"

msgid "static void instance_dealloc(PyInstanceObject *inst) {     /* Allocate temporaries if needed, but do not begin        destruction just yet.      */      if (inst->in_weakreflist != NULL)         PyObject_ClearWeakRefs((PyObject *) inst);      /* Proceed with object destruction normally. */ }"
msgstr ""
"static void instance_dealloc(PyInstanceObject *inst) {     /* Przeznacz "
"miejsce dla tymczasowych jeśli potrzeba, ale nie zaczynaj destrukcji jeszcze "
"w tej chwili.      */      if (inst->in_weakreflist != NULL)         "
"PyObject_ClearWeakRefs((PyObject *) inst);      /* Postępuj z destrukcją "
"przedmiotów normalnie. */ }"

msgid "More Suggestions"
msgstr "Więcej sugestii"

msgid "Remember that you can omit most of these functions, in which case you provide ``0`` as a value.  There are type definitions for each of the functions you must provide.  They are in :file:`object.h` in the Python include directory that comes with the source distribution of Python."
msgstr ""
"Pamiętaj że możesz pominąć większość z tych zadań, w którym to przypadku, "
"dostarczysz ``0`` jako wartość. Istnieją definicje typu dla każdego zadania "
"które musisz dostarczyć. Są one w pliku :file:`object.h` w katalogu "
"załączania języka pytonowskiego, który dostarczony jest w źródłowej "
"dystrybucji języka pytonowskiego."

msgid "In order to learn how to implement any specific method for your new data type, do the following: Download and unpack the Python source distribution.  Go to the :file:`Objects` directory, then search the C source files for ``tp_`` plus the function you want (for example, ``tp_richcompare``).  You will find examples of the function you want to implement."
msgstr ""
"W celu nauczenia się jak wypełniać jakiekolwiek szczególne metody dla "
"twojego nowego typu danych, wykonaj poniższe: Ściągnij i rozpakuj "
"dystrybucję źródłową języka pytonowskiego. Przejdź do katalogu "
":file:`Objects`, a następnie przeszukaj pliki źródłowe C w poszukiwaniu "
"``tp_`` plus nazwę zadania której potrzebujesz (na przykład, "
"``tp_richcompare``). Znajdziesz przykłady zadań, które chcesz wypełnić."

msgid "When you need to verify that an object is an instance of the type you are implementing, use the :cfunc:`PyObject_TypeCheck` function. A sample of its use might be something like the following::"
msgstr ""
"Kiedy potrzebujesz zweryfikować że przedmiot jest przykładem typu który "
"wypełniasz, użyj zadania :cfunc:`PyObject_TypeCheck`. Przykład jego użycia "
"mógłby być czymś następującym::"

msgid "if (! PyObject_TypeCheck(some_object, &MyType)) {     PyErr_SetString(PyExc_TypeError, \"arg #1 not a mything\");     return NULL; }"
msgstr ""
"if (! PyObject_TypeCheck(some_object, &MyType)) {     "
"PyErr_SetString(PyExc_TypeError, \"arg #1 nie moja rzecz\");     return NULL; "
"}"

msgid "This is true when we know that the object is a basic type, like a string or a float."
msgstr ""
"To jest prawdziwe gdy wiemy że przedmiot jest typem bazowym, jak ciąg znaków "
"lub liczba zmiennoprzecinkowa."

msgid "We relied on this in the :attr:`tp_dealloc` handler in this example, because our type doesn't support garbage collection. Even if a type supports garbage collection, there are calls that can be made to \"untrack\" the object from garbage collection, however, these calls are advanced and not covered here."
msgstr ""
"Oparliśmy się na tym w uchwycie obsługi :attr:`tp_dealloc` w tym "
"przykładzie, ponieważ nasz typ nie wspiera zbierania śmieci. Nawet jeśli typ "
"wspiera zbieranie śmieci, istnieją wywołania którymi można uczynić "
"przedmiot \"nieśledzonym\" przez zbiórkę śmieci, jednakże, te wywołania są "
"zaawansowane i nie są omawiane tutaj. "

msgid "We now know that the first and last members are strings, so perhaps we could be less careful about decrementing their reference counts, however, we accept instances of string subclasses. Even though deallocating normal strings won't call back into our objects, we can't guarantee that deallocating an instance of a string subclass won't call back into our objects."
msgstr ""
"Teraz wiemy, że pierwszy i ostatni członek są ciągami znaków, więc być może "
"moglibyśmy być mniej ostrożni w temacie zmniejszania ich liczby odniesień, "
"jednakże, akceptujemy przykłady podrzędnych uogólnień ciągu znaków. Nawet "
"chociaż odbieranie przydzielonego miejsca w pamięci dla normalnych ciągów "
"znaków nie daje wywołania wstecznego do naszych przedmiotów, nie możemy "
"zagwarantować, że zabranie miejsca w pamięci dla przykładu ciągu znaków nie "
"wywoła wstecznie do naszego przedmiotu."

msgid "Even in the third version, we aren't guaranteed to avoid cycles.  Instances of string subclasses are allowed and string subclasses could allow cycles even if normal strings don't."
msgstr ""
"Nawet w trzeciej wersji, nie dostajemy gwarancji że ominiemy cykle. "
"Przykłady podrzędnych uogólnień względem ciągów znaków są tolerowane i "
"podrzędne uogólnienia względem ciągu znaków mogłyby pozwolić na cykle nawet "
"jeśli normalne ciągi znaków nie są tolerowane."

msgid "Building C and C++ Extensions on Windows"
msgstr "Budowanie Rozszerzeń C i C++ na Windows"

msgid "This chapter briefly explains how to create a Windows extension module for Python using Microsoft Visual C++, and follows with more detailed background information on how it works.  The explanatory material is useful for both the Windows programmer learning to build Python extensions and the Unix programmer interested in producing software which can be successfully built on both Unix and Windows."
msgstr ""
"Ten rozdział krótko wyjaśnia jak stworzyć moduł rozszerzający dla Windows "
"dla języka pytonowskiego używając Microsoft Visual C++, i dalej wyjaśnia "
"bardziej szczegółowo informacje tła o tym jak on działa. Wyjaśniający "
"materiał jest użyteczny dla zarówno programisty Windows uczącego się budować "
"rozszerzenia języka pytonowskiego i dla programisty Unix zainteresowanego "
"wyprodukowaniem oprogramowania które może być z sukcesem zbudowane zarówno w "
"Unixie jak i Windows."

msgid "Module authors are encouraged to use the distutils approach for building extension modules, instead of the one described in this section. You will still need the C compiler that was used to build Python; typically Microsoft Visual C++."
msgstr ""
"Autorzy modułów są zachęcani aby użyć podejścia distutils dla budowania "
"rozszerzających modułów, zamiast tego opisanego w tej sekcji. Wciąż będziesz "
"potrzebował kompilatora C który był użyty do zbudowania języka "
"pytonowskiego; typowo Microsoft Visual C++."

msgid "This chapter mentions a number of filenames that include an encoded Python version number.  These filenames are represented with the version number shown as ``XY``; in practice, ``'X'`` will be the major version number and ``'Y'`` will be the minor version number of the Python release you're working with.  For example, if you are using Python 2.2.1, ``XY`` will actually be ``22``."
msgstr ""
"Ten rozdział wspomina pewną ilość nazw plików które zawierają zakodowany "
"numer wersji języka pytonowskiego. Te nazwy plików są reprezentowane przez "
"numer wersji pokazany jako ``XY``; w praktyce, ``'X'`` będzie numerem wersji "
"głównej zaś ``'Y'`` będzie numerem wersji pobocznym względem wydania języka "
"pytonowskiego z którym pracujesz. Dla przykładu, jeśli używasz języka "
"pytonowskiego 2.2.1, ``XY`` będzie ``22``."

msgid "A Cookbook Approach"
msgstr "Podejście ksiązki kucharskiej"

msgid "There are two approaches to building extension modules on Windows, just as there are on Unix: use the :mod:`distutils` package to control the build process, or do things manually.  The distutils approach works well for most extensions; documentation on using :mod:`distutils` to build and package extension modules is available in :ref:`distutils-index`.  This section describes the manual approach to building Python extensions written in C or C++."
msgstr ""
"Istnieją dwa podejścia do budowania modułów rozszerzających w Windows, tak "
"jak istnieją na Unix-ie: użyj pakietu :mod:`distutils` aby kontrolować "
"proces budowania, lub rób rzeczy ręcznie. Podejście distutils działa dobrze "
"na większości rozszerzeń; dokumentacja, jak używać :mod:`distutils` aby "
"budować rozszerzające pakiety jest dostępna w :ref:`distutils-index`. Ta "
"sekcja opisuje ręczne podejście do budowania rozszerzeń napisanych w C lub "
"C++."

msgid "To build extensions using these instructions, you need to have a copy of the Python sources of the same version as your installed Python. You will need Microsoft Visual C++ \"Developer Studio\"; project files are supplied for VC++ version 7.1, but you can use older versions of VC++.  Notice that you should use the same version of VC++that was used to build Python itself. The example files described here are distributed with the Python sources in the :file:`PC\\\\example_nt\\\\` directory."
msgstr ""
"Aby zbudować rozszerzenia używając tych instrukcji, potrzebujesz mieć kopię "
"języka pytonowskiego tej samej wersji jak twój zainstalowany język "
"pytonowski. Będziesz potrzebował Microsoft Visual C++ \"Developer Studio\"; "
"pliki projektu są dostarczone dla wersji VC++ 7.1, ale możesz używać "
"starszej wersji VC++.  Zauważ że powinieneś używać tej samej wersji VC++ "
"która była użyta aby zbudować język pytonowski sam w sobie. Przykładowe "
"pliki opisane tutaj są dystrybuowane ze źródłowymi plikami języka "
"pytonowskiego w katalogu :file:`PC\\example_nt\\`"

msgid "**Copy the example files** ---  The :file:`example_nt` directory is a subdirectory of the :file:`PC` directory, in order to keep all the PC-specific files under the same directory in the source distribution.  However, the :file:`example_nt` directory can't actually be used from this location.  You first need to copy or move it up one level, so that :file:`example_nt` is a sibling of the :file:`PC` and :file:`Include` directories.  Do all your work from within this new location."
msgstr ""
"**Skopiuj przykłady plików** --- Katalog :file:`example_nt` jest "
"podkatalogiem katalogu :file:`PC`, w celu utrzymania wszystkich szczególnych "
"dla PC-ta plików w tym samym katalogu w źródłowej dystrybucji. Jednakże, "
"katalog :file:`example_nt` nie może być użyty z tej lokacji. Najpierw "
"potrzebujesz skopiować lub przenieść go o jeden poziom wyżej, tak że "
":file:`example_nt` jest siostrzane względem katalogu :file:`PC` i katalogu "
":file:`include`. Wykonuj całą swoją pracę z wnętrza tej nowej lokalizacji."

msgid "**Open the project** ---  From VC++, use the :menuselection:`File --> Open Solution` dialog (not :menuselection:`File --> Open`!).  Navigate to and select the file :file:`example.sln`, in the *copy* of the :file:`example_nt` directory you made above.  Click Open."
msgstr ""
"**Otwórz projekt** --- Z VC++, użyj :menuselection:`File --> Open Solution` "
"- z ang. - :menuselection:`Plik --> Otwórz rozwiązanie` (nie "
":menuselection:`File --> Open`!). Przejdź i wybierz plik "
":file:`example.sln`, w *kopii* katalogu :file:`example_nt` którą uczyniłeś "
"powyżej. Kliknij Otwórz."

msgid "**Build the example DLL** ---  In order to check that everything is set up right, try building:"
msgstr ""
"**Zbuduj przykładowy DLL** --- W celu sprawdzenia czy wszystko jest "
"ustawione właściwie, spróbuj zbudować:"

msgid "Select a configuration.  This step is optional.  Choose :menuselection:`Build --> Configuration Manager --> Active Solution Configuration` and select either :guilabel:`Release`  or :guilabel:`Debug`.  If you skip this step, VC++ will use the Debug configuration by default."
msgstr ""
"Wybierz konfigurację. Ten krok jest opcjonalny. Wybierz "
":menuselection:`Build --> Configuration Manager --> Active Solution "
"Configuration` z ang. - :menuselection:`Buduj --> Zarządca "
"Konfiguracji-->Konfiguracja Aktywnego Rozwiązania` i wybierz albo "
":guilabel:`Release` albo :guilabel:`Debug`. Jeśli pominiesz ten krok, VC++ "
"będzie używało konfiguracji Debug domyślnie."

msgid "Build the DLL.  Choose :menuselection:`Build --> Build Solution`.  This creates all intermediate and result files in a subdirectory called either :file:`Debug` or :file:`Release`, depending on which configuration you selected in the preceding step."
msgstr ""
"Zbuduj DLL. Wybierz :menuselection:`Buduj --> Buduj Rozwiązanie`. To tworzy "
"wszystkie pośrednie i wynikowe pliki w podkatalogu nazwanym albo "
":file:`Debug` albo :file:`Release`, w zależności od tego, którą konfiguracje "
"wybrałeś w poprzednim kroku."

msgid "**Testing the debug-mode DLL** ---  Once the Debug build has succeeded, bring up a DOS box, and change to the :file:`example_nt\\\\Debug` directory.  You should now be able to repeat the following session (``C>`` is the DOS prompt, ``>>>`` is the Python prompt; note that build information and various debug output from Python may not match this screen dump exactly)::"
msgstr ""
"**Testowanie w trybie-debug DLL** --- Gdy budowanie Debug powiodło się, "
"wywołaj okno DOS'a i zmień katalog na :file:`example_nt\\Debug`. Powinieneś "
"teraz być w stanie powtórzyć następującą sesję (``C>`` jest zachętą DOS'a, "
"``>>>`` jest zachętą języka pytonowskiego; zauważ, że informacja o budowaniu "
"i rożne treści wychodzące przy debugowaniu z języka pytonowskiego mogą nie "
"pasować do tego zrzutu ekranu dokładnie)::"

msgid "C>..\\..\\PCbuild\\python_d Adding parser accelerators ... Done. Python 2.2 (#28, Dec 19 2001, 23:26:37) [MSC 32 bit (Intel)] on win32 Type \"copyright\", \"credits\" or \"license\" for more information. >>> import example [4897 refs] >>> example.foo() Hello, world [4903 refs] >>>"
msgstr ""
"C>..\\..\\PCbuild\\python_d Adding parser accelerators ... Done. Python 2.2 "
"(#28, Dec 19 2001, 23:26:37) [MSC 32 bit (Intel)] on win32 Type \"copyright\", "
"\"credits\" or \"license\" for more information. >>> import example [4897 refs] "
">>> example.foo() Hello, world [4903 refs] >>>"

msgid "Congratulations!  You've successfully built your first Python extension module."
msgstr ""
"Gratulacje! z powodzeniem zbudowałeś swój pierwszy moduł rozszerzający "
"języka pytonowskiego."

msgid "**Creating your own project** ---  Choose a name and create a directory for it.  Copy your C sources into it.  Note that the module source file name does not necessarily have to match the module name, but the name of the initialization function should match the module name --- you can only import a module :mod:`spam` if its initialization function is called :cfunc:`initspam`, and it should call :cfunc:`Py_InitModule` with the string ``\"spam\"`` as its first argument (use the minimal :file:`example.c` in this directory as a guide). By convention, it lives in a file called :file:`spam.c` or :file:`spammodule.c`. The output file should be called :file:`spam.pyd` (in Release mode) or :file:`spam_d.pyd` (in Debug mode). The extension :file:`.pyd` was chosen to avoid confusion with a system library :file:`spam.dll` to which your module could be a Python interface."
msgstr ""
"**Tworzenie twojego własnego projektu** --- Wybierz nazwę i utwórz katalog "
"dla niej. Przekopiuj pliki źródłowe C do niego. Zauważ, że nazwa pliku "
"źródłowego modułu nie koniecznie musi odpowiadać nazwie modułu, ale nazwa "
"zadania inicjującego powinna odpowiadać nazwie modułu --- możesz tylko "
"importować moduł :mod:`spam` jeśli jego zadanie inicjujące jest nazwane "
":cfunc:`initspam`, i powinno wywołać :cfunc:`PyInitModule` z ciągiem znaków "
"``\"spam\"`` jako pierwszym parametrem (użyj minimalnego pliku "
":file:`example.c` w tym katalogu jako przewodnika). Przez konwencję, on "
"przebywa w pliku nazywanym :file:`spam.c` lub :file:`spammodule.c`. Plik "
"wyjściowy powinien być nazwany :file:`spam.pyd` (w trybie Wydania - z ang. - "
"Release) lub :file:`spam_d.pyd` (w trybie Debugowania). Rozszerzenie "
":file:`.pyd` zostało wybrane aby uniknąć pomyłek z systemową biblioteką "
":file:`spam.dll` do której twój moduł mógłby być sprzęgiem języka "
"Pytonowskiego."

msgid "Now your options are:"
msgstr "Teraz twoje opcje są następujące:"

msgid ":file:`spam.\\*`, and edit them by hand, or"
msgstr ":file:`spam.\\*`, do zmian ręcznych, lub"

msgid "Create a brand new project; instructions are below."
msgstr "Utwórz zupełnie nowy projekt; instrukcje są poniżej. "

msgid "In either case, copy :file:`example_nt\\\\example.def` to :file:`spam\\\\spam.def`, and edit the new :file:`spam.def` so its second line contains the string '``initspam``'.  If you created a new project yourself, add the file :file:`spam.def` to the project now.  (This is an annoying little file with only two lines.  An alternative approach is to forget about the :file:`.def` file, and add the option :option:`/export:initspam` somewhere to the Link settings, by manually editing the setting in Project Properties dialog)."
msgstr ""
"W każdym razie, skopiuj plik :file:`example_nt\\example.def` do "
":file:`spam\\spam.def`, i zmień nowy plik :file:`spam.def` tak aby jego druga "
"linia zawierała ciąg '``initspam``'. Jeśli utworzyłeś nowy projekt "
"własnoręcznie, dodaj plik :file:`spam.def` do projektu teraz. (To jest ten "
"denerwujący mały plik tylko z dwiema liniami. Alternatywnym podejściem jest "
"zapomnieć o pliku :file:`.def`, i dodać opcję :option:`/export:initspam` "
"gdzieś w ustawieniach łączenia (z ang. - Link Settings) ręcznie zmieniając "
"ustawienia w dialogowym okienku właściwości projektu)."

msgid "**Creating a brand new project** ---  Use the :menuselection:`File --> New --> Project` dialog to create a new Project Workspace.  Select :guilabel:`Visual C++ Projects/Win32/ Win32 Project`, enter the name (``spam``), and make sure the Location is set to parent of the :file:`spam` directory you have created (which should be a direct subdirectory of the Python build tree, a sibling of :file:`Include` and :file:`PC`).  Select Win32 as the platform (in my version, this is the only choice).  Make sure the Create new workspace radio button is selected.  Click OK."
msgstr ""
"**Tworzenie zupełnie nowego projektu** --- Użyj okna dialogowego "
":menuselection:`File --> New --> Project` - z ang. - :menuselection:`Plik "
"--> Nowy --> Projekt` aby stworzyć nową przestrzeń pracy Projektu. Wybierz "
":guilabel:`Visual C++ Projects/Win32/Win32 Project`, wpisz nazwę (``spam``) "
"i upewnij się że lokacja jest ustawiona na katalog nadrzędny względem "
"katalogu :file:`spam` który utworzyłeś (który powinien być bezpośrednim "
"podkatalogiem drzewa budowania języka pytonowskiego, siostrzanym względem "
":file:`Include` i :file:`PC`). Wybierz Win32 jako maszynę/środowisko (w "
"mojej wersji, to jest jedyny wybór). Upewnij się że opcja \"Stwórz nową "
"przestrzeń pracy\" jest wybrana. Kliknij OK."

msgid "You should now create the file :file:`spam.def` as instructed in the previous section. Add the source files to the project, using :menuselection:`Project --> Add Existing Item`. Set the pattern to ``*.*`` and select both :file:`spam.c` and :file:`spam.def` and click OK.  (Inserting them one by one is fine too.)"
msgstr ""
"Powinieneś teraz utworzyć plik :file:`spam.def` jak powiedziano w poprzednim "
"rozdziale. Dodaj pliki źródłowe do projektu, używając "
":menuselection:`Project --> Add Existing Item` z ang. - "
":menuselection:`Projekt --> Dodaj Istniejący Element`. Ustaw wzorzec na "
"``*.*`` i wybierz zarówno :file:`spam.c` i :file:`spam.def` i naciśnij OK. "
"(Wstawianie ich jeden po drugim też jest w porządku.)"

msgid "Now open the :menuselection:`Project --> spam properties` dialog. You only need to change a few settings.  Make sure :guilabel:`All Configurations` is selected from the :guilabel:`Settings for:` dropdown list.  Select the C/C++ tab.  Choose the General category in the popup menu at the top.  Type the following text in the entry box labeled :guilabel:`Additional Include Directories`::"
msgstr ""
"Teraz otwórz okno dialogowe :menuselection:`Project --> spam properties` - z "
"ang. - :menuselection:`Projekt --> właściwości spam`. Potrzebujesz zmienić "
"tylko kilka opcji. Upewnij się, że :guilabel:`Wszystkie konfiguracje` jest "
"zaznaczony z listy rozwijalnej :guilabel:`Ustawienia dla:`. Wybierz zakładkę "
"C/C++. Wybierz kategorię Ogólną w menu spod prawego przycisku na górze. "
"Wpisz następujący tekst w polu wprowadzania oznaczonym :guilabel:`Dodatkowe "
"Katalogi Załączania` -z ang. - :guilabel:`Additional Include Directories`::"

msgid "..\\Include,..\\PC"
msgstr "..\\Include,..\\PC"

msgid "Then, choose the General category in the Linker tab, and enter ::"
msgstr "Następnie, wybierz kategorię ogólną w zakładce załączania, i wpisz ::"

msgid "..\\PCbuild"
msgstr "..\\PCbuild"

msgid "in the text box labelled :guilabel:`Additional library Directories`."
msgstr ""
"w polu tekstowym oznaczonym :guilabel:`Dodatkowe katalogi biblioteczne`."

msgid "Now you need to add some mode-specific settings:"
msgstr "Teraz potrzebujesz dodać pewne ustawienia szczególne dla trybu-pracy:"

msgid "Select :guilabel:`Release` in the :guilabel:`Configuration` dropdown list. Choose the :guilabel:`Link` tab, choose the :guilabel:`Input` category, and append ``pythonXY.lib`` to the list in the :guilabel:`Additional Dependencies` box."
msgstr ""
"Wybierz :guilabel:`Release` - z ang. - :guilabel:`Wydanie` w liście "
"rozwijalnej :guilabel:`Configuration` - z ang. - :guilabel:`Konfiguracja`. "
"Wybierz zakładkę :guilabel:`Link` - z ang. - :guilabel:`Połączenia`, wybierz "
"kategorię :guilabel:`Input` - z ang. - :guilabel:`Wprowadzanie`, i dodaj "
"``pythonXY.lib`` do listy w polu :guilabel:`Dodatkowe Zależności` - z ang. - "
":guilabel:`Additional Dependencies`."

msgid "Select :guilabel:`Debug` in the :guilabel:`Configuration` dropdown list, and append ``pythonXY_d.lib`` to the list in the :guilabel:`Additional Dependencies` box.  Then click the C/C++ tab, select :guilabel:`Code Generation`, and select :guilabel:`Multi-threaded Debug DLL` from the :guilabel:`Runtime library` dropdown list."
msgstr ""
"Wybierz :guilabel:`Debug` z listy rozwijalnej :guilabel:`Konfiguracja` i "
"dodaj ``pythonXY_d.lib`` do listy w polu :guilabel:`Dodatkowe Zależności`. "
"Potem kliknij zakładkę C/C++, wybierz :guilabel:`Generacja Kodu`, i wybierz "
":guilabel:`Wielo-wątkowa biblioteka DLL Debugowania` z listy rozwijalnej "
":guilabel:`biblioteka czasu wykonania`."

msgid "Select :guilabel:`Release` again from the :guilabel:`Configuration` dropdown list.  Select :guilabel:`Multi-threaded DLL` from the :guilabel:`Runtime library` dropdown list."
msgstr ""
"Wybierz :guilabel:`Release` jeszcze raz z listy rozwijalnej "
":guilabel:`Konfiguracji`. Wybierz :guilabel:`Wielo-wątkowa biblioteka DLL` z "
"listy rozwijalnej :guilabel:`Biblioteki czasu wykonania`."

msgid "If your module creates a new type, you may have trouble with this line::"
msgstr "Jeśli twój moduł tworzy nowy typ, możesz mieć problemy z tą linijką::"

msgid "Change it to::"
msgstr "Zamień ją na::"

msgid "and add the following to the module initialization function::"
msgstr "i dodaj następujące do zadania zainicjowania modułu::"

msgid "MyObject_Type.ob_type = &PyType_Type;"
msgstr "MyObject_Type.ob_type = &PyType_Type;"

msgid "Refer to section 3 of the `Python FAQ <http://www.python.org/doc/faq>`_ for details on why you must do this."
msgstr ""
"Odwołaj się do rozdziału 3 `FAQ (z ang. - często zadawane pytania) języka "
"pytonowskiego  <http://www.python.org/doc/faq>`_ po szczegóły na temat tego, "
"dlaczego musisz to robić."

msgid "Differences Between Unix and Windows"
msgstr "Różnice pomiędzy Unix-em i Windows-em"

msgid "Unix and Windows use completely different paradigms for run-time loading of code.  Before you try to build a module that can be dynamically loaded, be aware of how your system works."
msgstr ""
"Unix i Windows używają kompletnie różnych zwyczajów dla ładowania kodu w "
"czasie wykonania. Zanim spróbujesz zbudować moduł który może być dynamicznie "
"załadowany, przypomnij sobie jak działa twój system."

msgid "In Unix, a shared object (:file:`.so`) file contains code to be used by the program, and also the names of functions and data that it expects to find in the program.  When the file is joined to the program, all references to those functions and data in the file's code are changed to point to the actual locations in the program where the functions and data are placed in memory. This is basically a link operation."
msgstr ""
"W Unix-ie, pliki współdzielonych przedmiotów (:file:`.so`) zawierają kod do "
"użycia przez program, a także nazwy zadań i danych których spodziewa się "
"znaleźć w programie. Gdy plik jest łączony z programem, wszystkie "
"odniesienia do tych zadań i danych w kodzie pliku są zmieniane aby wskazywać "
"na konkretne położenia w programie gdzie zadania i dane są umieszczane w "
"pamięci. To jest właściwie operacja połączenia."

msgid "In Windows, a dynamic-link library (:file:`.dll`) file has no dangling references.  Instead, an access to functions or data goes through a lookup table.  So the DLL code does not have to be fixed up at runtime to refer to the program's memory; instead, the code already uses the DLL's lookup table, and the lookup table is modified at runtime to point to the functions and data."
msgstr ""
"W Windows, plik dynamicznie-łączonej biblioteki (:file:`.dll`) nie ma "
"żadnych wiszących odniesień. Zamiast tego, dostęp do zadań lub danych "
"przechodzi przez tablicę podglądania. Więc kod DLL nie musi być naprawiany w "
"czasie wykonania aby odnosić się do pamięci programu; zamiast tego, kod już "
"używa tablicy podglądania DLL, i tablica podglądania jest zmieniana w "
"czasie wykonania aby wskazywać na zadania i dane."

msgid "In Unix, there is only one type of library file (:file:`.a`) which contains code from several object files (:file:`.o`).  During the link step to create a shared object file (:file:`.so`), the linker may find that it doesn't know where an identifier is defined.  The linker will look for it in the object files in the libraries; if it finds it, it will include all the code from that object file."
msgstr ""
"W Unix-ie, istnieje tylko jeden typ pliku biblioteki (:file:`.a`), który "
"zawiera kod z kilku plików przedmiotów (:file:`.o`). W czasie kroku łączenia "
"aby utworzyć współdzielony plik przedmiotu (:file:`.so`), program łączący "
"może stwierdzić że nie wie gdzie jest zdefiniowany identyfikator. Program "
"łączący poszuka go w plikach przedmiotów w bibliotekach; jeśli go znajdzie, "
"załączy cały kod z takiego pliku przedmiotu."

msgid "In Windows, there are two types of library, a static library and an import library (both called :file:`.lib`).  A static library is like a Unix :file:`.a` file; it contains code to be included as necessary. An import library is basically used only to reassure the linker that a certain identifier is legal, and will be present in the program when the DLL is loaded.  So the linker uses the information from the import library to build the lookup table for using identifiers that are not included in the DLL.  When an application or a DLL is linked, an import library may be generated, which will need to be used for all future DLLs that depend on the symbols in the application or DLL."
msgstr ""
"W Windows, istnieją dwa typy bibliotek, statyczna biblioteka i biblioteka "
"importu (obie zwane :file:`.lib`). Statyczna biblioteka jest jak Unix-owy "
"plik :file:`.a`; zawiera kod do załączenia gdy potrzeba. Biblioteka importu "
"jest w zasadzie używana tylko aby zapewnić program łączący, że dany "
"identyfikator jest legalny, i będzie obecny w programie gdy DLL jest "
"ładowany. Więc program łączący używa informacji z biblioteki importu aby "
"zbudować tabelę podglądania dla użycia identyfikatorów, które nie są "
"załączone w pliku DLL. Gdy aplikacja lub DLL jest łączony biblioteka importu "
"może być wygenerowana, która może być potrzebna do użycia dla wszystkich "
"przyszłych plików DLL, które zależą od symboli w aplikacji lub pliku DLL."

msgid "Suppose you are building two dynamic-load modules, B and C, which should share another block of code A.  On Unix, you would *not* pass :file:`A.a` to the linker for :file:`B.so` and :file:`C.so`; that would cause it to be included twice, so that B and C would each have their own copy.  In Windows, building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it just contains information which will be used at runtime to access A's code."
msgstr ""
"Załóżmy że budujesz dwa dynamicznie-ładowane moduły, B i C, które powinny "
"współdzielić inny blok kodu A. W Unix-ie *nie* podałbyś pliku :file:`A.a` "
"dla programu łączącego dla pliku `B.so` i pliku :file:`C.so`; to mogłoby "
"spowodować że będzie on załączony dwukrotnie, więc B i C miałyby mieć każdy "
"swoją własną kopię. W Windows, zbudowanie pliku :file:`A.dll` zbuduje także "
":file:`A.lib`. Przekazujesz plik :file:`A.lib` dla programu łączącego B i C. "
"Plik :file:`A.lib` nie zawiera kodu; zawiera tylko informacje, które będą "
"użyte w czasie wykonania aby uzyskać dostęp do kodu A."

msgid "In Windows, using an import library is sort of like using ``import spam``; it gives you access to spam's names, but does not create a separate copy.  On Unix, linking with a library is more like ``from spam import *``; it does create a separate copy."
msgstr ""
"W Windows, używanie bibliotek importu jest trochę jak używanie ``import "
"spam``; daje Ci dostęp do nazw spamu, ale nie tworzy oddzielnej kopii. Na "
"Unix-ie, połączenie z biblioteką jest bardziej jak ``from spam import *``; "
"tworzy oddzielną kopię."

msgid "Using DLLs in Practice"
msgstr "Używanie DLLów w praktyce"

msgid "Windows Python is built in Microsoft Visual C++; using other compilers may or may not work (though Borland seems to).  The rest of this section is MSVC++ specific."
msgstr ""
"Język pytonowski w Windows jest zbudowany w Microsoft Visual C++; użycie "
"innych kompilatorów może lub może nie działać (chociaż Borland wydaje się). "
"Reszta tego rozdziału jest szczególna dla MSVC++."

msgid "When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the linker. To build two DLLs, spam and ni (which uses C functions found in spam), you could use these commands::"
msgstr ""
"Gdy tworzymy pliki DLL w Windows, trzeba przekazać plik :file:`pythonXY.lib` "
"dla programu łączącego. Aby zbudować dwa DLL, spam i ni (który używa zadań "
"C znajdujących się w spam), możesz użyć tych poleceń::"

msgid "cl /LD /I/python/include spam.c ../libs/pythonXY.lib cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib"
msgstr ""
"cl /LD /I/python/include spam.c ../libs/pythonXY.lib cl /LD "
"/I/python/include ni.c spam.lib ../libs/pythonXY.lib"

msgid "The first command created three files: :file:`spam.obj`, :file:`spam.dll` and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python functions (such as :cfunc:`PyArg_ParseTuple`), but it does know how to find the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"Pierwsze polecenie utworzyło trzy pliki: :file:`spam.obj`, :file:`spam.dll` "
"i :file:`spam.lib`. Plik :file:`Spam.dll` nie zawiera żadnych zadań języka "
"pytonowskiego (takich jak :cfunc:`PyArg_ParseTuple`), ale wie jak znaleźć "
"kod języka pytonowskiego dzięki plikowi :file:`pythonXY.lib`."

msgid "The second command created :file:`ni.dll` (and :file:`.obj` and :file:`.lib`), which knows how to find the necessary functions from spam, and also from the Python executable."
msgstr ""
"Drugie polecenie utworzyło plik :file:`ni.dll` (i pliki :file:`.obj` i "
":file:`.lib`), które wiedzą jak znaleźć konieczne zadania ze spamu, a także "
"z pliku wykonywalnego języka pytonowskiego."

msgid "Not every identifier is exported to the lookup table.  If you want any other modules (including Python) to be able to see your identifiers, you have to say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"Nie każdy identyfikator jest exportowany do tabeli podglądania. Jeśli chcesz "
"jakichkolwiek innych modułów (a także języka pytonowskiego) aby mogły "
"widzieć twoje identyfikatory, musisz powiedzieć ``_declspec(dllexport)``, "
"jak w ``void _declspec(dllexport) initspam(void)`` lub ``PyObject "
"_declspec(dllexport) *NiGetSpamData(void)``."

msgid "Developer Studio will throw in a lot of import libraries that you do not really need, adding about 100K to your executable.  To get rid of them, use the Project Settings dialog, Link tab, to specify *ignore default libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries."
msgstr ""
"Studio Rozwoju będzie wrzucało mnóstwo bibliotek import których nie "
"potrzebujesz tak naprawdę, dodając około 100K do twojego pliku "
"wykonywalnego. Aby się go pozbyć, użyj okna dialogowego Ustawienia Projektu, "
"zakładki Połączeń, aby określić *ignoruj domyślne biblioteki*. Dodaj "
"właściwy plik :file:`msvcrtxx.lib` do listy bibliotek."
