# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2010, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2010-06-30 14:00\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.7.0\n"

msgid "Abstract Objects Layer"
msgstr "Płaszczyzna przedmiotów ogólnych"

msgid "The functions in this chapter interact with Python objects regardless of their type, or with wide classes of object types (e.g. all numerical types, or all sequence types).  When used on object types for which they do not apply, they will raise a Python exception."
msgstr ""
"Zadania opisane w tym rozdziale oddziałują na przedmioty napisane w "
"pytonowskim języku bez względu na ich typ, lub też na różnorodne rodzaje "
"typów przedmiotów (np. wszystkie typy liczbowe, lub wszystkie typy "
"kolejkowe). Gdy użyte z przedmiotami niezgodnego typu zadania zgłaszają "
"wyjątki pytonowskiego języka."

msgid "It is not possible to use these functions on objects that are not properly initialized, such as a list object that has been created by :cfunc:`PyList_New`, but whose items have not been set to some non-\\ ``NULL`` value yet."
msgstr ""
"Nie jest możliwe wykonanie tych zadań na przedmiotach, które nie zostały "
"poprawnie zapoczątkowane, takimi, jak np. lista - utworzona przy użyciu "
":cfunc:`PyList_New`, której pozycje nie były jeszcze uzupełnione jakimiś "
"wartościami znacząco odróżniającymi się od ``NULL``."

msgid "Allocating Objects on the Heap"
msgstr "Przydział miejsca dla przedmiotów w stercie"

msgid "See also"
msgstr "Zobacz też:"

msgid "To allocate and create extension modules."
msgstr "Aby umieścić i utworzyć moduły rozszerzające."

msgid "Parsing arguments and building values"
msgstr ""
"Pobieranie kolejnych rzeczy podanych na wejściu i konstruowanie wartości."

msgid "These functions are useful when creating your own extensions functions and methods.  Additional information and examples are available in :ref:`extending-index`."
msgstr ""
"Te działania są użyteczne przy tworzeniu swoich własnych zadań "
"rozszerzających i rozszerzających sposobów działania. Dodatkowe informacje i "
"przykłady dostępne są w :ref:`extending-index`."

msgid "The first three of these functions described, :cfunc:`PyArg_ParseTuple`, :cfunc:`PyArg_ParseTupleAndKeywords`, and :cfunc:`PyArg_Parse`, all use *format strings* which are used to tell the function about the expected arguments.  The format strings use the same syntax for each of these functions."
msgstr ""
"Te pierwsze trzy z opisanych działań, "
":cfunc:`PyArg_ParseTuple`,:cfunc:`PyArg_ParseTupleAndKeywords`, "
"i:cfunc:`PyArg_Parse`, wszystkie posługują się instrukcjami kształtującymi "
"sposób pobierania rzeczy na wejściu zawartymi w \"napisach kształtujących\", "
"które są używane, aby przekazać dla zadania wskazówki wyjaśniające "
"oczekiwany charakter wprowadzanych rzeczy. Zapisy kształtujące używają tej "
"samej składni dla każdego z tych zadań."

msgid "Parsing arguments"
msgstr "Przetwarzanie rzeczy wchodzących"

msgid "A format string consists of zero or more \"format units.\"  A format unit describes one Python object; it is usually a single character or a parenthesized sequence of format units.  With a few exceptions, a format unit that is not a parenthesized sequence normally corresponds to a single address argument to these functions.  In the following description, the quoted form is the format unit; the entry in (round) parentheses is the Python object type that matches the format unit; and the entry in [square] brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"napis kształtujący może być pusty lub składać się z \"jednostek "
"kształtujących\". Jednostka ukształtowania opisuje jeden pytonowski "
"przedmiot; jest to zazwyczaj jedna litera, lub kolejką jednostek "
"ukształtowania w ujętych w nawias. Z kilkoma wyjątkami, jednostka "
"ukształtowania, która nie jest  kolejką jednostek ujętą w nawias zwykle "
"odpowiada pojedynczo umiejscowionej rzeczy przekazywanej dla tych zadań. W "
"poniższych zapisach cytat jest jednostką kształtującą; polecenie ujęte w "
"nawias okrągły ( ) oznacza typ przedmiotu w języku pytonowskim, który "
"odpowiada jednostce kształtującej, a zapis ujęty w nawiasie kwadratowym [ ] "
"określa typ przedmiotu / przedmiotów w języku C, którego miejsce powinno "
"zostać wskazane i przekazane dla zadania."

msgid "Strings and buffers"
msgstr "Napisy i skrzynki wymiany"

msgid "These formats do not expect you to provide raw storage for the returned string or bytes.  Also, you won't have to release any memory yourself, except with the ``es``, ``es#``, ``et`` and ``et#`` formats."
msgstr ""
"Dla tych formatów nie musisz zapewniać miejsca dla zwracanych ciągów znaków "
"lub bajtów. Nie musisz też zwalniać żadnej pamięci własnoręcznie, z "
"wyjątkiem tych w formatach ``es``, ``es#``, ``et`` i ``et#``"

msgid "However, when a :ctype:`Py_buffer` structure gets filled, the underlying buffer is locked so that the caller can subsequently use the buffer even inside a :ctype:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable data being resized or destroyed.  As a result, **you have to call** :cfunc:`PyBuffer_Release` after you have finished processing the data (or in any early abort case)."
msgstr ""
"Jednak, gdy struktura :ctype:`Py_buffer` zostanie zapełniona, leżący u "
"podłoża bufor zostaje zablokowany, tak że wywołujący może ponownie użyć "
"bufora nawet wewnątrz bloku :ctype:`Py_BEGIN_ALLOW_THREADS` bez ryzyka "
"zmiany rozmiaru lub skasowania zmienialnych danych. W wyniku tego **trzeba "
"wywołać** :cfunc: `PyBuffer_Release` po zakończeniu przetwarzania danych "
"(lub w przypadku przedwczesnego przerwania)."

msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "Bufory nie są zakończone znakiem NULL, chyba że zaznaczono inaczej."

msgid "For all ``#`` variants of formats (``s#``, ``y#``, etc.), the type of the length argument (int or :ctype:`Py_ssize_t`) is controlled by defining the macro :cmacro:`PY_SSIZE_T_CLEAN` before including :file:`Python.h`.  If the macro was defined, length is a :ctype:`Py_ssize_t` rather than an :ctype:`int`. This behavior will change in a future Python version to only support :ctype:`Py_ssize_t` and drop :ctype:`int` support. It is best to always define :cmacro:`PY_SSIZE_T_CLEAN`."
msgstr ""
"Dla wszystkich wariantów ``#`` formatów (``s#``,``y#``, itp.) typ argumentu "
"długości (int lub :ctype: `Py_ssize_t`) jest kontrolowany przez "
"zdefiniowanie makra :cmacro:`PY_SSIZE_T_CLEAN` przed załączeniem pliku "
":file:`Python.h`. Jeśli makro zostało zdefiniowane, długość jest typu "
":ctype:`Py_ssize_t` zamiast :ctype:`int`. Ta sytuacja zostanie zmieniona w "
"przyszłych wersjach Pythona, które wspierać będą już tylko :ctype: "
"`Py_ssize_t`, pomijać zaś wsparcie dla :ctype:`int`. Najlepiej zawsze "
"definiować :cmacro:`PY_SSIZE_T_CLEAN`."

msgid "Convert a Unicode object to a C pointer to a character string. A pointer to an existing string is stored in the character pointer variable whose address you pass.  The C string is NUL-terminated. The Python string must not contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is raised. Unicode objects are converted to C strings using ``'utf-8'`` encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"Zamień obiekt Unicode na wskaźnik C do ciągu znaków.Wskaźnik na istniejący "
"ciąg znaków jest przechowywany w zmiennej wskaźnikowej której adres "
"przekazujesz. Ciąg znaków C jest zakończony zerem. Ciąg znaków Pythona nie "
"może zawierać wewnętrznych bajtów równych zero; Jeśli zawiera, zgłaszany "
"jest wyjątek :exc:`TypeError`. Obiekt Unicode jest zamieniany na ciąg znaków "
"C używając kodowania ``'uft-8'``. Jeśli ta konwersja zawiedzie, wyjątek "
":exc:`UnicodeError` jest zgłaszany."

msgid "This format does not accept bytes-like objects.  If you want to accept filesystem paths and convert them to C character strings, it is preferrable to use the ``O&`` format with :cfunc:`PyUnicode_FSConverter` as *converter*."
msgstr ""
"Ten format nie akceptuje bajtowych obiektów. jeśli chcesz akceptować ścieżki "
"systemowe i konwertować je do ciągów znakowych z języka C, zalecane jest "
"używanie formatu ``O&`` z funkcją :cfunc:`PyUnicode_FSConverter` jako "
"*konwerterem* formatu."

msgid "This format accepts Unicode objects as well as objects supporting the buffer protocol. It fills a :ctype:`Py_buffer` structure provided by the caller. In this case the resulting C string may contain embedded NUL bytes. Unicode objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Ten format akceptuje obiekty Unicode w równym stopniu jak obiekty "
"wspierające protokół buforowy. Wypełnia on strukturę :ctype:`Py_buffer` "
"dostarczaną przez wywołującego. W tym przypadku wynikowy ciąg znaków języka "
"C może zawierać osadzone znaki NUL. Obiekty Unicode są konwertowane do "
"ciągów znaków języka C używając kodowania ``'utf-8'``."

msgid "Like ``s*``, except that it doesn't accept mutable buffer-like objects such as :class:`bytearray`.  The result is stored into two C variables, the first one a pointer to a C string, the second one its length. The string may contain embedded null bytes. Unicode objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Podobnie do ``s*`` z tą różnicą, że nie są akceptowane obiekty zmienne, z "
"natury podobne do buforów, takie jak :class:`bytearray`. Wynik jest "
"przechowywany w dwóch zmiennych języka C, pierwszej będącej wskaźnikiem na "
"ciąg znaków języka C i drugiej będącej jego długością. Ciąg znaków może "
"zawierać osadzone znaki null. Obiekty Unicode są konwertowane do ciągów "
"znaków języka C przy użyciu kodowania ``'utf-8'``."

msgid "Like ``s``, but the Python object may also be ``None``, in which case the C pointer is set to *NULL*."
msgstr ""
"Jak ``s``, ale obiekt Pythona może też być żaden - ``None``, a w takim "
"przypadku wskaźnik C jest ustawiony na *NULL*."

msgid "Like ``s*``, but the Python object may also be ``None``, in which case the ``buf`` member of the :ctype:`Py_buffer` structure is set to *NULL*."
msgstr ""
"Jak ``s*``, ale obiekt Pythona może też być ``None``, a w takim przypadku "
"członek ``buf`` struktury :ctype:`Py_buffer` jest ustawiony na *NULL*."

msgid "Like ``s#``, but the Python object may also be ``None``, in which case the C pointer is set to *NULL*."
msgstr ""
"Jak ``s#``, ale obiekt z języka Python może też być ``None``, a w takim "
"przypadku wskaźnik z języka C jest ustawiany na *NULL*."

msgid "This format converts a bytes-like object to a C pointer to a character string; it does not accept Unicode objects.  The bytes buffer must not contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is raised."
msgstr ""
"Ten format konwertuje obiekt bajtowy na wskaźnik z języka C wskazujący na "
"ciąg znaków; Nie akceptuje obiektów Unicode. Bufor bajtowy nie może zawierać "
"znaków NUL; jeśli zawiera, zgłaszany jest wyjątek :exc:`TypeError`."

msgid "This variant on ``s*`` doesn't accept Unicode objects, only objects supporting the buffer protocol.  **This is the recommended way to accept binary data.**"
msgstr ""
"Ten wariant ``s*`` nie akceptuje obiektów Unicode, tylko obiekty wspierające "
"protokół bufora. **Jest to zalecany sposób, akceptowania danych "
"binarnych.**"

msgid "This variant on ``s#`` doesn't accept Unicode objects, only bytes-like objects."
msgstr ""
"Ten wariant ``s#`` nie akceptuje obiektów Unicode, a jedynie bajto-podobne "
"obiekty."

msgid "Requires that the Python object is a :class:`bytes` object, without attempting any conversion.  Raises :exc:`TypeError` if the object is not a bytes object.  The C variable may also be declared as :ctype:`PyObject\\*`."
msgstr ""
"Wymaga, aby obiekt Pythona był obiektem klasy :class:`bytes` bez "
"podejmowania próby żadnej konwersji. Zgłasza :exc:`TypeError`, jeśli obiekt "
"nie jest obiektem bajtowym. Zmienna C może również zostać zadeklarowana jako "
":ctype:`PyObject\\*`."

msgid "Requires that the Python object is a :class:`bytearray` object, without attempting any conversion.  Raises :exc:`TypeError` if the object is not a :class:`bytearray` object. The C variable may also be declared as :ctype:`PyObject\\*`."
msgstr ""
"Wymaga, aby obiekt Pythona był obiektem klasy :class:`bytearray` bez "
"podejmowania prób konwersji. Zgłasza :exc:`TypeError`, jeśli obiekt nie jest "
"obiektem klasy :class:`bytearray`. Zmienna C może również zostać "
"zadeklarowana jako :CType:`PyObject\\*`."

msgid "Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of Unicode characters.  You must pass the address of a :ctype:`Py_UNICODE` pointer variable, which will be filled with the pointer to an existing Unicode buffer.  Please note that the width of a :ctype:`Py_UNICODE` character depends on compilation options (it is either 16 or 32 bits). The Python string must not contain embedded NUL characters; if it does, a :exc:`TypeError` exception is raised."
msgstr ""
"Konwertuje obiekt w formacie Unicode Pythona do wskaźnika C na zakończony "
"znakiem NUL bufor znaków Unicode. Trzeba przekazać adres zmiennej "
"wskaźnikowej :ctype:`Py_UNICODE`, która zostanie zapełniona wskaźnikiem do "
"istniejącego buforu Unicode. Zwróć uwagę, że szerokość znaku "
":ctype:`Py_UNICODE` zależy od opcji kompilacji (jest to albo 16 albo 32 "
"bity). Łańcuch znaków Pythona nie może zawierać osadzonych znaków NUL, jeśli "
"zawiera, to zgłaszany jest wyjątek :exc:`TypeError`."

msgid "Since ``u`` doesn't give you back the length of the string, and it may contain embedded NUL characters, it is recommended to use ``u#`` or ``U`` instead."
msgstr ""
"Ponieważ ``u`` nie zwraca długości łańcucha znaków, i może zawierać osadzone "
"znaki NUL, zaleca się zamiast tego stosowanie ``u#`` lub ``U``."

msgid "This variant on ``u`` stores into two C variables, the first one a pointer to a Unicode data buffer, the second one its length."
msgstr ""
"Ten wariant ``u`` zapisuje w dwóch zmiennych C, w pierwszej - wskaźnik do "
"bufora danych Unicode, w drugiej - jego długość."

msgid "Like ``u``, but the Python object may also be ``None``, in which case the :ctype:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""
"Jak ``u``, ale obiekt Pythona może również być ``None``, a w takim przypadku "
"wskaźnik :ctype:`Py_UNICODE` jest ustawiony na *NULL*."

msgid "Like ``u#``, but the Python object may also be ``None``, in which case the :ctype:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""
"Podobnie, jak ``u#``, ale obiekt Pythona może być również ``None``, a w "
"takim przypadku wskaźnik :ctype:`Py_UNICODE`. jest ustawiony na *NULL*."

msgid "Requires that the Python object is a Unicode object, without attempting any conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  The C variable may also be declared as :ctype:`PyObject\\*`."
msgstr ""
"Wymaga, aby obiekt Pythona był obiektem Unicode, bez podejmowania prób "
"konwersji. Zgłasza wyjątek :exc:`TypeError`, jeśli obiekt nie jest obiektem "
"Unicode. Zmienna C może również być zadeklarowana jako :ctype:`PyObject\\*`."

msgid "This format accepts any object which implements the read-write buffer interface. It fills a :ctype:`Py_buffer` structure provided by the caller. The buffer may contain embedded null bytes. The caller have to call :cfunc:`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"Format ten akceptuje dowolne obiekty implementujące interfejs odczytu i "
"zapisu do bufora. Wypełnia strukturę: ctype:`Py_buffer`, dostarczoną przez "
"wołającego. Bufor może zawierać osadzone znaki null. Wywołujący musi odwołać "
"się do funkcji :cfunc:`PyBuffer_Release`, gdy zakończy pracę z buforem."

msgid "This variant on ``s`` is used for encoding Unicode into a character buffer. It only works for encoded data without embedded NUL bytes."
msgstr ""
"Ten wariant ``s`` jest używany do zakodowania Unicode w buforze znaków. To "
"działa tylko dla zakodowanych danych bez osadzonych znaków NUL."

msgid "This format requires two arguments.  The first is only used as input, and must be a :ctype:`const char\\*` which points to the name of an encoding as a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An exception is raised if the named encoding is not known to Python.  The second argument must be a :ctype:`char\\*\\*`; the value of the pointer it references will be set to a buffer with the contents of the argument text. The text will be encoded in the encoding specified by the first argument."
msgstr ""
"Ten format wymaga dwóch argumentów. Pierwszy z nich jest używany tylko jako "
"wejście, i musi być typu :ctype:`const char\\*` i wskazywać na nazwę "
"kodowania jako ciąg zakończony znakiem NUL, lub *NULL*, w przypadku którego "
"używane jest kodowanie ``'utf-8'``.  Jeśli nazwa kodowania nie jest znana w "
"języku Python Zgłaszany jest wyjątek. Drugim argumentem musi być wskaźnik "
":ctype:`char\\*\\*`; wartość wskaźnika do którego się odnosi będzie ustawiona "
"na bufor z treścią tekstu argumentu. Tekst zostanie zakodowany w kodowaniu "
"określonym przez pierwszy argument."

msgid ":cfunc:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy the encoded data into this buffer and adjust *\\*buffer* to reference the newly allocated storage.  The caller is responsible for calling :cfunc:`PyMem_Free` to free the allocated buffer after use."
msgstr ""
"Funkcja :cfunc:`PyArg_ParseTuple` alokuje bufor o wymaganym rozmiarze, "
"kopiuje zakodowane dane do tego bufora i ustawia *\\*bufor*, aby odwoływał "
"się do nowo przydzielonej pamięci. Wywołujący jest odpowiedzialny za "
"odwołanie się do funkcji :cfunc: `PyMem_Free`, w celu uwolnienia "
"przydzielonej pamięciu bufora po jego użyciu."

msgid "Same as ``es`` except that byte string objects are passed through without recoding them.  Instead, the implementation assumes that the byte string object uses the encoding passed in as parameter."
msgstr ""
"Podobnie jak ``es`` z wyjątkiem tego, że obiekty ciągów znaków są "
"przekazywane dalej bez ich zapisywania. Zamiast tego implementacja zakłada, "
"że obiekt łańcucha znaków wykorzystuje kodowanie przekazane jako parametr."

msgid "This variant on ``s#`` is used for encoding Unicode into a character buffer. Unlike the ``es`` format, this variant allows input data which contains NUL characters."
msgstr ""
"Ten wariant ``s#`` używany jest do kodowania Unicode w buforze znaków. W "
"przeciwieństwie do formatu ``es``, ten wariant pozwala wprowadzać dane "
"zawierające znaki NUL."

msgid "It requires three arguments.  The first is only used as input, and must be a :ctype:`const char\\*` which points to the name of an encoding as a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An exception is raised if the named encoding is not known to Python.  The second argument must be a :ctype:`char\\*\\*`; the value of the pointer it references will be set to a buffer with the contents of the argument text. The text will be encoded in the encoding specified by the first argument. The third argument must be a pointer to an integer; the referenced integer will be set to the number of bytes in the output buffer."
msgstr ""
"Wymagane są trzy argumenty. Pierwszy z nich jest używany tylko jako wejście, "
"i musi być typu :ctype:`const char\\*`, i wskazywać na nazwę kodowania jako "
"ciąg zakończony znakiem NUL, lub *NULL*, w przypadku którego używane jest "
"kodowanie ``'utf-8'``. Jeśli nazwa kodowania nie jest znana w języku Python, "
"zgłaszany jest wyjątek. Drugim argumentem musi być wskaźnik "
":ctype:`char\\*\\*`; Wartością wskaźnika do którego odnosi się ten będzie "
"bufor z zawartością tekstu argumentu. Tekst zostanie zakodowany w kodowaniu "
"określonym przez pierwszy argument. Trzecim argumentem musi być wskaźnik do "
"liczby całkowitej; liczba całkowita, do której się on odwołuje zostanie "
"ustawiona na liczbę znaków w buforze wyjściowym."

msgid "There are two modes of operation:"
msgstr "Istnieją dwa tryby pracy:"

msgid "If *\\*buffer* points a *NULL* pointer, the function will allocate a buffer of the needed size, copy the encoded data into this buffer and set *\\*buffer* to reference the newly allocated storage.  The caller is responsible for calling :cfunc:`PyMem_Free` to free the allocated buffer after usage."
msgstr ""
"Jeśli *\\*bufor* wskazuje na wskaźnik *NULL*, funkcja zaalokuje bufor o "
"wymaganym rozmiarze, skopiuje zakodowane dane do tego bufora i ustawi "
"*\\*bufor* aby odwoływał się do nowo przydzielonej pamięci. Wywołujący jest "
"odpowiedzialny za wywołanie funkcji: cfunc:`PyMem_Free` w celu uwolnienia "
"przydzielonej pamięciu bufora po zakończeniu użycia."

msgid "If *\\*buffer* points to a non-*NULL* pointer (an already allocated buffer), :cfunc:`PyArg_ParseTuple` will use this location as the buffer and interpret the initial value of *\\*buffer_length* as the buffer size.  It will then copy the encoded data into the buffer and NUL-terminate it.  If the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"Jeśli *\\*bufor* wskazuje na niezerowy wskaźnik (bufor umieszczony już w "
"pamięci), funkcja :cfunc:`PyArg_ParseTuple` użyje tego miejsca jako bufora i "
"zinterpretuje początkową wartość *\\*buffer_length* jako rozmiar bufora. "
"Skopiuje potem zakodowane dane do bufora i zakończy znakiem zera. Jeśli "
"bufor nie jest wystarczająco duży, wyjątek :exc:`ValueError` zostanie "
"zgłoszony."

msgid "In both cases, *\\*buffer_length* is set to the length of the encoded data without the trailing NUL byte."
msgstr ""
"W obu przypadkach, *\\*buffer_length* jest ustawiany na długość zakodowanych "
"danych z pominięciem zakańczającego znaku NUL."

msgid "Same as ``es#`` except that byte string objects are passed through without recoding them. Instead, the implementation assumes that the byte string object uses the encoding passed in as parameter."
msgstr ""
"Tak samo, jak w ``es#`` oprócz tego, że obiekty ciągu bajtów są przekazywane "
"do funkcji bez ich zapisywania. Zamiast tego, implementacja zakłada że "
"obiekt ciągu bajtów używa kodowania przekazywanego w parametrze."

msgid "Numbers"
msgstr "Liczby"

msgid "Convert a nonnegative Python integer to an unsigned tiny int, stored in a C :ctype:`unsigned char`."
msgstr ""
"Przelicza nieujemną liczbę całkowitą języka Python na liczbę całkowitą "
"krótką bez znaku, przechowywaną jako liczbę języka C typu :ctype:`unsigned "
"char`."

msgid "Convert a Python integer to a tiny int without overflow checking, stored in a C :ctype:`unsigned char`."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę całkowitą krótką bez "
"sprawdzania czy nie przekroczono zakresu wartości, zachowaną jako liczbę "
"języka C typu :ctype:`unsigned char`."

msgid "Convert a Python integer to a C :ctype:`short int`."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę języka C typu "
":ctype:`short int`."

msgid "Convert a Python integer to a C :ctype:`unsigned short int`, without overflow checking."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę języka C typu "
":ctype:`unsigned short int`, bez sprawdzania czy nie przekroczono zakresu "
"wartości."

msgid "Convert a Python integer to a plain C :ctype:`int`."
msgstr ""
"Przelicza liczbę całkowitą języka Python na zwykłą liczbę całkowitą języka C "
"typu :ctype:`int`."

msgid "Convert a Python integer to a C :ctype:`unsigned int`, without overflow checking."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu "
":ctype:`unsigned int`, bez sprawdzania czy nie przekroczono zakresu "
"wartości."

msgid "Convert a Python integer to a C :ctype:`long int`."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu "
":ctype:`long int`."

msgid "Convert a Python integer to a C :ctype:`unsigned long` without overflow checking."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu "
":ctype:`long int` bez sprawdzania czy nie przekroczono zakresu wartości."

msgid "Convert a Python integer to a C :ctype:`long long`.  This format is only available on platforms that support :ctype:`long long` (or :ctype:`_int64` on Windows)."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu "
":ctype:`long long` (lub typu :ctype:`_int64` w systemie Windows)."

msgid "Convert a Python integer to a C :ctype:`unsigned long long` without overflow checking.  This format is only available on platforms that support :ctype:`unsigned long long` (or :ctype:`unsigned _int64` on Windows)."
msgstr ""
"Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu "
":ctype:`unsigned long long` bez sprawdzania czy nie przekroczono zakresu "
"wartości. Ten format jest dostępny tylko w systemach, które wspierają liczby "
"typu :ctype:`unsigned long long` (lub typu :ctype:`unsigned _int64` w "
"systemie Windows)."

msgid "Convert a Python integer to a C :ctype:`Py_ssize_t`."
msgstr ""
"Przelicza liczbę całkowitą języka Python do wielkości rozmiaru "
":ctype:`Py_ssize_t` z języka C."

msgid "Convert a Python byte, represented as a :class:`bytes` object of length 1, to a C :ctype:`char`."
msgstr ""
"Zamienia zawartość danej bajtowej z języka Python o typie byte, "
"reprezentującej obiekt ciągu bajtów klasy :class:`bytes` o długości 1, na "
"znak typu :ctype:`char` z języka C."

msgid "Convert a Python character, represented as a :class:`str` object of length 1, to a C :ctype:`int`."
msgstr ""
"Przelicza wartość reprezentującą znak języka Python - obiekt klasy "
":class:`str` o długości 1, na liczbę całkowitą języka C typu :ctype:`int`."

msgid "Convert a Python floating point number to a C :ctype:`float`."
msgstr ""
"Zamienia liczbę zmiennoprzecinkową języka Python na liczbę "
"zmiennoprzecinkową typu :ctype:`float` języka C."

msgid "Convert a Python floating point number to a C :ctype:`double`."
msgstr ""
"Zamienia liczbę zmiennoprzecinkową z języka Python na liczbę "
"zmiennoprzecinkową podwójnej precyzji typu :ctype:`double` w języku C."

msgid "Convert a Python complex number to a C :ctype:`Py_complex` structure."
msgstr ""
"Przekłada liczbę zespoloną języka Python do struktury liczby zespolonej "
"języka C typu :ctype:`Py_complex`."

msgid "Other objects"
msgstr "Inne obiekty"

msgid "Store a Python object (without any conversion) in a C object pointer.  The C program thus receives the actual object that was passed.  The object's reference count is not increased.  The pointer stored is not *NULL*."
msgstr ""
"Zachowuje wskazanie na obiekt języka Python (bez wprowadzania żadnych zmian) "
"do wskaźnika obiektowego języka C. Program w języku C otrzymuje w ten "
"sposób konkretnie ten obiekt który został przekazany do funkcji. Liczba "
"odniesień do obiektu nie zwiększa się. Zapamiętany wskaźnik jest niepusty "
"(not *NULL*)."

msgid "Store a Python object in a C object pointer.  This is similar to ``O``, but takes two C arguments: the first is the address of a Python type object, the second is the address of the C variable (of type :ctype:`PyObject\\*`) into which the object pointer is stored.  If the Python object does not have the required type, :exc:`TypeError` is raised."
msgstr ""
"Zachowuje obiekt języka Python we wskaźniku na obiekt z języka C. Jest "
"podobna do ``O``, ale oczekuje dwóch argumentów: pierwszym jest adres "
"obiektu typu języka Python, a drugim jest adres zmiennej języka C (o typie "
":ctype:`PyObject\\*`) do którego zachowywany jest wskaźnik na obiekt. Jeśli "
"obiekt języka Python nie posiada wymaganego typu, wyjątek :exc:`TypeError` "
"jest zgłaszany."

msgid "Convert a Python object to a C variable through a *converter* function.  This takes two arguments: the first is a function, the second is the address of a C variable (of arbitrary type), converted to :ctype:`void \\*`.  The *converter* function in turn is called as follows::"
msgstr ""
"Zamienia obiekt języka Python na zmienną języka C przy użyciu funkcji "
"*konwertującej*. Oczekuje dwóch argumentów: pierwszym jest funkcja, a drugim "
"jest adres zmiennej z języka C (o dowolnym typie), zamieniany do wskaźnika "
"typu :ctype:`void\\*`. Funkcja *konwertująca* z kolei jest wywoływana w "
"sposób następujący::"

msgid "status = converter(object, address);"
msgstr "stan = konwerter(obiekt, adres);"

msgid "where *object* is the Python object to be converted and *address* is the :ctype:`void\\*` argument that was passed to the :cfunc:`PyArg_Parse\\*` function. The returned *status* should be ``1`` for a successful conversion and ``0`` if the conversion has failed.  When the conversion fails, the *converter* function should raise an exception and leave the content of *address* unmodified."
msgstr ""
"Gdzie *obiekt* jest obiektem przeznaczonym do zamiany, a *adres* jest "
"argumentem typu :ctype:`void\\*`, który został przekazany do funkcji "
":cfunc:`PyArg_Parse\\*`. Zwrócony *status* powinien być równy ``1`` dla "
"udanej zamiany i ``0`` jeśli zamiana nie powiodła się. Gdy zamiana zawodzi, "
"funkcja *konwertera* powinna zgłosić wyjątek i pozostawić zawartość pamięci "
"spod *adresu* bez zmian."

msgid "If the *converter* returns Py_CLEANUP_SUPPORTED, it may get called a second time if the argument parsing eventually fails, giving the converter a chance to release any memory that it had already allocated. In this second call, the *object* parameter will be NULL; *address* will have the same value as in the original call."
msgstr ""
"Jeśli *konwerter* zwraca status Py_CLEANUP_SUPPORTED, może zostać wywołany "
"po raz drugi, jeśli wczytywanie argumentów ostatecznie zawiedzie, dając "
"konwerterowi szansę na zwolnienie jakiejkolwiek pamięci, którą uprzednio "
"przydzielił. W tym drugim wywołaniu, parametr *obiekt* będzie pusty (NULL); "
"zaś *adres* będzie miał tą samą wartość, co przy pierwszym wywołaniu."

msgid "The object must be a Python sequence whose length is the number of format units in *items*.  The C arguments must correspond to the individual format units in *items*.  Format units for sequences may be nested."
msgstr ""
"Obiekt musi być sekwencją języka Python, której długość jest liczbą "
"elementów formatu mierzoną w *elementach*. Argumenty języka C muszą "
"odpowiadać poszczególnym jednostkom formatu w *elementach*. Jednostki "
"formatu dla sekwencji mogą być zagnieżdżane."

msgid "It is possible to pass \"long\" integers (integers whose value exceeds the platform's :const:`LONG_MAX`) however no proper range checking is done --- the most significant bits are silently truncated when the receiving field is too small to receive the value (actually, the semantics are inherited from downcasts in C --- your mileage may vary)."
msgstr ""
"Możliwe jest przekazywanie liczb całkowitych \"długich\" (liczb całkowitych, "
"których wartość przekracza wartość stałej :const:`LONG_MAX` określoną dla "
"danej architektury) chociaż żadne właściwe sprawdzenie zakresu nie jest "
"wykonywane - najbardziej znaczące cyfry dwójkowe są w milczeniu obcinane, "
"gdy docelowy obszar pamięci jest zbyt mały, aby przyjąć wartość (w "
"rzeczywistości składnia jest odziedziczona po rzutowaniu z języka C --- "
"twoje doświadczenia mogą się różnić)."

msgid "A few other characters have a meaning in a format string.  These may not occur inside nested parentheses.  They are:"
msgstr ""
"Kilka innych znaków ma jeszcze znaczenie w ciągu formatu. Nie mogą one "
"wystąpić wewnątrz zagnieżdżonych nawiasach okrągłych. Są to:"

msgid "Indicates that the remaining arguments in the Python argument list are optional. The C variables corresponding to optional arguments should be initialized to their default value --- when an optional argument is not specified, :cfunc:`PyArg_ParseTuple` does not touch the contents of the corresponding C variable(s)."
msgstr ""
"Oznacza, że pozostałe argumenty z listy argumentów języka Python są dowolne. "
"Zmiennym języka C odpowiadającym parametrom nadobowiązkowym powinny zostać "
"przypisane wartości początkowe równe ich wartościom automatycznym --- gdy "
"nadobowiązkowy parametr nie jest określony, funkcja "
":cfunc:`PyArg_ParseTuple` nie zmienia zawartości odpowiadającej "
"zmiennej(ych) języka C."

msgid "The list of format units ends here; the string after the colon is used as the function name in error messages (the \"associated value\" of the exception that :cfunc:`PyArg_ParseTuple` raises)."
msgstr ""
"Lista jednostek formatu kończy się tutaj; Ciąg po dwukropku jest używany "
"jako nazwa funkcji w wiadomościach o błędach (\"załączona wartość\" dla "
"wyjątku, który zgłasza funkcja :cfunc:`PyArg_ParseTuple`). "

msgid "The list of format units ends here; the string after the semicolon is used as the error message *instead* of the default error message.  ``:`` and ``;`` mutually exclude each other."
msgstr ""
"Na tym kończy się lista jednostek formatu; ciąg po średniku jest traktowany "
"jako informacja o błędzie do użycia *zamiast* automatycznej wiadomości o "
"błędzie. Znaki dwukropka ``:`` i średnika ``;`` wzajemnie się wykluczają."

msgid "Note that any Python object references which are provided to the caller are *borrowed* references; do not decrement their reference count!"
msgstr ""
"Zwróć uwagę, że każde odniesienie do obiektu Pythona które jest dostarczone "
"do wywołującego funkcję jest odniesieniem *pożyczonym*; nie zmniejsza ich "
"liczby odniesień!"

msgid "Additional arguments passed to these functions must be addresses of variables whose type is determined by the format string; these are used to store values from the input tuple.  There are a few cases, as described in the list of format units above, where these parameters are used as input values; they should match what is specified for the corresponding format unit in that case."
msgstr ""
"Dodatkowe parametry przekazywane do tych funkcji muszą być adresami "
"zmiennych których typ jest określany przez ciąg formatu; są one używane do "
"przechowywania wartości z krotki wejściowej. Jest parę przypadków, jak "
"opisuje to lista jednostek formatu powyżej, gdzie te parametry są używane "
"jako wprowadzane wartości; w takich przypadku powinny one odpowiadać temu, "
"co jest określone we właściwych im jednostach formatu."

msgid "For the conversion to succeed, the *arg* object must match the format and the format must be exhausted.  On success, the :cfunc:`PyArg_Parse\\*` functions return true, otherwise they return false and raise an appropriate exception. When the :cfunc:`PyArg_Parse\\*` functions fail due to conversion failure in one of the format units, the variables at the addresses corresponding to that and the following format units are left untouched."
msgstr ""
"Aby zamiana się powiodła, obiekt argumentu *arg* musi odpowiadać formatowi i "
"format musi zostać wyczerpany. W przypadku powodzenia operacji funkcje "
":cfunc:`PyArg_Parse\\*` zwracają wartość prawdy, w przeciwnym przypadku "
"zwracają fałsz i zgłaszają właściwy wyjątek. Gdy funkcje "
":cfunc:`PyArg_Parse\\*` zawiodą z powodu niepowodzenia konwersji w jednej z "
"jednostek formatu, zmienne pod adresami odpowiadającymi temu i następnym "
"jednostkom formatu są pozostawiane nietknięte."

msgid "API Functions"
msgstr "Funkcje interfejsu programowania aplikacji"

msgid "Building values"
msgstr "Budowanie wartości"

msgid "Boolean Objects"
msgstr "Obiekty logiki Boole'a"

msgid "Booleans in Python are implemented as a subclass of integers.  There are only two booleans, :const:`Py_False` and :const:`Py_True`.  As such, the normal creation and deletion functions don't apply to booleans.  The following macros are available, however."
msgstr ""
"zmienne logiczne w języku Python są wykonane jako podklasa liczb "
"całkowitych. Są tylko dwie wartości Boolowskie, stała oznaczająca wartość "
"fałszu - :const:`Py_False` i stała oznaczająca wartość prawdy - "
":const:`Py_True`. Jako takie, normalne funkcje tworzące i usuwające nie "
"dotyczą zmiennych logicznych. Dostępne są jednak następujące makropolecenia."

msgid "Buffer Objects"
msgstr "Obiekty buforów"

msgid "Python objects implemented in C can export a \"buffer interface.\"  These functions can be used by an object to expose its data in a raw, byte-oriented format. Clients of the object can use the buffer interface to access the object data directly, without needing to copy it first."
msgstr ""
"Przedmioty języka pyton urzeczywistnione w języku C mogą uzewnętrzniać "
"\"postać skrzynki wymiany\". Te zadania mogą być wykonane przez przedmiot do "
"odsłaniania swoich zapisów w nieprzetworzonej postaci zobrazowanej w równej "
"wielkości kęsach. Używający przedmiotu mogą skorzystać z postaci skrzynki "
"wymiany aby uzyskać dostęp do zapisów przedmiotu bezpośrednio, bez "
"konieczności uprzedniego sporządzania odwzorowania przedmiotu."

msgid "Two examples of objects that support the buffer interface are bytes and arrays. The bytes object exposes the character contents in the buffer interface's byte-oriented form. An array can also expose its contents, but it should be noted that array elements may be multi-byte values."
msgstr ""
"Dwoma przykładami przedmiotów, które wspierają sprzęg wczytywania z "
"wyprzedzeniem są zestawy kęsowe i tabele. Przedmiot zestawu kęsowego "
"uzewnętrznia zawartość znakową w postaci zorientowanego kęsowo zawartej w "
"sprzęgu wczytywania z wyprzedzeniem. Tabela może także uzewnętrzniać swoją "
"zawartość, ale warto zauważyć, że elementami tabeli mogą być wartości "
"wielokęsowe."

msgid "An example user of the buffer interface is the file object's :meth:`write` method. Any object that can export a series of bytes through the buffer interface can be written to a file. There are a number of format codes to :cfunc:`PyArg_ParseTuple` that operate against an object's buffer interface, returning data from the target object."
msgstr ""
"Przykładem przypadku użycia sprzęgu wczytywania z wyprzedzeniem jest sposób "
"postępowania zapisywania :meth:`write` przedmiotu plikowego. Każdy "
"przedmiot, który może wydawać seryjnie kęsy przez sprzęg wczytywania z "
"wyprzedzeniem może być zapisany do pliku. Jest kilka postaci kodujących dla "
"zadania :cfunc:`PyArg_ParseTuple` które operują na sprzęgu wczytywania z "
"wyprzedzeniem przedmiotu, zwracając dane z przedmiotu docelowego."

msgid "More information on the buffer interface is provided in the section :ref:`buffer-structs`, under the description for :ctype:`PyBufferProcs`."
msgstr ""
"Więcej informacji o sprzęgu wczytywania z wyprzedzeniem w sekcji :ref"
":`struktury-bufora`, pod opisem dla :ctype:`PyBufferProcs`. "

msgid "Buffer objects are useful as a way to expose the data from another object's buffer interface to the Python programmer.  They can also be used as a zero-copy slicing mechanism.  Using their ability to reference a block of memory, it is possible to expose any data to the Python programmer quite easily.  The memory could be a large, constant array in a C extension, it could be a raw block of memory for manipulation before passing to an operating system library, or it could be used to pass around structured data in its native, in-memory format."
msgstr ""
"przedmioty wczytywania z wyprzedzeniem są użyteczne jako sposób "
"uzewnętrzniania danych ze sprzęgu wczytywania z wyprzedzeniem innego "
"przedmiotu dla programującego w języku pytonowskim. Mogą także być użyte do "
"mechanizmu operacji na ciągach cząstkowych bez kopiowania. Używając ich "
"zdolności do odwołania się do obszaru pamięci, jest możliwe uzewnętrznienie "
"dowolnych danych dla programującego w języku pytonowskim w całkiem łatwy "
"sposób. Pamięć może mieć postać całkiem sporej stałej tabeli w rozszerzeniu "
"języka C, może także być surowym obszarem pamięci dla operowania przed "
"przekazaniem dla biblioteki systemu operacyjnego, lub może być używana dla "
"wzajemnego przekazywania usystematyzowanych informacji w swojej naturalnej "
"postaci wewnętrznej dla pamięci."

msgid "Buffer related functions"
msgstr "Zadania związane z przedmiotem wczytywania z wyprzedzeniem."

msgid "MemoryView objects"
msgstr "Przedmioty Widoku Pamięci"

msgid "A memoryview object exposes the C level buffer interface to Python."
msgstr ""
"Przedmiot widoku pamięci uzewnętrznia sprzęg wczytywania z wyprzedzeniem z "
"poziomu języka C dla języka pytonowskiego."

msgid "Byte Array Objects"
msgstr "Przedmioty Tabel Kęsowych"

msgid "Type check macros"
msgstr "Makra sprawdzające typ danych"

msgid "Direct API functions"
msgstr "Zadania Bezpośredniego API (sprzęgu programującego aplikację)"

msgid "Macros"
msgstr "Makropolecenia"

msgid "These macros trade safety for speed and they don't check pointers."
msgstr ""
"Te makropolecenia pomijają zabezpieczenia na korzyść zwiększenia szybkości "
"działania i nie sprawdzają wskaźników."

msgid "Bytes Objects"
msgstr "Przedmioty Kęsowe"

msgid "These functions raise :exc:`TypeError` when expecting a bytes parameter and are called with a non-bytes parameter."
msgstr ""
"Te zadania zgłaszają wyjątek :exc:`TypeError` gdy w oczekiwaniu na parametr "
"kęsowy otrzymają nie-kęsowy parametr wejściowy."

msgid "Capsules"
msgstr "Kapsuły"

msgid "Refer to :ref:`using-capsules` for more information on using these objects."
msgstr ""
"Zerknij do :ref:`używanie-kapsuł` po więcej informacji o używaniu tych "
"przedmiotów."

msgid "Cell Objects"
msgstr "Przedmioty Komórkowe."

msgid "\"Cell\" objects are used to implement variables referenced by multiple scopes. For each such variable, a cell object is created to store the value; the local variables of each stack frame that references the value contains a reference to the cells from outer scopes which also use that variable.  When the value is accessed, the value contained in the cell is used instead of the cell object itself.  This de-referencing of the cell object requires support from the generated byte-code; these are not automatically de-referenced when accessed. Cell objects are not likely to be useful elsewhere."
msgstr ""
"\"Komórkowe\" przedmioty są używane do uszczegóławiania zmiennych, do których "
"odwołania znajdują się w wielu zakresach. Dla każdej takiej zmiennej, "
"przedmiot komórkowy jest tworzony aby przechowywać wartość; Zmienne lokalne "
"dla każdej ramki stosu,  która odwołuje się do wartości, zawiera odniesienie "
"do komórek z zewnętrznych zakresów które także używają tych zmiennych. Gdy "
"wartość jest odczytywana, wartość zawarta w komórce jest używana zamiast "
"przedmiotu komórki samego w sobie. To wtórne odwołanie przedmiotu "
"komórkowego wymaga wsparcia od wygenerowanego kodu-kęsowego; takie kody nie "
"są automatycznie wtórnie odwoływane podczas dostępu. Przedmioty komórkowe "
"nie są raczej użyteczne gdzie indziej."

msgid "Code Objects"
msgstr "Przedmioty kodowe"

msgid "Code objects are a low-level detail of the CPython implementation. Each one represents a chunk of executable code that hasn't yet been bound into a function."
msgstr ""
"Przedmioty kodowe są niskopoziomowym detalem realizacji języka pytonowskiego "
"- CPython. Każdy jeden reprezentuje fragment wykonywalnego kodu który nie "
"został jeszcze związany z żadną funkcją."

msgid "Complex Number Objects"
msgstr "Przedmioty Liczb Zespolonych"

msgid "Python's complex number objects are implemented as two distinct types when viewed from the C API:  one is the Python object exposed to Python programs, and the other is a C structure which represents the actual complex number value. The API provides functions for working with both."
msgstr ""
"Przedmioty liczb zespolonych języka pytonowskiego są urzeczywistnione jako "
"dwa różne typy patrząc z punktu widzenia sprzęgu programowania API języka C: "
"jednym jest przedmiot wyprowadzony dla programów języka pytonowskiego, zaś "
"drugi jest strukturą języka C która oddaje właściwą wartość liczby "
"zespolonej. Sprzęg oprogramowania (API) dostarcza zadania do pracy z "
"obydwoma typami."

msgid "Complex Numbers as C Structures"
msgstr "Liczby zespolone jako struktury języka C."

msgid "Note that the functions which accept these structures as parameters and return them as results do so *by value* rather than dereferencing them through pointers.  This is consistent throughout the API."
msgstr ""
"Zauważ proszę że zadania które przyjmują te struktury w miejsce parametrów i "
"zwracają je jako wyniki czynią to *przez wartość* zamiast odwoływać się do "
"nich przez wskazania. Ta własność jest spójna w całym sprzęgu programowania "
"(API)."

msgid "Complex Numbers as Python Objects"
msgstr "Liczby zespolone jako przedmioty języka pytonowskiego"

msgid "Concrete Objects Layer"
msgstr "Warstwa przedmiotów konkretnych"

msgid "The functions in this chapter are specific to certain Python object types. Passing them an object of the wrong type is not a good idea; if you receive an object from a Python program and you are not sure that it has the right type, you must perform a type check first; for example, to check that an object is a dictionary, use :cfunc:`PyDict_Check`.  The chapter is structured like the \"family tree\" of Python object types."
msgstr ""
"Zadania w tym rozdziale są szczególne dla konkretnych typów przedmiotów "
"języka pytonowskiego. Przekazywanie im przedmiotów niewłaściwego typu to nie "
"dobry pomysł; jeśli otrzymujesz przedmiot z programy w języku pytonowskim i "
"nie jesteś pewien czy jest on właściwego typu, musisz najpierw wykonać "
"sprawdzenie typu; na przykład, aby sprawdzić czy przedmiot jest słownikiem, "
"użyj zadania :cfunc:`PyDict_Check`. Rozdział jest podzielony jako \"drzewo "
"rodzinne\" typów przedmiotów języka pytonowskiego."

msgid "While the functions described in this chapter carefully check the type of the objects which are passed in, many of them do not check for *NULL* being passed instead of a valid object.  Allowing *NULL* to be passed in can cause memory access violations and immediate termination of the interpreter."
msgstr ""
"Podczas gdy zadania opisane w tym rozdziale dokładnie sprawdzają rodzaj "
"przedmiotów które zostaną im przekazane, wiele z nich nie jest odporna na "
"przekazanie im wartości *NULL* zamiast właściwego przedmiotu. Pozwalając aby "
"wartość *NULL* była przekazywana dla zadania może powodować naruszenia "
"dostępu do pamięci i natychmiastowe zakończenie programu wykonującego "
"program."

msgid "Fundamental Objects"
msgstr "Przedmioty podstawowe"

msgid "This section describes Python type objects and the singleton object ``None``."
msgstr ""
"Ten rozdział opisuje przedmioty typów języka pytonowskiego i przedmiot "
"prostacki ``Żaden`` (``None``)."

msgid "Numeric Objects"
msgstr "Przedmioty numeryczne"

msgid "Sequence Objects"
msgstr "Przedmioty sekwencji"

msgid "Generic operations on sequence objects were discussed in the previous chapter; this section deals with the specific kinds of sequence objects that are intrinsic to the Python language."
msgstr ""
"Podstawowe operacje na przedmiotach ciągłych zostały opisane w poprzednim "
"rozdziale; ten rozdział zajmuje się szczególnymi rodzajami przedmiotów "
"ciągłych które są wewnętrzne dla języka pytonowskiego."

msgid "Mapping Objects"
msgstr "Przedmioty mapujące"

msgid "Other Objects"
msgstr "Inne przedmioty"

msgid "String conversion and formatting"
msgstr "Podstawienia i formatowanie ciągów znaków"

msgid "Functions for number conversion and formatted string output."
msgstr "Zadanie dla zamiany liczb i wyjścia znakowego sformatowanego."

msgid ":cfunc:`PyOS_snprintf` and :cfunc:`PyOS_vsnprintf` wrap the Standard C library functions :cfunc:`snprintf` and :cfunc:`vsnprintf`. Their purpose is to guarantee consistent behavior in corner cases, which the Standard C functions do not."
msgstr ""
"zadania :cfunc:`PyOS_snpritf` i :cfunc:`PyOS_vsnprintf` opakowują "
"sztandarowe biblioteczne zadania języka C :cfunc:`snprintf` i "
":cfunc:`vsnprintf`. Ich celem jest zagwarantowanie spójnego zachowania w "
"przypadkach brzegowych, których sztandarowe zadania języka C nie gwarantują."

msgid "The wrappers ensure that *str*[*size*-1] is always ``'\\0'`` upon return. They never write more than *size* bytes (including the trailing ``'\\0'``) into str. Both functions require that ``str != NULL``, ``size > 0`` and ``format != NULL``."
msgstr ""
"Opakowania zapewniają że ostatni znak ciągu *str*[*size*-1] gdzie size - "
"rozmiar ciągu zawsze zwraca ``'\\0'``. Nigdy nie wypisują więcej niż *rozmiar "
"ciągu* (*size*) kęsów (włącznie z kończącym znakiem zera ``'\\0'``) do str. "
"Obydwa zadania wymagają aby ``str != NULL``, ``size > 0 `` i ``format != "
"NULL``."

msgid "If the platform doesn't have :cfunc:`vsnprintf` and the buffer size needed to avoid truncation exceeds *size* by more than 512 bytes, Python aborts with a *Py_FatalError*."
msgstr ""
"Jeśli system nie posiada zadania :cfunc:`vsnprintf` i rozmiar wymiennika "
"potrzebny aby uniknąć obcinania przekracza *rozmiar* (*size*) o więcej niż "
"512 kęsów, program wykonujący przerywany jest z komunikatem *Py_FatalError*."

msgid "The return value (*rv*) for these functions should be interpreted as follows:"
msgstr ""
"Wartość zwracana (z ang. - return value) *wr* ( z ang. - *rv*) dla tych "
"zadań powinna być rozumiana następująco:"

msgid "When ``0 <= rv < size``, the output conversion was successful and *rv* characters were written to *str* (excluding the trailing ``'\\0'`` byte at *str*[*rv*])."
msgstr ""
"Gdy ``0 <= rv < size``, konwersja wyjściowa została zakończona powodzeniem i "
"znaki *rv* zostały zapisane do ciągu znaków *str* (pomijając kończący znak "
"``'\\0'`` w *str*[*rv*])."

msgid "When ``rv >= size``, the output conversion was truncated and a buffer with ``rv + 1`` bytes would have been needed to succeed. *str*[*size*-1] is ``'\\0'`` in this case."
msgstr ""
"Gdy ``rv >= size``, wynikowa podmiana została ucięta i wymiennik z ``rv + "
"1`` kęsami byłby potrzebny do zakończenia powodzeniem. znak "
"*str*[*rozmiar*-1] jest znakiem ``'\\0'`` w tym przypadku."

msgid "When ``rv < 0``, \"something bad happened.\" *str*[*size*-1] is ``'\\0'`` in this case too, but the rest of *str* is undefined. The exact cause of the error depends on the underlying platform."
msgstr ""
"Gdy ``rv < 0``, \"stało się coś złego.\" *str*[*size*-1] jest znakiem ``'\\0'`` "
"także w tym przypadku, ale reszta ciągu *str* jest nieokreślona. Dokładna "
"przyczyna błędu zależy od leżącego u podstaw systemu."

msgid "The following functions provide locale-independent string to number conversions."
msgstr ""
"Następujące zadania dostarczają niezależne od ustawień regionalnych ciągi do "
"zamian liczb."

msgid "DateTime Objects"
msgstr "Przedmioty Daty-Czasu (z ang. - DateTime)"

msgid "Various date and time objects are supplied by the :mod:`datetime` module. Before using any of these functions, the header file :file:`datetime.h` must be included in your source (note that this is not included by :file:`Python.h`), and the macro :cmacro:`PyDateTime_IMPORT` must be invoked, usually as part of the module initialisation function.  The macro puts a pointer to a C structure into a static variable, :cdata:`PyDateTimeAPI`, that is used by the following macros."
msgstr ""
"Różne przedmioty daty i czasu są dostarczane przez moduł :mod:`datetime`. "
"Przed użyciem którychkolwiek z tych zadań, plik nagłówkowy "
":file:`datetime.h` musi zostać załączony do źródeł (zauważ że nie jest to "
"załączone w pliku :file:`Python.h`), i makropolecznie "
":cmacro:`PyDateTime_IMPORT` powinno zostać wywołane, zwykle jako część "
"zadania inicjującego moduł. Makropolecenie wstawia wskaźnik do struktury "
"języka C do zmiennej statycznej, :cdata:`PyDateTimeAPI`, które jest używane "
"przez następujące makropolecenia."

msgid "Type-check macros:"
msgstr "Makropolecenia sprawdzenia typu:"

msgid "Macros to create objects:"
msgstr "Makropolecenia do tworzenia przedmiotów:"

msgid "Macros to extract fields from date objects.  The argument must be an instance of :cdata:`PyDateTime_Date`, including subclasses (such as :cdata:`PyDateTime_DateTime`).  The argument must not be *NULL*, and the type is not checked:"
msgstr ""
"Makropolecenia do wydobywania elementów daty. Parametr musi być "
"przedstawicielem :cdata:`PyDateTime_Date`, zawierając podklasy (takie jak: "
":cdata:`PyDateTime_DateTime`). Parametr nie może być *NULL*, i typ nie jest "
"sprawdzany:"

msgid "Macros to extract fields from datetime objects.  The argument must be an instance of :cdata:`PyDateTime_DateTime`, including subclasses. The argument must not be *NULL*, and the type is not checked:"
msgstr ""
"Makropolecenia do wydobywania elementów z przedmiotu daty. Parametr musi być "
"przedstawicielem :cdata:`PyDateTime_DateTime`, włączając podklasy. Parametr "
"nie może być *NULL*, i typ nie jest sprawdzany:"

msgid "Macros to extract fields from time objects.  The argument must be an instance of :cdata:`PyDateTime_Time`, including subclasses. The argument must not be *NULL*, and the type is not checked:"
msgstr ""
"Makropolecenia do wydobywania elementów z przedmiotu czasu. Parametr musi "
"być przedstawicielem :cdata:`PyDateTime_Time`, włączając podklasy. Parametr "
"nie może być pusty *NULL*, a jego typ nie jest sprawdzany:"

msgid "Macros for the convenience of modules implementing the DB API:"
msgstr ""
"Makropolecenia dla wygody modułów realizujących sprzęg programowania baz "
"danych DB API:"

msgid "Descriptor Objects"
msgstr "Przedmioty Deskryptorów"

msgid "\"Descriptors\" are objects that describe some attribute of an object. They are found in the dictionary of type objects."
msgstr ""
"\"Deskryptory\" są przedmiotami które opisują niektóre własności przedmiotu. "
"Można je znaleźć w słowniku przedmiotów typów."

msgid "Dictionary Objects"
msgstr "Przedmioty Słownikowe"

msgid "Exception Handling"
msgstr "Obsługa sytuacji wyjątkowych"

msgid "The functions described in this chapter will let you handle and raise Python exceptions.  It is important to understand some of the basics of Python exception handling.  It works somewhat like the Unix :cdata:`errno` variable: there is a global indicator (per thread) of the last error that occurred.  Most functions don't clear this on success, but will set it to indicate the cause of the error on failure.  Most functions also return an error indicator, usually *NULL* if they are supposed to return a pointer, or ``-1`` if they return an integer (exception: the :cfunc:`PyArg_\\*` functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"Zadania opisane w tym rozdziale pozwalają obsługiwać i zgłaszać sytuacje "
"wyjątkowe języka pytonowskiego. Istotne jest pojęcie pewnych podstaw obsługi "
"sytuacji wyjątkowych języka Pytonowskiego. Działa ono trochę, jak zmienna "
"znana z systemu Unix :cdata:`errno`: istnieje ogólnego poziomu wskaźnik (po "
"jednym na wątek) ostatniego błędu który wystąpił. Większość zadań nie "
"wyczyszcza tego przy bezbłędnym wykonaniu, ale ustawia go aby wskazywał na "
"powód błędu przy jego wystąpieniu. Większość zadań zwraca także wskazanie "
"błędu, zwykle *NULL* jeśli miały zwrócić wskaźnik, lub ``-1`` jeśli zwracają "
"liczbę całkowitą (z wyjątkiem: zadań :cfunc:`PyArg_\\*` które zwracają ``1`` "
"przy pozytywnym wykonaniu i ``0`` przy błędnym zakończeniu)."

msgid "When a function must fail because some function it called failed, it generally doesn't set the error indicator; the function it called already set it.  It is responsible for either handling the error and clearing the exception or returning after cleaning up any resources it holds (such as object references or memory allocations); it should *not* continue normally if it is not prepared to handle the error.  If returning due to an error, it is important to indicate to the caller that an error has been set.  If the error is not handled or carefully propagated, additional calls into the Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"Gdy zadanie musi zawieźć z powodu błędu zadania które wywołało, ogólnie nie "
"ustawia ona wskaźnika błędu; podzadanie które zostało wywołane już go "
"ustawiła. Jest on odpowiedzialny albo za obsługę błędu i wyczyszczenie "
"wskaźnika sytuacji wyjątkowej lub powrót po sprzątnięciu jakichkolwiek "
"zasobów które utrzymuje (takich jak odwołania do przedmiotów lub zajęte "
"pamięci); *nie* powinien kontynuować zwyczajnie jeśli nie jest przygotowany "
"do obsługi błędu. Jeśli kończy z powodu błędu, istotne jest zwrócenie uwagi "
"wołającego że został zgłoszony błąd. Jeśli błąd nie jest obsługiwany lub "
"propagowany właściwie, dodatkowe odwołania do sprzęgu języka pytonowskiego/C "
"mogą nie zachowywać się tak, jak planowano i mogą zawieźć w nieoczekiwane "
"sposoby."

msgid "The error indicator consists of three Python objects corresponding to the result of ``sys.exc_info()``.  API functions exist to interact with the error indicator in various ways.  There is a separate error indicator for each thread."
msgstr ""
"Wskaźnik błędu składa się z trzech przedmiotów języka pytonowskiego "
"odpowiadających wynikowi wykonania zadania ``sys.exc_info()``. Istnieją "
"zadania sprzęgu programowania do współpracy ze wskaźnikiem błędu na różne "
"sposoby. Dla każdego wątku istnieje osobny wskaźnik błędu."

msgid "Exception Objects"
msgstr "Przedmioty Sytuacji Wyjątkowych"

msgid "Recursion Control"
msgstr "Kontrola Rekursji"

msgid "These two functions provide a way to perform safe recursive calls at the C level, both in the core and in extension modules.  They are needed if the recursive code does not necessarily invoke Python code (which tracks its recursion depth automatically)."
msgstr ""
"Te dwa zadania dostarczają sposób postępowania dla wykonania bezpiecznego "
"odwołania rekursywnego na poziomie języka C, zarówno w głównych jak i "
"zewnętrznych modułach. Są one potrzebne jeśli kod odwołujący się sam do "
"siebie nie koniecznie wywołuje kod w języku pytonowskim (który śledzi poziom "
"zagnieżdżenia odwołań rekursywnych automatycznie)."

msgid "Standard Exceptions"
msgstr "Sztandarowe Sytuacje Wyjątkowe"

msgid "All standard Python exceptions are available as global variables whose names are ``PyExc_`` followed by the Python exception name.  These have the type :ctype:`PyObject\\*`; they are all class objects.  For completeness, here are all the variables:"
msgstr ""
"Wszystkie sztandarowe sytuacje wyjątkowe języka pytonowskiego są dostępne "
"jako nadrzędne zmienne których nazwy zaczynają się od ``PyExc_`` po którym "
"następuje nazwa sytuacji wyjątkowej języka pytonowskiego. Te są typu "
":ctype:`PyObject\\*`; wszystkie są przedmiotami definiującymi rodzaj "
"przedmiotu. Dla uzupełnienia, tu są wszystkie nazwy zmiennych:"

msgid "C Name"
msgstr "Nazwa C"

msgid "Python Name"
msgstr "Nazwa w języku pytonowskim"

msgid "Notes"
msgstr "Uwagi"

msgid ":cdata:`PyExc_BaseException`"
msgstr ":cdata:`PyExc_BaseException`"

msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

msgid "\\(1)"
msgstr "\\(1)"

msgid ":cdata:`PyExc_Exception`"
msgstr ":cdata:`PyExc_Exception`"

msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

msgid ":cdata:`PyExc_ArithmeticError`"
msgstr ":cdata:`PyExc_ArithmeticError`"

msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

msgid ":cdata:`PyExc_LookupError`"
msgstr ":cdata:`PyExc_LookupError`"

msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

msgid ":cdata:`PyExc_AssertionError`"
msgstr ":cdata:`PyExc_AssertionError`"

msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

msgid ":cdata:`PyExc_AttributeError`"
msgstr ":cdata:`PyExc_AttributeError`"

msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

msgid ":cdata:`PyExc_EOFError`"
msgstr ":cdata:`PyExc_EOFError`"

msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

msgid ":cdata:`PyExc_EnvironmentError`"
msgstr ":cdata:`PyExc_EnvironmentError`"

msgid ":exc:`EnvironmentError`"
msgstr ":exc:`EnvironmentError`"

msgid ":cdata:`PyExc_FloatingPointError`"
msgstr ":cdata:`PyExc_FloatingPointError`"

msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

msgid ":cdata:`PyExc_IOError`"
msgstr ":cdata:`PyExc_IOError`"

msgid ":exc:`IOError`"
msgstr ":exc:`IOError`"

msgid ":cdata:`PyExc_ImportError`"
msgstr ":cdata:`PyExc_ImportError`"

msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

msgid ":cdata:`PyExc_IndexError`"
msgstr ":cdata:`PyExc_IndexError`"

msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

msgid ":cdata:`PyExc_KeyError`"
msgstr ":cdata:`PyExc_KeyError`"

msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

msgid ":cdata:`PyExc_KeyboardInterrupt`"
msgstr ":cdata:`PyExc_KeyboardInterrupt`"

msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

msgid ":cdata:`PyExc_MemoryError`"
msgstr ":cdata:`PyExc_MemoryError`"

msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

msgid ":cdata:`PyExc_NameError`"
msgstr ":cdata:`PyExc_NameError`"

msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

msgid ":cdata:`PyExc_NotImplementedError`"
msgstr ":cdata:`PyExc_NotImplementedError`"

msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

msgid ":cdata:`PyExc_OSError`"
msgstr ":cdata:`PyExc_OSError`"

msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

msgid ":cdata:`PyExc_OverflowError`"
msgstr ":cdata:`PyExc_OverflowError`"

msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

msgid ":cdata:`PyExc_ReferenceError`"
msgstr ":cdata:`PyExc_ReferenceError`"

msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

msgid "\\(2)"
msgstr "\\(2)"

msgid ":cdata:`PyExc_RuntimeError`"
msgstr ":cdata:`PyExc_RuntimeError`"

msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

msgid ":cdata:`PyExc_SyntaxError`"
msgstr ":cdata:`PyExc_SyntaxError`"

msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

msgid ":cdata:`PyExc_SystemError`"
msgstr ":cdata:`PyExc_SystemError`"

msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

msgid ":cdata:`PyExc_SystemExit`"
msgstr ":cdata:`PyExc_SystemExit`"

msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

msgid ":cdata:`PyExc_TypeError`"
msgstr ":cdata:`PyExc_TypeError`"

msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

msgid ":cdata:`PyExc_ValueError`"
msgstr ":cdata:`PyExc_ValueError`"

msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

msgid ":cdata:`PyExc_WindowsError`"
msgstr ":cdata:`PyExc_WindowsError`"

msgid ":exc:`WindowsError`"
msgstr ":exc:`WindowsError`"

msgid "\\(3)"
msgstr "\\(3)"

msgid ":cdata:`PyExc_ZeroDivisionError`"
msgstr ":cdata:`PyExc_ZeroDivisionError`"

msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

msgid "Notes:"
msgstr "Uwagi:"

msgid "This is a base class for other standard exceptions."
msgstr ""
"To jest podstawowy rodzaj przedmiotu dla innych sztandarowych sytuacji "
"wyjątkowych."

msgid "This is the same as :exc:`weakref.ReferenceError`."
msgstr "To jest to samo, co sytuacja wyjątkowa :exc:`weakref.ReferenceError`."

msgid "Only defined on Windows; protect code that uses this by testing that the preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""
"Zdefiniowane tylko w systemie Windows; Kod chroniony który używa tego przez "
"sprawdzenie czy makrodefinicja preprocesora ``MS_WINDOWS`` jest określona."

msgid "File Objects"
msgstr "Przedmioty Plikowe"

msgid "These APIs are a minimal emulation of the Python 2 C API for built-in file objects, which used to rely on the buffered I/O (:ctype:`FILE\\*`) support from the C standard library.  In Python 3, files and streams use the new :mod:`io` module, which defines several layers over the low-level unbuffered I/O of the operating system.  The functions described below are convenience C wrappers over these new APIs, and meant mostly for internal error reporting in the interpreter; third-party code is advised to access the :mod:`io` APIs instead."
msgstr ""
"Te sprzęgi programowania (API) są najmniejszą emulacją sprzęgów "
"zamieniających z języka pytonowskiego do języka C dla wbudowanych "
"przedmiotów plikowych, które polegały na wsparciu wczytywania i zapisu z "
"wyprzedzeniem (:ctype:`FILE\\*`) z biblioteki sztandarowej języka C. W "
"trzeciej wersji języka pytonowskiego pliki i strumienie używają nowego "
"modułu :mod:`io`, który określa kilka warstw ponad niskopoziomowym "
"niewyprzedzającym odczycie/zapisie systemu operacyjnego. Zadania opisane "
"poniżej są konwencjonalnymi opakowaniami języka C ponad tymi nowymi "
"sprzęgami programowania ( - z ang. - API), i służą głównie wewnętrznemu "
"raportowaniu błędów wewnątrz programu interpretującego polecenia języka "
"pytonowskiego; dla programów pochodzących od zewnętrznych dostawców zalecany "
"jest dostęp przez sprzęgi programowania :mod:`io`"

msgid "Floating Point Objects"
msgstr "Przedmioty Liczb Zmiennopozycyjnych"

msgid "Function Objects"
msgstr "Przedmioty Zadań"

msgid "There are a few functions specific to Python functions."
msgstr "Istnieje kilka zadań szczególnych dla zadań języka pytonowskiego"

msgid "Supporting Cyclic Garbage Collection"
msgstr "Wsparcie dla Cyklicznego Zbierania Śmieci"

msgid "Python's support for detecting and collecting garbage which involves circular references requires support from object types which are \"containers\" for other objects which may also be containers.  Types which do not store references to other objects, or which only store references to atomic types (such as numbers or strings), do not need to provide any explicit support for garbage collection."
msgstr ""
"Wsparcie języka pytonowskiego dla wykrywania i zbierania śmieci które "
"zahacza o cykliczne odwołania wymaga wsparcia od rodzajów przedmiotów, które "
"są pojemnikami dla innych przedmiotów które mogą także być pojemnikami. "
"Rodzaje, które nie przechowują odwołań do innych przedmiotów, lub które "
"tylko przechowują odwołania do przedmiotów o rodzajach podstawowych (takich "
"jak liczby lub ciągi znaków), nie potrzebują dostarczać żadnego wsparcia dla "
"zbierania śmieci."

msgid "To create a container type, the :attr:`tp_flags` field of the type object must include the :const:`Py_TPFLAGS_HAVE_GC` and provide an implementation of the :attr:`tp_traverse` handler.  If instances of the type are mutable, a :attr:`tp_clear` implementation must also be provided."
msgstr ""
"Aby utworzyć rodzaj pojemnika, pole :attr:`tp_flags` rodzaju przedmiotu "
"pojemnika musi zawierać :const:`Py_TPFLAGS_HAVE_GC` i dostarczać "
"urzeczywistnienie uchwytu zadania  :attr:`tp_traverse`. Jeśli egzemplarze "
"tego rodzaju pojemników są zmienialne (mutowalne), urzeczywistnienie zadania "
":attr:`tp_clear` musi także być dostarczone."

msgid "Objects with a type with this flag set must conform with the rules documented here.  For convenience these objects will be referred to as container objects."
msgstr ""
"Przedmioty o rodzaju z tą flagą ustawioną muszą stosować się do zasad "
"opisanych tutaj. Dla wygody te przedmioty te będą określane mianem "
"przedmiotów pojemnikowych."

msgid "Constructors for container types must conform to two rules:"
msgstr ""
"Konstruktory przedmiotów typu pojemnikowego muszą stosować się do dwóch "
"zasad:"

msgid "The memory for the object must be allocated using :cfunc:`PyObject_GC_New` or :cfunc:`PyObject_GC_NewVar`."
msgstr ""
"Pamięć dla przedmiotu musi być przydzielona używając zadania "
":cfunc:`PyObject_GC_New` lub :cfunc:`PyObject_GC_NewVar`."

msgid "Once all the fields which may contain references to other containers are initialized, it must call :cfunc:`PyObject_GC_Track`."
msgstr ""
"Gdy wszystkie pola które mogą zawierać odwołania do innych pojemników "
"zostaną zainicjowane, wtedy musi wywoływać zadanie "
":cfunc:`PyObject_GC_Track`."

msgid "Similarly, the deallocator for the object must conform to a similar pair of rules:"
msgstr ""
"Podobnie odbieracz przydziału dla przedmiotu musi stosować się do podobnej "
"pary zasad:"

msgid "Before fields which refer to other containers are invalidated, :cfunc:`PyObject_GC_UnTrack` must be called."
msgstr ""
"Zanim pola które odnoszą się do innych pojemników zostaną unieważnione, "
"zadanie :cfunc:`PyObject_GC_UnTrack` musi zostać wywołane."

msgid "The object's memory must be deallocated using :cfunc:`PyObject_GC_Del`."
msgstr ""
"Pamięć przydzielona przedmiotowi musi zostać zabrana używając zadania "
":cfunc:`PyObject_GC_Del`."

msgid "The :attr:`tp_traverse` handler accepts a function parameter of this type:"
msgstr "Uchwyt :attr:`tp_traverse` przyjmuje jako parametr zadania ten typ:"

msgid "The :attr:`tp_traverse` handler must have the following type:"
msgstr "Uchwyt :attr:`tp_traverse` musi być tego typu:"

msgid "To simplify writing :attr:`tp_traverse` handlers, a :cfunc:`Py_VISIT` macro is provided.  In order to use this macro, the :attr:`tp_traverse` implementation must name its arguments exactly *visit* and *arg*:"
msgstr ""
"Aby uprościć pisanie uchwytu :attr:`tp_traverse`, dostarcza się "
"makropolecenie :cfunc:`Py_VISIT`. Aby użyć tego makropolecenia, realizacja "
"zadania :attr:`tp_traverse` musi nazywać jego parametry dokładnie *visit* i "
"*arg*:"

msgid "The :attr:`tp_clear` handler must be of the :ctype:`inquiry` type, or *NULL* if the object is immutable."
msgstr ""
"Uchwyt :attr:`tp_clear` musi być typu :ctype:`inquiry` (z ang. - zapytanie) "
"lub *NULL* jeśli przedmiot jest niezmienny (niemutowalny)."

msgid "Generator Objects"
msgstr "Przemioty Generatorów"

msgid "Generator objects are what Python uses to implement generator iterators. They are normally created by iterating over a function that yields values, rather than explicitly calling :cfunc:`PyGen_New`."
msgstr ""
"Przedmiotów Generatorów język pytonowski używa aby realizować iteratory "
"generatorów. Zwykle są one tworzone przez iterację po wynikach wyrzuconych z "
"zadania, zamiast jawnie wywoływać zadanie :cfunc:`PyGen_New`."

msgid "Importing Modules"
msgstr "Importowanie Modułów"

msgid "Python/C API Reference Manual"
msgstr "Podręcznik programowania sprzęgów między językami pyton i C"

msgid "Release"
msgstr "Wydanie"

msgid "|version|"
msgstr "|wersja|"

msgid "Date"
msgstr "Data"

msgid "|today|"
msgstr "|dzisiaj|"

msgid "This manual documents the API used by C and C++ programmers who want to write extension modules or embed Python.  It is a companion to :ref:`extending-index`, which describes the general principles of extension writing but does not document the API functions in detail."
msgstr ""
"Ten podręcznik opisuje sprzęg programowania (z ang. - API) używany przez "
"programujących w językach C i C++, którzy chcieliby pisać moduły "
"rozszerzające lub wstawki w języku pytonowskim. Jest on uzupełnieniem sekcji "
":ref:`extending-index`, który opisuje ogólne zasady pisania rozszerzeń ale "
"nie opisuje zadań sprzęgu programowania (API) w szczegółach."

msgid "Initialization, Finalization, and Threads"
msgstr "Inicjalizacja, Zakańczanie i Wątki"

msgid "Thread State and the Global Interpreter Lock"
msgstr "Stan Wątku i Nadrzędny Zamek programu Interpretującego "

msgid "The Python interpreter is not fully thread safe.  In order to support multi-threaded Python programs, there's a global lock, called the :dfn:`global interpreter lock` or :dfn:`GIL`, that must be held by the current thread before it can safely access Python objects. Without the lock, even the simplest operations could cause problems in a multi-threaded program: for example, when two threads simultaneously increment the reference count of the same object, the reference count could end up being incremented only once instead of twice."
msgstr ""
"Program interpretujący język pytonowski nie jest w pełni bezpieczny ze "
"względu na wątki. W celu udzielenia wsparcia dla wielowątkowych programów "
"języka pytonowskiego, istnieje nadrzędna blokada, zwana :dfn:`nadrzędną "
"blokadą programu interpretującego` w skrócie :dfn:`GIL` (z ang. - global "
"interpreter lock) która musi zostać wstrzymana przez aktywny wątek zanim "
"będzie mógł korzystać bezpiecznie z przedmiotów języka pytonowskiego. Bez "
"blokady, nawet najprostsze operacje mogłyby powodować kłopoty w "
"wielowątkowym programie: np. gdy dwa wątki jednocześnie zwiększają liczbę "
"odwołań do tego samego przedmiotu, liczba odwołań mogłaby ostatecznie zostać "
"zwiększona tylko jednokrotnie zamiast dwukrotnie."

msgid "Therefore, the rule exists that only the thread that has acquired the global interpreter lock may operate on Python objects or call Python/C API functions. In order to support multi-threaded Python programs, the interpreter regularly releases and reacquires the lock --- by default, every 100 bytecode instructions (this can be changed with  :func:`sys.setcheckinterval`).  The lock is also released and reacquired around potentially blocking I/O operations like reading or writing a file, so that other threads can run while the thread that requests the I/O is waiting for the I/O operation to complete."
msgstr ""
"Dlatego też, istnieje zasada mówiąca, że tylko wątek który przejął nadrzędną "
"blokadę programu interpretującego może operować na przedmiotach języka "
"pytonowskiego lub wzywać wykonania zadań sprzęgu programowania między "
"językami pytonowskim i C. W celu udzielenia wsparcia dla wielowątkowych "
"programów języka pytonowskiego, program interpretujący w równych odstępach "
"czasu zwalnia i na powrót przejmuje blokadę --- domyślnie co 100 instrukcji "
"w kęsokodzie (to może zostać zmienione za pomocą zadania "
":func:`sys.setcheckinterval`). Blokada jest także zwalniana i na powrót "
"przejmowana wokół, potencjalnie blokowania operacji dostępu I/O, jak odczyt "
"i zapis do pliku, tak że inne wątki mogą się toczyć podczas gdy wątek "
"stawiający żądanie dostępu I/O (odczytu/zapisu) czeka aż operacja "
"odczytu/zapisu zostanie zakończona. "

msgid "The Python interpreter needs to keep some bookkeeping information separate per thread --- for this it uses a data structure called :ctype:`PyThreadState`. There's one global variable, however: the pointer to the current :ctype:`PyThreadState` structure.  Before the addition of :dfn:`thread-local storage` (:dfn:`TLS`) the current thread state had to be manipulated explicitly."
msgstr ""
"Program Interpretujący potrzebuje utrzymywać niektóre wiadomości porządkowe "
"oddzielnie dla każdego wątku --- dla nich używa struktury danych zwanej "
":ctype:`PyThreadState`. Istnieje jednak jedna nadrzędna zmienna: wskaźnik na "
"strukturę stanu obecnego wątku :ctype:`PyThreadState`. Przed dodaniem "
"miejscowego magazynu wątku ( z ang. - :dfn:`thread-local storage` w skrócie "
":dfn:`TLS`) stan aktualnego wątku musiał być jawnie określany."

msgid "This is easy enough in most cases.  Most code manipulating the global interpreter lock has the following simple structure::"
msgstr ""
"Jest to proste w większości przypadków. Większość kodu operującego na "
"nadrzędnej blokadzie programu interpretującego ma następującą prostą "
"budowę::"

msgid "Save the thread state in a local variable. Release the global interpreter lock. ...Do some blocking I/O operation... Reacquire the global interpreter lock. Restore the thread state from the local variable."
msgstr ""
"Zapamiętaj stan wątku w zmiennej miejscowej. Zwolnij nadrzędną blokadę "
"programu interpretującego. ...Wykonaj pewną operację blokującą "
"odczytu/zapisu... Na nowo przejmij i załóż nadrzędną blokadę programu "
"interpretującego. Przywróć stan wątku ze zmiennej miejscowej."

msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"Jest to tak często spotykane postępowanie że istnieje para makropoleceń "
"służąca do jego uproszczenia"

msgid "Py_BEGIN_ALLOW_THREADS ...Do some blocking I/O operation... Py_END_ALLOW_THREADS"
msgstr ""
"Py_BEGIN_ALLOW_THREADS ...Wykonaj pewną blokującą odzyt/zapis operację... "
"Py_END_ALLOW_THREADS"

msgid "The :cmacro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a hidden local variable; the :cmacro:`Py_END_ALLOW_THREADS` macro closes the block.  Another advantage of using these two macros is that when Python is compiled without thread support, they are defined empty, thus saving the thread state and GIL manipulations."
msgstr ""
"Makropolecenie :cmacro:`Py_BEGIN_ALLOW_THREADS` otwiera nowy blok i "
"deklaruje ukrytą zmienną lokalną; Makropolecenie "
":cmacro:`Py_END_ALLOW_THREADS` zamyka blok. Dodatkową zaletą używania tych "
"dwóch makropoleceń jest to, że gdy język pytonowski jest kompilowany bez "
"wsparcia dla wątków, są zdefiniowane jako puste, w ten sposób zachowując "
"stan wątków i zmiany typu GIL."

msgid "When thread support is enabled, the block above expands to the following code::"
msgstr ""
"Gdy wsparcie dla wątków jest włączone, powyższy blok rozwijany jest do "
"poniższego kodu::"

msgid "PyThreadState *_save;  _save = PyEval_SaveThread(); ...Do some blocking I/O operation... PyEval_RestoreThread(_save);"
msgstr ""
"PyThreadState *_save; _save = PyEval_SaveThread(); ...Wykonaj pewne operacje "
"blokujące wejście/wyjście... PyEval_RestoreThread(_save);"

msgid "Using even lower level primitives, we can get roughly the same effect as follows::"
msgstr ""
"Używanie nawet niższego poziomu zadań podstawowych, możemy uzyskać z grubsza "
"ten sam efekt w następujący sposób::"

msgid "PyThreadState *_save;  _save = PyThreadState_Swap(NULL); PyEval_ReleaseLock(); ...Do some blocking I/O operation... PyEval_AcquireLock(); PyThreadState_Swap(_save);"
msgstr ""
"PyThreadState *_save;  _save = PyThreadState_Swap(NULL); "
"PyEval_ReleaseLock(); ...Wykonaj pewną operację blokującą wejście/wyjście... "
"PyEval_AcquireLock(); PyThreadState_Swap(_save);"

msgid "There are some subtle differences; in particular, :cfunc:`PyEval_RestoreThread` saves and restores the value of the  global variable :cdata:`errno`, since the lock manipulation does not guarantee that :cdata:`errno` is left alone.  Also, when thread support is disabled, :cfunc:`PyEval_SaveThread` and :cfunc:`PyEval_RestoreThread` don't manipulate the GIL; in this case, :cfunc:`PyEval_ReleaseLock` and :cfunc:`PyEval_AcquireLock` are not available. This is done so that dynamically loaded extensions compiled with thread support enabled can be loaded by an interpreter that was compiled with disabled thread support."
msgstr ""
"Istnieją pewne drobne różnice; w szczególności, "
":cfunc:`PyEval_RestoreThread` zachowuje i przywraca wartość zmiennej "
"globalnej :cdata:`errno`, biorąc pod uwagę to, że zmiany dokonywane na "
"blokadzie nie gwarantują, że zmienna :cdata:`errno` zostanie zostawiona w "
"spokoju. Także gdy wsparcie dla wątków jest wyłączone, zadabue "
":cfunc:`PyEval_SaveThread` i :cfunc:`PyEval_RestoreThread` nie zmieniają "
"GILa; w tym przypadku zadania :cfunc:`PyEvalReleaseLock` i "
":cfunc:`PyEval_AcquireLock` nie są dostępne. Jest to zrobione tak, aby "
"dynamicznie ładowane rozszerzenia kompilowane ze wsparciem dla wątków "
"włączonym mogły być ładowane przez program interpretujący polecenia języka "
"pytonowskiego który został utworzony z wyłączonym wsparciem dla wątków."

msgid "The global interpreter lock is used to protect the pointer to the current thread state.  When releasing the lock and saving the thread state, the current thread state pointer must be retrieved before the lock is released (since another thread could immediately acquire the lock and store its own thread state in the global variable). Conversely, when acquiring the lock and restoring the thread state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"GIL - 'global interpreter lock' nadrzędna blokada programu interpretującego "
"polecenia języka pytonowskiego jest używany do ochrony wskaźnika na obecny "
"stan wątku. W czasie zwalniania blokady, wskaźnik na stan aktualnego wątku "
"musi zostać odebrany zanim blokada zostanie zwolniona (gdyż inny wątek "
"mógłby natychmiast przejąć blokadę i zapamiętać stan swojego własnego wątku "
"w zmiennej nadrzędnej). Wtórnie, po przejęciu blokady i przywróceniu stanu "
"wątku, blokada musi być przejęta przed zachowaniem wskaźnika stanu wątku."

msgid "It is important to note that when threads are created from C, they don't have the global interpreter lock, nor is there a thread state data structure for them.  Such threads must bootstrap themselves into existence, by first creating a thread state data structure, then acquiring the lock, and finally storing their thread state pointer, before they can start using the Python/C API.  When they are done, they should reset the thread state pointer, release the lock, and finally free their thread state data structure."
msgstr ""
"Warto zauważyć, że gdy wątki są tworzone z C, nie mają nadrzędnej blokady, "
"ani nie ma dla nich struktury danych stanu wątku. Takie wątki muszą wciągnąć "
"się za przysłowiowe szelki do istnienia, najpierw tworząc strukturę danych "
"stanu wątku, potem przejmując zatrzask, i w końcu zapamiętując wskaźnik na "
"ich stan wątku, zanim będzie mógł być rozpoczęty przy użyciu sprzęgu "
"programowania zrębem między językami pytonowskim i C (API). Gdy zostaną "
"zakończone powinny zresetować wskaźnik stanu wątku, zwolnić zatrzask, i w "
"końcu zwolnić ich pamięć przydzieloną strukturze danych stanu wątku."

msgid "Threads can take advantage of the :cfunc:`PyGILState_\\*` functions to do all of the above automatically.  The typical idiom for calling into Python from a C thread is now::"
msgstr ""
"Wątki mogą korzystać z zadań :cfunc:`PyGILState_\\*` aby wykonywać powyższe "
"zadania automatycznie. Typowym idiomem wzywającym zadania języka "
"pytonowskiego z wątku w języku C jest teraz::"

msgid "PyGILState_STATE gstate; gstate = PyGILState_Ensure();  /* Perform Python actions here.  */ result = CallSomeFunction(); /* evaluate result */  /* Release the thread. No Python API allowed beyond this point. */ PyGILState_Release(gstate);"
msgstr ""
"PyGILState_STATE gstan; gstan = PyGILState_Ensure();  /* Wykonaj działania w "
"języku pytonowskim tutaj.  */ wynik = WykonajPewneZadania(); /* oblicz "
"wynik */  /* Zwolnij wątek. Żadne sprzęgi programowania języka pytonowskiego "
"nie dozwolone po tym miejscu. */ PyGILState_Release(gstan);"

msgid "Note that the :cfunc:`PyGILState_\\*` functions assume there is only one global interpreter (created automatically by :cfunc:`Py_Initialize`).  Python still supports the creation of additional interpreters (using :cfunc:`Py_NewInterpreter`), but mixing multiple interpreters and the :cfunc:`PyGILState_\\*` API is unsupported."
msgstr ""
"Warto zauważyć, że :cfunc:`PyGILState_\\*` zadania przyjmują że istnieje "
"tylko jeden nadrzędny program interpretujący polecenia języka pytonowskiego "
"(tworzony automatycznie przez :cfunc:`Py_Initialize`).  Język pytonowski "
"wspiera uruchamianie dodatkowych programów interpretujących polecenia języka "
"pytonowskiego (używając zadania :cfunc:`Py_NewInterpreter`), ale mieszanie "
"kilku programów interpretujących polecenia języka pytonowskiego i sprzęgu "
"programowania :cfunc:`PyGILState_\\*` (API) nie jest wspierane."

msgid "Another important thing to note about threads is their behaviour in the face of the C :cfunc:`fork` call. On most systems with :cfunc:`fork`, after a process forks only the thread that issued the fork will exist. That also means any locks held by other threads will never be released. Python solves this for :func:`os.fork` by acquiring the locks it uses internally before the fork, and releasing them afterwards. In addition, it resets any :ref:`lock-objects` in the child. When extending or embedding Python, there is no way to inform Python of additional (non-Python) locks that need to be acquired before or reset after a fork. OS facilities such as :cfunc:`posix_atfork` would need to be used to accomplish the same thing. Additionally, when extending or embedding Python, calling :cfunc:`fork` directly rather than through :func:`os.fork` (and returning to or calling into Python) may result in a deadlock by one of Python's internal locks being held by a thread that is defunct after the fork. :cfunc:`PyOS_AfterFork` tries to reset the necessary locks, but is not always able to."
msgstr ""
"Następną wartą zauważenia sprawą o wątkach jest ich zachowanie wobec "
"napotkania wywołania zadania z języka C :cfunc:`fork`. W większości systemów "
"z zadaniem :cfunc:`fork`, po tym jak proces dokonuje podziału tylko wątek, "
"który wywoływał zadanie podziału wątku będzie istniał. To także oznacza, że "
"dowolne inne blokady utrzymywane przez inne wątki nie zostaną nigdy "
"zwolnione. Język pytonowski wprowadza rozwiązanie dla zadania "
":func:`os.fork` przez przejęcie blokad używanych wewnętrznie, przed "
"rozwidleniem i zwolnienie ich po wszystkim. W dodatku resetuje wszystkie "
"przedmioty-blokady - z ang. :ref:`lock-objects` w wątku potomnym. Przy "
"rozszerzaniu lub zawieraniu programu interpretującego polecenia języka "
"pytonowskiego w programie, nie istnieje żaden sposób, aby poinformować "
"program interpretujący polecenia języka pytonowskiego o (niepochodzących z "
"programu zapisanym w języku pytonowskim) blokadach które należy przejąć "
"przed lub wyzerować po zakończeniu rozwidlenia wątków. Urządzenia systemu "
"operacyjnego (OS) tkaie jak zadanie :cfunc:`posix_atfork` powinny służyć tym "
"samym celom. Dodatkowo, przy rozszerzaniu lub załączaniu programu "
"interpretującego polecenia języka pytonowskiego, wywoływanie zadania "
":cfunc:`fork` bezpośrednio zamiast przez :func:`os.fork` (i powracając do "
"lub wywołując zadania z poziomu języka pytonowskiego) może skutkować "
"zakleszczeniem jednej z wewnętrznych blokad programu interpretującego języka "
"pytonowskiego utrzymywanych przez wątek, który został wyłączony po "
"rozwidleniu. Zadanie :cfunc:`PyOS_AfterFork` próbuje rozwiązać odpowiednie "
"blokady, choć nie zawsze jest w stanie."

msgid "The following macros are normally used without a trailing semicolon; look for example usage in the Python source distribution."
msgstr ""
"Następujące makropolecenia są za zwyczaj używane bez uwieńczania średnikiem; "
"zobacz też przykładowe użycie w pakiecie źródłowym języka pytonowskiego."

msgid "All of the following functions are only available when thread support is enabled at compile time, and must be called only when the global interpreter lock has been created."
msgstr ""
"Wszystkie następujące zadania są dostępne tylko, gdy wspieranie wątków jest "
"włączone w czasie kompilowania programu interpretującego język pytonowski, i "
"mogą być użyte tylko po utworzeniu nadrzędnej blokady programu "
"interpretującego."

msgid "Asynchronous Notifications"
msgstr "Powiadomienia Asynchroniczne"

msgid "A mechanism is provided to make asynchronous notifications to the main interpreter thread.  These notifications take the form of a function pointer and a void argument."
msgstr ""
"Mechanizm dostarczany w celu wytwarzania niejednoczesnych powiadomień dla "
"głównego wątku programu interpretującego polecenia języka pytonowskiego. Te "
"powiadomienia mają postać wskaźnika na zadanie i pustego parametru."

msgid "Every check interval, when the global interpreter lock is released and reacquired, Python will also call any such provided functions.  This can be used for example by asynchronous IO handlers.  The notification can be scheduled from a worker thread and the actual call than made at the earliest convenience by the main thread where it has possession of the global interpreter lock and can perform any Python API calls."
msgstr ""
"W równych odstępach pomiędzy sprawdzeniami, gdy nadrzędna blokada programu "
"interpretującego jest zwalniana i na powrót przechwytywana, program "
"interpretujący język pytonowski wywołuje każde takie napotkane dostarczone "
"mu zadanie. Może być to użyte na przykład przez niejednoczesne uchwyty "
"wejścia/wyjścia. Powiadomienia mogą być planowane z wyprzedzeniem przez "
"wątek roboczy i właściwe wywołanie potem wykonywane przy najbliższej okazji "
"przez główny wątek który ma w posiadaniu główną blokadę programu "
"interpretującego i może wykonywać dowolne wywołania sprzęgu programowania "
"poleceń języka pytonowskiego (Python API)."

msgid "Profiling and Tracing"
msgstr ""
"Profilowanie (badanie prędkości) i trasowanie (badanie przebiegów) programów "
"języka pytonowskiego."

msgid "The Python interpreter provides some low-level support for attaching profiling and execution tracing facilities.  These are used for profiling, debugging, and coverage analysis tools."
msgstr ""
"Program interpretujący dostarcza pewnych nisko-poziomowego wsparcia dla "
"doczepiania urządzeń profilowania i badania przebiegów wykonania. "
"Następujące używane są jak narzędzia badania prędkości, odpluskwiania i "
"badania pokrycia."

msgid "This C interface allows the profiling or tracing code to avoid the overhead of calling through Python-level callable objects, making a direct C function call instead.  The essential attributes of the facility have not changed; the interface allows trace functions to be installed per-thread, and the basic events reported to the trace function are the same as had been reported to the Python-level trace functions in previous versions."
msgstr ""
"Ten sprzęg języka C pozwala aby kod badający prędkość lub badający przebiegi "
"unikał nadmiaru wywoływań przez rzeczy wywoływalne z poziomu języka "
"Pytonowskiego, wykonując zamiast tego bezpośrednie wywołania zadań z języka "
"C. Najważniejsze własności urządzenia nie zmieniły się; sprzęg pozwala "
"zadaniom badającym przebiegi wykonania programu na doczepianie do "
"poszczególnych wątków, a podstawowe zdarzenia raportowane do zadania badania "
"przebiegów programu są takie same jakie były raportowane do zadań "
"badających przebiegi wykonania programu w poprzednich wersjach. "

msgid "Advanced Debugger Support"
msgstr "Wsparcie dla Rozwiniętego Odpluskwiacza"

msgid "These functions are only intended to be used by advanced debugging tools."
msgstr ""
"Te zadania są przeznaczone tylko dla użycia przez narzędzia rozwiniętego "
"odpluskwiacza."

msgid "Introduction"
msgstr "Wprowadzenie"

msgid "The Application Programmer's Interface to Python gives C and C++ programmers access to the Python interpreter at a variety of levels.  The API is equally usable from C++, but for brevity it is generally referred to as the Python/C API.  There are two fundamentally different reasons for using the Python/C API. The first reason is to write *extension modules* for specific purposes; these are C modules that extend the Python interpreter.  This is probably the most common use.  The second reason is to use Python as a component in a larger application; this technique is generally referred to as :dfn:`embedding` Python in an application."
msgstr ""
"Sprzęg programowania aplikacji w języku pytonowskim daje programistom "
"języków C i C++ dostęp do programu interpretującego polecenia języka "
"pytonowskiego na wielu poziomach. Sprzęg (API) jest równo użyteczny z "
"poziomu C++ ale dla porządku jest zwykle określany mianem sprzęgu pomiędzy "
"językami pytonowskim a C (z ang. - Python/C API). Istnieją dwie zasadniczo "
"różne przyczyny dla użycia sprzęgu między językami pytonowskim i C. Pierwszą "
"przyczyną jest pisanie *modułów rozszerzających* dla szczególnych powodów; "
"są to moduły języka C, które rozszerzają program interpretujący języka "
"pytonowskiego. To jest zwykle najczęstsze użycie. Drugą przyczyną jest "
"użycie języka pytonowskiego jako komponentu większego programu; ta technika "
"jest zwykle określana mianem załączania - z ang. - :dfn:`embedding` w "
"aplikacji."

msgid "Writing an extension module is a relatively well-understood process,  where a \"cookbook\" approach works well.  There are several tools  that automate the process to some extent.  While people have embedded  Python in other applications since its early existence, the process of  embedding Python is less straightforward than writing an extension."
msgstr ""
"Pisanie rozszerzającego modułu jest względnie dobrze zrozumiałym procesem, "
"gdzie podejście \"książki kucharskiej\" działa dobrze. Istnieje kilka narzędzi "
"które automatyzują proces do pewnego stopnia. Chociaż załączano program "
"interpretujący język pytonowski od wczesnych lat jego istnienia, jednak "
"proces załączania programu interpretującego język pytonowski jest mniej "
"prosty niż pisanie rozszerzenia."

msgid "Many API functions are useful independent of whether you're embedding  or extending Python; moreover, most applications that embed Python  will need to provide a custom extension as well, so it's probably a  good idea to become familiar with writing an extension before  attempting to embed Python in a real application."
msgstr ""
"Wiele zadań sprzęgu (API) jest użytecznych niezależnie od tego czy "
"załączasz, czy też rozszerzasz program interpretujący język pytonowski; co "
"więcej, większość aplikacji które załącza program interpretujący polecenia "
"jezyka pytonowskiego potrzebuje także szczególnych rozszerzeń, więc "
"prawdopodobnie jest dobrym pomysłem zaznajomienie się z pisaniem "
"rozszerzenia przed próbą załączenia języka pytonowskiego w prawdziwej "
"aplikacji."

msgid "Include Files"
msgstr "Pliki Włączania - z ang. Include"

msgid "All function, type and macro definitions needed to use the Python/C API are included in your code by the following line::"
msgstr ""
"Wszystkie zadania, definicje typu i makropoleceń konieczne do użycia sprzęgu "
"między językami pytonowskim i C są włączane do źródeł w kodzie użytkownika "
"przez następującą linijkę::"

msgid "#include \"Python.h\""
msgstr "#include \"Python.h\""

msgid "This implies inclusion of the following standard headers: ``<stdio.h>``, ``<string.h>``, ``<errno.h>``, ``<limits.h>``, and ``<stdlib.h>`` (if available)."
msgstr ""
"To oznacza włączenie następujących typowych plików nagłówkowych: "
"``<stdio.h>``, ``<string.h>``, ``<errno.h>``, ``<limits.h>``, i "
"``<stdlib.h>`` (jeśli są dostępne)."

msgid "Since Python may define some pre-processor definitions which affect the standard headers on some systems, you *must* include :file:`Python.h` before any standard headers are included."
msgstr ""
"Odkąd język pytonowski może definiować pewne definicje preprocesora, które "
"wpływają na pliki nagłówkowe na niektórych systemach, *musisz* załączyć plik "
":file:`Python.h` zanim jakiekolwiek standardowe nagłówki zostaną załączone."

msgid "All user visible names defined by Python.h (except those defined by the included standard headers) have one of the prefixes ``Py`` or ``_Py``.  Names beginning with ``_Py`` are for internal use by the Python implementation and should not be used by extension writers. Structure member names do not have a reserved prefix."
msgstr ""
"Wszystkie widoczne dla użytkownika nazwy określone w Python.h ( z wyjątkiem "
"tych określonych przez załączone standardowe pliki nagłówkowe ) mają jeden z "
"przedrostków ``Py`` lub ``_Py``. Nazwy rozpoczynające się od ``_Py`` służą "
"do wewnętrznego użytku przez urzeczywistnienie programu interpretującego "
"języka pytonowskiego i nie powinno być używane przez piszących rozszerzenia. "
"Nazwy członków struktury nie mają zarezerwowanych przedrostków."

msgid "**Important:** user code should never define names that begin with ``Py`` or ``_Py``.  This confuses the reader, and jeopardizes the portability of the user code to future Python versions, which may define additional names beginning with one of these prefixes."
msgstr ""
"**Istotne:** Kod użytkownika nie powinien nigdy określać nazw które "
"zaczynają się od ``Py`` lub ``_Py``. Wprowadza to zamieszanie dla "
"czytających kod, i utrudnia przenośność kodu użytkownika do przyszłych "
"wersji języka pytonowskiego, które mogą definiować dodatkowe nazwy "
"rozpoczynające się jednym z tych przedrostków."

msgid "The header files are typically installed with Python.  On Unix, these  are located in the directories :file:`{prefix}/include/pythonversion/` and :file:`{exec_prefix}/include/pythonversion/`, where :envvar:`prefix` and :envvar:`exec_prefix` are defined by the corresponding parameters to Python's :program:`configure` script and *version* is ``sys.version[:3]``.  On Windows, the headers are installed in :file:`{prefix}/include`, where :envvar:`prefix` is the installation directory specified to the installer."
msgstr ""
"Pliki nagłówkowe są zazwyczaj instalowane z językiem pytonowskim. Na "
"Uniksie, są one umieszczone w katalogach "
":plik:`{przedrostek}/include/pythonawersja/` i "
":plik:`{exec_prefix}/include/pythonwersja` gdzie :envvar:`prefix` są "
"zdefiniowane przez korespondujące parametry dla skryptu :program:`configure` "
"konfigurującego program interpretujący języka pytonowskiego i *wersja* jest "
"``sys.version[:3]``. W Windows, nagłówki są instalowane w katalogu "
":file:`{przedrostek}/include`, gdzie :envvar:`przedrostek` jest katalog "
"instalacyjny określony w procesie instalacji."

msgid "To include the headers, place both directories (if different) on your compiler's search path for includes.  Do *not* place the parent directories on the search path and then use ``#include <pythonX.Y/Python.h>``; this will break on multi-platform builds since the platform independent headers under :envvar:`prefix` include the platform specific headers from :envvar:`exec_prefix`."
msgstr ""
"Aby załączyć pliki nagłówkowe, umieść oba katalogi (jeśli są różne) na "
"liście przeszukiwanych ścieżek poszukiwania plików nagłówkowych. *Nie* "
"umieszczaj katalogów nadrzędnych na ścieżkach poszukiwania plików "
"nagłówkowych po czym wpisując ``#include <pythonX.Y/Python.h>``; To "
"spowoduje przerwanie na realizacjach wieloplatformowych gdyż niezależne od "
"platformy nagłówki dostępne w katalogu :envvar:`przedrostek` zawiera pliki "
"nagłówkowe szczególne dla pewnych platform z katalogu :envvar:`exec_prefix`."

msgid "C++ users should note that though the API is defined entirely using C, the header files do properly declare the entry points to be ``extern \"C\"``, so there is no need to do anything special to use the API from C++."
msgstr ""
"Użytkownicy C++ powinni wziąć pod uwagę, że chociaż sprzęg programowania "
"jest dostępny w całości przy użyciu C, pliki nagłówkowe prawidłowo deklarują "
"punkty wejściowe aby następowały ``extern \"C\"``, tak że nie ma potrzeby "
"robić nic więcej szczególnego aby używać sprzęgu z poziomu języka C++."

msgid "Objects, Types and Reference Counts"
msgstr "Przedmioty, ich Rodzaje i Liczby Odwołań"

msgid "Most Python/C API functions have one or more arguments as well as a return value of type :ctype:`PyObject\\*`.  This type is a pointer to an opaque data type representing an arbitrary Python object.  Since all Python object types are treated the same way by the Python language in most situations (e.g., assignments, scope rules, and argument passing), it is only fitting that they should be represented by a single C type.  Almost all Python objects live on the heap: you never declare an automatic or static variable of type :ctype:`PyObject`, only pointer variables of type :ctype:`PyObject\\*` can  be declared.  The sole exception are the type objects; since these must never be deallocated, they are typically static :ctype:`PyTypeObject` objects."
msgstr ""
"Większość zadań sprzęgu między językami pytonowskim i C ( z ang. Python/C "
"API) ma jeden lub więcej parametrów zarówno jak wartość zwracaną typu "
":ctype:`PyObject\\*`. Ten rodzaj jest wskaźnikiem na przezroczysty rodzaj "
"danych reprezentujący konkretne przedmioty języka pytonowskiego. Od kiedy "
"wszystkie rodzaje przedmiotów w języku pytonowskim są traktowane tak samo "
"przez język pytonowski w większości sytuacji (np. przypisania, prawa "
"pierwszeństwa nawiasów i przekazywania parametrów), jest zatem zrozumiałe, "
"że powinny być reprezentowane przez jeden rodzaj przedmiotu w języku C. "
"Prawie wszystkie przedmioty języka pytonowskiego wiodą swój żywot na "
"stercie: nigdy nie deklaruje się automatycznych ani statycznych zmiennych "
"rodzaju :ctype:`PyObject`, tylko zmienne wskaźnikowe o rodzaju "
":ctype:`PyObject\\*` mogą być deklarowane. Jedynym wyjątkiem od tej reguły są "
"przedmioty określające rodzaj przedmiotu; ponieważ nigdy nie mogą być one "
"zdjęte, są one zwykle przedmiotami statycznymi :ctype:`PyTypeObject`."

msgid "All Python objects (even Python integers) have a :dfn:`type` and a :dfn:`reference count`.  An object's type determines what kind of object it is (e.g., an integer, a list, or a user-defined function; there are many more as explained in :ref:`types`).  For each of the well-known types there is a macro to check whether an object is of that type; for instance, ``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is a Python list."
msgstr ""
"Wszystkie przedmioty języka pytonowskiego (nawet liczby całkowite języka "
"pytonowskiego) mają :dfn:`rodzaj` i :dfn:`liczbę odniesień`. Typ przedmiotu "
"określa jakiego rodzaju przedmiot to jest (np. liczba całkowita, lista, lub "
"zadanie zdefiniowane przez użytkownika; jest wiele więcej jak wyjaśniono w "
":ref:`types`). Dla każdego z dobrze-znanych rodzajów istnieje makropolecenie "
"sprawdzające czy przedmiot jest tego rodzaju; na przykład, "
"``PyList_Check(a)`` jest prawdziwe wtedy (i tylko wtedy) gdy przedmiot na "
"który wskazuje *a* jest lista z języka pytonowskiego."

msgid "Reference Counts"
msgstr "Liczby odniesień"

msgid "The reference count is important because today's computers have a  finite (and often severely limited) memory size; it counts how many  different places there are that have a reference to an object.  Such a  place could be another object, or a global (or static) C variable, or  a local variable in some C function. When an object's reference count  becomes zero, the object is deallocated.  If it contains references to  other objects, their reference count is decremented. Those other  objects may be deallocated in turn, if this decrement makes their reference count become zero, and so on.  (There's an obvious problem  with objects that reference each other here; for now, the solution is  \"don't do that.\")"
msgstr ""
"Liczba odniesień jest istotna, gdyż dzisiejsze komputery mają skończony (i "
"zwykle poważnie ograniczony) rozmiar pamięci; liczy ona jak wiele różnych "
"miejsc istnieje, które przechowują odniesienie do przedmiotu. Takie miejsce "
"może być innym przedmiotem, zmienną C nadrzędnego poziomu (lub statyczną), "
"lub lokalną zmienną w jakimś zadaniu języka C. Gdy liczba odniesień do "
"przedmiotu staje się równa zero, przedmiot jest zdejmowany z pamięci. Jeśli "
"zawiera odniesienia do innych przedmiotów liczba odniesień do nich jest "
"obniżana po jednym dla każdego. Te inne przedmioty mogą być zdejmowane z "
"pamięci w konsekwencji, jeśli obniżenie liczby odniesień do nich spowoduje "
"że liczba odniesień stanie się równa zero, itd. (Istnieje dość oczywisty "
"problem z przedmiotami które wzajemnie się odnoszą do siebie; na razie "
"rozwiązaniem jest \"proszę tak nie robić.\")"

msgid "Reference counts are always manipulated explicitly.  The normal way is  to use the macro :cfunc:`Py_INCREF` to increment an object's reference count by one, and :cfunc:`Py_DECREF` to decrement it by   one.  The :cfunc:`Py_DECREF` macro is considerably more complex than the incref one, since it must check whether the reference count becomes zero and then cause the object's deallocator to be called. The deallocator is a function pointer contained in the object's type structure.  The type-specific deallocator takes care of decrementing the reference counts for other objects contained in the object if this is a compound object type, such as a list, as well as performing any additional finalization that's needed.  There's no chance that the reference count can overflow; at least as many bits are used to hold the reference count as there are distinct memory locations in virtual memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the reference count increment is a simple operation."
msgstr ""
"Liczby odniesień są zawsze zmieniane jawnie. Zwykłym sposobem jest użycie "
"makropolecenia :cfunc:`Py_INCREF` aby zwiększyć liczbę odniesień dla "
"przedmiotu o jeden, i makropolecenie :cfunc:`Py_DECREF` aby zmniejszyć ją o "
"jeden. Makropolecenie :cfunc:`Py_DECREF` jest z konieczności bardziej "
"złożone niż to zwiększające o nazwie incref, gdyż musi sprawdzać czy liczba "
"odniesień staje się równa zero i dopiero wtedy powodować wezwanie zdjęcia "
"przedmiotu z pamięci. Zadanie zdejmujące jest wskaźnikiem na zadanie zawarte "
"w strukturze typu przedmiotu. Szczególne dla każdego rodzaju zadanie "
"zajmuje się zmniejszeniem liczby odniesień dla innych przedmiotów zawartych "
"w przedmiocie, jeśli jest to przedmiot o złożonym rodzaju, takim jak lista, "
"zarówno jak wykonując dowolne dodatkowe zakańczanie jeśli jest to konieczne. "
"Nie ma możliwości aby liczba odniesień uległa przepełnieniu; przynajmniej "
"tak wiele bitów użyto do przechowywania liczby odniesień, jak wiele jest "
"różnych miejsc w pamięci w pamięci wirtualnej (zakładając "
"``sizeof(Py_ssize_t) >= sizeof(void*)``). Zatem zwiększenie liczby odniesień "
"jest prostą operacją."

msgid "It is not necessary to increment an object's reference count for every  local variable that contains a pointer to an object.  In theory, the  object's reference count goes up by one when the variable is made to  point to it and it goes down by one when the variable goes out of  scope.  However, these two cancel each other out, so at the end the  reference count hasn't changed.  The only real reason to use the  reference count is to prevent the object from being deallocated as  long as our variable is pointing to it.  If we know that there is at  least one other reference to the object that lives at least as long as our variable, there is no need to increment the reference count  temporarily. An important situation where this arises is in objects  that are passed as arguments to C functions in an extension module  that are called from Python; the call mechanism guarantees to hold a  reference to every argument for the duration of the call."
msgstr ""
"Nie jest konieczne zwiększanie zwiększanie liczby odniesień do przedmiotu "
"dla każdej lokalnej zmiennej która zawiera wskaźnik na przedmiot. "
"Teoretycznie, liczba odniesień do przedmiotu zwiększa się o jeden gdy "
"zmienna jest zmuszana do wskazywania nań i jest zmniejszana o jeden gdy "
"zmienna wychodzi z widoku. Jednakże te dwa działania wykluczają się "
"nawzajem, więc ostatecznie liczba odniesień nie ulega zmianie. Jedynym "
"prawdziwym powodem użycia liczby odniesień jest aby uniemożliwić zdjęcie z "
"pamięci przedmiotu tak długo jak nasza zmienna nań wskazuje. Jeśli wiemy, że "
"istnieje przynajmniej jedno inne odniesienie do przedmiotu, które żyje tak "
"długo jak nasza zmienna, nie ma potrzeby zwiększania liczby odniesień "
"tymczasowo. Istotną sytuacją gdzie to się pojawia jest w obiektach które są "
"przekazywane jako parametry do zadań C w modułach rozszerzających które są "
"wywoływane przez polecenia języka pytonowskiego; mechanizm wywołania "
"gwarantuje przytrzymanie odniesienia do każdego parametru na czas wywołania "
"zadania z tym parametrem."

msgid "However, a common pitfall is to extract an object from a list and hold on to it for a while without incrementing its reference count. Some other operation might conceivably remove the object from the list, decrementing its reference count and possible deallocating it. The real danger is that innocent-looking operations may invoke arbitrary Python code which could do this; there is a code path which allows control to flow back to the user from a :cfunc:`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""
"Jednakże typową pułapką jest wyjęcie przedmiotu z listy i przetrzymanie go "
"przez pewien czas bez zwiększenia liczby odniesień. Jakaś inna operacja może "
"wyobrażalnie usunąć ten przedmiot z listy, zmniejszając liczbę odniesień do "
"niego. Prawdziwym niebezpieczeństwem jest to, że niewinnie-wyglądające "
"operacje mogą wywoływać dowolny kod w języku pytonowskim który może tego "
"dokonać; istnieje ścieżka kodowa która pozwala aby przebieg wykonania został "
"zwrócony do użytkownika z makropolecenia :cfunc:`Py_DECREF`, tak że prawie "
"każda operacja jest potencjalnie niebezpieczna."

msgid "A safe approach is to always use the generic operations (functions  whose name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or ``PyMapping_``). These operations always increment the reference count of the object they return. This leaves the caller with the responsibility to call :cfunc:`Py_DECREF` when they are done with the result; this soon becomes second nature."
msgstr ""
"Bezpiecznym podejściem jest zawsze używać operacji podstawowych (zadań "
"których nazwy zaczynają się ``PyObject_``, ``PyNumber_``, ``PySequence_`` "
"lub ``PyMapping_``). Te operacje zawsze zwiększają o jeden liczbę odniesień "
"przedmiotu który zwracają. To pozostawia wołającego obarczonego "
"odpowiedzialnością za wywołanie :cfunc:`Py_DECREF` gdy już skończy działać "
"na wyniku; można się do tego przyzwyczaić."

msgid "Reference Count Details"
msgstr "Szczegóły Liczby Odniesień"

msgid "The reference count behavior of functions in the Python/C API is best  explained in terms of *ownership of references*.  Ownership pertains to references, never to objects (objects are not owned: they are always shared).  \"Owning a reference\" means being responsible for calling Py_DECREF on it when the reference is no longer needed.  Ownership can also be transferred, meaning that the code that receives ownership of the reference then becomes responsible for eventually decref'ing it by calling :cfunc:`Py_DECREF` or :cfunc:`Py_XDECREF` when it's no longer needed---or passing on this responsibility (usually to its caller). When a function passes ownership of a reference on to its caller, the caller is said to receive a *new* reference.  When no ownership is transferred, the caller is said to *borrow* the reference. Nothing needs to be done for a borrowed reference."
msgstr ""
"Zachowanie liczby odniesień w zadaniach sprzęgu między językami pytonowskim "
"i języku C najlepiej wyjaśniać w kategoriach *właściciela odniesień*. "
"Własność dotyczy odniesień, nigdy przedmiotów (przedmioty nie mają "
"posiadacza: zamiast tego są współdzielone). \"Posiadanie odniesienia\" oznacza "
"bycie odpowiedzialnym za wezwanie Py_DECREF na nim gdy odniesienie nie jest "
"już więcej potrzebne. Akt własności może być przekazywany, co oznacza że "
"kod który otrzymuje odniesienie na własność staje się odpowiedzialny za "
"ostateczne jego \"zdecrefowanie\" przez wywołanie :cfunc:`Py_DECREF` lub "
":cfunc:`Py_XDECREF`gdy nie jest już więcej potrzebne --- lub przekazanie tej "
"odpowiedzialności (zwykle swojemu wywołującemu). Gdy zadanie przekaże "
"własność odniesienia do swojego wywołującego to zadanie, o wołającym mówi "
"się, że otrzymał *nowe* odniesienie. Gdy żadna własność nie jest "
"przenoszona, o wywołującym mówi się że *pożycza* odniesienie. Nic nie jest "
"wymagane do zrobienia dla pożyczonego odniesienia."

msgid "Conversely, when a calling function passes in a reference to an  object, there are two possibilities: the function *steals* a  reference to the object, or it does not.  *Stealing a reference* means that when you pass a reference to a function, that function assumes that it now owns that reference, and you are not responsible for it any longer."
msgstr ""
"Idąc dalej, gdy wywołujące zadanie przekazuje odniesienie do przedmiotu, "
"istnieją dwie możliwości: zadanie *kradnie* odniesienie do przedmiotu, lub "
"nie kradnie go. *Kradnięcie odniesienia* oznacza, że gdy przekazujesz "
"odniesienie do zadania, to zadanie przyjmuje, że teraz ono posiada "
"odniesienie i nie jesteś za nie odpowiedzialny ani chwili dłużej."

msgid "Few functions steal references; the two notable exceptions are :cfunc:`PyList_SetItem` and :cfunc:`PyTuple_SetItem`, which  steal a reference to the item (but not to the tuple or list into which the item is put!).  These functions were designed to steal a reference because of a common idiom for populating a tuple or list with newly created objects; for example, the code to create the tuple ``(1, 2, \"three\")`` could look like this (forgetting about error handling for the moment; a better way to code this is shown below)::"
msgstr ""
"Niewiele zadań kradnie referencje; dwoma szczególnymi wyjątkami są "
":cfunc:`PyList_SetItem` i :cfunc:`PyTuple_SetItem`, które kradną odniesienie "
"do przedmiotu (ale nie do krotki czy listy do których przedmiot jest "
"wkładany!). Te zadania zostały zaprojektowane tak, aby kraść odniesienie z "
"powodu wspólnego idiomu dla zapełnienia krotki czy listy nowo utworzonymi "
"przedmiotami; na przykład, kod do tworzenia krotki ``(1,2, \"trzy\")`` mógłby "
"wyglądać następująco (pomijając błąd obsługę błędów tymczasowo; lepszy "
"sposób na zakodowanie tego pokazany jest poniżej)::"

msgid "PyObject *t;  t = PyTuple_New(3); PyTuple_SetItem(t, 0, PyLong_FromLong(1L)); PyTuple_SetItem(t, 1, PyLong_FromLong(2L)); PyTuple_SetItem(t, 2, PyString_FromString(\"three\"));"
msgstr ""
"PyObject *t;  t = PyTuple_New(3); PyTuple_SetItem(t, 0, "
"PyLong_FromLong(1L)); PyTuple_SetItem(t, 1, PyLong_FromLong(2L)); "
"PyTuple_SetItem(t, 2, PyString_FromString(\"three\"));"

msgid "Here, :cfunc:`PyLong_FromLong` returns a new reference which is immediately stolen by :cfunc:`PyTuple_SetItem`.  When you want to keep using an object although the reference to it will be stolen, use :cfunc:`Py_INCREF` to grab another reference before calling the reference-stealing function."
msgstr ""
"Tutaj, :cfunc:`PyLong_FromLong` zwraca nowe odniesienie, które jest "
"natychmiast kradzione przez zadanie :cfunc:`PyTuple_SetItem`. Gdy chcesz "
"nadal używać przedmiotu pomimo tego, że odniesienie do niego zostanie "
"skradzione, używaj makropolecenia :cfunc:`Py_INCREF` aby schwycić jeszcze "
"jedno odniesienie przed wywołaniem kradnącego-odniesienia zadania."

msgid "Incidentally, :cfunc:`PyTuple_SetItem` is the *only* way to set tuple items; :cfunc:`PySequence_SetItem` and :cfunc:`PyObject_SetItem` refuse to do this since tuples are an immutable data type.  You should only use :cfunc:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"Przypadkowo zadanie :cfunc:`PyTuple_SetItem` jest *jedynym* sposobem aby "
"ustawiać elementy krotek; Zadania :cfunc:`PySequence_SetItem` i "
":cfunc:`PyObject_SetItem` odmawiają wykonania tego samego działania gdyż "
"krotki są niezmiennym rodzajem danych. Powinieneś używać tylko "
":cfunc:`PyTuple_SetItem` dla krotek, które tworzysz własnoręcznie."

msgid "Equivalent code for populating a list can be written using :cfunc:`PyList_New` and :cfunc:`PyList_SetItem`."
msgstr ""
"Równoważny kod dla zapełnienia listy można napisać używając: zadań "
":cfunc:`PyList_New` i :cfunc:`PyList_SetItem`."

msgid "However, in practice, you will rarely use these ways of creating and populating a tuple or list.  There's a generic function, :cfunc:`Py_BuildValue`, that can create most common objects from C values, directed by a :dfn:`format string`. For example, the above two blocks of code could be replaced by the following (which also takes care of the error checking)::"
msgstr ""
"Jednakże, w praktyce, rzadko używa się tych sposobów tworzenia i zapełniania "
"krotek czy list. Istnieje funkcja prosta :cfunc:`Py_BuildValue`, która może "
"tworzyć większość typowych przedmiotów z wartości zapisanych w języku C, "
"określona przez :dfn:`ciąg formatu`. Na przykład, powyższe dwa fragmenty "
"kodu mogłyby być zastąpione przez następujący (który także zajmuje się "
"sprawdzaniem błędów)::"

msgid "PyObject *tuple, *list;  tuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\"); list = Py_BuildValue(\"[iis]\", 1, 2, \"three\");"
msgstr ""
"PyObject *krotka, *lista;  krotka = Py_BuildValue(\"(iis)\", 1, 2, \"trzy\"); "
"lista = Py_BuildValue(\"[iis]\", 1, 2, \"trzy\");"

msgid "It is much more common to use :cfunc:`PyObject_SetItem` and friends with items whose references you are only borrowing, like arguments that were passed in to the function you are writing.  In that case, their behaviour regarding reference counts is much saner, since you don't have to increment a reference count so you can give a reference away (\"have it be stolen\").  For example, this function sets all items of a list (actually, any mutable sequence) to a given item::"
msgstr ""
"Dużo częściej spotyka się użycie zadania :cfunc:`PyObject_SetItem` i "
"zaprzyjaźnionych z elementami których odniesienia tylko się pożycza, jak "
"parametrów, które zostały przekazane do funkcji którą piszesz. W takim "
"przypadku, ich zachowanie w stosunku do liczb odniesień jest dużo zdrowsze, "
"gdyż nie musisz zwiększać liczby odniesień, kiedy chcesz oddać odniesienie "
"(\"pozwolić aby zostało ukradzione\"). Na przykład, to zadanie ustawia "
"wszystkie elementy listy (właściwie dowolnej zmiennej sekwencji) na dany "
"element::"

msgid "int set_all(PyObject *target, PyObject *item) {     int i, n;      n = PyObject_Length(target);     if (n < 0)         return -1;     for (i = 0; i < n; i++) {         PyObject *index = PyLong_FromLong(i);         if (!index)             return -1;         if (PyObject_SetItem(target, index, item) < 0)             return -1;         Py_DECREF(index);     }     return 0; }"
msgstr ""
"int ustaw_wszystkie(PyObject *cel, PyObject *element) {     int i, n;      n "
"= PyObject_Length(cel);     if (n < 0)         return -1;     for (i = 0; i "
"< n; i++) {         PyObject *nr = PyLong_FromLong(i);         if (!nr) "
"            return -1;         if (PyObject_SetItem(cel, nr, element) < 0) "
"            return -1;         Py_DECREF(nr);     }     return 0; }"

msgid "The situation is slightly different for function return values.   While passing a reference to most functions does not change your  ownership responsibilities for that reference, many functions that  return a reference to an object give you ownership of the reference. The reason is simple: in many cases, the returned object is created  on the fly, and the reference you get is the only reference to the  object.  Therefore, the generic functions that return object references, like :cfunc:`PyObject_GetItem` and  :cfunc:`PySequence_GetItem`, always return a new reference (the caller becomes the owner of the reference)."
msgstr ""
"Sytuacja jest trochę inna dla wartości zwracanych z zadania. Podczas gdy "
"przekazywanie odniesienia do większości zadań nie zmienia twojego "
"odpowiedzialności właścicielskiej za to odniesienie, wiele zadań, które "
"zwracają odniesienie do przedmiotu daje też odniesienie do tego przedmiotu "
"na własność. Powód jest prosty: w wielu przypadkach przedmiot zwracany "
"tworzony jest w locie i odniesienie które dostajesz jest jedynym "
"odniesieniem do tego obiektu. Zatem proste zadania które zwracają "
"odniesienia do przedmiotów, jak :cfunc:`PyObject_GetItem` i "
":cfunc:`PySequence_GetItem`, zawsze zwracają nowe odniesienia (wywoływujący "
"zadanie staje się właścicielem odniesienia)."

msgid "It is important to realize that whether you own a reference returned  by a function depends on which function you call only --- *the plumage* (the type of the object passed as an argument to the function) *doesn't enter into it!* Thus, if you  extract an item from a list using :cfunc:`PyList_GetItem`, you don't own the reference --- but if you obtain the same item from the same list using :cfunc:`PySequence_GetItem` (which happens to take exactly the same arguments), you do own a reference to the returned object."
msgstr ""
"Jest istotne zdać sobie sprawę, że to, czy posiadasz odniesienie zwrócone "
"przez zadanie, zależy tylko od tego, które zadanie wywołasz --- *pakuły* "
"(przedmioty przekazywane jako parametry zadania) *nie odnoszą się do tego!* "
"Zatem, jeśli wyjmiesz element z listy używając :cfunc:`PyList_GetItem`, nie "
"posiądziesz odniesienia --- ale jeśli otrzymasz ten sam element z tej samej "
"listy korzystając z :cfunc:`PySequence_GetItem` (które przyjmuje dokładnie "
"te same parametry), posiadasz odniesienie do zwróconego przedmiotu."

msgid "Here is an example of how you could write a function that computes the sum of the items in a list of integers; once using  :cfunc:`PyList_GetItem`, and once using :cfunc:`PySequence_GetItem`. ::"
msgstr ""
"Tutaj jest przykład tego, jak można zapisać zadanie, które oblicza sumę "
"wszystkich elementów na liście liczb całkowitych; raz przy użyciu "
":cfunc:`PyList_GetItem`, a raz przy użyciu :cfunc:`PySequence_GetItem`"

msgid "long sum_list(PyObject *list) {     int i, n;     long total = 0;     PyObject *item;      n = PyList_Size(list);     if (n < 0)         return -1; /* Not a list */     for (i = 0; i < n; i++) {         item = PyList_GetItem(list, i); /* Can't fail */         if (!PyLong_Check(item)) continue; /* Skip non-integers */         total += PyLong_AsLong(item);     }     return total; }"
msgstr ""
"long sumuj_liste(PyObject *lista) {     int i, n;     long suma = 0;     "
"PyObject *element;      n = PyList_Size(lista);     if (n < 0)         "
"return -1; /* To nie lista */     for (i = 0; i < n; i++) {         element "
"= PyList_GetItem(lista, i); /* Nie może zawieźć */         if "
"(!PyLong_Check(element)) continue; /* Pomiń nie będące całkowitymi liczbami "
"*/         suma += PyLong_AsLong(element);     }     return suma; }"

msgid "long sum_sequence(PyObject *sequence) {     int i, n;     long total = 0;     PyObject *item;     n = PySequence_Length(sequence);     if (n < 0)         return -1; /* Has no length */     for (i = 0; i < n; i++) {         item = PySequence_GetItem(sequence, i);         if (item == NULL)             return -1; /* Not a sequence, or other failure */         if (PyLong_Check(item))             total += PyLong_AsLong(item);         Py_DECREF(item); /* Discard reference ownership */     }     return total; }"
msgstr ""
"long sumuj_sekwencje(PyObject *sekwencja) {     int i, n;     long suma = 0; "
"    PyObject *element;     n = PySequence_Length(sekwencja);     if (n < 0) "
"        return -1; /* Nie ma długości */     for (i = 0; i < n; i++) { "
"        element = PySequence_GetItem(sekwencja, i);         if (element == "
"NULL)             return -1; /* To nie sekwencja, lub inny błąd */         "
"if (PyLong_Check(element))             suma += PyLong_AsLong(element); "
"        Py_DECREF(element); /* Odrzuć własność odniesień */     }     "
"return suma; }"

msgid "Types"
msgstr "Typy"

msgid "There are few other data types that play a significant role in  the Python/C API; most are simple C types such as :ctype:`int`,  :ctype:`long`, :ctype:`double` and :ctype:`char\\*`.  A few structure types  are used to describe static tables used to list the functions exported  by a module or the data attributes of a new object type, and another is used to describe the value of a complex number.  These will  be discussed together with the functions that use them."
msgstr ""
"Istnieje kilka innych typów danych które pełnią ważną rolę w sprzęgu "
"pomiędzy językami pytonowskim i C (API); większość jest prostymi typami "
"języka C takimi jak :ctype:`int`, :ctype:`long`, :ctype:`double`, "
":ctype`char\\*`. Kilka typów struktur jest używanych do opisania statycznych "
"tabel używanych do wypisywania zadań wystawianych na zewnątrz modułu lub "
"własności danych nowych rodzajów przedmiotów, a inne używane są do opisania "
"wartości liczby zespolonej. Te będą opisane razem z zadaniami, które ich "
"używają."

msgid "Exceptions"
msgstr "Sytuacje Wyjątkowe"

msgid "The Python programmer only needs to deal with exceptions if specific  error handling is required; unhandled exceptions are automatically  propagated to the caller, then to the caller's caller, and so on, until they reach the top-level interpreter, where they are reported to the  user accompanied by a stack traceback."
msgstr ""
"Programujący komputer w języku pytonowskim musi sobie zaprzątać głowę tylko "
"sytuacjami wyjątkowymi tylko jeśli szczególna obsługa błędów jest konieczna; "
"Nieobsłużone wyjątki są automatycznie przesyłane do zadania wywołującego, "
"potem do zadania które wywołało tamto zadanie, i tak dalej, dopóki nie "
"natrafi na program interpretujący najwyższego poziomu, gdzie są przekazywane "
"użytkownikowi wraz z wypisem kolejnych wywołań odłożonych na stercie."

msgid "For C programmers, however, error checking always has to be explicit.   All functions in the Python/C API can raise exceptions, unless an  explicit claim is made otherwise in a function's documentation.  In  general, when a function encounters an error, it sets an exception,  discards any object references that it owns, and returns an  error indicator --- usually *NULL* or ``-1``.  A few functions  return a Boolean true/false result, with false indicating an error. Very few functions return no explicit error indicator or have an  ambiguous return value, and require explicit testing for errors with :cfunc:`PyErr_Occurred`."
msgstr ""
"Dla programujących w języku C, jednakże, sprawdzanie błędów, zawsze musi być "
"jawne. Wszystkie zadania w sprzęgu między językami pytonowskim a C mogą "
"zgłaszać sytuacje wyjątkowe, chyba że jawne założenie zostało poczynione o "
"innym brzmieniu w dokumentacji zadania. Zasadniczo jeśli zadanie napotka "
"błąd, ustawia sytuację wyjątkową, odrzuca wszystkie odniesienia do "
"przedmiotów które posiada i zwraca wskaźnik błędu --- zwykle *NULL* lub "
"``-1``. Kilka zadań zwraca prawdę/fałsz jako wynik, z fałszem wskazującym "
"błąd. Bardzo mało zadań nie zwraca żadnych jawnych wskazań błędu, czy ma "
"dwuznaczną wartość zwracaną i wymaga jawnego sprawdzenia błędów przy użyciu "
":cfunc:`PyErr_Occurred`."

msgid "Exception state is maintained in per-thread storage (this is  equivalent to using global storage in an unthreaded application).  A  thread can be in one of two states: an exception has occurred, or not. The function :cfunc:`PyErr_Occurred` can be used to check for this: it returns a borrowed reference to the exception type object when an exception has occurred, and *NULL* otherwise.  There are a number of functions to set the exception state: :cfunc:`PyErr_SetString` is the most common (though not the most general) function to set the exception state, and :cfunc:`PyErr_Clear` clears the exception state."
msgstr ""
"Stan wyjątku jest utrzymywany w przestrzeni przydzielonej wątkowi (jest to "
"równoważne użyciu nadrzędnego miejsca przechowania w programie pozbawionym "
"wątków). Wątek może być w jednym z dwu stanów: gdy wyjątek nastąpił, lub "
"nie. Zadanie :cfunc:`PyErr_Occurred` może być użyty aby to sprawdzić: zwraca "
"on pożyczone odniesienie do przedmiotu rodzaju błędu gdy sytuacja wyjątkowa "
"nastąpiła, i *NULL* w przeciwnym razie. Istnieje parę zadań ustawiających "
"stan wyjątku: :cfunc:`PyErr_SetString` jest najczęstszym (chociaż nie "
"najogólniejszym) zadaniem ustalającym stan wyjątku, a zadanie "
":cfunc:`PyErr_Clear` czyści stan wyjątku."

msgid "The full exception state consists of three objects (all of which can  be *NULL*): the exception type, the corresponding exception  value, and the traceback.  These have the same meanings as the Python result of ``sys.exc_info()``; however, they are not the same: the Python objects represent the last exception being handled by a Python  :keyword:`try` ... :keyword:`except` statement, while the C level exception state only exists while an exception is being passed on between C functions until it reaches the Python bytecode interpreter's  main loop, which takes care of transferring it to ``sys.exc_info()`` and friends."
msgstr ""
"Pełen stan wyjątku obejmuje trzy przedmioty (z których wszystkie mogą być "
"*NULL*): rodzaj wyjątku, odpowiadająca mu wartość wyjątku, i przebieg "
"wykonania. Te mają te same znaczenia, jak wynik wywołania "
"``sys.exc_info()``; jednakże nie są one tożsame: przedmioty języka "
"pytonowskiego reprezentują ostatni wyjątek obsłużone przez wyrażenie języka "
"pytonowskiego :keyword:`try` ... :keyword:`except`, podczas gdy stan wyjątku "
"poziomu języka C istnieje tylko podczas przekazywania wyjątku pomiędzy "
"zadaniami języka C dopóki nie natrafi na kod kęsowy głównej pętli programu "
"interpretującego polecenia języka pytonowskiego, który zajmuje się "
"przenoszeniem wyjątku do ``sys.exc_info()`` i zaprzyjaźnionych."

msgid "Note that starting with Python 1.5, the preferred, thread-safe way to access the exception state from Python code is to call the function :func:`sys.exc_info`, which returns the per-thread exception state for Python code.  Also, the semantics of both ways to access the exception state have changed so that a function which catches an exception will save and restore its thread's exception state so as to preserve the exception state of its caller.  This prevents common bugs in exception handling code caused by an innocent-looking function overwriting the exception being handled; it also reduces the often unwanted lifetime extension for objects that are referenced by the stack frames in the traceback."
msgstr ""
"Zauważ że poczynając od języka pytonowskiego w wersji 1.5 preferowaną, "
"bezpiecznym dla wątków sposobem na dostęp do stanu wyjątku z poziomu kodu "
"napisanego w języku pytonowskim jest wezwanie zadania :func:`sys.exc_info`, "
"które zwraca określony-dla-wątku stan wyjątku dla kodu napisanego w języku "
"pytonowskim. Poza tym składnia obu sposobów na dostęp do stanu sytuacji "
"wyjątkowej zmieniła się tak, że zadanie które złapie wyjątek zachowa i "
"przywróci swój stan wyjątku tak, aby zachować stan wyjątku wywołujacego "
"zadanie. To działanie zapobiega typowym błędom w obsłudze sytuacji "
"wyjątkowych powodowanych przez niewinnie-wyglądające zadania nadpisujące "
"sytuacje wyjątkowe które aktualnie są obsługiwane; to także redukuje często "
"niechciane wydłużanie czasu życia przedmiotów do których odnosi się ramka "
"stosu w wypisie śladu wywołań."

msgid "As a general principle, a function that calls another function to  perform some task should check whether the called function raised an  exception, and if so, pass the exception state on to its caller.  It  should discard any object references that it owns, and return an  error indicator, but it should *not* set another exception --- that would overwrite the exception that was just raised, and lose important information about the exact cause of the error."
msgstr ""
"Jako nadrzędną zasadę, przyjmuje się że zadanie które wywołuje inne zadanie "
"do wykonania pewnych operacji powinno sprawdzić czy wywołane zadanie "
"zgłosiło wyjątek, a jeśli tak, to przekazać stan wyjątku do wywołującego. "
"Powinno też odrzucić jakiekolwiek odniesienia do przedmiotów, które posiada, "
"i zwrócić sygnalizator błędu, ale nie powinno ustawiać innego wyjątku --- "
"który nadpisywałby wyjątek, który właśnie został zgłoszony i tracić istotne "
"informacje o dokładnym powodzie błędu."

msgid "A simple example of detecting exceptions and passing them on is shown in the :cfunc:`sum_sequence` example above.  It so happens that that example doesn't need to clean up any owned references when it detects an error.  The following example function shows some error cleanup.  First, to remind you why you like Python, we show the equivalent Python code::"
msgstr ""
"Prosty przykład wykrywania wyjątków i przykazywania ich jest pokazany w "
"powyższym przykładzie :cfunc:`suma_sekwencji`. Tak się składa że w tym "
"przykładzie nie ma potrzeby czyszczenia żadnych posiadanych odniesień gdy "
"wykryje błąd. Następujące przykładowe zadanie pokazuje pewne sprzątanie po "
"błędach. Wpierw, aby przypomnieć dlaczego lubić można język pytonowski, "
"pokazujemy odpowiadający kod w języku pytonowskim::"

msgid "def incr_item(dict, key):     try:         item = dict[key]     except KeyError:         item = 0     dict[key] = item + 1"
msgstr ""
"def zwieksz_element(slownik, klucz):     try:         element = "
"slownik[klucz]     except KeyError:         element = 0     slownik[klucz] = "
"element + 1"

msgid "Here is the corresponding C code, in all its glory::"
msgstr "Tu następuje odpowiadający kod w języku C, w całej pełni okazałości::"

msgid "int incr_item(PyObject *dict, PyObject *key) {     /* Objects all initialized to NULL for Py_XDECREF */     PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;     int rv = -1; /* Return value initialized to -1 (failure) */      item = PyObject_GetItem(dict, key);     if (item == NULL) {         /* Handle KeyError only: */         if (!PyErr_ExceptionMatches(PyExc_KeyError))             goto error;          /* Clear the error and use zero: */         PyErr_Clear();         item = PyLong_FromLong(0L);         if (item == NULL)             goto error;     }     const_one = PyLong_FromLong(1L);     if (const_one == NULL)         goto error;      incremented_item = PyNumber_Add(item, const_one);     if (incremented_item == NULL)         goto error;      if (PyObject_SetItem(dict, key, incremented_item) < 0)         goto error;     rv = 0; /* Success */     /* Continue with cleanup code */   error:     /* Cleanup code, shared by success and failure path */      /* Use Py_XDECREF() to ignore NULL references */     Py_XDECREF(item);     Py_XDECREF(const_one);     Py_XDECREF(incremented_item);      return rv; /* -1 for error, 0 for success */ }"
msgstr ""
"int zwieksz_element(PyObject *slownik, PyObject *klucz) {     /* Wszystkie "
"przedmioty ustawione pierwotnie na NULL dla Py_XDECREF */     PyObject "
"*element = NULL, *staly_jeden = NULL, *zwiekszany_element = NULL;     int "
"wzw = -1; /* Wartość zwracana ustawiona początkowo na -1 (błąd) */      "
"element = PyObject_GetItem(slownik, klucz);     if (element == NULL) { "
"        /* Obsłuż tylko wyjątek KeyError: */         if "
"(!PyErr_ExceptionMatches(PyExc_KeyError))             goto blad;          /* "
"Wytrzyj błąd i użyj zera: */         PyErr_Clear();         element = "
"PyLong_FromLong(0L);         if (element == NULL)             goto blad; "
"    }     staly_jeden = PyLong_FromLong(1L);     if (staly_jeden == NULL) "
"        goto blad;      zwiekszany_element = PyNumber_Add(element, "
"staly_jeden);     if (zwiekszany_element == NULL)         goto blad;      if "
"(PyObject_SetItem(slownik, klucz, zwiekszany_element) < 0)         goto "
"blad;     wzw = 0; /* Sukces */     /* Kontynuuj ze sprzątaniem po kodzie */ "
"  blad:     /* Sprzątanie, współdzielone przez ścieżki błędu i sukcesu */ "
"     /* Używaj Py_XDECREF() aby zignorować NULL odniesienia */     "
"Py_XDECREF(element);     Py_XDECREF(staly_jeden);     "
"Py_XDECREF(zwiekszany_element);      return wzw; /* -1 dla błędu, 0 for "
"sukcesu */ }"

msgid "This example represents an endorsed use of the ``goto`` statement  in C! It illustrates the use of :cfunc:`PyErr_ExceptionMatches` and :cfunc:`PyErr_Clear` to handle specific exceptions, and the use of :cfunc:`Py_XDECREF` to dispose of owned references that may be *NULL* (note the ``'X'`` in the name; :cfunc:`Py_DECREF` would crash when confronted with a *NULL* reference).  It is important that the variables used to hold owned references are initialized to *NULL* for this to work; likewise, the proposed return value is initialized to ``-1`` (failure) and only set to success after the final call made is successful."
msgstr ""
"Ten przykład pokazuje przyjęte użycie wyrażenia idzdo - z ang. - ``goto`` w "
"C! Pokazuje ono użycie :cfunc:`PyErr_ExceptionMatches` i "
":cfunc:`PyErr_Clear` do obsługi szczególnych wyjątków, i użycie "
":cfunc:`Py_XDECREF` do posprzątania po posiadanych odniesieniach, które mogą "
"być *NULL* (zwróć uwagę na ``'X'`` w nazwie; :cfunc:`Py_DECREF wyłożyłby "
"się w konfrontacji z *pustym* - *NULL* odniesieniem). Jest istotne, że "
"zmienne użyte do trzymania własnych odniesień są zainicjowane *NULL* aby "
"mogło to zadziałać; podobnie, proponowana wartość zwracana jest inicjowana "
"na ``-1`` (błąd) i ustawiana na sukces tylko gdy ostatnie wywołanie zakończy "
"się sukcesem."

msgid "Embedding Python"
msgstr "Załączanie programu interpretującego język pytonowski"

msgid "The one important task that only embedders (as opposed to extension writers) of the Python interpreter have to worry about is the initialization, and possibly the finalization, of the Python interpreter.  Most functionality of the interpreter can only be used after the interpreter has been initialized."
msgstr ""
"Jedno istotne zadanie, o które załączający (w przeciwieństwie do piszących "
"rozszerzenia) program interpretujący język pytonowski muszą się martwić jest "
"zainicjowanie i prawdopodobne zakończenie programu interpretującego "
"polecenia języka pytonowskiego. Większość użyteczności programu "
"interpretującego polecenia języka pytonowskiego może tylko być użyta po jego "
"zainicjowaniu."

msgid "The basic initialization function is :cfunc:`Py_Initialize`. This initializes the table of loaded modules, and creates the fundamental modules :mod:`builtins`, :mod:`__main__`, :mod:`sys`, and :mod:`exceptions`.  It also initializes the module search path (``sys.path``)."
msgstr ""
"podstawowym poleceniem inicjującym jest :cfunc:`Py_Initialize`. To inicjuje "
"tabelę załadowanych modułów, i tworzy podstawowe moduły wbudowane - "
":mod:`builtins`, nadrzędny - :mod:`__main__`, i systemowy - :mod:`sys`, i "
"moduł wyjątków - :mod:`exceptions`. Inicjuje także ścieżkę poszukiwania "
"modułów - (``sys.path``)."

msgid ":cfunc:`Py_Initialize` does not set the \"script argument list\"  (``sys.argv``). If this variable is needed by Python code that will be executed later, it must be set explicitly with a call to  ``PySys_SetArgvEx(argc, argv, updatepath)`` after the call to :cfunc:`Py_Initialize`."
msgstr ""
":cfunc:`Py_Initialize` nie ustawia \"listy parametrów skryptu\" "
"(``sys.argv``). Jeśli ta zmienna jest wymagana przez kod języka "
"pytonowskiego który ma być wykonany później, musi być ustalony jawnie przez "
"wywołanie ``PySys_SetArgvEx(argc, argv, updatepath)`` po odwołaniu do "
":cfunc:`Py_Initialize`."

msgid "On most systems (in particular, on Unix and Windows, although the details are slightly different), :cfunc:`Py_Initialize` calculates the module search path based upon its best guess for the location of the standard Python interpreter executable, assuming that the Python library is found in a fixed location relative to the Python interpreter executable.  In particular, it looks for a directory named :file:`lib/python{X.Y}` relative to the parent directory where the executable named :file:`python` is found on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"Na większości systemów (w szczególności w Unixie i Windowsie, chociaż "
"szczegóły są w niewielkim stopniu różne), zadanie :cfunc:`Py_Initialize` "
"oblicza ścieżkę poszukiwania modułów w oparciu o najlepsze zgadywanie dla "
"położenia najlepszego pliku wykonywalnego programu interpretującego język "
"pytonowski, zakładając że biblioteka języka pytonowskiego znajduje się w "
"ustalonym położeniu względem pliku wykonywalnego programu interpretującego "
"polecenia języka pytonowskiego. W szczególności, poszukuje katalogu "
"nazwanego :file:`lib/python{X.Y}` w odniesieniu do katalogu nadrzędnego "
"gdzie plik wykonywalny nazwany :file:`python` znajduje się na ścieżce "
"poszukiwań poleceń powłoki (w zmiennej środowiskowej :envvar:`PATH`)."

msgid "For instance, if the Python executable is found in :file:`/usr/local/bin/python`, it will assume that the libraries are in :file:`/usr/local/lib/python{X.Y}`.  (In fact, this particular path is also the \"fallback\" location, used when no executable file named :file:`python` is found along :envvar:`PATH`.)  The user can override this behavior by setting the environment variable :envvar:`PYTHONHOME`, or insert additional directories in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"Na przykład, jeśli plik wykonywalny programu interpretującego polecenia "
"języka pytonowskiego znajduje się w katalogu :file:`/usr/local/bin/python`, "
"będzie zakładał, że biblioteki są w katalogu "
":file:`/usr/local/lib/python{X.Y}` (Faktycznie, ta szczególna ścieżka jest "
"także \"ratunkowym\" położeniem, używanym gdy żaden plik wykonywalny nazwany "
":file:`python` nie znajdzie się w katalogach znajdujących się w zmiennej "
"środowiskowej :envvar:`PATH`.) Użytkownik może podmienić to zachowanie przez "
"ustawienie zmiennej środowiskowej :envvar:`PYTHONHOME`, lub wstawić "
"dodatkowe katalogi przed sztandarową ścieżką przez ustawienie zmiennej "
"środowiskowej :envvar:`PYTHONPATH`."

msgid "The embedding application can steer the search by calling ``Py_SetProgramName(file)`` *before* calling  :cfunc:`Py_Initialize`.  Note that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` is still inserted in front of the standard path.  An application that requires total control has to provide its own implementation of :cfunc:`Py_GetPath`, :cfunc:`Py_GetPrefix`, :cfunc:`Py_GetExecPrefix`, and :cfunc:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr ""
"Załącczająca  aplikacja może wysterować ścieżkę poszukiwania przez wywołanie "
"``Py_SetProgramName(file)`` *przed* wywołaniem :cfunc:`Py_Initialize`. "
"Zauważ że ścieżka :envvar:`PYTHONHOME` wciąż wyprzedza to ustalenie zaś "
":envvar:`PYTHONPATH` wciąż jest wstawiane przed standardową ścieżką dostępu. "
"Aplikacja która wymaga całkowitej kontroli potrzebowałaby swojej własnej "
"interpretacji zadań :cfunc:`Py_GetPath`, :cfunc:`Py_GetPrefix`, "
":cfunc:`Py_GetExecPrefix`, i :cfunc:`Py_GetProgramFullPath` (wszystkie "
"zdefiniowane w pliku :file:`Modules/getpath.c`)."

msgid "Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the application may want to start over (make another call to :cfunc:`Py_Initialize`) or the application is simply done with its  use of Python and wants to free memory allocated by Python.  This can be accomplished by calling :cfunc:`Py_Finalize`.  The function :cfunc:`Py_IsInitialized` returns true if Python is currently in the initialized state.  More information about these functions is given in a later chapter. Notice that :cfunc:`Py_Finalize` does *not* free all memory allocated by the Python interpreter, e.g. memory allocated by extension modules currently cannot be released."
msgstr ""
"Czasami jest wymagane aby \"odinicjować\" środowisko języka pytonowskiego. Dla "
"przykładu gdy aplikacja ma potrzebę zrestartować (wykonać jeszcze jedno "
"wywołanie zadania :cfunc:`Py_Initialize`) lub aplikacja jest po prostu "
"zrobiona z użyciem języka pytonowskiego i chciałaby zwolnić pamięć "
"przydzieloną programowi interpretującemu polecenia języka pytonowskiego. "
"Można tego dokonać przez wezwanie :cfunc:`Py_Finalize`. Zadanie "
":cfunc:`Py_IsInitialized` zwraca prawdę jeśli program wykonujący polecenia "
"języka pytonowskiego jest aktualnie w zainicjowanym stanie. Więcej "
"informacji o tych zadaniach jest dostępna w późniejszym rozdziale. Zauważ, "
"że zadanie :cfunc:`Py_Finalize` *nie* uwalnia całej pamięci przydzielonej "
"przez program interpretujący polecenia języka pytonowskiego, np. pamięci "
"przydzielonej przez moduły rozszerzające aktualnie nie mogą być uwalniane."

msgid "Debugging Builds"
msgstr "Odpluskwiające Budowy"

msgid "Python can be built with several macros to enable extra checks of the interpreter and extension modules.  These checks tend to add a large amount of overhead to the runtime so they are not enabled by default."
msgstr ""
"Program interpretujący język pytonowski może być zbudowany z kilkoma "
"makropoleceniami do załączenia dodatkowych sprawdzeń programu "
"interpretującego polecenia języka pytonowskiego i modułów rozszerzających. "
"Te sprawdzenia mają zwyczaj dodawać duży narzut czasu wykonania poleceń "
"programu więc nie są załączane domyślnie."

msgid "A full list of the various types of debugging builds is in the file :file:`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are available that support tracing of reference counts, debugging the memory allocator, or low-level profiling of the main interpreter loop.  Only the most frequently-used builds will be described in the remainder of this section."
msgstr ""
"Pełną listę różnego rodzaju budów odpluskwiania znajduje się w pliku "
":file:`Misc/SpecialBuilds.txt` w źródłowych zasobach pakietu języka "
"pytonowskiego. Są dostępne budowy ze wsparciem wypisywania przebiegów liczb "
"odniesień, lub profilowania nisko-poziomowego głównej pętli programu "
"interpretującego polecenia języka pytonowskiego. Tylko najczęściej używane "
"budowy będą opisane w dalszej części tej sekcji."

msgid "Compiling the interpreter with the :cmacro:`Py_DEBUG` macro defined produces what is generally meant by \"a debug build\" of Python. :cmacro:`Py_DEBUG` is enabled in the Unix build by adding :option:`--with-pydebug` to the :file:`configure` command.  It is also implied by the presence of the not-Python-specific :cmacro:`_DEBUG` macro.  When :cmacro:`Py_DEBUG` is enabled in the Unix build, compiler optimization is disabled."
msgstr ""
"Kompilowanie programu interpretującego polecenia języka pytonowskiego z "
"makrodefinicją :cmacro:`Py_DEBUG` określoną daje to co potocznie zwane jest "
"\"budową odpluskwiającą\" języka pytonowskiego. Makrodefinicja "
":cmacro:`Py_DEBUG` włączana jest w budowie Unixowej przez dodanie opcji "
":option:`--with-pydebug` do pliku skryptu :file:`configure` - komendy "
"konfiguracji. Jest to także niejawnie sugerowane przez obecność nie-typowej-"
"dla-języka-pytonowskiego makrodefinicji :cmacro:`_DEBUG`. Gdy makrodefinicja "
":cmacro:`Py_DEBUG` jest załączona w budowie Unixowej, optymalizacja "
"kompilacji jest wyłączana."

msgid "In addition to the reference count debugging described below, the following extra checks are performed:"
msgstr ""
"W uzupełnieniu odpluskwiania opartego o zliczanie odniesień opisanego "
"poniżej, następujące dodatkowe sprawdzenia są wykonywane:"

msgid "Extra checks are added to the object allocator."
msgstr ""
"Dodatkowe sprawdzenia są dodawane do przedmiotu lokującego inne przedmioty w "
"pamięci."

msgid "Extra checks are added to the parser and compiler."
msgstr ""
"Dodatkowe sprawdzenia są dodawane do przedmiotu wczytującego i "
"kompilującego."

msgid "Downcasts from wide types to narrow types are checked for loss of information."
msgstr ""
"Rzutowania w dół z szerokich do wąskich typów są sprawdzane pod kątem utraty "
"informacji."

msgid "A number of assertions are added to the dictionary and set implementations. In addition, the set object acquires a :meth:`test_c_api` method."
msgstr ""
"Pewna ilość ustaleń twierdzących jest dodawana do realizacji słownika i "
"zbioru. W dodatku przedmiot zbioru otrzymuje sposób postępowania zwany pod "
"nazwą :meth:`test_c_api`."

msgid "Sanity checks of the input arguments are added to frame creation."
msgstr ""
"Sprawdzenia przytomności parametrów wejściowych dodawane są do kreacji "
"ramki."

msgid "The storage for ints is initialized with a known invalid pattern to catch reference to uninitialized digits."
msgstr ""
"Przechowalnia przedmiotów liczb całkowitych z ang. - ints jest inicjowana ze "
"znanym błędnym wzorem do wyłapania odniesień do niezainicjowanych cyfr."

msgid "Low-level tracing and extra exception checking are added to the runtime virtual machine."
msgstr ""
"Niskopoziomowe śledzenie i dodatkowe sprawdzanie błędów dodawane jest do "
"kodu wykonywalnego wirtualnej maszyny."

msgid "Extra checks are added to the memory arena implementation."
msgstr "Dodatkowe sprawdzenia dodawane są do implementacji areny pamięci."

msgid "Extra debugging is added to the thread module."
msgstr "Dodatkowe odpluskwianie dodawane jest do modułu wątków."

msgid "There may be additional checks not mentioned here."
msgstr "Mogą istnieć dodatkowe sprawdzenia nie wymienione tutaj."

msgid "Defining :cmacro:`Py_TRACE_REFS` enables reference tracing.  When defined, a circular doubly linked list of active objects is maintained by adding two extra fields to every :ctype:`PyObject`.  Total allocations are tracked as well.  Upon exit, all existing references are printed.  (In interactive mode this happens after every statement run by the interpreter.)  Implied by :cmacro:`Py_DEBUG`."
msgstr ""
"Definiowanie makrodefinicji :cmacro:`Py_TRACE_REFS` włącza śledzenie "
"odniesień. Gdy definicja jest włączona, cykliczna podwójnie powiązana lista "
"aktywnych przedmiotów jest utrzymywana przez dodanie dwóch dodatkowych pól "
"do każdego przedmiotu :ctype:`PyObject`. Suma przydzielonego miejsca jest "
"również śledzona. W momencie wyjścia, wszystkie istniejące odniesienia są "
"wypisywane. (W trybie współpracy człowieka z komputerem to następuje po "
"każdym poleceniu wykonanym przez program interpretujący polecenia języka "
"pytonowskiego.) Dorozumiane po napotkaniu makrodefinicji :cmacro:`Py_DEBUG`."

msgid "Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source distribution for more detailed information."
msgstr ""
"Odwołaj się do :file:`Misc/SpecialBuilds.txt` w źródłowym pakiecie języka "
"pytonowskiego po więcej szczegółów."

msgid "Iterator Protocol"
msgstr "Protokół przedmiotów iterujących."

msgid "There are only a couple of functions specifically for working with iterators."
msgstr ""
"Istnieje tylko kilka zadań szczególnie przeznaczonych do pracy z "
"przedmiotami iterującymi."

msgid "To write a loop which iterates over an iterator, the C code should look something like this::"
msgstr ""
"Aby napisać pętlę iterującą ponad przedmiotem iterującym, kod C powinien "
"wyglądać mniej więcej tak::"

msgid "PyObject *iterator = PyObject_GetIter(obj); PyObject *item;  if (iterator == NULL) {     /* propagate error */ }  while (item = PyIter_Next(iterator)) {     /* do something with item */     ...     /* release reference when done */     Py_DECREF(item); }  Py_DECREF(iterator);  if (PyErr_Occurred()) {     /* propagate error */ } else {     /* continue doing useful work */ }"
msgstr ""
"PyObject *iterator = PyObject_GetIter(przedm); PyObject *element;  if "
"(iterator == NULL) {     /* propaguj błąd */ }  while (element = "
"PyIter_Next(iterator)) {     /* zrób coś z elementem */     ...     /* "
"zwolnij odniesienie gdy skończysz */     Py_DECREF(element); }  "
"Py_DECREF(iterator);  if (PyErr_Occurred()) {     /* propaguj błąd */ } else "
"{     /* dalej rób coś porzytecznego */ }"

msgid "Iterator Objects"
msgstr "Przedmioty Iterujące"

msgid "Python provides two general-purpose iterator objects.  The first, a sequence iterator, works with an arbitrary sequence supporting the :meth:`__getitem__` method.  The second works with a callable object and a sentinel value, calling the callable for each item in the sequence, and ending the iteration when the sentinel value is returned."
msgstr ""
"Język pytonowski dostarcza dwa ogólnego użytku przedmioty iterujące. "
"Pierwszy przedmiot iterujący po sekwencji, współpracuje z dowolną sekwencją "
"wspierającą sposób działania :meth:`__getitem__`. Drugi współpracuje z "
"przedmiotami reagującymi na wywołanie i flagą-bezpiecznikiem, wywołując "
"przedmiot reagujący na wywołanie dla każdego elementu sekwencji, i kończąc "
"iteracje po otrzymaniu powrotnej flagi-bezpiecznika."

msgid "List Objects"
msgstr "Przedmioty list"

msgid "Integer Objects"
msgstr "Przedmioty liczb całkowitych"

msgid "All integers are implemented as \"long\" integer objects of arbitrary size."
msgstr ""
"Wszystkie liczby całkowite są realizowane jako przedmioty liczb całkowitych "
"\"długich\" o określonym rozmiarze. "

msgid "Mapping Protocol"
msgstr "Protokół mapowania"

msgid "Data marshalling support"
msgstr "Wsparcie dla marszruty danych."

msgid "These routines allow C code to work with serialized objects using the same data format as the :mod:`marshal` module.  There are functions to write data into the serialization format, and additional functions that can be used to read the data back.  Files used to store marshalled data must be opened in binary mode."
msgstr ""
"Te utarte sposoby postępowania pozwalają kodowi C działać z przedmiotami "
"serializowanymi przy użyciu tych samych formatów danych jak moduł "
":mod:`marshal`a. Istnieją zadania do wpisywania danych do formatów "
"serializowalnych, i dodatkowe zadania, które mogą być używane do odczytania "
"danych otrzymanych tą drogą. Pliki używane do przechowywania marszrutowanych "
"danych muszą być otwarte w trybie binarnym."

msgid "Numeric values are stored with the least significant byte first."
msgstr ""
"Wartości numeryczne zapisywane są z najmniej znaczącym bajtem jako "
"pierwszym."

msgid "The module supports two versions of the data format: version 0 is the historical version, version 1 shares interned strings in the file, and upon unmarshalling.  Version 2 uses a binary format for floating point numbers. *Py_MARSHAL_VERSION* indicates the current file format (currently 2)."
msgstr ""
"Moduł wspiera dwie wersje formatu danych: wersja 0 jest wersją historyczną, "
"wersja 1 zachowuje w pliku pobrane ciągi znaków z momentu odmarszrutowania. "
"Wersja 2 używa formatu binarnego dla liczb zmiennoprzecinkowych: "
"*Py_MARSHAL_VERSION* wskazuje aktualny format pliku (obecnie 2)."

msgid "The following functions allow marshalled values to be read back in."
msgstr ""
"Następujące zadania pozwalają marszrutowanym wartościom na wczytywanie ich "
"na powrót."

msgid "XXX What about error detection?  It appears that reading past the end of the file will always result in a negative numeric value (where that's relevant), but it's not clear that negative values won't be handled properly when there's no error.  What's the right way to tell? Should only non-negative values be written using these routines?"
msgstr ""
"XXX Co ze sprawdzaniem błędów? Wygląda na to, że wczytywanie po końcu pliku "
"zawsze spowoduje wczytanie ujemnej wartości liczbowej (tam gdzie jest to "
"istotne), ale nie jest jasne czy ujemne wartości nie będą potraktowane "
"właściwie gdy nie będą one skutkiem błędu. Jak właściwe rozeznać? Czy tylko "
"nieujemne wartości powinny być zapisywane używając tych sposobów "
"postępowania?"

msgid "Memory Management"
msgstr "Zarządzanie Pamięcią"

msgid "Overview"
msgstr "Skorowidz"

msgid "Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the *Python memory manager*.  The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Zarządzanie pamięcią w języku pytonowskim zakłada prywatną stertę "
"zawierającą wszystkie przedmioty języka pytonowskiego i struktury danych. "
"Zarządzanie tą prywatną stertą jest zapewniane wewnętrznie przez *zarządcę "
"pamięci języka pytonowskiego*. Zarządca pamięci języka pytonowskiego ma "
"różne komponenty które radzą sobie z różnymi aspektami dynamicznego "
"przechowywania, jak współdzielenie, segmentacja, alokacja wstępna i "
"kieszeniowanie."

msgid "At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data by interacting with the memory manager of the operating system. On top of the raw memory allocator, several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type. For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"Na najniższym poziomie, przedmiot przydzielający pamięć \"na-surowo\" zapewnia "
"że będzie dość pamięci na prywatnej stercie dla przechowania wszystkich "
"związanych-z-językiem-pytonowskim danych przez współdziałanie z zarządcą "
"pamięci systemu operacyjnego. Ponad zarządcą surowej pamięci, kilka "
"szczególnych dla danych typów przedmiotów zarządców operuje na tej samej "
"stercie i wypełnia szczególne zasady zarządzania pamięcią dostosowane do "
"szczególnych własności każdego rodzaju przedmiotu. Dla przykładu przedmioty "
"liczb całkowitych są zarządzane inaczej wewnątrz sterty niż ciągi znaków, "
"krotki czy słowniki gdyż liczby całkowite zakładają inne wymagania "
"przechowywania i wady i zalety prędkości/zajętej przestrzeni. Zarządca "
"pamięcią języka pytonowskiego zatem odprawia pewną ilość nakładów pracy dla "
"szczególnych dla przedmiotów różnych typów zarządców, ale zapewnia że te "
"drugie będą operować wewnątrz ograniczeń prywatnej sterty."

msgid "It is important to understand that the management of the Python heap is performed by the interpreter itself and that the user has no control over it, even if she regularly manipulates object pointers to memory blocks inside that heap.  The allocation of heap space for Python objects and other internal buffers is performed on demand by the Python memory manager through the Python/C API functions listed in this document."
msgstr ""
"Istotnym jest pojąć że zarządzanie stertą języka pytonowskiego jest "
"dokonywane przez program interpretujący polecenia języka pytonowskiego sam w "
"sobie i że użytkownik nie ma nad nim żadnej kontroli, nawet jeśli "
"regularnie zmienia wskaźniki przedmiotowe do obszarów pamięci wewnątrz "
"sterty. Przydział przestrzeni pamięci dla przedmiotów języka pytonowskiego i "
"innych wewnętrznych obszarów wymiany jest dokonywany na żądanie przez "
"zarządcę pamięci języka pytonowskiego za pośrednictwem zadań sprzęgu między "
"językami pytonowskim i C opisanych w tym dokumencie."

msgid "To avoid memory corruption, extension writers should never try to operate on Python objects with the functions exported by the C library: :cfunc:`malloc`, :cfunc:`calloc`, :cfunc:`realloc` and :cfunc:`free`.  This will result in  mixed calls between the C allocator and the Python memory manager with fatal consequences, because they implement different algorithms and operate on different heaps.  However, one may safely allocate and release memory blocks with the C library allocator for individual purposes, as shown in the following example::"
msgstr ""
"Aby uniknąć zburzenia porządku pamięci, piszący rozszerzenia nie powinni "
"nigdy próbować operować na przedmiotach języka pytonowskiego za pomocą zadań "
"udostępnionych z biblioteki C: :cfunc:`malloc`, :cfunc:`calloc`, "
":cfunc:`realloc` i :cfunc:`free`. To doprowadzi do pomieszania wywołań "
"pomiędzy zarządcą z języka C i zarządcą z języka pytonowskiego z fatalnymi "
"konsekwencjami, ponieważ realizują one różne algorytmy i operują na różnych "
"stertach. Jednakże można bezpiecznie przydzielać i zwalniać obszary pamięci "
"dla indywidualnych potrzeb, jak pokazano w następującym przykładzie::"

msgid "PyObject *res; char *buf = (char *) malloc(BUFSIZ); /* for I/O */  if (buf == NULL)     return PyErr_NoMemory(); ...Do some I/O operation involving buf... res = PyString_FromString(buf); free(buf); /* malloc'ed */ return res;"
msgstr ""
"PyObject *zasob; char *buf = (char *) malloc(BUFSIZ); /* dla we/wy */  if "
"(buf == NULL)     return PyErr_NoMemory(); ...Wykonaj pewne operacje we/wy "
"korzystające z buf... zasob = PyString_FromString(buf); free(buf); /* "
"malloc-nięte */ return res;"

msgid "In this example, the memory request for the I/O buffer is handled by the C library allocator. The Python memory manager is involved only in the allocation of the string object returned as a result."
msgstr ""
"W tym przykładzie, żądanie do pamięci obszaru wymiany jest obsługiwane przez "
"zarządcę bibliotecznego języka C. Zarządca pamięci języka pytonowskiego "
"zajmuje się tylko przydziałem miejsca dla przedmiotu ciągu znaków zwracanego "
"jako wynik."

msgid "In most situations, however, it is recommended to allocate memory from the Python heap specifically because the latter is under control of the Python memory manager. For example, this is required when the interpreter is extended with new object types written in C. Another reason for using the Python heap is the desire to *inform* the Python memory manager about the memory needs of the extension module. Even when the requested memory is used exclusively for internal, highly-specific purposes, delegating all memory requests to the Python memory manager causes the interpreter to have a more accurate image of its memory footprint as a whole. Consequently, under certain circumstances, the Python memory manager may or may not trigger appropriate actions, like garbage collection, memory compaction or other preventive procedures. Note that by using the C library allocator as shown in the previous example, the allocated memory for the I/O buffer escapes completely the Python memory manager."
msgstr ""
"W większości przypadków, jednakże, zalecane jest umieszczanie w pamięci ze "
"sterty języka pytonowskiego szczególnie ponieważ ta ostatnia jest pod "
"kontrolą zarządcy pamięci języka Pytonowskiego. Na przykład, jest to "
"wymagane gdy program interpretujący polecenia języka pytonowskiego jest "
"rozszerzany nowymi typami przedmiotów napisanych w języku C. Inną przyczyną "
"użycia sterty języka pytonowskiego jest chęć *poinformowania* zarządcy "
"pamięci języka pytonowskiego o potrzebach pamięciowych modułu "
"rozszerzającego. Nawet gdy żądana pamięć jest używana wyłącznie dla "
"wewnętrznych wysoko-wyspecjalizowanych potrzeb, oddelegowanie wszystkich "
"zapytań o pamięć do zarządcy pamięci języka pytonowskiego spowoduje że "
"program interpretujący polecenia języka pytonowskiego będzie  miał  bardziej "
"trafny obraz podstawowego rozmiaru potrzeb pamięciowych jako całości. "
"Konsekwentnie, w pewnych warunkach zarządca pamięci języka pytonowskiego "
"może lub może nie uruchomić właściwych działań, jak zbiórki śmieci, "
"porządkowania pamięci lub innych zapobiegawczych działań. Zauważ, że "
"używając programu bibliotecznego lokującego pamięć z języka C jak pokazano w "
"poprzednim przykładzie zarezerwowana pamięć dla obszaru wymiany "
"wejścia/wyjścia całkowicie umyka uwadze zarządcy pamięci języka "
"pytonowskiego."

msgid "Memory Interface"
msgstr "Sprzęg Pamięci"

msgid "The following function sets, modeled after the ANSI C standard, but specifying behavior when requesting zero bytes, are available for allocating and releasing memory from the Python heap:"
msgstr ""
"Następujące zbiory zadań, ukształtowane na wzór standardu znanego z ANSI C, "
"ale określając zachowanie po zażądaniu zera kęsów, są dostępne do lokowania "
"i zwalniania pamięci na stercie języka pytonowskiego:"

msgid "The following type-oriented macros are provided for convenience.  Note  that *TYPE* refers to any C type."
msgstr ""
"Następujące makropolecenia zorientowane-według-typu dostarczone są dla "
"wygody. Zauważ że *TYP* odnosi się do dowolnego typu C."

msgid "In addition, the following macro sets are provided for calling the Python memory allocator directly, without involving the C API functions listed above. However, note that their use does not preserve binary compatibility across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Dodać należy, że następujący zbiór makropoleceń dostarczony jest aby "
"odwoływać się do programu przydzielającego pamięć w języku pytonowskim "
"bezpośrednio, bez udziału zadań sprzęgu C wymienionych powyżej. Jednakże, "
"zauważ, że ich użycie nie zachowuje wzajemnej zgodności binarnej pomiędzy "
"wersjami języka pytonowskiego i z tego też powodu ich użycie jest "
"niewskazane w modułach rozszerzających."

msgid ":cfunc:`PyMem_MALLOC`, :cfunc:`PyMem_REALLOC`, :cfunc:`PyMem_FREE`."
msgstr ":cfunc:`PyMem_MALLOC`, :cfunc:`PyMem_REALLOC`, :cfunc:`PyMem_FREE`."

msgid ":cfunc:`PyMem_NEW`, :cfunc:`PyMem_RESIZE`, :cfunc:`PyMem_DEL`."
msgstr ":cfunc:`PyMem_NEW`, :cfunc:`PyMem_RESIZE`, :cfunc:`PyMem_DEL`."

msgid "Examples"
msgstr "Przykłady"

msgid "Here is the example from section :ref:`memoryoverview`, rewritten so that the I/O buffer is allocated from the Python heap by using the first function set::"
msgstr ""
"Tutaj jest przykład z sekcji \"przeglądu pamięci\" - z ang. - "
":ref:`memoryoverview`, przepisane, tak aby przestrzeń wejścia/wyjścia była "
"przydzielona ze sterty języka pytonowskiego używając pierwszego zestawu "
"zadań::"

msgid "PyObject *res; char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */  if (buf == NULL)     return PyErr_NoMemory(); /* ...Do some I/O operation involving buf... */ res = PyString_FromString(buf); PyMem_Free(buf); /* allocated with PyMem_Malloc */ return res;"
msgstr ""
"PyObject *zasob; char *buf = (char *) PyMem_Malloc(BUFSIZ); /* dla we/wy */ "
" if (buf == NULL)     return PyErr_NoMemory(); /* ...Wykonaj pewne operacje "
"we/wy dotyczące buf... */ zasob = PyString_FromString(buf); "
"PyMem_Free(buf); /* umieszczone przez PyMem_Malloc */ return zasob;"

msgid "The same code using the type-oriented function set::"
msgstr "ten sam kod przy użyciu zorientowanych na typ zbiorów zadań::"

msgid "PyObject *res; char *buf = PyMem_New(char, BUFSIZ); /* for I/O */  if (buf == NULL)     return PyErr_NoMemory(); /* ...Do some I/O operation involving buf... */ res = PyString_FromString(buf); PyMem_Del(buf); /* allocated with PyMem_New */ return res;"
msgstr ""
"PyObject *zasob; char *buf = PyMem_New(char, BUFSIZ); /* dla we/wy */  if "
"(buf == NULL)     return PyErr_NoMemory(); /* ...Wykonaj pewne operacje "
"we/wy dotyczące buf... */ zasob = PyString_FromString(buf); PyMem_Del(buf); "
"/* utworzone przez PyMem_New */ return zasob;"

msgid "Note that in the two examples above, the buffer is always manipulated via functions belonging to the same set. Indeed, it is required to use the same memory API family for a given memory block, so that the risk of mixing different allocators is reduced to a minimum. The following code sequence contains two errors, one of which is labeled as *fatal* because it mixes two different allocators operating on different heaps. ::"
msgstr ""
"Zauważ, że w dwóch powyższych przykładach, przestrzeń wymiany jest zawsze "
"zmieniana przez zadania należące do tego samego zbioru. Właściwie, jest "
"wymagane użycie tej samej rodziny sprzęgów zarządzania pamięcią (z ang. - "
"memory API) dla danego obszaru pamięci, tak, że ryzyko pomieszania różnych "
"programów lokujących zmniejszone jest do minimum. Następująca sekwencja "
"zawiera dwa błędy, jeden z których określony jest jako *krytyczny* ponieważ "
"miesza dwa różne programy lokujące pamięć działające na różnych stertach. ::"

msgid "char *buf1 = PyMem_New(char, BUFSIZ); char *buf2 = (char *) malloc(BUFSIZ); char *buf3 = (char *) PyMem_Malloc(BUFSIZ); ... PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */ free(buf2);       /* Right -- allocated via malloc() */ free(buf1);       /* Fatal -- should be PyMem_Del()  */"
msgstr ""
"char *buf1 = PyMem_New(char, BUFSIZ); char *buf2 = (char *) malloc(BUFSIZ); "
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ); ... PyMem_Del(buf3);  /* Źle -- "
"powinno być PyMem_Free() */ free(buf2);       /* Prawidłowo -- przydzielone "
"przez malloc() */ free(buf1);       /* Krytyczny błąd -- powinno być "
"PyMem_Del()  */"

msgid "In addition to the functions aimed at handling raw memory blocks from the Python heap, objects in Python are allocated and released with :cfunc:`PyObject_New`, :cfunc:`PyObject_NewVar` and :cfunc:`PyObject_Del`."
msgstr ""
"Na dodatek do zadań określonych dla obsługi surowych obszarów pamięci ze "
"sterty języka pytonowskiego, przedmioty w języku pytonowskim są umieszczane "
"i pamięć po nich jest zwalniana przy użyciu :cfunc:`PyObject_New`, "
":cfunc:`PyObject_NewVar` i :cfunc:`PyObject_Del`."

msgid "These will be explained in the next chapter on defining and implementing new object types in C."
msgstr ""
"Te zostaną wyjaśnione w następnym rozdziale o określaniu i realizowaniu "
"nowych typów przedmiotów w języku C."

msgid "Instance Method Objects"
msgstr "Przedmioty Sposobów postępowania dla egzemplarzy."

msgid "An instance method is a wrapper for a :cdata:`PyCFunction` and the new way to bind a :cdata:`PyCFunction` to a class object. It replaces the former call ``PyMethod_New(func, NULL, class)``."
msgstr ""
"Sposób postępowania dla egzemplarza jest opakowaniem dla "
":cdata:`PyCFunction` i nowym sposobem na związanie :cdata:`PyCFunction` do "
"przedmiotu klasy. Zastępuje poprzednie wezwanie ``PyMethod_New(func, NULL, "
"class)``."

msgid "Method Objects"
msgstr "Przedmioty Sposobów Postępowania"

msgid "Methods are bound function objects. Methods are always bound to an instance of an user-defined class. Unbound methods (methods bound to a class object) are no longer available."
msgstr ""
"Sposoby Postępowania są związanymi przedmiotami zadań. Sposoby postępowania "
"są zawsze związane z przykładowymi przedmiotami należącymi do zdefiniowanych "
"przez użytkownika kategorii. Niezwiązane sposoby postępowania (sposoby "
"postępowania związane z przedmiotem kategorii) nie są już dostępne."

msgid "Module Objects"
msgstr "Przedmioty modułów"

msgid "There are only a few functions special to module objects."
msgstr "Istnieje tylko kilka zadań szczególnych dla przedmiotów modułów."

msgid "Initializing C modules"
msgstr "Inicjowanie modułów języka C."

msgid "These functions are usually used in the module initialization function."
msgstr "Te zadania są zwykle używane w zadaniu rozpoczynającym modułu"

msgid "The None Object"
msgstr "Przedmiot \"Żaden\" - z ang. - None"

msgid "Note that the :ctype:`PyTypeObject` for ``None`` is not directly exposed in the Python/C API.  Since ``None`` is a singleton, testing for object identity (using ``==`` in C) is sufficient. There is no :cfunc:`PyNone_Check` function for the same reason."
msgstr ""
"Zauważ, że :ctype:`PyTypeObject` dla ``Żadnego`` - z ang. - ``None`` nie "
"jest bezpośrednio wystawiany w sprzęgu między językami pytonowskim a C. "
"Ponieważ ``Żaden`` - z ang. - ``None`` jest kategorią samą w sobie, "
"sprawdzanie tożsamości przedmiotu (używając ``==`` w języku C) jest "
"wystarczające. Nie istnieje zadanie :cfunc:`PyNone_Check` z tego samego "
"powodu."

msgid "Number Protocol"
msgstr "Protokół Liczbowy"

msgid "Buffer Protocol"
msgstr "Protokół Wymiany Danych"

msgid "Object Protocol"
msgstr "Protokół Przedmiotów"

msgid "Subclass determination is done in a fairly straightforward way, but includes a wrinkle that implementors of extensions to the class system may want to be aware of.  If :class:`A` and :class:`B` are class objects, :class:`B` is a subclass of :class:`A` if it inherits from :class:`A` either directly or indirectly.  If either is not a class object, a more general mechanism is used to determine the class relationship of the two objects.  When testing if *B* is a subclass of *A*, if *A* is *B*, :cfunc:`PyObject_IsSubclass` returns true.  If *A* and *B* are different objects, *B*'s :attr:`__bases__` attribute is searched in a depth-first fashion for *A* --- the presence of the :attr:`__bases__` attribute is considered sufficient for this determination."
msgstr ""
"sprawdzanie podkategorii jest dokonywane w raczej prosto zrozumiały sposób, "
"ale zawiera załomek o którym realizatorzy rozszerzeń systemu kategorii "
"mogliby chcieć wiedzieć. Jeśli kategoria przedmiotów :class:`A` i kategoria "
"przedmiotów :class:`B` są przedmiotami kategorii przedmiotów, wtedy "
"kategoria przedmiotów :class:`B` jest podkategorią przedmiotów kategorii "
"przedmiotów :class:`A`, jeśli dziedziczy po kategorii przedmiotów :class:`A` "
"bezpośrednio lub pośrednio. Jeśli któraś z nich nie jest przedmiotem "
"kategorii przedmiotów, wtedy bardziej ogólny mechanizm jest używany do "
"sprawdzenia relację bycia podkategorią zachodzącą pomiędzy dwoma "
"przedmiotami. Sprawdzając czy *B* jest podkategorią *A*, jeśli *A* jest *B*, "
"wtedy zadanie :cfunc:`PyObject_IsSubclass` zwraca prawdę. Jeśli *A* i *B* "
"są różnymi przedmiotami, wtedy atrybut *B* - :attr:`__bases__` jest "
"przeszukiwany w sposób \"wpierw-wgłąb\" na obecność *A* --- obecność atrybutu "
":attr:`__bases__` jest uważana za wystarczającą dla tego sprawdzenia."

msgid "Object Implementation Support"
msgstr "Wsparcie dla realizacji przedmiotów"

msgid "This chapter describes the functions, types, and macros used when defining new object types."
msgstr ""
"Ten rozdział opisuje zadania, rodzaje przedmiotów, i makrodefinicje i "
"makropolecenia używane przy definiowaniu nowych rodzajów przedmiotów."

msgid "Reference Counting"
msgstr "Zliczanie Odniesień"

msgid "The macros in this section are used for managing reference counts of Python objects."
msgstr ""
"Makropolecenia w tym rozdziale są używane do zarządzania liczbami odniesień "
"dla przedmiotów w języku pytonowskim."

msgid "The following functions are for runtime dynamic embedding of Python: ``Py_IncRef(PyObject *o)``, ``Py_DecRef(PyObject *o)``. They are simply exported function versions of :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF`, respectively."
msgstr ""
"Następujące zadania służą dynamicznemu załączaniu kodów języka "
"pytonowskiego: ``Py_IncRef(PyObject *o)``, ``Py_DecRef(PyObject *o)``. Są "
"one po prostu uzewnętrznionymi wersjami zadań :cfunc:`Py_XINCREF` i "
":cfunc:`Py_XDECREF`, odpowiednio."

msgid "The following functions or macros are only for use within the interpreter core: :cfunc:`_Py_Dealloc`, :cfunc:`_Py_ForgetReference`, :cfunc:`_Py_NewReference`, as well as the global variable :cdata:`_Py_RefTotal`."
msgstr ""
"Następujące zadania lub makropolecenia są tylko do użytku wewnątrz rdzenia "
"programu iterpretującego polecenia języka pytonowskiego: "
":cfunc:`_Py_Dealloc`, :cfunc:`_Py_Forget_Reference` "
":cfunc:`_Py_NewReference`, zarówno, jak też nadrzędną zmienną "
":cdata:`_Py_RefTotal`."

msgid "Reflection"
msgstr "Refleksja"

msgid "Sequence Protocol"
msgstr "Protokół Sekwencji"

msgid "Set Objects"
msgstr "Przedmioty Zbiorów"

msgid "This section details the public API for :class:`set` and :class:`frozenset` objects.  Any functionality not listed below is best accessed using the either the abstract object protocol (including :cfunc:`PyObject_CallMethod`, :cfunc:`PyObject_RichCompareBool`, :cfunc:`PyObject_Hash`, :cfunc:`PyObject_Repr`, :cfunc:`PyObject_IsTrue`, :cfunc:`PyObject_Print`, and :cfunc:`PyObject_GetIter`) or the abstract number protocol (including :cfunc:`PyNumber_And`, :cfunc:`PyNumber_Subtract`, :cfunc:`PyNumber_Or`, :cfunc:`PyNumber_Xor`, :cfunc:`PyNumber_InPlaceAnd`, :cfunc:`PyNumber_InPlaceSubtract`, :cfunc:`PyNumber_InPlaceOr`, and :cfunc:`PyNumber_InPlaceXor`)."
msgstr ""
"Ten rozdział wyszczególnia publiczny sprzęg programowania z ang. - API dla "
"kategorii przedmiotu zbioru z ang. - :class:`set` i kategorii przedmiotu "
"zamrożonego zbioru - z ang. - :class:`frozenset`. Do dowolnych możliwości "
"nie wyszczególnionych poniżej najlepiej odnieść się przy użyciu "
"abstrakcyjnego protokołu przedmiotów (włączając w to "
":cfunc:`PyObject_CallMethod`, :cfunc:`PyObject_RichCompareBool`, "
":cfunc:`PyObject_Hash`, :cfunc:`PyObject_Repr`, :cfunc:`PyObject_IsTrue`, "
":cfunc:`PyObject_Print`, i :cfunc:`PyObject_GetIter`) lub przy użyciu "
"abstrakcyjnego protokołu liczbowego (włączając w to :cfunc:`PyNumber_And`, "
":cfunc:`PyNumber_Subtract`, :cfunc:`PyNumber_Or`, :cfunc:`PyNumber_Xor`, "
":cfunc:`PyNumber_InPlaceAnd`, :cfunc:`PyNumber_InPlaceSubtract`, "
":cfunc:`PyNumber_InPlaceOr`, i :cfunc:`PyNumber_InPlaceXor`)."

msgid "The following type check macros work on pointers to any Python object. Likewise, the constructor functions work with any iterable Python object."
msgstr ""
"Następujące makropolecenia sprawdzające rodzaj przedmiotu pracują na "
"wskaźnikach do dowolnych przedmiotów języka pytonowskiego. Podobnie, zadania "
"konstruktorów pracjują z dowolnymi przedmiotami przechodnimi języka "
"pytonowskiego"

msgid "The following functions and macros are available for instances of :class:`set` or :class:`frozenset` or instances of their subtypes."
msgstr ""
"Następujące zadania i makropolecenia dostępne są dla przykładów kategorii "
"zbioru - z ang. - :class:`set` lub zbioru zamrożonego - z ang. - "
":class:`frozenset` lub przykładowych realizacjach ich podtypów i "
"podkategorii."

msgid "The following functions are available for instances of :class:`set` or its subtypes but not for instances of :class:`frozenset` or its subtypes."
msgstr ""
"Następujące zadania dostępne są  dla przykładów kategorii zbioru -  z ang. - "
":class:`set` lub jej podkategorii, ale nie dla przykładów kategorii "
"zamrożonego zbioru - z ang. - :class:`frozenset` lub jego podkategorii."

msgid "Slice Objects"
msgstr "Przedmioty wycinków"

msgid "Common Object Structures"
msgstr "Wspólne struktury przedmiotów"

msgid "There are a large number of structures which are used in the definition of object types for Python.  This section describes these structures and how they are used."
msgstr ""
"Istnieje duża liczba struktur, które są używane przy definiowaniu rodzajów "
"przedmiotów w języku pytonowskim. Ten rozdział opisuje te struktury i jak są "
"one używane."

msgid "All Python objects ultimately share a small number of fields at the beginning of the object's representation in memory.  These are represented by the :ctype:`PyObject` and :ctype:`PyVarObject` types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects."
msgstr ""
"Wszystkie przedmioty języka pytonowskiego ostatecznie współdzielą niewielką "
"liczbę pól na początku ich reprezentacji w pamięci. Są one reprezentowane "
"przez pola o rodzaju :ctype:`PyObject` i :ctype:`PyVarObject` które są "
"zdefiniowane z kolei przez rozwinięcia pewnych makrodefinicji używanych "
"także bezpośrednio lub pośrednio, w definicji wszystkich innych przedmiotów "
"języka pytonowskiego."

msgid "These macros are used in the definition of :ctype:`PyObject` and :ctype:`PyVarObject`:"
msgstr ""
"Te makrodefinicje używane są przy definicjach :ctype:`PyObject` i "
":ctype:`PyVarObject`:"

msgid "The :attr:`ml_meth` is a C function pointer.  The functions may be of different types, but they always return :ctype:`PyObject\\*`.  If the function is not of the :ctype:`PyCFunction`, the compiler will require a cast in the method table. Even though :ctype:`PyCFunction` defines the first parameter as :ctype:`PyObject\\*`, it is common that the method implementation uses a the specific C type of the *self* object."
msgstr ""
"Atrybut :attr:`ml_meth` jest wskaźnikiem zadania z jęyzka C. Zadania mogą "
"być różnych rodzajów, ale zawsze zwracają :ctype:`PyObject\\*`. Jeśli zadanie "
"nie jest :ctype:`PyCFunction`, kompilator będzie wymagał rzutowania w "
"tabeli sposobów postępowania. Chociaż :ctype:`PyCFunction` definiuje "
"pierwszy parametr jako :ctype:`PyObject\\*`, często zdarza się, że "
"wypełnienie sposobu postępowania używa szczególnego rodzaju z języka C "
"wynikającego z *swojego* - z ang. - *self* przedmiotu."

msgid "The :attr:`ml_flags` field is a bitfield which can include the following flags. The individual flags indicate either a calling convention or a binding convention.  Of the calling convention flags, only :const:`METH_VARARGS` and :const:`METH_KEYWORDS` can be combined (but note that :const:`METH_KEYWORDS` alone is equivalent to ``METH_VARARGS | METH_KEYWORDS``). Any of the calling convention flags can be combined with a binding flag."
msgstr ""
"Pole :attr:`ml_flags` jest polem bitowym, które może zawierać następujące "
"flagi.Indywidualne flagi wskazują albo konwencję wywoływania albo konwencję "
"wiązania. Z konwencji wywoływania, tylko :const:`METH_VARARGS` i "
":const:`METH_KEYWORDS` mogą być mieszane (ale zauważ, że samo "
":const:`METH_KEYWORDS jest równoważne ``METH_VARARGS | METH_KEYWORDS``). "
"Każda z flag konwencji wywołania może być mieszana z flagą wiążącą."

msgid "This is the typical calling convention, where the methods have the type :ctype:`PyCFunction`. The function expects two :ctype:`PyObject\\*` values. The first one is the *self* object for methods; for module functions, it is the module object.  The second parameter (often called *args*) is a tuple object representing all arguments. This parameter is typically processed using :cfunc:`PyArg_ParseTuple` or :cfunc:`PyArg_UnpackTuple`."
msgstr ""
"To jest typowa konwencja wywoływania, gdzie sposoby postępowania są rodzaju "
":ctype:`PyCFunction`. Zadanie oczekuje dwóch wartości typu "
":ctype:`PyObject\\*`, Pierwszą z nich jest *samo* - z ang. - *self* dla "
"sposobów postępowania; dla zadań modułowych, jest to przedmiot modułu. "
"Drugim parametrem (często zwanym *args*) jest przedmiot krotki "
"reprezentujący wszystkie parametry. Ten parametr jest zwykle przetwarzany "
"przy użyciu :cfunc:`PyArg_ParseTuple` lub :cfunc:`PyArg_UnpackTuple`."

msgid "Methods with these flags must be of type :ctype:`PyCFunctionWithKeywords`. The function expects three parameters: *self*, *args*, and a dictionary of all the keyword arguments.  The flag is typically combined with :const:`METH_VARARGS`, and the parameters are typically processed using :cfunc:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Sposoby postępowania z tymi flagami muszą być typu "
":ctype:`PyCFunctionWithKeywords`. Zadanie oczekuje trzech parametrów: "
"*samego*, *argumentów*, i słownika wszystkich parametrów kluczowych. Flaga "
"jest zwykle łączona z :const:`METH_VARARGS`, a parametry są zwykle "
"przetwarzane używając :cfunc:`PyArg_ParseTupleAndKeywords`."

msgid "Methods without parameters don't need to check whether arguments are given if they are listed with the :const:`METH_NOARGS` flag.  They need to be of type :ctype:`PyCFunction`.  The first parameter is typically named *self* and will hold a reference to the module or object instance.  In all cases the second parameter will be *NULL*."
msgstr ""
"Sposoby postępowania bez parametrów nie potrzebują sprawdzać czy parametry "
"zostały im dostarczone jeśli są one na liście z załączoną flagą "
":const:`METH_NOARGS`. Muszą być typu :ctype:`PyCFunction`. Pierwszy parametr "
"jest zwyczajowo nazwany *sam* - z ang. - *self* i przechowuje odwołanie do "
"modułu lub przykładu przedmiotu. We wszystkich przypadkach drugi parametr "
"jest *NULL*."

msgid "Methods with a single object argument can be listed with the :const:`METH_O` flag, instead of invoking :cfunc:`PyArg_ParseTuple` with a ``\"O\"`` argument. They have the type :ctype:`PyCFunction`, with the *self* parameter, and a :ctype:`PyObject\\*` parameter representing the single argument."
msgstr ""
"Sposoby postępowania z pojedynczym przedmiotem jako parametrem mogą być "
"umieszczone z flagą :const:`METH_O`, zamiast wywoływania "
":cfunc:`PyArg_ParseTuple` z parametrem ``\"O\"``. Są typu "
":ctype:`PyCFunction`, z parametrem *self*, i parametrem :ctype:`PyObject\\*` "
"reprezentującym pojedynczy parametr."

msgid "These two constants are not used to indicate the calling convention but the binding when use with methods of classes.  These may not be used for functions defined for modules.  At most one of these flags may be set for any given method."
msgstr ""
"Te dwie stałe nie są używane do zaznaczania konwencji wywoływania, ale wiążą "
"gdy są używane ze sposobami postępowania w rodzajach przedmiotów. Nie mogą "
"być one używane dla zadań określonych dla modułów. Co najwyżej jedna z tych "
"flag może być ustawiona dla dowolnego danego sposobu postępowania. "

msgid "The method will be passed the type object as the first parameter rather than an instance of the type.  This is used to create *class methods*, similar to what is created when using the :func:`classmethod` built-in function."
msgstr ""
"Sposobowi postępowania zostanie przekazany  przedmiot typu przedmiotu jako "
"pierwszy parametr zamiast przykładu przedmiotu tego typu. Jest to używane "
"aby tworzyć *sposoby postępowania rodzajów przedmiotów*, podobnie do tego, "
"co jest tworzone przy użyciu zadania wbudowanego :func:`classmethod`."

msgid "The method will be passed *NULL* as the first parameter rather than an instance of the type.  This is used to create *static methods*, similar to what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Sposobowi postępowania zostanie przekazany parametr *NULL* jako pierwszy "
"zamiast przykładu przedmiotu tego typu. Jest to używane aby tworzyć "
"*statyczny sposób postępowania*, podobne do tego co tworzy się przy użyciu "
"wbudowanego zadania  :func:`staticmethod`."

msgid "One other constant controls whether a method is loaded in place of another definition with the same method name."
msgstr ""
"Jedna pozostała stała kontroluje czy sposób postępowania jest ładowany w "
"miejscu innej definicji o tej samej nazwie sposobu postępowania."

msgid "The method will be loaded in place of existing definitions.  Without *METH_COEXIST*, the default is to skip repeated definitions.  Since slot wrappers are loaded before the method table, the existence of a *sq_contains* slot, for example, would generate a wrapped method named :meth:`__contains__` and preclude the loading of a corresponding PyCFunction with the same name.  With the flag defined, the PyCFunction will be loaded in place of the wrapper object and will co-exist with the slot.  This is helpful because calls to PyCFunctions are optimized more than wrapper object calls."
msgstr ""
"Sposób postępowania zostanie załadowany w miejsce istniejących definicji. "
"Bez *METH_COEXIST*, domyślnie pomija się powtórzone definicje. Od kiedy "
"opakowania gniazd są ładowane przed tabelą sposobów postępowania, istnienie "
"na przykład gniazda *sq_contains* generuje opakowany sposób postępowania "
"nazywany :meth:`__contains__` i zapobiega ładowaniu odpowiadającego zadania "
"PyCFunction o tej samej nazwie. Ze zdefiniowaną flagą, PyCFunction zostanie "
"załadowane w miejsce przedmiotu opakowania i będzie współistniał z gniazdem. "
"To jest pomocne ponieważ wywołania PyCFunction są zoptymalizowane bardziej "
"niż odwołania do przedmiotów opakowań."

msgid "Operating System Utilities"
msgstr "Użytki Systemu Operacyjnego"

msgid "System Functions"
msgstr "Zadania systemowe"

msgid "These are utility functions that make functionality from the :mod:`sys` module accessible to C code.  They all work with the current interpreter thread's :mod:`sys` module's dict, which is contained in the internal thread state structure."
msgstr ""
"To są zadania użytkowe, które czynią zadania z modułu :mod:`sys` dostępnymi "
"dla kodu z języka C. Wszystkie pracują z obecnym słownikiem modułu "
":mod:`sys` wątku programu interpretującego polecenia języka pytonowskiego, "
"który to słownik jest zawarty w wewnętrznej strukturze stanu wątku."

msgid "Process Control"
msgstr "Kontrola procesów"

msgid "Tuple Objects"
msgstr "Przedmioty krotek."

msgid "Type Objects"
msgstr "Przedmioty rodzaju"

msgid "Perhaps one of the most important structures of the Python object system is the structure that defines a new type: the :ctype:`PyTypeObject` structure.  Type objects can be handled using any of the :cfunc:`PyObject_\\*` or :cfunc:`PyType_\\*` functions, but do not offer much that's interesting to most Python applications. These objects are fundamental to how objects behave, so they are very important to the interpreter itself and to any extension module that implements new types."
msgstr ""
"Zapewne jedną z najważniejszych struktur systemu przedmiotów języka "
"pytonowskiego jest struktura która definiuje nowy typ: strukturę "
":ctype:`PyTypeObject`. Przedmioty typu mogą być obsłużone używając dowolnego "
"zadania spośród :cfunc:`PyObject_\\*` lub :cfunc:`PyType_\\*`, ale nie "
"oferują wiele w sensie tego, co mogłoby być interesujące dla większości "
"aplikacji języka pytonowskiego. Te przedmioty są podstawowe dla tego jak "
"zachowują się przedmioty, więc są one bardzo istotne dla samego programu "
"interpretującego polecenia języka pytonowskiego i do dowolnego modułu "
"rozszerzającego który określa nowe typy przedmiotów."

msgid "Type objects are fairly large compared to most of the standard types. The reason for the size is that each type object stores a large number of values, mostly C function pointers, each of which implements a small part of the type's functionality.  The fields of the type object are examined in detail in this section.  The fields will be described in the order in which they occur in the structure."
msgstr ""
"Przedmioty typu przedmiotów są znacznie większe w porównaniu do większości "
"standardowych typów.  Powodem tego rozmiaru jest to, że każdy przedmiot typu "
"przechowuje dużą liczbę wartości, w większości wskaźników zadań C, z "
"których każda wypełnia małą część użyteczności danego typu. Pola przedmiotu "
"typu zostaną opisane w kolejności w której pojawiają się w strukturze."

msgid "Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, intargfunc, intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, reprfunc, hashfunc"
msgstr ""
"Definicje typu: unaryfunc, binaryfunc, ternaryfunc, inquiry, intargfunc, "
"intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, "
"freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, "
"reprfunc, hashfunc"

msgid "The structure definition for :ctype:`PyTypeObject` can be found in :file:`Include/object.h`.  For convenience of reference, this repeats the definition found there:"
msgstr ""
"Definicja struktury dla :ctype:`PyTypeObject` można znaleźć w "
":file:`Include/object.h`. Dla wygody poręczności, powtórzona definicja "
"znajduje się tutaj:"

msgid "typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* For printing, in format \"<module>.<name>\" */     int tp_basicsize, tp_itemsize; /* For allocation */      /* Methods to implement standard operations */      destructor tp_dealloc;     printfunc tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void *tp_reserved;     reprfunc tp_repr;      /* Method suites for standard classes */      PyNumberMethods *tp_as_number;     PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping;      /* More standard operations (here for binary compatibility) */      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Functions to access object as input/output buffer */     PyBufferProcs *tp_as_buffer;      /* Flags to define presence of optional/expanded features */     long tp_flags;      char *tp_doc; /* Documentation string */      /* call function for all accessible objects */     traverseproc tp_traverse;      /* delete references to contained objects */     inquiry tp_clear;      /* rich comparisons */     richcmpfunc tp_richcompare;      /* weak reference enabler */     long tp_weaklistoffset;      /* Iterators */     getiterfunc tp_iter;     iternextfunc tp_iternext;      /* Attribute descriptor and subclassing stuff */     struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc tp_free; /* Low-level free-memory routine */     inquiry tp_is_gc; /* For PyObject_IS_GC */     PyObject *tp_bases;     PyObject *tp_mro; /* method resolution order */     PyObject *tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;"
msgstr ""
"typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* Dla "
"drukowania, w formacie \"<moduł>.<nazwa>\" */     int tp_basicsize, "
"tp_itemsize; /* Dla alokacji */      /* Sposoby postępowania wypełniające "
"standardowe operacje */      destructor tp_dealloc;     printfunc tp_print; "
"    getattrfunc tp_getattr;     setattrfunc tp_setattr;     void "
"*tp_reserved;     reprfunc tp_repr;      /* Suity sposobów postępowania dla "
"typów standardowych */      PyNumberMethods *tp_as_number;     "
"PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping; "
"     /* Wiele  standardowych operacji (tutaj dla  binarnej kompatybilności) "
"*/      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str; "
"    getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Zadania "
" do dostępu do przedmiotów jako wejścia/wyjścia przestrzeni wymiany */     "
"PyBufferProcs *tp_as_buffer;      /* Flagi do definiowania obecności "
"dodatkowych/rozszerzonych właściwości */     long tp_flags;      char "
"*tp_doc; /* ciągi znaków dokumentacji */      /* wywołanie zadania dla "
"wszystkich dostępnych przedmiotów */     traverseproc tp_traverse;      /* "
"skasuje odniesienia do zawartych przedmiotów */     inquiry tp_clear;      "
"/* bogate porównania */     richcmpfunc tp_richcompare;      /* załączanie "
"słabych odniesień */     long tp_weaklistoffset;      /* Przedmioty "
"przechodzące */     getiterfunc tp_iter;     iternextfunc tp_iternext;      "
"/* Przedmioty opisujące atrybuty i sprawy tworzenia podrodzajów */     "
"struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     "
"struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject "
"*tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set; "
"    long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     "
"newfunc tp_new;     freefunc tp_free; /* Sposób postępowania zwalniający "
"pamięć na niskim poziomie */     inquiry tp_is_gc; /* Dla PyObject_IS_GC */ "
"    PyObject *tp_bases;     PyObject *tp_mro; /* kolejność rozwiązywania "
"nazw sposobów postępowania */     PyObject *tp_cache;     PyObject "
"*tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;"

msgid "The type object structure extends the :ctype:`PyVarObject` structure. The :attr:`ob_size` field is used for dynamic types (created by  :func:`type_new`, usually called from a class statement). Note that :cdata:`PyType_Type` (the metatype) initializes :attr:`tp_itemsize`, which means that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""
"Struktura przedmiotu rodzaju rozszerza strukturę :ctype:`PyVarObject`. Pole "
":attr:`ob_size` używane jest dla typów dynamicznych (tworzonych przy użyciu "
":func:`type_new`, zwykle wywoływanych z deklaracji rodzaju przedmiotu). "
"Zauważ, że :cdata:`PyType_Type` (typ przedmiotu typu - inaczej metatyp) "
"inicjuje :attr:`tp_itemsize`, które oznacza, że jego przykłady (przedmioty "
"typu) *muszą* mieć pole :attr:`ob_size`."

msgid "The remaining fields are only defined if the feature test macro :const:`COUNT_ALLOCS` is defined, and are for internal use only. They are documented here for completeness.  None of these fields are inherited by subtypes."
msgstr ""
"Pozostałe pola są tylko zdefiniowane jeśli makrodefinicja sprawdzenia "
"występowania własności :const:`COUNT_ALLOCS` jest zdefiniowane, i jest tylko "
"do wewnętrznego użytku. Są tutaj opisane dla zupełności. Żadne z tych pól "
"nie jest dziedziczone przez podtypy."

msgid "Also, note that, in a garbage collected Python, tp_dealloc may be called from any Python thread, not just the thread which created the object (if the object becomes part of a refcount cycle, that cycle might be collected by a garbage collection on any thread).  This is not a problem for Python API calls, since the thread on which tp_dealloc is called will own the Global Interpreter Lock (GIL). However, if the object being destroyed in turn destroys objects from some other C or C++ library, care should be taken to ensure that destroying those objects on the thread which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"Zauważ też, że w programie interpretującym polecenia języka pytonowskiego z "
"regularnym odśmiecaniem, tp_dealloc może być wywoływane z dowolnego wątku "
"programu interpretującego polecenia języka pytonowskiego, nie tylko z wątku "
"który stworzył przedmiot (jeśli przedmiot stanie się częścią cyklu refcount, "
"ten cykl może być potraktowany odśmiecaniem przez zbiórkę śmieci w dowolnym "
"wątku). Nie jest to problem dla wywołań sprzęgu języka pytonowskiego (z "
"ang. - API), od kiedy wątek, na którym tp_dealloc jest wywoływany będzie "
"posiadał Nadrzędną Blokadę Programu Interpretującego język pytonowski (z "
"ang. - GIL). Jednakże, jeśli przedmiot ulegający destrukcji z kolei zniszczy "
"przedmioty z jakiejś innej biblioteki C lub C++, powinno się zwrócić "
"szczególną uwagę, aby niszcząc te przedmioty w wątku, który wywołał "
"tp_dealloc nie zakłócić żadnych założeń bibliotecznych."

msgid "Number Object Structures"
msgstr "Struktury przedmiotów liczbowych"

msgid "Mapping Object Structures"
msgstr "Struktury przedmiotów mapowania"

msgid "Sequence Object Structures"
msgstr "Struktury przedmiotów sekwencyjnych"

msgid "Buffer Object Structures"
msgstr "Struktury przedmiotów przestrzeni wymiany (z ang. - buffer)"

msgid "The buffer interface exports a model where an object can expose its internal data."
msgstr ""
"Sprzęg przestrzeni wymiany wystawia model gdzie przedmiot może wystawiać "
"swoje wewnętrzne dane."

msgid "If an object does not export the buffer interface, then its :attr:`tp_as_buffer` member in the :ctype:`PyTypeObject` structure should be *NULL*.  Otherwise, the :attr:`tp_as_buffer` will point to a :ctype:`PyBufferProcs` structure."
msgstr ""
"Jeśli przedmiot nie wystawia na zewnątrz sprzęgu przestrzeni wymiany, wtedy "
"jego pole :attr:`tp_as_buffer` w strukturze :ctype:`PyTypeObject` powinno "
"być puste - z ang. - *NULL*. W przeciwnym przypadku :attr:`tp_as_buffer` "
"będzie wskazywał na strukturę :ctype:`PyBufferProcs`."

msgid "Unicode Objects and Codecs"
msgstr "Przedmioty Unikodu i Kodery/Dekodery"

msgid "Unicode Objects"
msgstr "Przedmioty Unikodu"

msgid "Unicode Type"
msgstr "Rodzaj Unikodu"

msgid "These are the basic Unicode object types used for the Unicode implementation in Python:"
msgstr ""
"To są podstawowe przedmioty Unikodu używane dla wypełnienia Unikodu w języku "
"pytonowskim:"

msgid "Note that UCS2 and UCS4 Python builds are not binary compatible. Please keep this in mind when writing extensions or interfaces."
msgstr ""
"Zauważ, że kompilacje UCS2 i UCS4 języka pytonowskiego nie są wzajemnie "
"odpowiednie binarnie. Proszę miej to na uwadze pisząc rozszerzenia lub "
"sprzęgi biblioteczne."

msgid "The following APIs are really C macros and can be used to do fast checks and to access internal read-only data of Unicode objects:"
msgstr ""
"Następujące sprzęgi są w rzeczywistości makropoleceniami języka C i mogą być "
"używane do szybkich sprawdzeń i do uzyskiwania dostępu do  wewnętrznych "
"danych tylko do odczytu przedmiotów Unikodu:"

msgid "Unicode Character Properties"
msgstr "Własności znaków Unikodu"

msgid "Unicode provides many different character properties. The most often needed ones are available through these macros which are mapped to C functions depending on the Python configuration."
msgstr ""
"Unikod dostarcza wiele różnych właściwości znaków. Najczęściej potrzebne są "
"dostępne przez te makropolecenia które są zmapowane na zadania w języku C "
"zależnie od konfiguracji języka pytonowskiego. "

msgid "These APIs can be used for fast direct character conversions:"
msgstr "Te sprzęgi mogą być używane do szybkich zamian znaków: "

msgid "Plain Py_UNICODE"
msgstr "Czysty Py_UNICODE"

msgid "To create Unicode objects and access their basic sequence properties, use these APIs:"
msgstr ""
"Aby tworzyć przedmioty unikodowe i korzystać z ich podstawowych właściwości "
"sekwencyjnych, używaj tych sprzęgów - z ang. - API:"

msgid "If the platform supports :ctype:`wchar_t` and provides a header file wchar.h, Python can interface directly to this type using the following functions. Support is optimized if Python's own :ctype:`Py_UNICODE` type is identical to the system's :ctype:`wchar_t`."
msgstr ""
"Jeśli urządzenie fizyczne wspiera :ctype:`wchar_t` i dostarcza plik "
"nagłówkowy wchar.h, język pytonowski może odnosić się do tego typu "
"bezpośrednio przy użyciu następujących zadań. Wsparcie jest zoptymalizowane "
"jeśli typ własny języku pytonowskiego :ctype:`Py_UNICODE` jest identyczny z "
"systemowym :ctype:`wchar_t`."

msgid "File System Encoding"
msgstr "Kodowanie systemu plików "

msgid "To encode and decode file names and other environment strings, :cdata:`Py_FileSystemEncoding` should be used as the encoding, and ``\"surrogateescape\"`` should be used as the error handler (:pep:`383`). To encode file names during argument parsing, the ``\"O&\"`` converter should be used, passsing :func:PyUnicode_FSConverter as the conversion function:"
msgstr ""
"Aby zakodować i odkodować nazwy plików inne napisy środowiskowe, "
":cdata:`Py_FileSystemEncoding` powinien być używany jako kodowanie i "
"``\"surrogateescape\"`` powinien być używany do obsługi błędów (zob. "
":pep:`383`). Aby zakodować nazwy plików w czasie przetwarzania parametrów, "
"powinno się użyć konwertera ``\"O&\"`` przekazując "
":func:`PyUnicode_FSConverter` jako zadanie konwersji:"

msgid "wchar_t Support"
msgstr "Wsparcie dla wchar_t"

msgid "wchar_t support for platforms which support it:"
msgstr "Wsparcie dla wchar_t dla maszyn które je wspierają:"

msgid "Built-in Codecs"
msgstr "Wbudowane kodery/dekodery"

msgid "Python provides a set of built-in codecs which are written in C for speed. All of these codecs are directly usable via the following functions."
msgstr ""
"Język pytonowski zapewnia zestaw wbudowanych koderów/dekoderów, które są "
"napisane w języku C dla szybkości. Wszystkie te kodery/dekodery są "
"bezpośrednio użyteczne przez następujące zadania."

msgid "Many of the following APIs take two arguments encoding and errors. These parameters encoding and errors have the same semantics as the ones of the built-in :func:`unicode` Unicode object constructor."
msgstr ""
"Wiele z następujących sprzęgów pobiera dwa parametry kodowania i błędów. Te "
"parametry kodowania i błędów mają tę samą składnię, co te dla wbudowanego "
"konstruktora przedmiotu Unikodu - :func:`unicode`."

msgid "Setting encoding to *NULL* causes the default encoding to be used which is ASCII.  The file system calls should use :cfunc:`PyUnicode_FSConverter` for encoding file names. This uses the variable :cdata:`Py_FileSystemDefaultEncoding` internally. This variable should be treated as read-only: On some systems, it will be a pointer to a static string, on others, it will change at run-time (such as when the application invokes setlocale)."
msgstr ""
"Ustawienie kodowania na puste - z ang. - *NULL* powoduje użycie domyślnego "
"kodowania którym jest ASCII. Odwołania systemu plików powinny używać "
":cfunc:`PyUnicode_FSConverter` dla kodowania nazw plików. To używa zmiennej "
":cdata:`Py_FileSystemDefaultEncoding wewnętrznie. Ta zmienna powinna być "
"traktowana jak tylko-do-odczytu: Na niektórych maszynach, będzie ona "
"wskaźnikiem do statycznego ciągu znaków, na innych będzie ulegać zmianie w "
"czasie-wykonania-programu (ta, jak wtedy, gdy program wywołuje setlocale)."

msgid "Error handling is set by errors which may also be set to *NULL* meaning to use the default handling defined for the codec.  Default error handling for all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"Obsługa błędów jest ustawiana przez błędy które mogą także być ustawione na "
"*NULL* co oznacza użycie domyślnego sposobu obsługi określonego dla "
"kodera/dekodera. Domyślna obsługa błędów dla wszystkich wbudowanych "
"koderów/dekoderów jest \"ścisła\" (podnoszony jest :exc:`ValueError`)."

msgid "The codecs all use a similar interface.  Only deviation from the following generic ones are documented for simplicity."
msgstr ""
"Kodery/dekodery wszystkie używają podobnego sprzęgu. Jedyne odstępstwa od "
"następujących podstawowych są opisane dla uproszczenia."

msgid "Generic Codecs"
msgstr "Kodery/dekodery podstawowe"

msgid "These are the generic codec APIs:"
msgstr "To są podstawowe sprzęgi koderów/dekoderów (z ang. - API):"

msgid "UTF-8 Codecs"
msgstr "Kodery/dekodery UTF-8"

msgid "These are the UTF-8 codec APIs:"
msgstr "To są sprzęgi kodera/dekodera UTF-8 (z ang. - API):"

msgid "UTF-32 Codecs"
msgstr "Kodery/dekodery UTF-32"

msgid "These are the UTF-32 codec APIs:"
msgstr "To są sprzęgi kodera/dekodera UTF-32 (z ang. - API):"

msgid "UTF-16 Codecs"
msgstr "Kodery/dekodery UTF-16"

msgid "These are the UTF-16 codec APIs:"
msgstr "To są sprzęgi kodera/dekodera UTF-16 (z ang. - API):"

msgid "Unicode-Escape Codecs"
msgstr "Kodery/Dekodery ucieczkowych-sekwencji-Unikodu"

msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr ""
"To są sprzęgi kodera/dekodera ucieczkowych-sekwencji-Unikodu (z ang. - API):"

msgid "Raw-Unicode-Escape Codecs"
msgstr "Kodery/dekodery surowych-sekwencji-ucieczkowych-Unikodu"

msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr ""
"To są sprzęgi kodera/dekodera \"surowych sekwencji ucieczkowych Unikodu\" (z "
"ang. - API):"

msgid "Latin-1 Codecs"
msgstr "Kodery/dekodery Latin-1"

msgid "These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr ""
"To są sprzęgi kodera/dekodera Latin-1 (z ang. API): Latin-1 odpowiada "
"pierwszym 256 znakom porządkowym Unikodu i tylko te są akceptowane przez "
"kodery/dekodery podczas kodowania. "

msgid "ASCII Codecs"
msgstr "Kodery/dekodery ASCII"

msgid "These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All other codes generate errors."
msgstr ""
"To są sprzegi koderów/dekoderów ASCII (z ang. API). Tylko 7-bitowe dane "
"ASCII są akceptowane. Wszystkie inne kody generują błędy."

msgid "Character Map Codecs"
msgstr "Kodery/Dekodery Mapy Znaków"

msgid "These are the mapping codec APIs:"
msgstr "To są sprzęgi kodera/dekodera mapowania (z ang. API):"

msgid "This codec is special in that it can be used to implement many different codecs (and this is in fact what was done to obtain most of the standard codecs included in the :mod:`encodings` package). The codec uses mapping to encode and decode characters."
msgstr ""
"Ten koder/dekoder jest szczególny w tym że może być użyty do wypełnienia "
"wielu różnych kederów/dekoderów (i to jest faktycznie to co uczyniono aby "
"otrzymać większość ze standardowych koderów/dekoderów załączonych w pakiecie "
":mod:`encodings`). Koder/dekoder używa mapowania do zakodowania i "
"zdekodowania znaków."

msgid "Decoding mappings must map single string characters to single Unicode characters, integers (which are then interpreted as Unicode ordinals) or None (meaning \"undefined mapping\" and causing an error)."
msgstr ""
"Mapowania dekodujące muszą mapować pojedynczy ciąg znaków na pojedyncze "
"znaki Unikodu, liczby całkowite (które są potem interpretowane jako liczby "
"porządkowe Unikodu) lub Nic (z ang. - None) (oznaczające \"niezdefiniowane "
"mapowanie\" i powodujące błąd)."

msgid "Encoding mappings must map single Unicode characters to single string characters, integers (which are then interpreted as Latin-1 ordinals) or None (meaning \"undefined mapping\" and causing an error)."
msgstr ""
"Mapowania kodujące muszą mapować pojedyncze znaki Unikodu na pojedyncze "
"ciągi znaków, liczby całkowite (które są potem interpretowane jako liczby "
"porządkowe Latin-1) lub Nic ( z ang. None) (oznaczające \"niezdefiniowane "
"mapowanie\" i powodujące błąd)."

msgid "The mapping objects provided must only support the __getitem__ mapping interface."
msgstr ""
"Przedmioty mapujące dostarczane muszą tylko wspierać mapujący sprzęg "
"__getitem__."

msgid "If a character lookup fails with a LookupError, the character is copied as-is meaning that its ordinal value will be interpreted as Unicode or Latin-1 ordinal resp. Because of this, mappings only need to contain those mappings which map characters to different code points."
msgstr ""
"Jeśli podgląd znaku zawiedzie z błędem podglądu z ang. - LookupError, znak "
"jest kopiowany taki jaki jest to znaczy że jego wartość porządkowa zostanie "
"zinterpretowana jako Unikod lub liczba porządkowa Latin-1 odpowiednio. Z "
"tego powodu zbiór mapowań wymaga zawarcia w nim tylko tych mapowań, które "
"mapują znaki do różnych punktów kodowania."

msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr ""
"Następujący sprzęg kodera/dekodera (z ang. - API) jest szczególny gdyż "
"mapuje Unikod na Unikod. "

msgid "These are the MBCS codec APIs. They are currently only available on Windows and use the Win32 MBCS converters to implement the conversions.  Note that MBCS (or DBCS) is a class of encodings, not just one.  The target encoding is defined by the user settings on the machine running the codec."
msgstr ""
"To są sprzęgi kodera/dekodera MBCS Obecnie dostępne są one tylko na Windows "
"i używają konwerterów MBCS Win32 aby wypełnić konwersje. Zauważ, że MBCS "
"(lub DBCS) jest kategorią kodowań, nie tylko jednym z nich.  Docelowe "
"kodowanie jest zdefiniowane przez ustawienia użytkownik na maszynie "
"uruchamiającej koder/dekoder."

msgid "MBCS codecs for Windows"
msgstr "Kodery/dekodery MBCS w Windows"

msgid "Methods & Slots"
msgstr "Sposoby postępowania i Gniazda"

msgid "Methods and Slot Functions"
msgstr "Sposoby postępowania i Zadania Gniazd"

msgid "The following APIs are capable of handling Unicode objects and strings on input (we refer to them as strings in the descriptions) and return Unicode objects or integers as appropriate."
msgstr ""
"Następujące sprzęgi (z ang. - API) są przydatne w posługiwaniu się "
"przedmiotami Unikodu i ciągów znaków na wejściu (odwołujemy się do nich jako "
"do ciągów w opisach) i zwracają przedmioty Unikodu lub liczby całkowite "
"jako właściwe."

msgid "They all return *NULL* or ``-1`` if an exception occurs."
msgstr ""
"Wszystkie one zwracają *PUSTY* ( - z ang. - *NULL* ) lub ``-1`` jeśli "
"nastąpi sytuacja wyjątkowa."

msgid "Utilities"
msgstr "Użytki"

msgid "The functions in this chapter perform various utility tasks, ranging from helping C code be more portable across platforms, using Python modules from C, and parsing function arguments and constructing Python values from C values."
msgstr ""
"Zadania w tym rozdziale wykonują różne działania użytkowe, poczynając od "
"pomagania kodowi C aby był bardziej przenośny pomiędzy maszynami, poprzez "
"używanie modułów języka pytonowskiego z poziomu C, i przetwarzając parametry "
"zadań i konstruując wartości języka pytonowskiego z wartości C."

msgid "The Very High Level Layer"
msgstr "Warstwa Bardzo Wysokiego Poziomu"

msgid "The functions in this chapter will let you execute Python source code given in a file or a buffer, but they will not let you interact in a more detailed way with the interpreter."
msgstr ""
"Zadania w tym rozdziale będą pozwalały Ci wykonywać kod w języku pytonowskim "
"podany w pliku lub przestrzeni wymiany, ale nie pozwolą Ci współpracować w "
"szczególny sposób z programem interpretującym polecenia języka "
"pytonowskiego."

msgid "Several of these functions accept a start symbol from the grammar as a parameter.  The available start symbols are :const:`Py_eval_input`, :const:`Py_file_input`, and :const:`Py_single_input`.  These are described following the functions which accept them as parameters."
msgstr ""
"Kilka z tych zadań akceptuje symbol startowy z gramatyki jako parametr. "
"Dostępnymi symbolami startowymi są :const:`Py_eval_input`, "
":const:`Py_file_input` i :const:`Py_single_input`. Są one opisane po "
"zadaniach akceptujących je jako parametry."

msgid "Note also that several of these functions take :ctype:`FILE\\*` parameters.  One particular issue which needs to be handled carefully is that the :ctype:`FILE` structure for different C libraries can be different and incompatible.  Under Windows (at least), it is possible for dynamically linked extensions to actually use different libraries, so care should be taken that :ctype:`FILE\\*` parameters are only passed to these functions if it is certain that they were created by the same library that the Python runtime is using."
msgstr ""
"Zwróć także uwagę że kilka z tych zadań przyjmuje pliki - :ctype:`FILE\\*` "
"jako paramtery. Jedną szczególną sprawą którą trzeba traktować uważnie jest "
"to, że struktura :ctype:`FILE` dla różnych bibliotek C może być różna i "
"niezgodna. Pod Windows (przynajmniej) możliwe jest dla dynamicznie łączonych "
"rozszerzeń użycie różnych bibliotek, więc powinno się zwrócić uwagę, aby "
"parametry :ctype:`FILE\\*` były przekazywane do tych zadań tylko gdy jest "
"pewne że zostały utworzone przez tą samą bibliotekę której używa aktualnie "
"wykonywany program interpretujący polecenia języka pytonowskiego."

msgid "Weak Reference Objects"
msgstr "Przedmioty Słabych Odniesień "

msgid "Python supports *weak references* as first-class objects.  There are two specific object types which directly implement weak references.  The first is a simple reference object, and the second acts as a proxy for the original object as much as it can."
msgstr ""
"Język pytonowskie wspiera *słabe odniesienia* jako przedmioty pierwszej-"
"klasy. Istnieją dwa szczególne rodzaje przedmiotów które bezpośrednio "
"wypełniają słabe odniesienia. Pierwszym jest prosty przedmiot odniesienia, a "
"drugi działa jako przedmiot zastępczy dla pierwotnego przedmiotu na tyle na "
"ile się da."
