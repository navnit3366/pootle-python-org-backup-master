<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.1.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Design and History FAQ</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>FAQ Histoire et Design</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does Python use indentation for grouping of statements?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi Python utilise l'indentation pour grouper les instructions ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guido van Rossum believes that using indentation for grouping is extremely elegant and contributes a lot to the clarity of the average Python program. Most people learn to love this feature after a while.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Guido van Rossum pense que l'usage de l'indentation pour regrouper les blocs d'instruction est élégant et contribue énormément à la clareté globale du programme Python. La plupart des gens finissent par aimer cette particularité au bout d'un moment.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since there are no begin/end brackets there cannot be a disagreement between grouping perceived by the parser and the human reader.  Occasionally C programmers will encounter a fragment of code like this::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comme il n'y a pas d'accolades de début/fin, il ne peut y avoir de différence entre le bloc perçu par l'analyseur syntaxique et le lecteur humain. Parfois les programmeurs C pourront trouver un morceau de code comme celui-ci::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (x &lt;= y)         x++;         y--; z++;</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>if (x &lt;= y) x++; y--; z++;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the ``x++`` statement is executed if the condition is true, but the indentation leads you to believe otherwise.  Even experienced C programmers will sometimes stare at it a long time wondering why ``y`` is being decremented even for ``x &gt; y``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Seule l'instruction ``x++`` sera exécutée si la condition est vraie, mais l'indentation pourrait vous faire penser le contraire. Mêmes des développeurs C expérimentés resteront pendant un moment à se demander pourquoi ``y`` est décrémenté même si ``x &gt; y``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because there are no begin/end brackets, Python is much less prone to coding-style conflicts.  In C there are many different ways to place the braces. If you're used to reading and writing code that uses one style, you will feel at least slightly uneasy when reading (or being required to write) another style.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comme il n'y a pas d'accolades de début/fin, Python est moins sujet aux conflits de style de code. En C, on peut placer les accolades de nombreuses façons. Si vous êtes habitués à lire et écrire selon un style particulier, vous pourriez vous sentir perturbé en lisant (ou en devant écrire) avec un autre style.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many coding styles place begin/end brackets on a line by themself.  This makes programs considerably longer and wastes valuable screen space, making it harder to get a good overview of a program.  Ideally, a function should fit on one screen (say, 20-30 lines).  20 lines of Python can do a lot more work than 20 lines of C.  This is not solely due to the lack of begin/end brackets -- the lack of declarations and the high-level data types are also responsible -- but the indentation-based syntax certainly helps.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Nombre de styles de programmation placent les accolades de début/fin sur une ligne à part. Cela rend les sources beaucoup plus longues et fait perdre une bonne partie de l'espace visible sur l'écran, rendant plus compliqué un aperçu global du programme. Idéalement, une fonction doit être visible sur un même écran (environ 20 ou 30 lignes). 20 lignes de Python peuvent faire beaucoup plus que 20 lignes de C. Ce n'est pas seulement dû à l'absence d'accolades de début/fin -- l'absence de déclarations et les types de haut-niveau en sont également responsables -- mais la syntaxe basée sur l'indentation y est pour beaucoup.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why am I getting strange results with simple arithmetic operations?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi ai-je d'étranges résultats suite à de simples opérations arithmétiques ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the next question.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Voir la question suivante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why are floating point calculations so inaccurate?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi les calculs à virgules flottantes sont si imprécis ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>People are often very surprised by results like this::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les gens sont très souvent surpris par des résultats comme celui-ci ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; 1.2 - 1.0 0.199999999999999996</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; 1.2 - 1.0 0.199999999999999996</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and think it is a bug in Python. It's not.  This has nothing to do with Python, but with how the underlying C platform handles floating point numbers, and ultimately with the inaccuracies introduced when writing down numbers as a string of a fixed number of digits.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>et pensent que c'est un bogue dans Python. Ça ne l'est pas. Ceci n'a rien à voir avec Python, mais avec la manière dont la plateforme C sous-jacente gère les nombres à virgule flottante et enfin, les imprécisions introduites lors de l'écriture des nombres en chaînes de caractères d'un nombre fixe de chiffres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The internal representation of floating point numbers uses a fixed number of binary digits to represent a decimal number.  Some decimal numbers can't be represented exactly in binary, resulting in small roundoff errors.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La représentation interne des nombres à virgule flottante utilise un nombre fixe de chiffres binaires pour représenter un nombre décimal. Certains nombres décimaux ne peuvent être représentés exactement en binaire, résultant ainsi à de petites erreurs d'arrondi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In decimal math, there are many numbers that can't be represented with a fixed number of decimal digits, e.g.  1/3 = 0.3333333333.......</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En mathématiques, beaucoup de nombre ne peuvent être représentés par un nombre fixe de chiffres, par exemple 1/3 = 0.3333333333.......</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In base 2, 1/2 = 0.1, 1/4 = 0.01, 1/8 = 0.001, etc.  .2 equals 2/10 equals 1/5, resulting in the binary fractional number 0.001100110011001...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En base 2, 1/2 = 0.1, 1/4 = 0.01, 1/8 = 0.001, etc.  .2 est égale à 2/10 qui est égale à 1/5, ayant pour résultat le nombre fractionnel binaire 0.001100110011001...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Floating point numbers only have 32 or 64 bits of precision, so the digits are cut off at some point, and the resulting number is 0.199999999999999996 in decimal, not 0.2.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les nombres à virgule flottante ont une précision de seulement 32 ou 64 bits, donc les chiffres finissent par être tronqués, et le nombre résultant est 0.199999999999999996 en décimal, pas 0.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A floating point number's ``repr()`` function prints as many digits are necessary to make ``eval(repr(f)) == f`` true for any float f.  The ``str()`` function prints fewer digits and this often results in the more sensible number that was probably intended::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La fonction ``repr()`` d'un nombre décimal affiche autant de chiffres que nécessaire pour rendre l'expression ``eval(repr(f)) == f`` vraie pour tout nombre décimal f. La fonction ``str()`` affiche moins de chiffres et correspond généralement plus au nombre attendu ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; 1.1 - 0.9 0.20000000000000007 &gt;&gt;&gt; print(1.1 - 0.9) 0.2</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; 1.1 - 0.9 0.20000000000000007 &gt;&gt;&gt; print(1.1 - 0.9) 0.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the consequences of this is that it is error-prone to compare the result of some computation to a float with ``==``. Tiny inaccuracies may mean that ``==`` fails.  Instead, you have to check that the difference between the two numbers is less than a certain threshold::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En conséquence  comparer le résultat d'un calcul avec un nombre flottant avec l'opérateur '==' est propice à l'obtention d'erreurs. D'infimes imprécisions peuvent faire qu'un test d'égalité avec "==" échoue. Au lieu de cela, vous devez vérifier que la différence entre les deux chiffres est inférieure à un certain seuil ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see the chapter on :ref:`floating point arithmetic &lt;tut-fp-issues&gt;` in the Python tutorial for more information.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Veuillez vous référer au chapitre sur :ref:`floating point arithmetic &lt;tut-fp-issues&gt;` du tutoriel python pour de plus amples informations.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why are Python strings immutable?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi les chaînes de caractères Python sont-elles immuable ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several advantages.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il y a plusieurs avantages.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One is performance: knowing that a string is immutable means we can allocate space for it at creation time, and the storage requirements are fixed and unchanging.  This is also one of the reasons for the distinction between tuples and lists.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La première concerne la performance : savoir qu'une chaîne de caractères est immuable signifie que l'allocation mémoire allouée lors de la création de cette chaîne est fixe et figé. C'est aussi l'une des raisons pour lesquelles on fait la distinction entre les tuples et les listes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another advantage is that strings in Python are considered as "elemental" as numbers.  No amount of activity will change the value 8 to anything else, and in Python, no amount of activity will change the string "eight" to anything else.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Un autre avantage est que les chaînes en Python sont considérées aussi "élémentaires" que les nombres. Aucun processus ne changera la valeur du nombre 8 en autre chose, et en Python, aucun processus changera la chaîne de caractère "huit" en autre chose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why must 'self' be used explicitly in method definitions and calls?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi "self" doit-il être explicitement utilisé dans les définitions et les appels de méthode ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The idea was borrowed from Modula-3.  It turns out to be very useful, for a variety of reasons.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>L'idée a été empruntée à Modula-3. Il s'avère être très utile, pour diverses raisons.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, it's more obvious that you are using a method or instance attribute instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it absolutely clear that an instance variable or method is used even if you don't know the class definition by heart.  In C++, you can sort of tell by the lack of a local variable declaration (assuming globals are rare or easily recognizable) -- but in Python, there are no local variable declarations, so you'd have to look up the class definition to be sure.  Some C++ and Java coding standards call for instance attributes to have an ``m_`` prefix, so this explicitness is still useful in those languages, too.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Tout d'abord, il est plus évident d'utiliser une méthode ou un attribut d'instance par exemple au lieu d'une variable locale. Lire ``self.x``  ou ``self.meth()`` est sans ambiguité sur le fait que c'est une variable d'instance ou une méthode qui est utilisée, même si vous ne connaissez pas la définition de classe par cœur. En C++, vous pouvez les reconnaitre par l'absence d'une déclaration de variable locale (en supposant que les variables globales sont rares ou facilement reconnaissables) - mais en Python, il n'y a pas de déclarations de variables locales, de sorte que vous devez chercher la définition de classe pour être sûr. Certaines normes de codages C++ et Java préfixent les attributs d'instance par ``m_``. Cette syntaxe explicite est ainsi utile également pour ces langages.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, it means that no special syntax is necessary if you want to explicitly reference or call the method from a particular class.  In C++, if you want to use a method from a base class which is overridden in a derived class, you have to use the ``::`` operator -- in Python you can write ``baseclass.methodname(self, &lt;argument list&gt;)``.  This is particularly useful for :meth:`__init__` methods, and in general in cases where a derived class method wants to extend the base class method of the same name and thus has to call the base class method somehow.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ensuite, ça veut dire qu'aucune syntaxe spéciale n'est nécessaire si vous souhaitez explicitement référencer ou appeler la méthode depuis une classe en particulier. En C++, si vous utilisez la méthode d'une classe de base elle-même surchargée par une classe dérivée, vous devez utiliser l'opérateur ``::`` -- en Python vous pouvez écrire ``baseclass.methodname(self, &lt;argument list&gt;)``. C'est particulièrement utile pour les méthodes :meth:`__init__`, et de manière générale dans les cas où une classe dérivée veut étendre la méthode du même nom de la classe de base, devant ainsi appeler la méthode de la classe de base d'une certaine manière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, for instance variables it solves a syntactic problem with assignment: since local variables in Python are (by definition!) those variables to which a value is assigned in a function body (and that aren't explicitly declared global), there has to be some way to tell the interpreter that an assignment was meant to assign to an instance variable instead of to a local variable, and it should preferably be syntactic (for efficiency reasons).  C++ does this through declarations, but Python doesn't have declarations and it would be a pity having to introduce them just for this purpose.  Using the explicit ``self.var`` solves this nicely.  Similarly, for using instance variables, having to write ``self.var`` means that references to unqualified names inside a method don't have to search the instance's directories.  To put it another way, local variables and instance variables live in two different namespaces, and you need to tell Python which namespace to use.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Enfin, pour des variables d'instance, ça résout un problème syntactique pour l'assignation : puisque les variables locales en Python sont (par définition !) ces variables auxquelles les valeurs sont assignées dans le corps d'une fonction (et n'étant pas déclarées explicitement globales), il doit y avoir un moyen de dire à l'interpréteur qu'une assignation est censée assigner une variable d'instance plutôt qu'une variable locale, et doit de préférence être syntactique (pour des raisons d'efficacité). C++ fait ça au travers de déclarations, mais Python n'a pas de déclarations et ça serait dommage d'avoir à les introduire juste pour cette raison. Utiliser explicitement ``self.var`` résout ça avec élégance. Pareillement, pour utiliser des variables d'instance, avoir à écrire ``self.var`` signifie que les références vers des noms non-qualifiés au sein d'une méthode n'ont pas à être cherchés dans l'annuaire d'instances. En d'autres termes, les variables locales et les variables d'instance vivent dans deux différents espaces de noms, et vous devez dire à Python quel espace de noms utiliser.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why can't I use an assignment in an expression?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi ne puis-je pas utiliser d'assignation dans une expression ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many people used to C or Perl complain that they want to use this C idiom:</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>De nombreuses personnes habituées à C ou Perl se plaignent de vouloir utiliser cet idiome C :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>while (line = readline(f)) {     // do something with line }</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>while (line = readline(f)) { // faire quelque chose avec line }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where in Python you're forced to write this::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>où en Python vous êtes forcé à écrire ceci ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>while True:     line = f.readline()     if not line:         break     ... # do something with line</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>while True: line = f.readline() if not line: break ... # faire quelque chose avec line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason for not allowing assignment in Python expressions is a common, hard-to-find bug in those other languages, caused by this construct:</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La raison pour ne pas autoriser l'assignation dans les expressions en Python est un bug fréquent, et difficile à trouver dans ces autres langages, causé par cette construction :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (x = 0) {     // error handling } else {     // code that only works for nonzero x }</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>if (x = 0) { // prise en charge de l'erreur } else { // code qui ne fonctionne que quand x est non-zéro }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The error is a simple typo: ``x = 0``, which assigns 0 to the variable ``x``, was written while the comparison ``x == 0`` is certainly what was intended.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cette erreur est une simple coquille : ``x = 0``, qui assigne 0 à la variable ``x``, a été écrit alors que la comparaison ``x == 0`` est certainement ce qui était souhaité.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many alternatives have been proposed.  Most are hacks that save some typing but use arbitrary or cryptic syntax or keywords, and fail the simple criterion for language change proposals: it should intuitively suggest the proper meaning to a human reader who has not yet been introduced to the construct.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>De nombreuses alternatives ont été proposées. La plupart des hacks économisaient de la frappe mais utilisaient d'arbitraires ou cryptiques syntaxes ou mot-clés et faillait le simple critère pour proposition de changement du langage : ça doit intuitivement suggérer la bonne signification au lecteur qui n'a pas encore été introduit à la construction.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interesting phenomenon is that most experienced Python programmers recognize the ``while True`` idiom and don't seem to be missing the assignment in expression construct much; it's only newcomers who express a strong desire to add this to the language.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Un phénomène intéressant est que la plupart des programmeurs Python expérimentés reconnaissent l'idiome ``while True`` et ne semblent pas manquer l'assignation dans la construction de l'expression; seuls les nouveaux-venus expriment un fort désir d'ajouter ceci au langage.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's an alternative way of spelling this that seems attractive but is generally less robust than the "while True" solution::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il y a une manière alternative de faire ça qui semble attrayante mais elle est généralement moins robuste que la solution ``while True`` ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>line = f.readline() while line:     ... # do something with line...     line = f.readline()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>line = f.readline() while line: ... # faire quelque chose avec line... line = f.readline()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The problem with this is that if you change your mind about exactly how you get the next line (e.g. you want to change it into ``sys.stdin.readline()``) you have to remember to change two places in your program -- the second occurrence is hidden at the bottom of the loop.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Le problème avec ceci est que si vous changez d'avis sur la manière dont vous allez récupérer la prochaine ligne (ex : vous voulez changer en ``sys.stdin.readline()``) vous devez vous souvenir de le changer à deux endroits dans votre programme -- la deuxième occurrence est cachée en bas de la boucle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best approach is to use iterators, making it possible to loop through objects using the ``for`` statement.  For example, in the current version of Python file objects support the iterator protocol, so you can now write simply::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La meilleur approche est d'utiliser les itérateurs, rendant possible de boucler au travers d'objets en utilisant la déclaration ``for``. Par exemple, dans la version actuelle de Python, les fichiers objets supportent le protocole d'itérateur, vous pouvez alors simplement écrire ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for line in f:     ... # do something with line...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>for line in f: ... # faire quelque chose avec line...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi Python utilise des méthodes pour certaines fonctionnalités (ex : list.index()) mais des fonctions pour d'autres (ex : len(list)) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The major reason is history. Functions were used for those operations that were generic for a group of types and which were intended to work even for objects that didn't have methods at all (e.g. tuples).  It is also convenient to have a function that can readily be applied to an amorphous collection of objects when you use the functional features of Python (``map()``, ``apply()`` et al).</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La raison principale est historique. Les fonctions étaient utilisées pour ces opérations qui étaient génériques pour un groupe de types et qui étaient censés fonctionner même pour les objets qui n'avaient pas de méthodes du tout (ex : tuples). C'est aussi pratique d'avoir une fonction qui s'apprête bien à une collection amorphe d'objets lorsque vous utiliser les fonctionnalités fonctionnelles de Python (``map()``, ``apply()`` et autres).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In fact, implementing ``len()``, ``max()``, ``min()`` as a built-in function is actually less code than implementing them as methods for each type.  One can quibble about individual cases but it's a part of Python, and it's too late to make such fundamental changes now. The functions have to remain to avoid massive code breakage.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En fait, implémenter ``len()``, ``max()``, ``min()`` en tant que fonction intégrée produit moins de code que de les implémenter en tant que méthode pour chaque type. Certains peuvent rouspéter pour des cas individuels mais ça fait partie de Python et il est trop tard pour faire des changements si fondamentaux maintenant. Ces fonctions doivent rester pour éviter la casse massive de code.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For string operations, Python has moved from external functions (the ``string`` module) to methods.  However, ``len()`` is still a function.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les opérations de chaînes, Python a déplacé les fonctions externes (le module ``string``) vers des méthodes. Cependant, ``len()`` est toujours une fonction.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why is join() a string method instead of a list or tuple method?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi join() est une méthode de chaîne plutôt qu'une de liste ou de tuple ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings became much more like other standard types starting in Python 1.6, when methods were added which give the same functionality that has always been available using the functions of the string module.  Most of these new methods have been widely accepted, but the one which appears to make some programmers feel uncomfortable is::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les chaînes sont devenues bien plus comme d'autres types standards à partir de Python 1.6, lorsque les méthodes ont été ajoutées fournissant ainsi les mêmes fonctionnalités que celles qui étaient déjà disponibles en utilisant les fonctions du module string. La plupart de ces nouvelles méthodes ont été largement acceptées, mais celle qui semble rendre certains programmeurs inconfortables est ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>", ".join(['1', '2', '4', '8', '16'])</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>", ".join(['1', '2', '4', '8', '16'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which gives the result::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>qui donne le résultat ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"1, 2, 4, 8, 16"</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>"1, 2, 4, 8, 16"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two common arguments against this usage.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il y a deux arguments fréquents contre cet usage.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first runs along the lines of: "It looks really ugly using a method of a string literal (string constant)", to which the answer is that it might, but a string literal is just a fixed value. If the methods are to be allowed on names bound to strings there is no logical reason to make them unavailable on literals.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Le premier se caractérise par les lignes suivantes : "C'est vraiment moche d'utiliser une méthode de chaîne littérale (chaîne constante)", à laquelle la réponse est qu'il se peut, mais une chaîne littérale est juste une valeur fixe. Si la méthode est autorisée sur des noms liés à des chaînes, il n'y a pas de raison logique à les rendre indisponibles sur des chaînes littérales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second objection is typically cast as: "I am really telling a sequence to join its members together with a string constant".  Sadly, you aren't.  For some reason there seems to be much less difficulty with having :meth:`~str.split` as a string method, since in that case it is easy to see that ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La deuxième objection se réfère typiquement à : "Je suis réellement en train de dire à une séquence de joindre ses membres avec une constante de chaîne". Malheureusement, vous ne l'êtes pas. Pour quelque raison, il semble être bien moins difficile d'avoir :meth:`~str.split` en tant que méthode de chaîne, puisque dans ce cas il est facile de voir que ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"1, 2, 4, 8, 16".split(", ")</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>"1, 2, 4, 8, 16".split(", ")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is an instruction to a string literal to return the substrings delimited by the given separator (or, by default, arbitrary runs of white space).</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>est une instruction à une chaîne littérale de retourner les sous-chaînes délimitées par le séparateur fournit (ou, par défaut, les espaces).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:meth:`~str.join` is a string method because in using it you are telling the separator string to iterate over a sequence of strings and insert itself between adjacent elements.  This method can be used with any argument which obeys the rules for sequence objects, including any new classes you might define yourself. Similar methods exist for bytes and bytearray objects.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>:meth:`~str.join` est une méthode de chaîne parce qu'en l'utilisant vous dites au séparateur de chaîne d'itérer autour d'une séquence de chaînes et de s'insérer entre les éléments adjacents. Cette méthode peut être utilisée avec n'importe quel argument qui obéit aux règles d'objets séquence, incluant n'importe quelles nouvelles classes que vous pourriez définir vous-même. Des méthodes similaires existent pour des objets bytes et bytearray.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using global variables.  This isn't thread-safe, and is not recommended.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En utilisant des variables globales. Ce qui n'est pas thread-safe, et n'est donc pas recommandé.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By passing a mutable (changeable in-place) object::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En passant un objet mutable (modifiable par remplacement)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By passing in a dictionary that gets mutated::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En utilisant un dictionnaire, qui est modifié (en place).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's almost never a good reason to get this complicated.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il n'y a pratiquement jamais de bonne raison de faire quelque chose d'aussi compliqué.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your best choice is to return a tuple containing the multiple results.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Votre meilleure option est de renvoyer un tuple contenant les résultats multiples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do you make a higher order function in Python?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment construire une fonction de grand ordre en Python?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have two choices: you can use nested scopes or you can use callable objects. For example, suppose you wanted to define ``linear(a,b)`` which returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested scopes::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Vous avez deux choix: vous pouvez utiliser les portées imbriquées ou vous pouvez utiliser des objets appelable. Par exemple, supposons que vous vouliez définir ``lineare (a, b)`` qui retourne une fonction ``f (x)`` qui calcule la valeur ``a * x + b``. En utilisant les portées imbriquées::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def linear(a, b):     def result(x):         return a * x + b     return result</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def linear(a, b): def result(x): return a * x + b return result</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or using a callable object::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ou en utilisant un objet appelable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both cases, ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>dans les deux cas, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>retourne un objet appelable tel que ``taxes(10e6) == 0.3 * 10e6 + 2``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The callable object approach has the disadvantage that it is a bit slower and results in slightly longer code.  However, note that a collection of callables can share their signature via inheritance::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>L'approche par objet appelables a le désavantage d'être légèrement plus lente et de produire un code légèrement plus long. Cependant, il faut noter qu'une collection d'objet appelables peuvent partager leur signatures par héritage::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the same counting variable.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ici ``inc()``, ``dec()`` et ``reset`` agissent comme des fonctions partageant une même variable compteur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I copy an object in Python?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment copier un objet en Python?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general case. Not all objects can be copied, but most can.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En général, essayez :funct:`copy.copy` ou :func:`copy.deepcopy` pour le cas général. Tout les objets ne peuvent pas être copiés, mais la plupart peuvent.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some objects can be copied more easily.  Dictionaries have a :meth:`~dict.copy` method::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Certains objects peuvent être copiés plus facilement. Les Dictionnaires ont une méthode :meth:`~dict.copy` ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>newdict = olddict.copy()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>newdict = olddict.copy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequences can be copied by slicing::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les séquences peuvent être copiées par tranches::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>new_l = l[:]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>new_l = l[:]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I find the methods or attributes of an object?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je trouver les méthodes ou les attribues d'un objet?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For an instance x of a user-defined class, ``dir(x)`` returns an alphabetized list of the names containing the instance attributes and methods and attributes defined by its class.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour une instance x d'une classe définie par un utilisateur, ``dir(x)`` renvoie une liste alphabétique des noms contenants les attributs de l'instance, et les attributs et méthodes définies par sa classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can my code discover the name of an object?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment mon code peut il découvrir le nom d'un objet?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally speaking, it can't, because objects don't really have names. Essentially, assignment always binds a name to a value; The same is true of ``def`` and ``class`` statements, but in that case the value is a callable. Consider the following code::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>De façon générale, il ne peut pas, par ce que les objets n'ont pas réellement de noms. Essentiellement, l'assignation attache un nom à une valeur; C'est vrai aussi pour les mots clés ``def`` et ``class``, à la différence que la valeur est un objet appelable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arguably the class has a name: even though it is bound to two names and invoked through the name B the created instance is still reported as an instance of class A.  However, it is impossible to say whether the instance's name is a or b, since both names are bound to the same value.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Le fait que la classe ait un nom est discutable, même si elle a deux noms et qu'elle est appelé via le nom B, l'instance crée déclare tout de même être une instance de la classe A. De même Il est impossible de dire si le nom de l'instance est a ou b, les deux noms sont attachés à la même valeur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally speaking it should not be necessary for your code to "know the names" of particular values. Unless you are deliberately writing introspective programs, this is usually an indication that a change of approach might be beneficial.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>De façon général, il ne devrait pas être nécessaire pour votre application de "connaitre le nom" d'une valeur particulière. À moins que vous soyez délibérément en train d'écrire un programme introspectif, c'est souvent une indication qu'un changement d'approche pourrait être bénéfique.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to this question:</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Sur comp.lang.python, Fredrik Lundh a donné un jour une excellente analogie pour répondre à cette question:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same way as you get the name of that cat you found on your porch: the cat (object) itself cannot tell you its name, and it doesn't really care -- so the only way to find out what it's called is to ask all your neighbours (namespaces) if it's their cat (object)...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>De la même manière que vous trouvez le nom du chat que vous avez trouvé dans votre coure: le chat ne peux pas vous dire lui même son nom, et il s'en moque un peu -- alors le meilleur moyen de savoir comment il est appelé est de demander à tous vos voisins (namespaces) si c'est leur chat (object)…</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>....and don't be surprised if you'll find that it's known by many names, or no name at all!</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>…et ne soyez pas surpris si vous découvrez qu'il est connus sous plusieurs noms différents, ou pas de nom du tout!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's up with the comma operator's precedence?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Quel est le souci avec la précédente de l'opérateur virgule?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comma is not an operator in Python.  Consider this session::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Virgule n'est pas un opérateur en Python. Observez la session suivante::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; "a" in "b", "a" (False, 'a')</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; "a" in "b", "a" (False, 'a')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the comma is not an operator, but a separator between expressions the above is evaluated as if you had entered::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comme la virgule n'est pas un opérateur, mais un séparateur entre deux expression, l'expression ci dessus, est évaluée de la même façon que si vous aviez écrit::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; ("a" in "b"), "a"</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; ("a" in "b"), "a"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>not::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>et non::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; "a" in ("b", "a")</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; "a" in ("b", "a")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same is true of the various assignment operators (``=``, ``+=`` etc).  They are not truly operators but syntactic delimiters in assignment statements.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ceci est vrai de tous les opérateurs d'assignations (``=``, ``+=`` etc). Ce ne sont pas vraiment des opérateurs mais des délimiteurs syntaxiques dans les instructions d'assignation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is there an equivalent of C's "?:" ternary operator?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Existe-t'il un équivalent à l'opérateur "?:" ternaire du C?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, this feature was added in Python 2.5. The syntax would be as follows::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Oui, cette fonctionnalité à été ajouté à partir de Python 2.5. La syntaxe est la suivante::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[on_true] if [expression] else [on_false]  x, y = 50, 25  small = x if x &lt; y else y</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>[on_true] if [expression] else [on_false] x, y = 50, 25 small = x if x &lt; y else y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For versions previous to 2.5 the answer would be 'No'.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les versions précédentes de python la réponse serait "Non".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In many cases you can mimic ``a ? b : c`` with ``a and b or c``, but there's a flaw: if *b* is zero (or empty, or ``None`` -- anything that tests false) then *c* will be selected instead.  In many cases you can prove by looking at the code that this can't happen (e.g. because *b* is a constant or has a type that can never be false), but in general this can be a problem.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Dans de nombreux cas vous pouvez imiter ``a ? b : c`` par ``a and b or c``, mais il y a une faille: si *b* est zéro (ou vide ou None -- n'importe quoi qui soit assimilé à False) alors *c* sera choisit à la place. Dans de nombreux cas vous pouvez montrer que ça ne peux pas arriver par observation du code (par exemple si *b* est une constante ou est d'un type ne pouvant être assimilé à False), mais dans le cas général cela peut être un problème.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tim Peters (who wishes it was Steve Majewski) suggested the following solution: ``(a and [b] or [c])[0]``.  Because ``[b]`` is a singleton list it is never false, so the wrong path is never taken; then applying ``[0]`` to the whole thing gets the *b* or *c* that you really wanted.  Ugly, but it gets you there in the rare cases where it is really inconvenient to rewrite your code using 'if'.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Tim Peters (qui aurait souhaité que ce soit Steve Majewski) a suggéré la solution suivante: ``(a and [b] or [c])[0]``. Comme ``[b]`` est une liste d'un seul élément, il n'est jamais évalué à faux, le mauvais chemin n'est donc jamais prit, et appliquer ``[0]`` à l'ensemble vous donne le *b* ou *c* qque vous vouliez vraiment. Peu élégant, mais cela vous donne une solution pour les rares cas où il est vraiment peu pratique de réécrire le code sur une base de ``if``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best course is usually to write a simple ``if...else`` statement.  Another solution is to implement the ``?:`` operator as a function::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La meilleure solution est souvent d'écrire un simple ``if…else``. Une autre solution est d'implémenter l'opérateur ``?:`` comme une fonction::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def q(cond, on_true, on_false):     if cond:         if not isfunction(on_true):             return on_true         else:             return on_true()     else:         if not isfunction(on_false):             return on_false         else:             return on_false()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def q(cond, on_true, on_false):    if cond:        if not isfunction(on_true):            return on_true        else:            return on_true()    else:        if not isfunction(on_false):            return on_false        else:            return on_false()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most cases you'll pass b and c directly: ``q(a, b, c)``.  To avoid evaluating b or c when they shouldn't be, encapsulate them within a lambda function, e.g.: ``q(a, lambda: b, lambda: c)``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Dans la plupart des cas vous pourrez passer b et c directement: ``q(a,b,c)``. Pour éviter d'évaluer b et c quand il ne faut pas, encapsulez les dans une fonction lambda, exemple:``q(a, lambda: b, lambda: c)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It has been asked *why* Python has no if-then-else expression.  There are several answers: many languages do just fine without one; it can easily lead to less readable code; no sufficiently "Pythonic" syntax has been discovered; a search of the standard library found remarkably few places where using an if-then-else expression would make the code more understandable.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il a souvent été demandé *pourquoi* Python n'avait pas d'expression if-the-else. Il y a plusieurs réponses à cette question: beaucoup de langages s'en sertent très bien sans en avoir une; elle peut aisément conduire à du code moins lisible; aucune syntaxe suffisamment "Pythonique" n'a été trouvée; une recherche dans la librairie standard à trouvé remarquablement peu d'endroit ou utiliser une expression if-then-else aurait rendu le code plus compréhensible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In 2002, :pep:`308` was written proposing several possible syntaxes and the community was asked to vote on the issue.  The vote was inconclusive.  Most people liked one of the syntaxes, but also hated other syntaxes; many votes implied that people preferred no ternary operator rather than having a syntax they hated.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En 2002, la :pep:`308` à été écrite, proposant plusieurs syntaxes et la communauté fut invité à voter. Le vote ne permit pas de tirer de conséquences. La plupart des gens aimaient une des syntaxes, mais détestaient les autres syntaxes; de nombreux votent exprimaient que les gens préféraient ne pas avoir d'opérateur ternaire que d'avoir une syntaxe qu'il détestent.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is it possible to write obfuscated one-liners in Python?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Est-il possible d'écrire des programmes volontairement difficile à comprendre sur une seule ligne en Python?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`lambda`.  See the following three examples, due to Ulf Bartelt::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Oui. Cela est généralement réalisé en imbriquant les :keyword:`lambda` les uns dans les autres. Observez les trois exemples suivants, contribués par Ulf Bartelt::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from functools import reduce  # Primes &lt; 1000 print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0, map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))  # First 10 Fibonacci numbers print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x&gt;1 else 1: f(x,f), range(10))))  # Mandelbrot set print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y, Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM, Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro, i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k&lt;=0)or (x*x+y*y &gt;=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr( 64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24)) #    \___ ___/  \___ ___/  |   |   |__ lines on screen #        V          V      |   |______ columns on screen #        |          |      |__________ maximum of "iterations" #        |          |_________________ range on y axis #        |____________________________ range on x axis</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>from functools import reduce # Primes &lt; 1000 print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0, map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000))))) # First 10 Fibonacci numbers print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x&gt;1 else 1: f(x,f), range(10)))) # Mandelbrot set print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y, Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM, Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro, i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k&lt;=0)or (x*x+y*y &gt;=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr( 64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24)) # \___ ___/ \___ ___/ | | |__ lines on screen # V V | |______ columns on screen # | | |__________ maximum of "iterations" # | |_________________ range on y axis # |____________________________ range on x axis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't try this at home, kids!</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les enfants, ne faîtes pas ça chez vous!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers and strings</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Nombres et chaines de caractères</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I specify hexadecimal and octal integers?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je spécifier des entiers hexadécimaux ou octaux?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify an octal digit, precede the octal value with a zero, and then a lower or uppercase "o".  For example, to set the variable "a" to the octal value "10" (8 in decimal), type::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour spécifier un entier octal, faites précéder la valeur octale par un zéro, puis un "o" majuscule ou minuscule. Par exemple assigner la valeur octale "10" (8 en décimal) à "a", tapez::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; a = 0o10 &gt;&gt;&gt; a 8</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; a = 0o10&gt;&gt;&gt; a 8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hexadecimal is just as easy.  Simply precede the hexadecimal number with a zero, and then a lower or uppercase "x".  Hexadecimal digits can be specified in lower or uppercase.  For example, in the Python interpreter::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>L'hexadécimal est tout aussi simple, faîtes précéder le nombre hexadécimal par un zéro, puis un "x" majuscule ou minuscule. Les nombres hexadécimaux peuvent être écrit en majuscules ou en minuscules. Par exemple, dans l'interpréteur Python::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; a = 0xa5 &gt;&gt;&gt; a 165 &gt;&gt;&gt; b = 0XB2 &gt;&gt;&gt; b 178</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; a = 0xa5 &gt;&gt;&gt; a 165 &gt;&gt;&gt; b = 0XB2 &gt;&gt;&gt; b 178</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does -22 // 10 return -3?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pourquoi -22//10 retourne-t'il -3?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's primarily driven by the desire that ``i % j`` have the same sign as ``j``. If you want that, and also want::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cela est principalement due à la volonté que ``i % j`` ait le même signe que j. Si vous voulez cela, vous voulez aussi::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i == (i // j) * j + (i % j)</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>i == (i // j) * j + (i % j)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then integer division has to return the floor.  C also requires that identity to hold, and then compilers that truncate ``i // j`` need to make ``i % j`` have the same sign as ``i``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Alors la division entière doit retourner l'entier inférieur. Le C demande aussi à ce que cette égalité soit vérifiée, et donc les compilateur qui tronquent ``i//j`` ont besoin que ``i % j`` ait le même signe que ``i``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are few real use cases for ``i % j`` when ``j`` is negative.  When ``j`` is positive, there are many, and in virtually all of them it's more useful for ``i % j`` to be ``&gt;= 0``.  If the clock says 10 now, what did it say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a bug waiting to bite.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il y a peu de cas d'utilisation réels pour ``i%j`` quand ``j`` est négatif. Quand ``j`` est positif, il y en a beaucoup, et dans pratiquement tous, il est plus utile que ``i % j`` soit ``&gt;=0``. Si l'horloge dit 10h maintenant, que disait-elle il y a 200 heures? ``-190%12 == 2`` est utile; ``-192 % 12 == -10`` est un bug qui attends pour mordre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I convert a string to a number?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je convertir une chaine de caractère en nombre?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For integers, use the built-in :func:`int` type constructor, e.g. ``int('144') == 144``.  Similarly, :func:`float` converts to floating-point, e.g. ``float('144') == 144.0``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les entiers, utilisez la fonction built-in :func: `int` de type constructeur, par exemple ``int('144') == 144``. De façon similaire, :func:`float` convertit en valeur flottante, par exemple ``float('144')`` == 144.0``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, these interpret the number as decimal, so that ``int('0144') == 144`` and ``int('0x144')`` raises :exc:`ValueError`. ``int(string, base)`` takes the base to convert from as a second optional argument, so ``int('0x144', 16) == 324``.  If the base is specified as 0, the number is interpreted using Python's rules: a leading '0' indicates octal, and '0x' indicates a hex number.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Par défaut, ces fonctions interprètent les nombre en tant que décimaux, de telles façons que ``int('0144')==144`` et ``int('0x144')`` remontent :exc:`ValueError`. ``int(string, base)`` prends la base depuis laquelle il faut convertir dans le second argument, optionnel, donc ``int('0x144', 16) == 324``. Si la base donnée est 0, le nombre est interprété selon les règles Python: un '0' en tête indique octal, et '0x' indique un hexadécimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use the built-in function :func:`eval` if all you need is to convert strings to numbers.  :func:`eval` will be significantly slower and it presents a security risk: someone could pass you a Python expression that might have unwanted side effects.  For example, someone could pass ``__import__('os').system("rm -rf $HOME")`` which would erase your home directory.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>N'utilisez pas la fonction built-in :func:`eval` si tout ce que vous avez besoin est de convertir des chaines en nombres. :func:`eval` sera significativement plus lent et implique des risque de sécurité: quelqu'un pourrait vous envoyez une expression Python pouvant avoir des effets de bord indésirables. Par exemple, quelqu'un pourrait passer ``__import__('os').system("rm -rf $HOME")`` ce qui aurait pour effet d'effacer votre répertoire personnel.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:func:`eval` also has the effect of interpreting numbers as Python expressions, so that e.g. ``eval('09')`` gives a syntax error because Python does not allow leading '0' in a decimal number (except '0').</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>:func:`eval` a aussi pour effet d'interpréter les nombres comme comme des expression python, ainsi ``eval('09')`` produit une erreur de syntaxe par ce que Python ne permet pas les '0' en tête d'un nombre décimal (à l'exception du nombre '0').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I convert a number to a string?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment convertir un nombre en chaine de caractère?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I modify a string in place?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment modifier une chaine de caractère "en place"?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can't, because strings are immutable.  If you need an object with this ability, try converting the string to a list or use the array module::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Vous ne pouvez pas, par ce que les chaines de caractères sont immuables, Si vous avez besoin d'un objet ayant une telle capacité, essayez de convertir la chaine en liste, ou utilisez le module array::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; s = "Hello, world" &gt;&gt;&gt; a = list(s) &gt;&gt;&gt; print(a) ['H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd'] &gt;&gt;&gt; a[7:] = list("there!") &gt;&gt;&gt; ''.join(a) 'Hello, there!'  &gt;&gt;&gt; import array &gt;&gt;&gt; a = array.array('u', s) &gt;&gt;&gt; print(a) array('u', 'Hello, world') &gt;&gt;&gt; a[0] = 'y' &gt;&gt;&gt; print(a) array('u', 'yello world') &gt;&gt;&gt; a.tounicode() 'yello, world'</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; s = "Hello, world" &gt;&gt;&gt; a = list(s) &gt;&gt;&gt; print(a) ['H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd'] &gt;&gt;&gt; a[7:] = list("there!") &gt;&gt;&gt; ''.join(a) 'Hello, there!' &gt;&gt;&gt; import array &gt;&gt;&gt; a = array.array('u', s) &gt;&gt;&gt; print(a) array('u', 'Hello, world') &gt;&gt;&gt; a[0] = 'y' &gt;&gt;&gt; print(a) array('u', 'yello world') &gt;&gt;&gt; a.tounicode() 'yello, world'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I use strings to call functions/methods?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment utiliser des chaines de caractères pour appeler des fonctions/méthodes?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various techniques.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il y a différentes techniques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best is to use a dictionary that maps strings to functions.  The primary advantage of this technique is that the strings do not need to match the names of the functions.  This is also the primary technique used to emulate a case construct::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La meilleure est d'utiliser un dictionnaire qui fait correspondre les chaines de caractères à des fonctions. Le principal avantage de cette technique est que les chaines n'ont pas besoin d'être égales aux noms de fonctions. C'est aussi la principale façon d'imiter la construction "case"::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def a():     pass  def b():     pass  dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs  dispatch[get_input()]()  # Note trailing parens to call function</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def a(): pass def b(): pass dispatch = {'go': a, 'stop': b} # Note lack of parens for funcs dispatch[get_input()]() # Note trailing parens to call function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the built-in function :func:`getattr`::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utiliser la fonction :func:`getattr`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import foo getattr(foo, 'bar')()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>import foo getattr(foo, 'bar')()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that :func:`getattr` works on any object, including classes, class instances, modules, and so on.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Notez que :func:`getattr` marche sur n'importe quel objet, ceci inclue les classes, les instances de classes, les modules et ainsi de suite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is used in several places in the standard library, like this::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ceci est utilisé dans plusieurs endroit de la bibliothèque standard, de cette façon::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Foo:     def do_foo(self):         ...      def do_bar(self):         ...  f = getattr(foo_instance, 'do_' + opname) f()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class Foo: def do_foo(self): ... def do_bar(self): ... f = getattr(foo_instance, 'do_' + opname) f()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use :func:`locals` or :func:`eval` to resolve the function name::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utilisez :func:`locals` ou :func:`eval` pour résoudre le nom de fonction::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def myFunc():     print("hello")  fname = "myFunc"  f = locals()[fname] f()  f = eval(fname) f()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def myFunc(): print("hello") fname = "myFunc" f = locals()[fname] f() f = eval(fname) f()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: Using :func:`eval` is slow and dangerous.  If you don't have absolute control over the contents of the string, someone could pass a string that resulted in an arbitrary function being executed.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Note: En utilisant :func:`eval` est lent est dangereux. Si vous n'avez pas un contrôle absolu sur le contenu de la chaine de caractère, quelqu'un peut passer une chaine de caractère pouvant résulter en l'exécution de code arbitraire.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is there an equivalent to Perl's chomp() for removing trailing newlines from strings?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Existe-t'il un équivalent à la fonction chomp() de Perl, pour retirer les caractères de fin de ligne d'une chaine de caractère?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Python 2.2, you can use ``S.rstrip("\r\n")`` to remove all occurences of any line terminator from the end of the string ``S`` without removing other trailing whitespace.  If the string ``S`` represents more than one line, with several empty lines at the end, the line terminators for all the blank lines will be removed::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>À partir de Python 2.2 vous pouvez utiliser ``S.rstrip("&#13;
")`` pour retirer toute occurrence de n'importe quel terminateur de ligne à la fin d'une chaine de caractère ``S``, sans retirer aucun espace de fin de ligne. Si la chaine ``S`` représente plus d'une ligne, avec plusieurs lignes vides, les terminateurs de lignes de toutes les lignes vides seront retirés::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; lines = ("line 1 \r\n" ...          "\r\n" ...          "\r\n") &gt;&gt;&gt; lines.rstrip("\n\r") 'line 1 '</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; lines = ("line 1 &#13;
" ... "&#13;
" ... "&#13;
") &gt;&gt;&gt; lines.rstrip("
&#13;") 'line 1 '</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since this is typically only desired when reading text one line at a time, using ``S.rstrip()`` this way works well.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Du fait que ce soit principalement utile en lisant un texte ligne à ligne, utiliser ``S.rstrip()`` devrait marcher correctement.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For older versions of Python, there are two partial substitutes:</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les versions plus anciennes de python, il y a deux substituts partiels disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to remove all trailing whitespace, use the ``rstrip()`` method of string objects.  This removes all trailing whitespace, not just a single newline.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Si vous voulez retirer tous les espaces de fin de ligne, utilisez la méthode ``rstrip()`` des chaines de caractères. Cela retire tous les espaces de fin de ligne, pas seulement le caractère de fin de ligne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, if there is only one line in the string ``S``, use ``S.splitlines()[0]``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Sinon, s'il y a seulement une ligne dans la chaine ``S``, utilisez ``S.splitlines()``[0].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is there a scanf() or sscanf() equivalent?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Existe-t'il un équivalent à scanf() ou sscanf()?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not as such.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pas exactement.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For simple input parsing, the easiest approach is usually to split the line into whitespace-delimited words using the :meth:`~str.split` method of string objects and then convert decimal strings to numeric values using :func:`int` or :func:`float`.  ``split()`` supports an optional "sep" parameter which is useful if the line uses something other than whitespace as a separator.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour une simple analyse de chaine, l'approche la plus simple est généralement de découper la ligne en mots délimités par des espaces, en utilisant la méthode :meth:`~str.split` des objets chaine de caractères, et ensuite de convertir les chaines de décimales en valeurs numériques en utilisant la fonction :func:`int` ou :func:`float`, ``split()`` supporte un paramètre optionnel "sep" qui est utile si la ligne utilise autre chose que des espaces comme séparateur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more complicated input parsing, regular expressions more powerful than C's :cfunc:`sscanf` and better suited for the task.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les analyses plus compliquées, les expressions rationnelles sont plus puissantes que la fonction `sscanf` de C et mieux adaptées à la tâche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Que signifient les erreurs  'UnicodeDecodeError' ou 'UnicodeEncodeError'?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequences (Tuples/Lists)</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Sequences (Tuples/Lists)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I convert between tuples and lists?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment convertir les listes en tuples et inversement?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The type constructor ``tuple(seq)`` converts any sequence (actually, any iterable) into a tuple with the same items in the same order.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Le constructeur de type ``tuple(seq)`` convertit toute séquence (en fait tout itérable) en un tuple avec les mêmes éléments dans le même ordre…</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a copy but returns the same object, so it is cheap to call :func:`tuple` when you aren't sure that an object is already a tuple.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Par exemple ``tuple([1, 2, 3])`` renvoi ``(1, 2, 3)`` et ``tuple('abc')`` renvoi ``('a', 'b', 'c')``. Si l'argument est un tuple, cela ne crèe pas une copie, mais renvoi le même objet, ce qui en fait un fonction économique à appeler quand vous ne savez pas si votre objet est déjà un tulpe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The type constructor ``list(seq)`` converts any sequence or iterable into a list with the same items in the same order.  For example, ``list((1, 2, 3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  If the argument is a list, it makes a copy just like ``seq[:]`` would.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Le constructeur de type ``list(seq)`` convertit toute séquence ou itérable en liste contenant les mêmes éléments dans le même ordre. Par exemple, ``list((1,2,3))`` retourne ``[1,2,3]`` et ``list('abc')`` retourne ``['a','b','c']``. Si l'argument est une liste, il retourne une copie, de la même façon que ``seq[:]``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's a negative index?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Qu'est-ce qu'un indexe négatif?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python sequences are indexed with positive numbers and negative numbers.  For positive numbers 0 is the first index 1 is the second index and so forth.  For negative indices -1 is the last index and -2 is the penultimate (next to last) index and so forth.  Think of ``seq[-n]`` as the same as ``seq[len(seq)-n]``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les séquences Python sont indexées avec des nombres positifs aussi bien que négatifs. Pour les nombres positifs, 0 est le premier index, 1 est le second, et ainsi de suite. Pour les indexes négatifs, -1 est le dernier index, -2 est le pénultième (avant dernier), et ainsi de suite. On peut aussi dire que ``seq[-n]`` est équivalent à ``seq[len(seq)-n]``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using negative indices can be very convenient.  For example ``S[:-1]`` is all of the string except for its last character, which is useful for removing the trailing newline from a string.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utiliser des indexes négatifs peut être très pratique. Par exemple ``S[:-1]`` indique la chaine entière a l'exception du dernier caractère, ce qui est pratique pour retirer un caractère de fin de ligne en fin d'une chaine.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I iterate over a sequence in reverse order?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment itérer à rebours sur une séquence?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the :func:`reversed` built-in function, which is new in Python 2.4::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utilisez la fonction embarquée :func:`reversed`, qui est apparue en Python 2.4::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for x in reversed(sequence):     ... # do something with x...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>for x in reversed(sequence): ... # do something with x...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This won't touch your original sequence, but build a new copy with reversed order to iterate over.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cela ne modifiera pas votre séquence initiale, mais construira à la place une copie en ordre inverse pour itérer dessus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Python 2.3, you can use an extended slice syntax::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Avec Python 2.3 vous pouvez utiliser la syntaxe étendue de tranches::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for x in sequence[::-1]:     ... # do something with x...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>for x in sequence[::-1]:     ... # do something with x...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do you remove duplicates from a list?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment retirer les doublons d'une liste?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the Python Cookbook for a long discussion of many ways to do this:</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Lisez le Python Cookbook pour trouver une longue discussion sur les nombreuses façons de faire cela:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't mind reordering the list, sort it and then scan from the end of the list, deleting duplicates as you go::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Si changer l'ordre de la liste ne vous dérange pas, commencez par trier celle ci, puis parcourez la d'un bout à l'autre, en supprimant les doublons trouvés en chemin::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if mylist:     mylist.sort()     last = mylist[-1]     for i in range(len(mylist)-2, -1, -1):         if last == mylist[i]:             del mylist[i]         else:             last = mylist[i]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>if mylist:     mylist.sort()     last = mylist[-1]     for i in range(len(mylist)-2, -1, -1):         if last == mylist[i]:             del mylist[i]         else:             last = mylist[i]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If all elements of the list may be used as dictionary keys (i.e. they are all hashable) this is often faster ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Si tous les éléments de la liste peuvent être utilisés comme des clés de dictionnaire (cad, elles sont toutes hashables) ceci est souvent plus rapide::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>d = {} for x in mylist:     d[x] = 1 mylist = list(d.keys())</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>d = {} for x in mylist:     d[x] = 1 mylist = list(d.keys())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Python 2.5 and later, the following is possible instead::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En Python 2.5 et suivant, la forme suivante est possible à la place::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mylist = list(set(mylist))</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>mylist = list(set(mylist))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This converts the list into a set, thereby removing duplicates, and then back into a list.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ceci convertis la liste en un ensemble, ce qui supprime automatiquement les doublons, puis la transforme à nouveau en liste.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do you make an array in Python?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment construire un tableau en Python?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a list::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utilisez une liste::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>["this", 1, "is", "an", "array"]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>["ceci", 1, "est", "un", "tableau"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lists are equivalent to C or Pascal arrays in their time complexity; the primary difference is that a Python list can contain objects of many different types.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les listes ont un cout équivalent à celui des tableau C ou Pascal; la principale différence est qu'une liste Python peut contenir des objets de différents types.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``array`` module also provides methods for creating arrays of fixed types with compact representations, but they are slower to index than lists.  Also note that the Numeric extensions and others define array-like structures with various characteristics as well.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Le module ``array`` fournit  des méthodes pour créer des tableaux de types fixes dans une représentation compacte, mais ils sont plus lents à indexer que les listes. Notez aussi que l'extension ``Numeric`` et d'autres, fournissent différentes structures de types tableaux, avec des caractéristiques différentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get Lisp-style linked lists, you can emulate cons cells using tuples::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour obtenir des listes chainées de type Lisp, vous pouvez émuler les "cons cells" en utilisant des tuples::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>lisp_list = ("like",  ("this",  ("example", None) ) )</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>lisp_list = ("like",  ("this",  ("example", None) ) )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If mutability is desired, you could use lists instead of tuples.  Here the analogue of lisp car is ``lisp_list[0]`` and the analogue of cdr is ``lisp_list[1]``.  Only do this if you're sure you really need to, because it's usually a lot slower than using Python lists.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Si vous voulez pouvoir modifier les éléments, utilisez une liste plutôt qu'un tuple. Ici la version équivalente au "car" de Lisp est ``lisp_list[0]`` et l'équivalent à "cdr" est ``list_lip[1]``. Ne faîtes ceci que si vous êtes réellement sûr d'en avoir besoin, cette méthode est en générale bien plus lente que les listes Python.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I create a multidimensional list?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je créer une liste à plusieurs dimensions?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You probably tried to make a multidimensional array like this::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Vous avez probablement essayé de créer une liste à plusieurs dimensions de cette façon::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A = [[None] * 2] * 3</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>A = [[None] * 2] * 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This looks correct if you print it::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cela semble correct quand vous essayer de l'afficher::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; A [[None, None], [None, None], [None, None]]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; A [[None, None], [None, None], [None, None]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But when you assign a value, it shows up in multiple places:</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Mais quand vous assignez une valeur, elle apparait en de multiples endroits::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; A[0][0] = 5 &gt;&gt;&gt; A [[5, None], [5, None], [5, None]]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; A[0][0] = 5 &gt;&gt;&gt; A [[5, None], [5, None], [5, None]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason is that replicating a list with ``*`` doesn't create copies, it only creates references to the existing objects.  The ``*3`` creates a list containing 3 references to the same list of length two.  Changes to one row will show in all rows, which is almost certainly not what you want.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La raison en est que dupliquer une liste en utilisant ``*`` ne crée pas de copies, cela crée seulement des références aux objets existants. Le ``*3`` crée une liste contenant trois références à la même liste de longueur deux. Un changement dans une colonne apparaîtra donc dans toutes les colonnes. Ce qui n'est de façon quasi certaine, pas ce que vous souhaitez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The suggested approach is to create a list of the desired length first and then fill in each element with a newly created list::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>L'approche suggérée est de créer une liste de la longueur désiré d'abords, puis de remplir tous les éléments avec une chaîne nouvellement créée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A = [None] * 3 for i in range(3):     A[i] = [None] * 2</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>A = [None] * 3 for i in range(3):     A[i] = [None] * 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This generates a list containing 3 different lists of length two.  You can also use a list comprehension::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cette liste générée contient trois listes différentes de longueur deux. Vous pouvez aussi utilisez la notation de compréhension de listes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>w, h = 2, 3 A = [[None] * w for i in range(h)]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>w, h = 2, 3 A = [[None] * w for i in range(h)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, you can use an extension that provides a matrix datatype; `Numeric Python &lt;http://numpy.scipy.org/&gt;`_ is the best known.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ou, vous pouvez utiliser une extension qui fournis un type de donnée de type matrice; `Numeric Python &lt;http://numpy.scipy.org/&gt;`_ étant le plus connu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I apply a method to a sequence of objects?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment appliquer une méthode à une séquence d'objets?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a list comprehension::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utilisez une compréhension de liste::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>result = [obj.method() for obj in mylist]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>result = [obj.method() for obj in mylist]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Dictionnaires</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I get a dictionary to display its keys in a consistent order?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je faire afficher les éléments d'un dictionnaire dans un ordre consistant?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can't.  Dictionaries store their keys in an unpredictable order, so the display order of a dictionary's elements will be similarly unpredictable.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Vous ne pouvez pas. Les dictionnaires enregistrent leurs clées dans un ordre non prévisible, l'ordre d'affichage des éléments d'un dictionnaire sera donc de la même façon imprévisible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be frustrating if you want to save a printable version to a file, make some changes and then compare it with some other printed dictionary.  In this case, use the ``pprint`` module to pretty-print the dictionary; the items will be presented in order sorted by the key.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cela peut être frustrant si vous voulez sauvegarder une version affichable dans un fichier, faire des changement puis comparer avec un autre dictionnaire affiché. Dans ce cas, utilisez le module ``pprint``` pour afficher joliement le dictionnaire; les éléments seront présentés triés par clés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more complicated solution is to subclass ``dict`` to create a ``SortedDict`` class that prints itself in a predictable order.  Here's one simpleminded implementation of such a class::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Une solution plus compliquée est de sousclasser ``dict`` pour créer une classe``SorterDict`` qui s'affiche de façon prévisible. Voici une implémentation simple d'une telle classe::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class SortedDict(dict):     def __repr__(self):         keys = sorted(self.keys())         result = ("{!r}: {!r}".format(k, self[k]) for k in keys)         return "{{{}}}".format(", ".join(result))      __str__ = __repr__</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class SortedDict(dict):     def __repr__(self):         keys = sorted(self.keys())         result = ("{!r}: {!r}".format(k, self[k]) for k in keys)         return "{{{}}}".format(", ".join(result))      __str__ = __repr__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will work for many common situations you might encounter, though it's far from a perfect solution. The largest flaw is that if some values in the dictionary are also dictionaries, their values won't be presented in any particular order.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cela marchera dans la plupart des situations que vous pourriez rencontrer, même si c'est loin d'être une solution parfaite. Le plus gros problème avec cette solution est que si certaines valeurs dans le dictionnaire sont aussi des dictionnaire, alors elles ne seront pas présentées dans un ordre particulier.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I want to do a complicated sort: can you do a Schwartzian Transform in Python?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Je souhaite faire un tri compliqué: peut on faire une transformation de Schwartz en Python?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The technique, attributed to Randal Schwartz of the Perl community, sorts the elements of a list by a metric which maps each element to its "sort value". In Python, just use the ``key`` argument for the ``sort()`` method::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cette technique, attribuée à Randal Schwartz de la communauté Perl, trie les éléments d'une liste selon une mesure qui fait correspondre chaque élément à une "valeur de tri". En Python, utilisez simplement l'argument ``key`` de la méthode ``sort``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Isorted = L[:] Isorted.sort(key=lambda s: int(s[10:15]))</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Isorted = L[:] Isorted.sort(key=lambda s: int(s[10:15]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``key`` argument is new in Python 2.4, for older versions this kind of sorting is quite simple to do with list comprehensions.  To sort a list of strings by their uppercase values::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>L'argument ``key`` est apparus en Python 2.4, pour les anciennes versions de Python, ce type de tri est relativement simple à faire avec des compréhensions de liste. Pour trier une liste de chaines par leur valeur en majuscule on peut faire::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tmp1 = [(x.upper(), x) for x in L]  # Schwartzian transform tmp1.sort() Usorted = [x[1] for x in tmp1]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>tmp1 = [(x.upper(), x) for x in L]  # Schwartzian transform tmp1.sort() Usorted = [x[1] for x in tmp1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To sort by the integer value of a subfield extending from positions 10-15 in each string::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour trier par la valeur d'un sous-champ allant des index 10 à 15 dans chaque chaine chaine::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tmp2 = [(int(s[10:15]), s) for s in L]  # Schwartzian transform tmp2.sort() Isorted = [x[1] for x in tmp2]</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>tmp2 = [(int(s[10:15]), s) for s in L]  # Schwartzian transform tmp2.sort() Isorted = [x[1] for x in tmp2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For versions prior to 3.0, Isorted may also be computed by ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les versions antérieures à 3.0, Isorted peut également être calculé par:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def intfield(s):     return int(s[10:15])  def Icmp(s1, s2):     return cmp(intfield(s1), intfield(s2))  Isorted = L[:] Isorted.sort(Icmp)</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def intfield(s):     return int(s[10:15])  def Icmp(s1, s2):     return cmp(intfield(s1), intfield(s2))  Isorted = L[:] Isorted.sort(Icmp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>but since this method calls ``intfield()`` many times for each element of L, it is slower than the Schwartzian Transform.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>mais du fait que cette méthode appelle `` intfield () `` plusieurs fois pour chaque élément de L, elle est plus lente que la transformée de Schwartz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I sort one list by values from another list?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je trier une liste en fonction des valeurs d'une autre liste?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Merge them into an iterator of tuples, sort the resulting list, and then pick out the element you want. ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Fusionnez les dans un itérateur de tuples, trier la liste obtenue, puis choisissez l'élément que vous voulez. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; list1 = ["what", "I'm", "sorting", "by"] &gt;&gt;&gt; list2 = ["something", "else", "to", "sort"] &gt;&gt;&gt; pairs = zip(list1, list2) &gt;&gt;&gt; pairs = sorted(pairs) &gt;&gt;&gt; pairs [("I'm", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')] &gt;&gt;&gt; result = [x[1] for x in pairs] &gt;&gt;&gt; result ['else', 'sort', 'to', 'something']</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; list1 = ["what", "I'm", "sorting", "by"] &gt;&gt;&gt; list2 = ["something", "else", "to", "sort"] &gt;&gt;&gt; pairs = zip(list1, list2) &gt;&gt;&gt; pairs = sorted(pairs) &gt;&gt;&gt; pairs [("I'm", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')] &gt;&gt;&gt; result = [x[1] for x in pairs] &gt;&gt;&gt; result ['else', 'sort', 'to', 'something']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; result = [] &gt;&gt;&gt; for p in pairs: result.append(p[1])</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>&gt;&gt;&gt; result = [] &gt;&gt;&gt; for p in pairs: result.append(p[1])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you find this more legible, you might prefer to use this instead of the final list comprehension.  However, it is almost twice as slow for long lists.  Why? First, the ``append()`` operation has to reallocate memory, and while it uses some tricks to avoid doing that each time, it still has to do it occasionally, and that costs quite a bit.  Second, the expression "result.append" requires an extra attribute lookup, and third, there's a speed reduction from having to make all those function calls.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Si vous trouvez cela plus lisible, vous préférez peut-être utiliser ceci à la place de la compréhension de la liste finale. Toutefois, ceci est presque deux fois plus lent pour les longues listes. Pourquoi? Tout d'abord, ``append ()`` doit réaffecter la mémoire, et si il utilise quelques astuces pour éviter de le faire à chaque fois, il doit encore le faire de temps en temps, ce qui coûte assez cher. Deuxièmement, l'expression "result.append" exige une recherche d'attribut supplémentaire, et enfin, tous ces appels de fonction impactent la vitesse d'exécution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Objets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a class?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Qu'est-ce qu'une classe?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class is the particular object type created by executing a class statement. Class objects are used as templates to create instance objects, which embody both the data (attributes) and code (methods) specific to a datatype.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Une classe est le type d'objet particulier créé par l'exécution d'une déclaration de classe. Les objets de classe sont utilisés comme modèles pour créer des objets, qui incarnent à la fois les données (attributs) et le code (méthodes) spécifiques à un type de données.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class can be based on one or more other classes, called its base class(es). It then inherits the attributes and methods of its base classes. This allows an object model to be successively refined by inheritance.  You might have a generic ``Mailbox`` class that provides basic accessor methods for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, ``OutlookMailbox`` that handle various specific mailbox formats.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Une classe peut être fondée sur une ou plusieurs autres classes, appelée sa ou ses classes de base. Il hérite alors les attributs et les méthodes de ses classes de base. Cela permet à un modèle d'objet d'être successivement raffinés par héritage. Vous pourriez avoir une classe générique ``Mailbox`` qui fournit des méthodes d'accès de base pour une boîte aux lettres, et sous-classes telles que ``MboxMailbox``, ``MaildirMailbox``, ``OutlookMailbox`` qui gèrent les différents formats de boîtes aux lettres spécifiques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a method?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Qu'est-ce qu'une méthode?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A method is a function on some object ``x`` that you normally call as ``x.name(arguments...)``.  Methods are defined as functions inside the class definition::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Une méthode est une fonction sur un  objet ``x`` appelez normalement comme ``x.name(arguments…)``. Les méthodes sont définies comme des fonctions à l'intérieur de la définition de classe::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C:     def meth (self, arg):         return arg * 2 + self.attribute</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class C:     def meth (self, arg):         return arg * 2 + self.attribute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is self?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Qu'est-ce que self?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Self is merely a conventional name for the first argument of a method.  A method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, c)`` for some instance ``x`` of the class in which the definition occurs; the called method will think it is called as ``meth(x, a, b, c)``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Self est simplement un nom conventionnel pour le premier argument d'une méthode. Une méthode définie comme ``meth(self, a, b, c)`` doit être appelée en tant que ``x.meth(a, b, c)``, pour une instance ``x`` de la classe dans laquelle elle est définie, la méthode appelée considérera qu'elle est appelée ``meth(x, a, b, c)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also :ref:`why-self`.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Voir aussi: ref:`why-self`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I check if an object is an instance of a given class or of a subclass of it?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je vérifier si un objet est une instance d'une classe donnée ou d'une sous-classe de celui-ci?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the built-in function ``isinstance(obj, cls)``.  You can check if an object is an instance of any of a number of classes by providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1, class2, ...))``, and can also check whether an object is one of Python's built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, float, complex))``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utilisez la fonction intégrée ``isInstance(obj, CLS)``. Vous pouvez vérifier si un objet est une instance de n'importe lequel d'un certain nombre de classes en fournissant un tuple à la place d'une seule classe, par exemple, ``IsInstance (obj, (Classe1, classe2, ...))``, et peut également vérifier si un objet est l'un des types intégrés à Python, par exemple, ``IsInstance (obj, str) isInstance`` ou ``(obj, (int, float, complexes ))``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that most programs do not use :func:`isinstance` on user-defined classes very often.  If you are developing the classes yourself, a more proper object-oriented style is to define methods on the classes that encapsulate a particular behaviour, instead of checking the object's class and doing a different thing based on what class it is.  For example, if you have a function that does something::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Notez que la plupart des programmes n'utilisent pas : func:``isInstance`` sur les classes définies par l'utilisateur, très souvent. Si vous développez vous-même les classes, un style plus appropriée orientée objet est de définir des méthodes sur les classes qui encapsulent un comportement particulier, au lieu de vérifier la classe de l'objet et de faire quelque chose de différent en fonction de sa classe. Par exemple, si vous avez une fonction qui fait quelque chose::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def search(obj):     if isinstance(obj, Mailbox):         # ... code to search a mailbox     elif isinstance(obj, Document):         # ... code to search a document     elif ...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def search(obj):     if isinstance(obj, Mailbox):         # ... code to search a mailbox     elif isinstance(obj, Document):         # ... code to search a document     elif ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A better approach is to define a ``search()`` method on all the classes and just call it::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Une meilleure approche est de définir une méthode ``search()`` sur toutes les classes et qu'il suffit d'appeler::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Mailbox:     def search(self):         # ... code to search a mailbox  class Document:     def search(self):         # ... code to search a document  obj.search()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class Mailbox:     def search(self):         # ... code to search a mailbox  class Document:     def search(self):         # ... code to search a document  obj.search()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is delegation?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Qu'est-ce que la délégation?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delegation is an object oriented technique (also called a design pattern). Let's say you have an object ``x`` and want to change the behaviour of just one of its methods.  You can create a new class that provides a new implementation of the method you're interested in changing and delegates all other methods to the corresponding method of ``x``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La délégation est une technique orientée objet (aussi appelé un modèle de conception). Disons que vous avez un objet ``x`` et que vous souhaitez modifier le comportement d'une seule de ses méthodes. Vous pouvez créer une nouvelle classe qui fournit une nouvelle implémentation de la méthode qui vous intéresse dans l'évolution et les délégués de toutes les autres méthodes la méthode correspondante de ``x``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python programmers can easily implement delegation.  For example, the following class implements a class that behaves like a file but converts all written data to uppercase::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les programmeurs Python peuvent facilement mettre en œuvre la délégation. Par exemple, la classe suivante implémente une classe qui se comporte comme un fichier, mais convertit toutes les données écrites en majuscules:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class UpperOut:      def __init__(self, outfile):         self._outfile = outfile      def write(self, s):         self._outfile.write(s.upper())      def __getattr__(self, name):         return getattr(self._outfile, name)</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class UpperOut:      def __init__(self, outfile):         self._outfile = outfile      def write(self, s):         self._outfile.write(s.upper())      def __getattr__(self, name):         return getattr(self._outfile, name)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here the ``UpperOut`` class redefines the ``write()`` method to convert the argument string to uppercase before calling the underlying ``self.__outfile.write()`` method.  All other methods are delegated to the underlying ``self.__outfile`` object.  The delegation is accomplished via the ``__getattr__`` method; consult :ref:`the language reference &lt;attribute-access&gt;` for more information about controlling attribute access.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ici, la classe ``UpperOut`` redéfinit la méthode  ``write()`` pour convertir la chaîne d'argument en majuscules avant d'appeler la méthode sous-jacentes ``self.__outfile.write()``. Toutes les autres méthodes sont déléguées à l'objet sous-jacent ``self.__outfile``. La délégation se fait par la méthode ``__getattr__``, consulter: ref:`the language reference &lt;attribute-access&gt;` pour plus d'informations sur le contrôle d'accès d'attribut.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that for more general cases delegation can get trickier. When attributes must be set as well as retrieved, the class must define a :meth:`__setattr__` method too, and it must do so carefully.  The basic implementation of :meth:`__setattr__` is roughly equivalent to the following::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Notez que pour une utilisation plus générale de la délégation, les choses peuvent se compliquer. Lorsque les attributs doivent être définis aussi bien que récupérés, la classe doit définir une méthode :meth:``__setattr__`` aussi, et il doit le faire avec soin. La mise en œuvre basique de la méthode :meth:``__setattr__`` est à peu près équivalent à ce qui suit:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class X:     ...     def __setattr__(self, name, value):         self.__dict__[name] = value     ...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class X:     ...     def __setattr__(self, name, value):         self.__dict__[name] = value     ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most :meth:`__setattr__` implementations must modify ``self.__dict__`` to store local state for self without causing an infinite recursion.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La plupart des implémentations de: meth:`__setattr__` doivent modifier ``self.__dict__`` pour stocker l'état locale de self sans provoquer une récursion infinie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I call a method defined in a base class from a derived class that overrides it?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment appeler une méthode définie dans une classe de base depuis une classe dérivée qui la surcharge?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the built-in :func:`super` function::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Utilisez la fonction built-in :func:``super``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Derived(Base):     def meth (self):         super(Derived, self).meth()</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class Derived(Base):     def meth (self):         super(Derived, self).meth()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For version prior to 3.0, you may be using classic classes: For a class definition such as ``class Derived(Base): ...`` you can call method ``meth()`` defined in ``Base`` (or one of ``Base``'s base classes) as ``Base.meth(self, arguments...)``.  Here, ``Base.meth`` is an unbound method, so you need to provide the ``self`` argument.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour version antérieure à 3.0, vous pouvez utiliser des classes classiques: Pour une définition de classe telle que ``class derived(Base)...`` vous pouvez appeler la méthode ``meth()`` défini dans `` `` Base (ou l'une des classes de base de ``Base``) en faisant ``Base.meth(self, arguments...)``. Ici, ``Base.meth`` est une méthode non liée, vous devez donc fournir l'argument ``self``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I organize my code to make it easier to change the base class?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je organiser mon code pour permettre de changer la classe de base plus facilement?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could define an alias for the base class, assign the real base class to it before your class definition, and use the alias throughout your class.  Then all you have to change is the value assigned to the alias.  Incidentally, this trick is also handy if you want to decide dynamically (e.g. depending on availability of resources) which base class to use.  Example::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Vous pouvez définir un alias pour la classe de base, lui attribuer la classe de base réelle avant la définition de classe, et utiliser l'alias au long de votre classe. Ensuite, tout ce que vous devez changer est la valeur attribuée à l'alias. Incidemment, cette astuce est également utile si vous voulez décider dynamiquement (par exemple en fonction de la disponibilité des ressources) la classe de base à utiliser. Exemple::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BaseAlias = &lt;real base class&gt;  class Derived(BaseAlias):     def meth(self):         BaseAlias.meth(self)         ...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>BaseAlias = &lt;real base class&gt;  class Derived(BaseAlias):     def meth(self):         BaseAlias.meth(self)         ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I create static class data and static class methods?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je créer des données statiques de classe et des méthodes statiques de classe?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both static data and static methods (in the sense of C++ or Java) are supported in Python.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Tant les données statiques que les méthodes statiques (dans le sens de C + + ou Java) sont pris en charge en Python.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For static data, simply define a class attribute.  To assign a new value to the attribute, you have to explicitly use the class name in the assignment::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Pour les données statiques, il suffit de définir un attribut de classe. Pour attribuer une nouvelle valeur à l'attribut, vous devez explicitement utiliser le nom de classe dans l'affectation:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C:     count = 0   # number of times C.__init__ called      def __init__(self):         C.count = C.count + 1      def getcount(self):         return C.count  # or return self.count</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class C:     count = 0   # number of times C.__init__ called      def __init__(self):         C.count = C.count + 1      def getcount(self):         return C.count  # or return self.count</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``c.count`` also refers to ``C.count`` for any ``c`` such that ``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some class on the base-class search path from ``c.__class__`` back to ``C``.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>``c.count`` se réfère également à ``C.count`` pour tout ``c`` telle que ``isInstance (c, C)`` est vrai, sauf remplacement par ``c`` lui-même ou par une classe sur le chemin de recherche de classe de base de ``c.__class__`` jusqu'à ``C``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caution: within a method of C, an assignment like ``self.count = 42`` creates a new and unrelated instance named "count" in ``self``'s own dict.  Rebinding of a class-static data name must always specify the class whether inside a method or not::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Attention: dans une méthode de C, une affectation comme ``self.count=42`` crée une nouvelle instance et sans rapport avec le nom "count" dans dans le dictionnaire de données de ``self``. La redéfinition d'une donnée statique de classe doit toujours spécifier la classe que l'on soit à l'intérieur d'une méthode ou non:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C.count = 314</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>C.count = 314</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Static methods are possible since Python 2.2::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les méthodes statiques sont possibles depuis Python 2.2::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C:     def static(arg1, arg2, arg3):         # No 'self' parameter!         ...     static = staticmethod(static)</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class C:     def static(arg1, arg2, arg3):         # No 'self' parameter!         ...     static = staticmethod(static)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Python 2.4's decorators, this can also be written as ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Avec les décorateurs de Python 2.4, cela peut aussi s'écrire:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C:     @staticmethod     def static(arg1, arg2, arg3):         # No 'self' parameter!         ...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class C:     @staticmethod     def static(arg1, arg2, arg3):         # No 'self' parameter!         ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, a far more straightforward way to get the effect of a static method is via a simple module-level function::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cependant, d'une manière beaucoup plus simple pour obtenir l'effet d'une méthode statique se fait par une simple fonction au niveau du module::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def getcount():     return C.count</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def getcount():     return C.count</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code is structured so as to define one class (or tightly related class hierarchy) per module, this supplies the desired encapsulation.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Si votre code est structuré de manière à définir une classe (ou bien la hiérarchie des classes connexes) par module, ceci fournira l'encapsulation souhaitée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I overload constructors (or methods) in Python?</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Comment puis-je surcharger les constructeurs (ou méthodes) en Python?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This answer actually applies to all methods, but the question usually comes up first in the context of constructors.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cette réponse s'applique en fait à toutes les méthodes, mais la question vient généralement en premier dans le contexte des constructeurs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In C++ you'd write</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>In C++ you'd write</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C {     C() { cout &lt;&lt; "No arguments\n"; }     C(int i) { cout &lt;&lt; "Argument is " &lt;&lt; i &lt;&lt; "\n"; } }</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class C {     C() { cout &lt;&lt; "No arguments\n"; }     C(int i) { cout &lt;&lt; "Argument is " &lt;&lt; i &lt;&lt; "\n"; } }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Python you have to write a single constructor that catches all cases using default arguments.  For example::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>En Python, vous devez écrire un constructeur unique qui considère tous les cas en utilisant des arguments par défaut. Par exemple::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C:     def __init__(self, i=None):         if i is None:             print("No arguments")         else:             print("Argument is", i)</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>class C:     def __init__(self, i=None):         if i is None:             print("No arguments")         else:             print("Argument is", i)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not entirely equivalent, but close enough in practice.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ce n'est pas tout à fait équivalent, mais suffisamment proche dans la pratique.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also try a variable-length argument list, e.g. ::</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Vous pouvez aussi utiliser une liste d'arguments de longueur variable, par exemple ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def __init__(self, *args):     ...</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>def __init__(self, *args):     ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same approach works for all method definitions.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La même approche fonctionne pour toutes les définitions de méthode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I try to use __spam and I get an error about _SomeClassName__spam.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>J'essaie d'utiliser __spam et j'obtiens une erreur à propos de _SomeClassName__spam.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variable names with double leading underscores are "mangled" to provide a simple but effective way to define class private variables.  Any identifier of the form ``__spam`` (at least two leading underscores, at most one trailing underscore) is textually replaced with ``_classname__spam``, where ``classname`` is the current class name with any leading underscores stripped.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Les noms de variables avec le double de soulignement sont «déformés» pour fournir un moyen simple mais efficace de définir variables privées à la classe. Tout identificateur de la forme ``__spam`` (au moins deux traits de soulignement préfixe, au plus un soulignement suffix) est textuellement remplacé par ``_classname__spam``, où ``classname`` est le nom de la classe en cours avec les traits de soulignement dépouillés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This doesn't guarantee privacy: an outside user can still deliberately access the "_classname__spam" attribute, and private values are visible in the object's ``__dict__``.  Many Python programmers never bother to use private variable names at all.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Cela ne garantit pas la privauté de l'accès : un utilisateur extérieur peut encore délibérément acceder à l'attribut ``_classname__spam``, et les valeurs privées sont visibles dans `` l'objet __dict__ ``. De nombreux programmeurs Python ne prennent jamais la peine d'utiliser des noms de variable privée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>My class defines __del__ but it is not called when I delete the object.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Ma classe définit __del__ mais il n'est pas appelé lorsque je supprime l'objet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several possible reasons for this.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>Il y a plusieurs raisons possibles pour cela.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The del statement does not necessarily call :meth:`__del__` -- it simply decrements the object's reference count, and if this reaches zero :meth:`__del__` is called.</seg>
      </tuv>
      <tuv xml:lang="fr">
        <seg>La commande del n'appelle pas forcément: meth: `__del__` - il décrémente simplement le compteur de références de l'objet, et si celui ci arrive à zéro: meth: `__del__` est appelée.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
