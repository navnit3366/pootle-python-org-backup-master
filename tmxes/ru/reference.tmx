<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.1.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Compound statements</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Составные инструкции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compound statements contain (groups of) other statements; they affect or control the execution of those other statements in some way.  In general, compound statements span multiple lines, although in simple incarnations a whole compound statement may be contained in one line.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Составные инструкции содержат другие инструкции или их группы. Они влияют, или прямо контролируют исполнение содержащихся инструкций каким-либо образом. Как правило составные инструкции состоят из нескольких строк, однако в простых выражениях составная инструкция может целиком размещаться в одной строке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement traditional control flow constructs.  :keyword:`try` specifies exception handlers and/or cleanup code for a group of statements, while the :keyword:`with` statement allows the execution of initialization and finalization code around a block of code.  Function and class definitions are also syntactically compound statements.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкции «:keyword:`if`», «:keyword:`while`» и «:keyword:`for`» реализуют стандартные конструкции управления потоком исполнения. «:keyword:`try`» определяет для определённой группы выражений обработчик исключения и/или код ликвидации последствий, тогда как инструкция «:keyword:`with`» позволяет исполнять инициализирующий и завершающий код соответственно до и после определённого кода. Определения функций и классов синтаксически также являются составными инструкциями</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compound statements consist of one or more 'clauses.'  A clause consists of a header and a 'suite.'  The clause headers of a particular compound statement are all at the same indentation level. Each clause header begins with a uniquely identifying keyword and ends with a colon.  A suite is a group of statements controlled by a clause.  A suite can be one or more semicolon-separated simple statements on the same line as the header, following the header's colon, or it can be one or more indented statements on subsequent lines.  Only the latter form of suite can contain nested compound statements; the following is illegal, mostly because it wouldn't be clear to which :keyword:`if` clause a following :keyword:`else` clause would belong::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Составные инструкции состоят из одной или более «групп» . Группа состоит из «заголовка» и «содержимого» . Все «заголовки» групп одной составной инструкции находятся на одном уровне отступов. Каждый «заголовок» группы начинается с однозначно идентифицирующего ключевого слова и заканчивается двоеточием. Инструкции «содержимого» являются подконтрольными в группе . «Содержимое» может быть одной или более простыми инструкциями разделенными точкой с запятой в той же строке, что и «заголовок» , после двоеточия «заголовка» , или же может быть одной или более инструкций, идущих в отдельных строках с отступом. Только последняя форма содержимого группы может содержать вложенные составные инструкции. Следующий пример недопустим, главным образом потому, что не ясно, группе которого «:keyword:`if`» будет относиться группа следующего «:keyword:`else`» ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if test1: if test2: print(x)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>if test1: if test2: print(x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that the semicolon binds tighter than the colon in this context, so that in the following example, either all or none of the :func:`print` calls are executed::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>К тому же, заметьте, что (в данном контексте) точка-с-запятой связывается сильнее, чем двоеточие, таким образом в следующем примере исполняются или все инструкции «:func:`print`» , или ни одной ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if x &lt; y &lt; z: print(x); print(y); print(z)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>if x &lt; y &lt; z: print(x); print(y); print(z)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summarizing:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В итоге :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that statements always end in a ``NEWLINE`` possibly followed by a ``DEDENT``.  Also note that optional continuation clauses always begin with a keyword that cannot start a statement, thus there are no ambiguities (the 'dangling :keyword:`else`' problem is solved in Python by requiring nested :keyword:`if` statements to be indented).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что инструкции всегда заканчиваются признаком «``NEWLINE``» , после которого может идти «``DEDENT``» . Также отметьте, что необязательные ветви в условиях всегда начинаются с такого ключевого слова, по которому ясно, что это именно продолжение инструкции необязательною ветвью, и с этого слова не может начинаться новая инструкция. Проблема “оторванных” «:keyword:`else`» решена в Питоне через обязательность отступов для вложенных «:keyword:`if`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`if` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`if`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`if` statement is used for conditional execution:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`if`» служит для исполнения по условию :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It selects exactly one of the suites by evaluating the expressions one by one until one is found to be true (see section :ref:`booleans` for the definition of true and false); then that suite is executed (and no other part of the :keyword:`if` statement is executed or evaluated).  If all expressions are false, the suite of the :keyword:`else` clause, if present, is executed.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`if`» выбирает только одну вложенную группу инструкций, вычисляя выражения-условия по очереди до первого со значением «:keyword:`True`» (смотрите раздел «Логические (булевы) операции» :ref:`booleans` ) , затем соответствующая вложенная группа исполняется (и больше не вычисляются другие выражения-условия и не выполняются другие группы) . Если все выражения-условия имеют значение «:keyword:`False`» , то вложенная группа ветви «:keyword:`else`» выполняется, если присутствует.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`while` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`while`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`while` statement is used for repeated execution as long as an expression is true:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`while`» используется для циклического исполнения пока выражение истинно :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This repeatedly tests the expression and, if it is true, executes the first suite; if the expression is false (which may be the first time it is tested) the suite of the :keyword:`else` clause, if present, is executed and the loop terminates.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`while`» циклически проверяет выражение-условие, и если оно истинно – выполняет первую вложенную группу, а если оно ложно – (даже если это происходит при первой же проверке) цикл завершается и вложенная группа ветви «:keyword:`else`» выполняется, если присутствует.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :keyword:`break` statement executed in the first suite terminates the loop without executing the :keyword:`else` clause's suite.  A :keyword:`continue` statement executed in the first suite skips the rest of the suite and goes back to testing the expression.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исполнение инструкции «:keyword:`break`» в первой группе прекращает цикл без исполнения ветви «:keyword:`else`» . Инструкция «:keyword:`continue`» в первой группе пропускает остаток этой группы, и происходит переход обратно к проверке выражения-условия.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`for` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`for`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`for` statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`for`» используется для того, чтобы перебирать последовательно элементы последовательности (например текстовые данные, «кортежи» , списки) или другого перечислимого объекта :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The expression list is evaluated once; it should yield an iterable object.  An iterator is created for the result of the ``expression_list``.  The suite is then executed once for each item provided by the iterator, in the order of ascending indices.  Each item in turn is assigned to the target list using the standard rules for assignments (see :ref:`assignment`), and then the suite is executed.  When the items are exhausted (which is immediately when the sequence is empty or an iterator raises a :exc:`StopIteration` exception), the suite in the :keyword:`else` clause, if present, is executed, and the loop terminates.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Список выражений «``expression_list``» вычисляется только один раз – он должен давать в результате итерируемый объект, для которого создаётся итератор. Вложенный блок затем исполняется по одному разу для каждого элемента, выданного итератором в порядке увеличения индексов. Каждый такой выданный итератором элемент назначается списку целей в соответствии со стандартными правилами назначения (смотрите раздел «Инструкции назначения» :ref:`assignment`) , и затем уже́ вложенный блок исполняется. Когда эти элементы кончаются (в самом начале, если последовательность пустая, или когда итератор инициирует исключение «:exc:`StopIteration`» ) , то исполняется блок инструкций ветви «:keyword:`else`» , если таковая присутствует, и цикл прекращается.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :keyword:`break` statement executed in the first suite terminates the loop without executing the :keyword:`else` clause's suite.  A :keyword:`continue` statement executed in the first suite skips the rest of the suite and continues with the next item, or with the :keyword:`else` clause if there was no next item.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`break`» , исполненная в основной ветви («:keyword:`for`») , прекращает цикл без исполнения ветви «:keyword:`else`» . Инструкция «:keyword:`continue`» , исполненная в основной ветви («:keyword:`for`») , пропускает оставшиеся инструкции блока и, если итерируемые элементы ещё есть – переходит к новому исполнению блока со следующим элементом, а иначе переходит к ветви «:keyword:`else`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The suite may assign to the variable(s) in the target list; this does not affect the next item assigned to it.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Внутри вложенного блока можно изменять значение переменных из списка целей, и это ни как не повлияет на их значение, когда при следующем проходе им будет назначено значение очередного элемента.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Names in the target list are not deleted when the loop is finished, but if the sequence is empty, it will not have been assigned to at all by the loop.  Hint: the built-in function :func:`range` returns an iterator of integers suitable to emulate the effect of Pascal's ``for i := a to b do``; e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Имена из списка целей не удаляются после окончания цикла, но, если последовательность пустая, то этим именам вообще не будет назначено значение (и, если переменные не существовали, то и не будут созданы) . Подсказка : встроенная функция «:func:`range`» возвращает итератор целых чисел, который можно использовать для эмулирования эффекта Паскалевского «``for i := a to b do``» , например, «``list(range(3))``» возвращает список «``[0, 1, 2]``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists).  An internal counter is used to keep track of which item is used next, and this is incremented on each iteration.  When this counter has reached the length of the sequence the loop terminates.  This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated).  Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g., ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Есть тонкость, когда итерируемая последовательность изменяется внутри цикла (это может произойти только с изменяемыми последовательностями, например списком) . Для отслеживания того, какой элемент будет использован следующим, – используется внутренний счётчик, увеличиваемый на единицу при каждом проходе. Когда он достигает длинны последовательности – цикл прекращается. Это значит, что если внутри блока цикла удаляется текущий (или один из предыдущих) элемент последовательности, то элемент, который должен был быть выдан следующим будет пропущен, поскольку он получит индекс элемента, обрабатываемого в данный момент. Таким же образом, если внутри блока цикла в последовательность добавляется элемент до текущего элемента, то текущий элемент будет обработан ещё раз на следующем проходе цикла. Это может приводить к очень неприятным ошибкам, которых можно избежать, если для последовательности делать временную копию, с помощью среза всей последовательности, например : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for x in a[:]:     if x &lt; 0: a.remove(x)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>for x in a[:]:     if x &lt; 0: a.remove(x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`try` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`try`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`try` statement specifies exception handlers and/or cleanup code for a group of statements:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`try`» задаёт обработчики исключения и/или завершающий код для блока инструкций :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`except` clause(s) specify one or more exception handlers. When no exception occurs in the :keyword:`try` clause, no exception handler is executed. When an exception occurs in the :keyword:`try` suite, a search for an exception handler is started.  This search inspects the except clauses in turn until one is found that matches the exception.  An expression-less except clause, if present, must be last; it matches any exception.  For an except clause with an expression, that expression is evaluated, and the clause matches the exception if the resulting object is "compatible" with the exception.  An object is compatible with an exception if it is the class or a base class of the exception object or a tuple containing an item compatible with the exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ветвь «:keyword:`except`» задаёт один или более обработчиков исключений. Если не происходит ни одного исключения в соответствующей ветви «:keyword:`try`» , то никакой из этих обработчиков не вызывается. Когда случается какое-либо исключение в соответствующей ветви «:keyword:`try`» , то начинается поиск обработчика этого исключения. При этом поиске просматриваются последовательно все блоки «:keyword:`except`» пока не встретится первый блок соответствующий произошедшему исключению. Если задан блок «:keyword:`except`» без указания исключения , который подразумевает любое исключение, то его логично указывать последним. Для инструкции «:keyword:`except`» с выражением – это выражение вычисляется, и если объект-результат является “совместимым” с обрабатываемым исключением, то данный блок «:keyword:`except`» соответствует данному исключению. Объект совместим с данным исключением, если он является классом или базовым классом данного исключения, или же является кортежем, содержащим объект, совместимый с данным исключением.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no except clause matches the exception, the search for an exception handler continues in the surrounding code and on the invocation stack.  [#]_</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если не найдено ни одного блока «:keyword:`except`» , соответствующего исключению, то поиск продолжается в окружающем коде и по стеку вызовов. [#]_  Исключение передаётся вверх по стеку вызовов только если отсутствует блок «:keyword:`finally`» , такой, который нейтрализует данное исключение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the evaluation of an expression in the header of an except clause raises an exception, the original search for a handler is canceled and a search starts for the new exception in the surrounding code and on the call stack (it is treated as if the entire :keyword:`try` statement raised the exception).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если при вычислении выражения у само́й инструкции «:keyword:`except`» возникает исключение, то обработка текущего исключения (возникшего внутри блока «:keyword:`try`» , к которому относится данная инструкция «:keyword:`except`» ) отменяется, и начинается поиск обработчика для этого нового исключения в объемлющем коде и по стеку вызовов (тоесть, считается, что исключение вызвала вся конструкция «:keyword:`try`» ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a matching except clause is found, the exception is assigned to the target specified after the :keyword:`as` keyword in that except clause, if present, and the except clause's suite is executed.  All except clauses must have an executable block.  When the end of this block is reached, execution continues normally after the entire try statement.  (This means that if two nested handlers exist for the same exception, and the exception occurs in the try clause of the inner handler, the outer handler will not handle the exception.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если найдена соответствующая ветвь «:keyword:`except`» , то внутри этой ветви данное исключение назначается получателю, указанному после ключевого слова «:keyword:`as`» , если таковое присутствует, и затем блок кода этой ветви «:keyword:`except`» исполняется. Все ветви «:keyword:`except`» должны иметь исполнимый блок. Когда исполнение этого блока завершается – обработка данного исключения завершена, и исполнение продолжается уже́ обычным образом после всей конструкции «:keyword:`try`» . (Это также значит, что если есть два вложенных обработчика для одного вида исключения, то когда оно происходит внутри внутренней ветви «:keyword:`try`» – внешний обработчик не получит этого исключения.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an exception has been assigned using ``as target``, it is cleared at the end of the except clause.  This is as if ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если исключение назначается переменной, указанной после ключевого слова «:keyword:`as`» , то эта переменная автоматически удаляется при завершении этого блока «:keyword:`except`» , как если бы ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>except E as N:     foo</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>except E as N:     foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>was translated to ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>транслировалось в ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>except E as N:     try:         foo     finally:         del N</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>except E as N:     try:         foo     finally:         del N</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means the exception must be assigned to a different name to be able to refer to it after the except clause.  Exceptions are cleared because with the traceback attached to them, they form a reference cycle with the stack frame, keeping all locals in that frame alive until the next garbage collection occurs.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Из этого следует, что если нужно иметь возможность обращаться к данному объекту-исключению после завершения блока «:keyword:`except`» , то нужно назначить это исключение ещё какому-либо имени. Причиной этого является то, что исключения со связанной с ними трассировкой образуют циклические ссылки с кадром стека, из-за чего все локальные переменные в этом кадре будут сохраняться до следующего сбора мусора.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before an except clause's suite is executed, details about the exception are stored in the :mod:`sys` module and can be access via :func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of: ``exc_type``, the exception class; ``exc_value``, the exception instance; ``exc_traceback``, a traceback object (see section :ref:`types`) identifying the point in the program where the exception occurred. :func:`sys.exc_info` values are restored to their previous values (before the call) when returning from a function that handled an exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Перед исполнением блока кода ветви «:keyword:`except`» информация об исключении записывается в модуль «:mod:`sys`» и её можно получить с помощью «:func:`sys.exc_info`» . «:func:`sys.exc_info`» возвращает тройной кортеж, содержащий : «``exc_type``» – класс данного исключения; «``exc_value``» – экземпляр исключения; «``exc_traceback``» – объект трассировки (смотрите раздел об иерархии стандартных типов :ref:`types`) указывающий место программы, в котором произошло исключение. Значения «:func:`sys.exc_info`» восстанавливаются в их предыдущее значение при возвращении из функции обработки исключения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The optional :keyword:`else` clause is executed if and when control flows off the end of the :keyword:`try` clause. [#]_ Exceptions in the :keyword:`else` clause are not handled by the preceding :keyword:`except` clauses.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Необязательная ветвь «:keyword:`else`» исполняется только если и когда происходит выход из блока «:keyword:`try`» в связи с его исчерпанием, а не в связи с исключением или исполнением инструкций «:keyword:`return`» , «:keyword:`continue`» или «:keyword:`break`» . [#]_ Исключения в такой ветви «:keyword:`else`» не обрабатываются идущими перед нею ветвями «:keyword:`except`» (относящимися к той же конструкции «:keyword:`try`») , а являются исключением, возникшим в целой этой конструкции «:keyword:`try`» (и обрабатываются во внешнем коде) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :keyword:`try` clause is executed, including any :keyword:`except` and :keyword:`else` clauses.  If an exception occurs in any of the clauses and is not handled, the exception is temporarily saved. The :keyword:`finally` clause is executed.  If there is a saved exception, it is re-raised at the end of the :keyword:`finally` clause. If the :keyword:`finally` clause raises another exception or executes a :keyword:`return` or :keyword:`break` statement, the saved exception is lost.  The exception information is not available to the program during execution of the :keyword:`finally` clause.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если присутствует ветвь «:keyword:`finally`» , то она определяет завершающий (зачищающий) обработчик. Выполняется ветвь «:keyword:`try`» , а также все ветви «:keyword:`except`» и «:keyword:`else`» . Если в любой из них происходит исключение, и оно не обработано, то оно временно сохраняется. Затем выполняется ветвь «:keyword:`finally`» . Затем, если было сохранено исключение, оно вызывается заново по завершении ветви «:keyword:`finally`» . Если в ветви «:keyword:`finally`» происходит исключение или исполняется инструкция «:keyword:`return`» или «:keyword:`break`» , то сохранённое исключение теряется. Информация об сохранённом исключении не доступна программе во время исполнения ветви «:keyword:`finally`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement is executed in the :keyword:`try` suite of a :keyword:`try`...\ :keyword:`finally` statement, the :keyword:`finally` clause is also executed 'on the way out.' A :keyword:`continue` statement is illegal in the :keyword:`finally` clause. (The reason is a problem with the current implementation --- this restriction may be lifted in the future).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если в ветви «:keyword:`try`» исполняется инструкция «:keyword:`return`» или «:keyword:`break`» , то ветвь «:keyword:`finally`» тоже исполняется перед выходом из всей конструкции «:keyword:`try`...finally» . В ветви «:keyword:`finally`» инструкция «:keyword:`continue`» недопустима. (Проблема в текущей реализации – это ограничение может быть снято в будущем.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional information on exceptions can be found in section :ref:`exceptions`, and information on using the :keyword:`raise` statement to generate exceptions may be found in section :ref:`raise`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Дополнительная информация об исключениях есть в разделе “Исключения” :ref:`exceptions` , а об использовании инструкции «:keyword:`raise`» для вызова исключений – в разделе “Инструкция «raise»” :ref:`raise` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`with` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`with`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`with` statement is used to wrap the execution of a block with methods defined by a context manager (see section :ref:`context-managers`). This allows common :keyword:`try`...\ :keyword:`except`...\ :keyword:`finally` usage patterns to be encapsulated for convenient reuse.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`with`» используется для “оборачивания” исполнения блока методами, определёнными менеджером контекста (смотрите раздел “Менеджеры контекста инструкции «:keyword:`with`» ” :ref:`context-managers` ) . Это позволяет общим схемам использования «:keyword:`try`...\ :keyword:`except`...\ :keyword:`finally`» быть инкапсулированными для удобного повторного использования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The execution of the :keyword:`with` statement with one "item" proceeds as follows:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исполнение инструкции «:keyword:`with`» с одним “элементом” происходит так:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The context expression is evaluated to obtain a context manager.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражение контекста («:token:`with_item`») вычисляется, чтобы получить менеджер контекста.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The context manager's :meth:`__enter__` method is invoked.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается метод «:meth:`__enter__`» этого менеджера контекста.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a target was included in the :keyword:`with` statement, the return value from :meth:`__enter__` is assigned to it.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если присутствует цель назначения («:token:`target`») , то возвращаемое от «:meth:`__enter__`» значение назначается этой цели.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`with` statement guarantees that if the :meth:`__enter__` method returns without an error, then :meth:`__exit__` will always be called. Thus, if an error occurs during the assignment to the target list, it will be treated the same as an error occurring within the suite would be. See step 6 below.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`with`» гарантирует, что если метод «:meth:`__enter__`» выполняется без ошибки, то обязательно будет вызван «:meth:`__exit__`» . Таким образом, если ошибка происходит в течение назначения списку целей, то на этом этапе она уже́ будет воспринята как ошибка внутри блока «:keyword:`with`» . Смотрите шаг 6 ниже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The suite is executed.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исполняется блок кода.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The context manager's :meth:`__exit__` method is invoked.  If an exception caused the suite to be exited, its type, value, and traceback are passed as arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are supplied.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается метод «:meth:`__exit__`» менеджера контекста. Если какое-либо исключение приводит к выходу из блока, то тип, значение и стек вызовов этого исключения передаются в качестве аргументов в «:meth:`__exit__`» – иначе передаются три аргумента «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the suite was exited due to an exception, and the return value from the :meth:`__exit__` method was false, the exception is reraised.  If the return value was true, the exception is suppressed, and execution continues with the statement following the :keyword:`with` statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если выход из блока был из-за исключения, и возвращённое методом «:meth:`__exit__`» значение было “ложь” , то это исключение перевызывается. Если же возвращённое значение было “истина” , то это исключение отменяется, и исполнение продолжается с инструкции следующей за блоком инструкции «:keyword:`with`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the suite was exited for any reason other than an exception, the return value from :meth:`__exit__` is ignored, and execution proceeds at the normal location for the kind of exit that was taken.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если выход из блока был по любой другой причине, то возвращённое методом «:meth:`__exit__`» значение игнорируется, и исполнение продолжается обычным образом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With more than one item, the context managers are processed as if multiple :keyword:`with` statements were nested::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если у «:keyword:`with`» более одного элемента, то это обрабатывается как если бы соответствующие блоки находились один внутри другого ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with A() as a, B() as b:     suite</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>with A() as a, B() as b:     suite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is equivalent to ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>является эквивалентом ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with A() as a:     with B() as b:         suite</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>with A() as a:     with B() as b:         suite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Смотрите также</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The specification, background, and examples for the Python :keyword:`with` statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Спецификация, объяснения и примеры по Питоновской инструкции «:keyword:`with`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Function definitions</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Задание функций</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function definition defines a user-defined function object (see section :ref:`types`):</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Код, задающий функцию, создаёт объект пользовательской функции (смотри́те раздел “Иерархия стандартных типов” :ref:`types` ) :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function definition is an executable statement.  Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function).  This function object contains a reference to the current global namespace as the global namespace to be used when the function is called.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Код, задающий функцию, является исполнимой инструкцией. Его исполнение связывает заданное имя в текущей локальной области имён с объектом функции (в котором содержится исполнимый код функции) . Этот объект функции содержит ссылку на текущую глобальную область имён, и она будет использоваться в качестве глобальной во время вызова этой функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function definition does not execute the function body; this gets executed only when the function is called. [#]_</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Код, задающий функцию, не исполняет тело этой функции – оно будет исполняться, когда функция будет вызвана. [#]_ Запись текстовой константы, идущая как первая инструкция внутри тела функции, преобразуется в атрибут «:attr:`__doc__`» этой функции и таким образом становится текстом документации этой функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function definition may be wrapped by one or more :term:`decorator` expressions. Decorator expressions are evaluated when the function is defined, in the scope that contains the function definition.  The result must be a callable, which is invoked with the function object as the only argument. The returned value is bound to the function name instead of the function object.  Multiple decorators are applied in nested fashion. For example, the following code ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Код, задающий функцию, может подвергаться действию одного или нескольких выражений “декораторов” (:term:`decorator`) . “Декоратор” исполняется после того, как соответствующая функция уже́ определена, в той же области видимости, в которой содержится код, задающий эту функцию. Результат исполнения выражения “декоратора” должен быть вызываемым объектом, который вызывается, с данной функцией в качестве единственного аргумента. Возвращаемый объект назначается имени данной функции вместо прежнего объекта-функции. Множественные “декораторы” применяются поочерёдно, в порядке близости к функции (в стиле вложенности) . Например, следующий код</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@f1(arg) @f2 def func(): pass</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>@f1(arg) @f2 def func(): pass</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def func(): pass func = f1(arg)(f2(func))</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>def func(): pass func = f1(arg)(f2(func))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Default parameter values are evaluated when the function definition is executed.** This means that the expression is evaluated once, when the function is defined, and that that same "pre-computed" value is used for each call.  This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended.  A way around this is to use ``None`` as the default, and explicitly test for it in the body of the function, e.g.::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>** Значения параметров по-умолчанию вычисляются, когда исполняется определение функции.** Это означает, что выражение вычисляется один раз, когда функция определяется, и одно и то же “предварительно вычисленное” значение используется для каждого вызова. Это особенно важно понять, когда параметр по-умолчанию является изменяемым объектом (например списком или словарём) : если функция изменяет этот объект (например, путем добавления элемента в список) , то это значение по-умолчанию останется изменённым. Как правило, это не то, что было задумано. Способом обойти это является использование «:const:`None`» в качестве значения по-умолчанию, и явная проверка этого параметра в теле функции, например: ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def whats_on_the_telly(penguin=None):     if penguin is None:         penguin = []     penguin.append("property of the zoo")     return penguin</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>def whats_on_the_telly(penguin=None):     if penguin is None:         penguin = []     penguin.append("property of the zoo")     return penguin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Function call semantics are described in more detail in section :ref:`calls`. A function call always assigns values to all parameters mentioned in the parameter list, either from position arguments, from keyword arguments, or from default values.  If the form "``*identifier``" is present, it is initialized to a tuple receiving any excess positional parameters, defaulting to the empty tuple.  If the form "``**identifier``" is present, it is initialized to a new dictionary receiving any excess keyword arguments, defaulting to a new empty dictionary. Parameters after "``*``" or "``*identifier``" are keyword-only parameters and may only be passed used keyword arguments.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Семантика вызова функции описана более подробно в разделе «:ref:`calls`» . Вызов функции всегда присваивает значения всем параметрам, упомянутым в списке параметров в определении, либо от переданных позиционных аргументов, либо от переданных именованных аргументов, либо от значений по умолчанию. Если присутствует форма “``*identifier``” , то она инициализируется кортежем, содержащим все лишние позиционные параметры, а при отсутствии таковых – пустым кортежем. Если присутствует форма “``**identifier``” , то она инициализируется новый словарём, содержащим все лишние именованные аргументы, а при отсутствии таковых – новым пустым словарём. Параметры после “``*``” или “``*identifier``” могут быть только именованными параметрами и могут быть переданы только через именованные параметры.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parameters may have annotations of the form "``: expression``" following the parameter name.  Any parameter may have an annotation even those of the form ``*identifier`` or ``**identifier``.  Functions may have "return" annotation of the form "``-&gt; expression``" after the parameter list.  These annotations can be any valid Python expression and are evaluated when the function definition is executed.  Annotations may be evaluated in a different order than they appear in the source code.  The presence of annotations does not change the semantics of a function.  The annotation values are available as values of a dictionary keyed by the parameters' names in the :attr:`__annotations__` attribute of the function object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Параметры могут иметь описания в форме “``: expression``” после имени параметра. Любой параметр может иметь описание, даже те, которые в форме “``*identifier``” или “``**identifier``” . Функции могут иметь описание возвращаемого результата в форме “``-&gt; expression``” в позиции после списка параметров. Эти описания могут быть любыми допустимыми выражениями Питона, они вычисляются при исполнении определения функции. Описания могут быть вычислены в другом порядке, чем они появляются в исходном коде. Наличие описаний не меняет семантику функции. Значения описаний доступны в виде значений словаря в атрибуте «:attr:`__annotations__`» данной функции, с именем нужного параметра в качестве ключа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions.  This uses lambda forms, described in section :ref:`lambda`.  Note that the lambda form is merely a shorthand for a simplified function definition; a function defined in a ":keyword:`def`" statement can be passed around or assigned to another name just like a function defined by a lambda form.  The ":keyword:`def`" form is actually more powerful since it allows the execution of multiple statements and annotations.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Кроме того, можно создавать анонимные функции (функции, не связанные с именем), для непосредственного использования по месту создания внутри выражения. Для этого используются ламбда-формы – это практически синоним понятия “упрощенное определение функции” – их описание в разделе Ламбды. Функцию, определенную инструкцией «:keyword:`def`» можно передавать или назначать другому имени так же, как и функцию, определенную ламбда-формой. Форма «:keyword:`def`» вообще-то имеет больше возможностей, например, позволяет выполнять несколько инструкций и иметь описания.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Programmer's note:** Functions are first-class objects.  A "``def``" form executed inside a function definition defines a local function that can be returned or passed around.  Free variables used in the nested function can access the local variables of the function containing the def.  See section :ref:`naming` for details.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>**Замечание:** Функции являются объектами первого класса. Форма «:keyword:`def`» выполняемая внутри определения другой функции – создаёт локальную функцию, которая может быть внешнею функцией возвращена в качестве результата или передана куда-либо. Свободные имена, используемые во вложенной функции, могут указывать на локальные переменные внешней функции. Смотрите детали в разделе “:ref:`naming`” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class definition is an executable statement.  It first evaluates the inheritance list, if present.  Each item in the inheritance list should evaluate to a class object or class type which allows subclassing.  The class's suite is then executed in a new execution frame (see section :ref:`naming`), using a newly created local namespace and the original global namespace. (Usually, the suite contains only function definitions.)  When the class's suite finishes execution, its execution frame is discarded but its local namespace is saved. [#]_ A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary.  The class name is bound to this class object in the original local namespace.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Код, задающий класс (“определение” класса) , является исполнимой инструкцией. Сначала, если имеется, вычисляется список наследуемых базовых классов. Каждый элемент в этом списке должен давать в результате объект-класс, такой, который допускает создание производного класса. Затем основной класс исполняется в новом кадре исполнения (смотри́те раздел :ref:`naming` ) с использованием новосозданной локальной области имён и исходной глобальной области имён. (Обычно код класса содержит только “определения” функций. ) Текстовый объект, идущий с первой строки содержания кода класса, преобразуется в элемент с именем “``__doc__``” в данной локальной области и, таким образом становится “документацией” этого класса. [#]_ Когда код класса завершён, его кадр исполнения удаляется, а его локальная область имён сохраняется. Затем создаётся объект-класс с использованием списка наследования для базовых классов, а полученная ранее область имён становится словарём атрибутов класса. Затем полученный объект-класс назначается указанному имени в исходной области имён.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes can also be decorated; as with functions, ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Классы могут быть “декорированы” , таким же образом как и функции: ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@f1(arg) @f2 class Foo: pass</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>@f1(arg) @f2 class Foo: pass</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Foo: pass Foo = f1(arg)(f2(Foo))</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>class Foo: pass Foo = f1(arg)(f2(Foo))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Programmer's note:** Variables defined in the class definition are class variables; they are shared by instances. Instance variables can be set in a method with ``self.name = value``.  Both class and instance variables are accessible through the notation "``self.name``", and an instance variable hides a class variable with the same name when accessed in this way.  Class variables can be used as defaults for instance variables, but using mutable values there can lead to unexpected results.  Descriptors can be used to create instance variables with different implementation details.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>**Замечание:** Переменные, созданные в “определении” класса становятся атрибутами класса, общими для всех его экземпляров. Атрибуты экземпляра могут быть созданы из какого-либо метода посредством «``self.name = значение``» . Атрибуты и класса и экземпляра доступны через формулировку «``self.name``» , и при таком способе доступа атрибут экземпляра перекрывает атрибут класса с тем же именем. Атрибуты класса могут использоваться как значения по умолчанию для атрибутов экземпляра, но если эти атрибуты класса являются изменяемыми – то это может привести к неожиданным результатам. Для создания у экземпляра переменных с нестандартными деталями реализации – можно использовать дескрипторы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`3129` - Class Decorators</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:pep:`3129` - “Декораторы” классов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class definitions, like function definitions, may be wrapped by one or more :term:`decorator` expressions.  The evaluation rules for the decorator expressions are the same as for functions.  The result must be a class object, which is then bound to the class name.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>“Определение” класса (так же как и функции) , может подвергаться действию одного или нескольких выражений :term:`“декораторов”&lt;decorator&gt;` . Правила исполнения :term:`“декораторов”&lt;decorator&gt;` такие же, как и для функций. Результат исполнения выражения :term:`“декоратора”&lt;decorator&gt;` должен быть объектом-классом, который затем назначается имени данного класса вместо прежнего класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Footnotes</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сноски</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The exception is propagated to the invocation stack only if there is no :keyword:`finally` clause that negates the exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исключение передаётся вверх по стеку вызовов только если отсутствует блок «:keyword:`finally`» , такой, который нейтрализует данное исключение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A string literal appearing as the first statement in the function body is transformed into the function's ``__doc__`` attribute and therefore the function's :term:`docstring`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись текстовой константы, идущая как первая инструкция внутри тела функции, преобразуется в атрибут «``__doc__``» этой функции и таким образом становится текстом :term:`“документации”&lt;docstring&gt;` этой функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A string literal appearing as the first statement in the class body is transformed into the namespace's ``__doc__`` item and therefore the class's :term:`docstring`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Текстовый объект, идущий с первой строки содержания кода класса, преобразуется в элемент с именем “``__doc__``” в данной локальной области и, таким образом, становится :term:`“документацией”&lt;docstring&gt;` этого класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data model</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Модель данных</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects, values and types</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты, значения и типы</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:dfn:`Objects` are Python's abstraction for data.  All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann's model of a "stored program computer," code is also represented by objects.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты в Питоне являются абстракцией для данных. Все данные в программе на Питоне представлены объектами или взаимоотношениями между объектами. (А с точки зрения Фон Неймановской модели «хранимых в памяти программ» , код также представляется объектами.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every object has an identity, a type and a value.  An object's *identity* never changes once it has been created; you may think of it as the object's address in memory.  The ':keyword:`is`' operator compares the identity of two objects; the :func:`id` function returns an integer representing its identity (currently implemented as its address). An object's :dfn:`type` is also unchangeable. [#]_ An object's type determines the operations that the object supports (e.g., "does it have a length?") and also defines the possible values for objects of that type.  The :func:`type` function returns an object's type (which is an object itself).  The *value* of some objects can change.  Objects whose value can change are said to be *mutable*; objects whose value is unchangeable once they are created are called *immutable*. (The value of an immutable container object that contains a reference to a mutable object can change when the latter's value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed.  So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object's mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Каждый объект имеет идентификатор, тип и значение. *Идентификатор* объекта никогда не изменяется после создания объекта, его можно представить себе как адрес объекта в памяти. Оператор «:keyword:`is`» сравнивает идентификаторы двух объектов; функция «:func:`id`» возвращает целое число, представляющее идентификатор (на текущий момент реализованный как адрес объекта). Тип объекта также является неизменяемым. [#]_ Тип объекта определяет операции, поддерживаемые объектом (например, имеет ли объект длину), а также возможные значения для объекта этого типа. Функция «:func:`type`» возвращает тип объекта (тип, в свою очередь, как и любые данные, является объектом). *Значение* некоторых объектов может меняться. Объекты, значение которых может меняться с сохранением того же идентификатора, называются *изменяемыми*; объекты, значение которых после их создания не может быть изменено так, чтобы идентификатор остался неизменным, называются *неизменяемыми*. (В некотором смысле значение неизменяемого объекта-контейнера, который содержит ссылки на изменяемые объекты, может виртуально меняться, когда значение последних изменено, тем не менее сам контейнер рассматривается как неизменяемый, потому что набор содержащихся в нем объектов не может быть изменен. Таким образом, неизменяемость *объекта* не подразумевает неизменяемость *результата* вычисления (интерпретирования) этого объекта.) Изменяемость объекта определяется его типом, например: числа, текстовые данные и кортежи неизменяемы, тогда как словари и списки изменяемы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.  An implementation is allowed to postpone garbage collection or omit it altogether --- it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты никогда явным образом не уничтожаются, тем не менее, когда они становятся недоступны они могут быть обработаны “сборщиком мусора” . В реализациях допустимы также отложенная “сборка мусора” или полное ее отсутствие. Каким образом реализована сборка мусора - это вопрос качества реализации, но при обязательном условии, что объекты, которые все еще доступны, не будут собраны “сборщиком мусора” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references.  See the documentation of the :mod:`gc` module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В настоящее время “CPython” использует схему подсчёта ссылок с (опционально) отсрочкой определения циклически связанного “мусора” , которая собирает большинство объектов, как только они становятся недоступными, но не гарантируется сборка мусора, содержащего циклические ссылки. Смотрите документацию модуля «:mod:`gc`», чтобы узнать о контроле сбора циклического мусора.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the use of the implementation's tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a ':keyword:`try`...\ :keyword:`except`' statement may keep objects alive.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обратите внимание, что в данной реализации использование трассировки или отладки может сохранить объекты, которые в норме были бы “собраны” . Отметьте также, что перехват исключения в выражении «:keyword:`try`...\ :keyword:`except`» может сохранить объекты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some objects contain references to "external" resources such as open files or windows.  It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a :meth:`close` method. Programs are strongly recommended to explicitly close such objects.  The ':keyword:`try`...\ :keyword:`finally`' statement and the ':keyword:`with`' statement provide convenient ways to do this.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Некоторые объекты содержат ссылки на “внешние” ресурсы, такие как открытые файлы или “окна” . Понятно что эти ресурсы освобождаются при сборке мусора, однако поскольку не гарантировано что “сбор мусора” произойдет, то такие объекты также предоставляют явный способ освобождения таких внешних ресурсов – как правило это метод :meth:`close` . В программах настоятельно рекомендуется закрывать такие объекты явно. Для этого удобно использовать конструкции «:keyword:`try`...\ :keyword:`finally`» и «:keyword:`with`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some objects contain references to other objects; these are called *containers*. Examples of containers are tuples, lists and dictionaries.  The references are part of a container's value.  In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied.  So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Некоторые объекты содержат ссылки на другие объекты; они называются “контейнерами” . Примеры “контейнеров” – это кортежи, списки и словари. Ссылки являются частью значения контейнера. В большинстве случаев, когда мы говорим о значении контейнера, мы подразумеваем значения, а не идентификаторы хранимых объектов; однако, когда мы говорим о изменяемости/неизменяемости контейнера, подразумеваются только непосредственно хранимые объекты (тоесть сами идентификаторы, а не указываемые значения) . Поэтому, если неизменный контейнер (как, например, кортеж) содержит ссылку на изменяемый объект, то значение, получающееся в результате интерпретирования этого контейнера меняется, если меняется указываемый изменяемый объект.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Types affect almost all aspects of object behavior.  Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer to the same object with the value one, depending on the implementation, but after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two different, unique, newly created empty lists. (Note that ``c = d = []`` assigns the same object to both ``c`` and ``d``.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Типы влияют почти на все аспекты поведения объекта. Даже идентичность объектов в какой-то степени подвержена этому влиянию: для неизменяемых типов, операции, которые вычисляют новые значения могут в действительности возвращать ссылку на какой-либо существующий объект такого же типа и с таким же значением, тогда как для изменяемых объектов это не допустимо. Например, после ``a = 1; b = 1`` , ``a`` и ``b`` могут ссылаться на один и тот же объект, имеющий значение “единица” (а могут и на разные), что зависит от конкретной реализации, но после ``c = []; d = []`` , ``c`` и ``d`` обязательно ссылаются на два различных, уникальных, заново созданных пустых списка. (Заметьте, что ``c = d = []`` присваивает один и тот же объект и ``c`` и ``d`` .)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The standard type hierarchy</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Иерархия стандартных типов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a list of the types that are built into Python.  Extension modules (written in C, Java, or other languages, depending on the implementation) can define additional types.  Future versions of Python may add types to the type hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.), although such additions will often be provided via the standard library instead.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ниже перечислены типы, встроенные в Питон. Модули расширения (написанные на “C”, “Java”, или других языках - в зависимости от реализации Питона в конкретном случае) могут определять дополнительные типы. Будущие версии Питона могут добавить новые к иерархии типов (напр. рациональные числа, эффективные массивы целых и т.д.), хотя, чаще всего, такие дополнения будут предоставляться с помощью стандартных библиотек.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of the type descriptions below contain a paragraph listing 'special attributes.'  These are attributes that provide access to the implementation and are not intended for general use.  Their definition may change in the future.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Некоторые из описаний типов, данные ниже, содержат абзац, перечисляющий “специальные атрибуты”. Это атрибуты, которые предоставляют доступ к внутреннему механизму реализации, и они не предназначены для использования в норме. Их определение может измениться в будущем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This type has a single value.  There is a single object with this value. This object is accessed through the built-in name ``None``. It is used to signify the absence of a value in many situations, e.g., it is returned from functions that don't explicitly return anything. Its truth value is false.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип может иметь только единственное значение. И имеется только единственый объект с этим значением. Доступ к этому объекту происходит через встроенное имя «:const:`None`» . Во многих ситуациях он используется, чтобы обозначить отсутствие значения, например он возвращается из функций, которые не возвращают ничего явным образом. «:const:`None`» имеет значение истинности: «:const:`False`» (“ложь”) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This type has a single value.  There is a single object with this value. This object is accessed through the built-in name ``NotImplemented``. Numeric methods and rich comparison methods may return this value if they do not implement the operation for the operands provided.  (The interpreter will then try the reflected operation, or some other fallback, depending on the operator.)  Its truth value is true.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип может иметь только единственное значение. И имеется только единственый объект с этим значением. Доступ к этому объекту происходит через встроенное имя «:const:`NotImplemented`» . Числовые методы и методы сравнения могут вернуть это значение, если они не имеют реализации данной операции для данных операндов. «:const:`NotImplemented`» имеет значение истинности: «:const:`True`» ("истина") .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This type has a single value.  There is a single object with this value. This object is accessed through the literal ``...`` or the built-in name ``Ellipsis``.  Its truth value is true.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип может иметь только единственное значение. И имеется только единственый объект с этим значением. Доступ к этому объекту происходит через запись ``...`` (троеточие), или встроенное имя «:const:`Ellipsis`» . «:const:`Ellipsis`» имеет значение истинности: «:const:`True`» ("истина").</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are created by numeric literals and returned as results by arithmetic operators and arithmetic built-in functions.  Numeric objects are immutable; once created their value never changes.  Python numbers are of course strongly related to mathematical numbers, but subject to the limitations of numerical representation in computers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты этого типа создаются непосредственной записью числа, а также возвращаются как результат арифметическими операторами и арифметическими встроенными функциями. Числовые объекты являются неизменяемыми (“immutable”) - будучи однажды созданным, их значение никогда не меняется. Питоновские числа, конечно, ассоциируются с числами, как они понимаются в математике, только имеют ограничения компьютерного числового представления.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python distinguishes between integers, floating point numbers, and complex numbers:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Питон различает целые, комплексные и числа с плавающей запятой :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent elements from the mathematical set of integers (positive and negative).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Представляют собой элементы математического множества целых (положительных и отрицательных) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two types of integers:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Есть два типа целых :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integers (:class:`int`)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Целые (:class:`int`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent numbers in an unlimited range, subject to available (virtual) memory only.  For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of 2's complement which gives the illusion of an infinite string of sign bits extending to the left.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип представляет целые числа в теоретически неограниченном диапазоне, ограничиваясь только доступной памятью (виртуальной). При выполнении операций сдвига и маскирования подразумевается двоичная запись числа, и отрицательные числа представлены в варианте двоичного дополнительного кода, который даёт впечатление бесконечного ряда знаковых битов, распространяющихся влево.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent the truth values False and True.  The two objects representing the values False and True are the only Boolean objects. The Boolean type is a subtype of the integer type, and Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings ``"False"`` or ``"True"`` are returned, respectively.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип представляет значения истинности - «:const:`False`» и «:const:`True`» . Только два объекта, представляющие «:const:`False`» и «:const:`True`» , являются булевыми(логическими). Булевый - является подтипом целых, и булевые значения ведут себя как значения “0” и “1” (для «:const:`False`» и «:const:`True`» соответственно) - почти во всех контекстах - с тем исключением, что при конвертации в строку возвращаются строки ``"False"`` или ``"True"`` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rules for integer representation are intended to give the most meaningful interpretation of shift and mask operations involving negative integers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Правила представления целых нацелены на наиболее функциональную интерпретацию операций сдвига и маскирования для целых чисел, включая отрицательные.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent machine-level double precision floating point numbers. You are at the mercy of the underlying machine architecture (and C or Java implementation) for the accepted range and handling of overflow. Python does not support single-precision floating point numbers; the savings in processor and memory usage that are usually the reason for using these is dwarfed by the overhead of using objects in Python, so there is no reason to complicate the language with two kinds of floating point numbers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Представляют собой машинную реализацию чисел с плавающей запятой двойной точности. Приходится полностью полагаться на архитектуру машины, на которой происходит исполнение (и на реализацию “C” или “Java”) , в отношении диапазона и обработки переполнения. Питон не поддерживает числа с плавающей запятой одинарной точности – экономия ресурсов процессора и памяти, которая обычно является причиной их использования, перечёркивается дополнительными затратами при использовании объектов Питона, так что нет причин усложнять язык двумя видами чисел с плавающей запятой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent complex numbers as a pair of machine-level double precision floating point numbers.  The same caveats apply as for floating point numbers. The real and imaginary parts of a complex number ``z`` can be retrieved through the read-only attributes ``z.real`` and ``z.imag``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип определяет комплексные числа, как пары зависящих от машинной реализации чисел двойной длины с плавающей точкой. Для них действительны те же ограничения, что и для чисел с плавающей точкой. Значения вещественной и мнимой частей комплексного числа ``z`` могут быть получены с помощью атрибутов (только для чтения) ``z.real`` и ``z.imag`` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent finite ordered sets indexed by non-negative numbers. The built-in function :func:`len` returns the number of items of a sequence. When the length of a sequence is *n*, the index set contains the numbers 0, 1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип представляет ограниченое (не бесконечное) упорядоченое множество, индексированное неотрицательными целыми числами. При длинне последовательности *n* множество индексов содержит числа 0, 1, ..., *n*-1. Элемент *i* последовательности a адресуется записью ``a[i]`` . Встроенная функция :func:`len` возвращает количество элементов в последовательности.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequences also support slicing: ``a[i:j]`` selects all items with index *k* such that *i* ``&lt;=`` *k* ``&lt;`` *j*.  When used as an expression, a slice is a sequence of the same type.  This implies that the index set is renumbered so that it starts at 0.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для последовательностей также доступно вырезание (“срезы”, “slices”). Так ``a[i:j]`` выбирает все элементы с индексом *k*, таким, что *i* ``&lt;=`` *k* ``&lt;`` *j*. При использовании в качестве выражения, срез является последовательностью того же типа, что и исходная последовательность. При этом множество индексов заново перечисляется, начиная с 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some sequences also support "extended slicing" with a third "step" parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = i + n*k``, *n* ``&gt;=`` ``0`` and *i* ``&lt;=`` *x* ``&lt;`` *j*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Некоторые последовательности также поддерживают “расширенные срезы” с третьим параметром “шаг” . Так ``a[i:j:k]`` выбирает все элементы из *a* с индексом *x* , где ``x = i + n*k`` , *n* ``&gt;=`` ``0`` , *i* ``&lt;=`` *x* ``&lt;`` *j* .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequences are distinguished according to their mutability:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Последовательности различаются с точки зрения их изменяемости :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An object of an immutable sequence type cannot change once it is created.  (If the object contains references to other objects, these other objects may be mutable and may be changed; however, the collection of objects directly referenced by an immutable object cannot change.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект принадлежащий к типу неизменяемой последовательности не может изменяться с момента создания. (Если же этот объект содержит ссылки на другие объекты, то уже́́́ эти другие объекты могут оказаться изменяемыми - и могут меняться; однако тот набор объектов, на которые непосредственно ссылается неизменяемый объект, меняться не может.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following types are immutable sequences:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие типы являются неизменяемыми последовательностями :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The items of a string object are Unicode code units.  A Unicode code unit is represented by a string object of one item and can hold either a 16-bit or 32-bit value representing a Unicode ordinal (the maximum value for the ordinal is given in ``sys.maxunicode``, and depends on how Python is configured at compile time).  Surrogate pairs may be present in the Unicode object, and will be reported as two separate items.  The built-in functions :func:`chr` and :func:`ord` convert between code units and nonnegative integers representing the Unicode ordinals as defined in the Unicode Standard 3.0. Conversion from and to other encodings are possible through the string method :meth:`encode`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Элементами текстового (“строкового”) объекта являются элементарные(минимальные) единицы(порции) кода Юникод. Код символа Юникод реализуется текстовым объектом из одного символа и может использовать 16- или 32-битное значение, означающее номер символа Юникод (максимальное значение для этого номера задано в ``sys.maxunicode`` , и зависит от того, как Питон сконфигурирован при компиляции) . Могущие присутствовать в Юникодном объекте “суррогатные пары” будут восприниматься как два отдельных объекта. Встроенные функции «:func:`chr`» и «:func:`ord`» выполняют преобразование между односимвольным текстовым объектом и неотрицательным целым числовым объектом с соответствующим значением номера символа Юникода, как определено в “Unicode Standard 3.0” . Преобазования из и в другие кодировки возможны с помощью метода «:meth:`encode`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The items of a tuple are arbitrary Python objects. Tuples of two or more items are formed by comma-separated lists of expressions.  A tuple of one item (a 'singleton') can be formed by affixing a comma to an expression (an expression by itself does not create a tuple, since parentheses must be usable for grouping of expressions).  An empty tuple can be formed by an empty pair of parentheses.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Элементами “кортежа” могут быть любые объекты Питона. Кортежи из двух и более элементов образуются перечнем выражений, разделённых запятыми. Кортеж из одного элемента (“singleton”) может быть образован добавлением запятой после выражения (само выражение без запятой - не создаёт кортеж, поскольку в таком случае скобки обозначают группирование в выражении). Пустой кортеж может быть образован пустой парой скобок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bytes object is an immutable array.  The items are 8-bit bytes, represented by integers in the range 0 &lt;= x &lt; 256.  Bytes literals (like ``b'abc'`` and the built-in function :func:`bytes` can be used to construct bytes objects.  Also, bytes objects can be decoded to strings via the :meth:`decode` method.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Байтовый объект является неизменяемым массивом. Его элементами являются 8-битовые байты, которые могут быть представлены целыми числами в диапазоне 0 &lt;= x &lt; 256. Для создания байтовых объектов можно использовать непосредственную запись байтов (как например  ``b'abc'`` ), или встроенную функцию «:func:`bytes`» . Кроме того, байтовые объекты могут быть перекодированы в строковые с помощью метода «:meth:`decode`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutable sequences can be changed after they are created.  The subscription and slicing notations can be used as the target of assignment and :keyword:`del` (delete) statements.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Изменяемые последовательности могут быть изменены после их создания. Обозначения индексации и “среза” могут быть использованы в качестве цели для выражений присваивания и :keyword:`del` (удаления) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are currently two intrinsic mutable sequence types:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В данной версии есть два типа изменяемых последовательностей:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The items of a list are arbitrary Python objects.  Lists are formed by placing a comma-separated list of expressions in square brackets. (Note that there are no special cases needed to form lists of length 0 or 1.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Элементами списка могут быть любые объекты Питона. Списки задаются перечислением выражений через запятую внутри пары квадратных скобок. (Заметьте, что нет специальной формы для списка пустого или с одним элементом.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bytearray object is a mutable array. They are created by the built-in :func:`bytearray` constructor.  Aside from being mutable (and hence unhashable), byte arrays otherwise provide the same interface and functionality as immutable bytes objects.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект типа массив байтов является изменяемым массивом. Они создаются встроенным конструктором «:func:`bytearray`» . За исключением изменяемости, байтовые массивы в остальном предоставляют теже интерфейс и функциональность как и неизменяемые байтовые объекты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension module :mod:`array` provides an additional example of a mutable sequence type, as does the :mod:`collections` module.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Модулях расширения «:mod:`array`» и «:mod:`collections`» предоставлены дополнительные варианты типов изменяемых последовательностей.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent unordered, finite sets of unique, immutable objects. As such, they cannot be indexed by any subscript. However, they can be iterated over, and the built-in function :func:`len` returns the number of items in a set. Common uses for sets are fast membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эти типы представляют неупорядоченные, конечные наборы неповторяющихся объектов. В связи с этим к ним не могут применяться операции выбора элементов по их индексу. Однако элементы наборов могут быть последовательно перебраны (“итерированы”), а также можно получить их количество с помощью встроенной функции «:func:`len`» . Обычно наборы находят применение для быстрого определения вхождения во множество, для удаления повторов из последовательностей и для проведения операций типа пересечения, объединения, разности.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For set elements, the same immutability rules apply as for dictionary keys. Note that numeric types obey the normal rules for numeric comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be contained in a set.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для элементов наборов применяются теже правила неизменяемости, как и для ключей словарей. Обратите внимание, что для числовых типов реализуются обычные правила сравнения чисел : если два числа равны (с точки зрения операции сравнения, как например ``1`` и ``1.0`` ), то только одно может присутствовать в наборе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are currently two intrinsic set types:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В данной версии языка существует два внутренних наборных типа :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent a mutable set. They are created by the built-in :func:`set` constructor and can be modified afterwards by several methods, such as :meth:`add`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип представляет изменяемый набор. Наборы создаются встроенным конструктором «:func:`set`» и впоследствии могут быть изменены с помощью некоторых "методов" - например «:meth:`add`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent an immutable set.  They are created by the built-in :func:`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, it can be used again as an element of another set, or as a dictionary key.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот тип представляет неизменяемый набор. Они создаются встроенным конструктором «:func:`frozenset`» . Поскольку они неизменяемые и “хешируемые” (“:term:`hashable`”) - они могут в свою очередь быть использованы как элемент другого набора, или как ключ словаря.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent finite sets of objects indexed by arbitrary index sets. The subscript notation ``a[k]`` selects the item indexed by ``k`` from the mapping ``a``; this can be used in expressions and as the target of assignments or :keyword:`del` statements. The built-in function :func:`len` returns the number of items in a mapping.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это конечные наборы объектов, индексированных произвольным набором индексов. Запись индексирования (извлечения) «``a[k]``» выбирает элемент, индексированный значением «``k``» , из отображения «``a``» . Такая запись может использоваться в выражениях и как получатель значения или с инструкцией «:keyword:`del`» . Встроенная функция «:func:`len`» возвращает количество элементов в отображении.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is currently a single intrinsic mapping type:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В данной версии есть единственный тип отображения :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These represent finite sets of objects indexed by nearly arbitrary values.  The only types of values not acceptable as keys are values containing lists or dictionaries or other mutable types that are compared by value rather than by object identity, the reason being that the efficient implementation of dictionaries requires a key's hash value to remain constant. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used interchangeably to index the same dictionary entry.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Словари - это конечные множества объектов, индексируемых соответственно элементами (которые могут быть практически любыми значениями) другого набора той же длины. Единственными типами значений, недопустимыми в качестве индекса (ключа), являются значения, содержащие списки или словари или другие изменяемые типы, сравнение которых производится по значению, а не по идентификатору, по причине того, что для эффективной реализации словарей требуется, чтобы значения хешей ключей оставались неизменяемыми. для числовых типов, используемых в качестве ключей, реализуются обычные правила сравнения чисел : если два числа равны (с точки зрения операции сравнения, как например ``1`` и ``1.0`` ), то они являются взаимозаменяемыми и любое из них может может быть использовано в качестве ключа к одной и той же записи словаря.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dictionaries are mutable; they can be created by the ``{...}`` notation (see section :ref:`dict`).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Словари являются изменяемыми. Они могут быть созданы с помощью записи «``{...}``» (смотрите раздел :ref:`dict`) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional examples of mapping types, as does the :mod:`collections` module.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В модулях расширения «:mod:`dbm.ndbm`» и «:mod:`dbm.gnu`» , также, как и в «:mod:`collections`» предоставлены дополнительные варианты типов отображений.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the types to which the function call operation (see section :ref:`calls`) can be applied:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это типы, к которым применима операция вызова (исполнения) функции (смотрите раздел "Вызовы" :ref:`calls` ) :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A user-defined function object is created by a function definition (see section :ref:`function`).  It should be called with an argument list containing the same number of items as the function's formal parameter list.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект функции определяемой пользователем создаётся определением функции (смотрите раздел “Определения функций” :ref:`function` ). Её следует вызывать со списком, содержащим ровно то же количество аргументов, что и в списке формальных параметров этой функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special attributes:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Атрибут</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Meaning</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Смысл</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__doc__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__doc__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function's documentation string, or ``None`` if unavailable</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Строка описания (“документации”) данной функции, или иначе значение :const:`None` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writable</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Изменяемый</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__name__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__name__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function's name</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Имя данной функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__module__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__module__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the module the function was defined in, or ``None`` if unavailable.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Имя модуля, в котором данная функция была определена, или иначе значение :const:`None` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__defaults__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__defaults__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A tuple containing default argument values for those arguments that have defaults, or ``None`` if no arguments have a default value</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Кортеж, содержащий значения по умолчанию для аргументов, для которых они определены, или значение :const:`None` , если нет аргументов со значением по умолчанию.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__code__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__code__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code object representing the compiled function body.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект кода, представляющий компилированное тело данной функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__globals__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__globals__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A reference to the dictionary that holds the function's global variables --- the global namespace of the module in which the function was defined.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ссылка на словарь, содержащий глобальные переменные данной функции — глобальная область имён того модуля, в котором данная функция была определена.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read-only</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Неизменяемый</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__dict__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__dict__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The namespace supporting arbitrary function attributes.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пространство имён для поддержки произвольных атрибутов данной функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__closure__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__closure__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``None`` or a tuple of cells that contain bindings for the function's free variables.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:const:`None`» или кортеж ячеек, содержащих назначения для тех переменных данной функции, которые более нигде не связаны (тоесть, “замыкание”) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__annotations__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__annotations__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dict containing annotations of parameters.  The keys of the dict are the parameter names, or ``'return'`` for the return annotation, if provided.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Словарь, содержащий описания параметров. Ключи этого словаря совпадают с именами параметров к этой функции, также может присутствовать ключ «``'return'``» для соответствующего описания .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:attr:`__kwdefaults__`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:attr:`__kwdefaults__`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dict containing defaults for keyword-only parameters.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Словарь, содержащий значения по умолчанию для параметров, доступных только по имени.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the attributes labelled "Writable" check the type of the assigned value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Большинство атрибутов помеченных “Изменяемый” проверяют тип записываемого в них значения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Function objects also support getting and setting arbitrary attributes, which can be used, for example, to attach metadata to functions.  Regular attribute dot-notation is used to get and set such attributes. *Note that the current implementation only supports function attributes on user-defined functions. Function attributes on built-in functions may be supported in the future.*</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты-функции также поддерживают получение и установку произвольных атрибутов, которые могут быть использованы, например, для прикрепления метаданных к функциям. Для получения и установки таких атрибутов используется стандартная запись атрибутов через точку. Обратите внимание, что текущая реализация поддерживает только атрибуты пользовательских функций. Атрибуты встроенных функций могут быть реализованы в будущем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional information about a function's definition can be retrieved from its code object; see the description of internal types below.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Дополнительная информация об определении функции может быть получена из ее объекта-кода; смотрите описание встроенных типов ниже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An instance method object combines a class, a class instance and any callable object (normally a user-defined function).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект метода экземпляра сочетает в себе класс, экземпляр класса и любой вызываемый объект (обычно - функция, определяемая пользователем) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special read-only attributes: :attr:`__self__` is the class instance object, :attr:`__func__` is the function object; :attr:`__doc__` is the method's documentation (same as ``__func__.__doc__``); :attr:`__name__` is the method name (same as ``__func__.__name__``); :attr:`__module__` is the name of the module the method was defined in, or ``None`` if unavailable.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты, доступные только для чтения : «:attr:`__self__`» это данный объект экземпляра класса, «:attr:`__func__`» это данный объект функции; «:attr:`__doc__`» это описание данного метода (то же, что и «``__func__.__doc__``»); «:attr:`__name__`» это имя данного метода (то же, что и «``__func__.__name__``»); «:attr:`__module__`» это имя того модуля, в котором данный метод был определен, или, если не применимо - «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods also support accessing (but not setting) the arbitrary function attributes on the underlying function object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Методы также поддерживают доступ (но не запись) к произвольному атрибуту функции в объекте соответствующей функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an instance method object is derived from a class method object, the "class instance" stored in :attr:`__self__` will actually be the class itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying function.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если метод экземпляра не определён в этом экземпляре, а унаследован от метода класса, то атрибут «:attr:`__self__`» на самом деле будет указывать не на этот экземпляр класса, а непосредственно на сам класс, и, таким образом, вызов и «``x.f(1)``» и «``C.f(1)``» является эквивалентом вызову «``f(C,1)``» , где «``f``» - соответствующая функция.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the transformation from function object to instance method object happens each time the attribute is retrieved from the instance.  In some cases, a fruitful optimization is to assign the attribute to a local variable and call that local variable. Also notice that this transformation only happens for user-defined functions; other callable objects (and all non-callable objects) are retrieved without transformation.  It is also important to note that user-defined functions which are attributes of a class instance are not converted to bound methods; this *only* happens when the function is an attribute of the class.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что преобразование из объекта функции в объект метода экземпляра происходит каждый раз при извлечении атрибута из экземпляра. В некоторых случаях эффективной оптимизацией является назначение атрибута локальной переменной и вызов этой локальной переменной. Также учитывайте, что это преобразование выполняется только для функций, определенных пользователем; прочие вызываемые объекты (и все невызываемые объекты) извлекаются без преобразования. Важно заметить, что такие определенные пользователем функции, которые являются атрибутами экземпляров классов, не преобразуются в связанные методы; это происходит **только** если функция является атрибутом класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function or method which uses the :keyword:`yield` statement (see section :ref:`yield`) is called a :dfn:`generator function`.  Such a function, when called, always returns an iterator object which can be used to execute the body of the function:  calling the iterator's :meth:`__next__` method will cause the function to execute until it provides a value using the :keyword:`yield` statement.  When the function executes a :keyword:`return` statement or falls off the end, a :exc:`StopIteration` exception is raised and the iterator will have reached the end of the set of values to be returned.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Функция или метод, задействующие инструкцию «:keyword:`yield`» (смотрите раздел “Инструкция «yield»” :ref:`yield` ) , называется : функция-генератор (:dfn:`generator function`) . При вызове такая функция всегда возвращает объект-итератор, который может быть использован для выполнения тела функции – вызов метода «:meth:`__next__`» данного итератора приведёт к исполнению данной функции, пока она предоставляет какое-либо значение с использованием инструкции «:keyword:`yield`» . Когда данная функция исполняет инструкцию «:keyword:`return`» или достигает своего конца – вызывается исключение «:exc:`StopIteration`» – и объект-итератор таким образом достигнет конца множества значений, которые он должен выдать.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A built-in function object is a wrapper around a C function.  Examples of built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a standard built-in module). The number and type of the arguments are determined by the C function. Special read-only attributes: :attr:`__doc__` is the function's documentation string, or ``None`` if unavailable; :attr:`__name__` is the function's name; :attr:`__self__` is set to ``None`` (but see the next item); :attr:`__module__` is the name of the module the function was defined in or ``None`` if unavailable.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект - встроенная функция – это посредник к функции на “C” . Примерами встроенных функций являются : «:func:`len`» и «:func:`math.sin`» ( «:mod:`math`» – стандартный встроенный модуль) . Количество и тип её аргументов определяется соответствующей функцией на “C” . Особые доступные только для чтения атрибуты : «:attr:`__doc__`» – текст документации данной функции или иначе «:const:`None`» ; «:attr:`__name__`» – имя данной функции; «attr:`__self__`» – установлен в «:const:`None`» (но далее смотрите об этом подробнее) ; «:attr:`__module__`» – имя модуля, в котором определена данная функция или иначе «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument.  An example of a built-in method is ``alist.append()``, assuming *alist* is a list object. In this case, the special read-only attribute :attr:`__self__` is set to the object denoted by *list*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это, по сути, другое обличие встроенных функций, которые в этом случае имеют дополнительный аргумент, передаваемый в функцию на “C” неявно. Примером встроенного метода является «``alist.append()``» , где *alist* – это объект-список. В таком случае особый предназначенный только для чтения атрибут «:attr:`__self__`» содержит указание на этот объект *alist* .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes are callable.  These objects normally act as factories for new instances of themselves, but variations are possible for class types that override :meth:`__new__`.  The arguments of the call are passed to :meth:`__new__` and, in the typical case, to :meth:`__init__` to initialize the new instance.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Классы являются вызываемыми (исполняемыми) объектами. Как правило, они работают как фабрики для новых собственных экземпляров класса, при этом генерация может проходить с вариациями у таких типов классов, в которых переопределён метод «:meth:`__new__`» . Аргументы вызова передаются методу «:meth:`__new__`» и, как правило, методу «:meth:`__init__`» для инициализации нового экземпляра.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of arbitrary classes can be made callable by defining a :meth:`__call__` method in their class.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Экземпляры любого класса могут быть сделаны вызываемыми (исполнимыми) посредством определения метода «:meth:`__call__`» в их классе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modules are imported by the :keyword:`import` statement (see section :ref:`import`). A module object has a namespace implemented by a dictionary object (this is the dictionary referenced by the __globals__ attribute of functions defined in the module).  Attribute references are translated to lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__["x"]``. A module object does not contain the code object used to initialize the module (since it isn't needed once the initialization is done).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Модули импортируются с помощью инструкции :keyword:`import` (смотрите раздел : “Инструкция «import»” :ref:`import` ). Объект модуль имеет область имён реализованую в виде объекта словарь в атрибуте «:attr:`__dict__`» (это тот самый словарь, на который ссылается атрибут «:attr:`__globals__`» функций определеных в этом модуле). Упоминания атрибутов преобразуются в поиск в этом словаре, например, «``m.x``» эквивалентно «``m.__dict__["x"]``» . Объект модуль не содержит объект код, используемый для инициализации этого модуля (поскольку инициализация уже произведена, и он больше не может понадобиться).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute assignment updates the module's namespace dictionary, e.g., ``m.x = 1`` is equivalent to ``m.__dict__["x"] = 1``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Назначение атрибуту, по сути, обновляет словарь области имён модуля, например «``m.x = 1``» эквивалентно «``m.__dict__["x"] = 1``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special read-only attribute: :attr:`__dict__` is the module's namespace as a dictionary object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальный атрибут только для чтения : «:attr:`__dict__`» - область имён модуля, в виде объекта словарь.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Predefined (writable) attributes: :attr:`__name__` is the module's name; :attr:`__doc__` is the module's documentation string, or ``None`` if unavailable; :attr:`__file__` is the pathname of the file from which the module was loaded, if it was loaded from a file. The :attr:`__file__` attribute is not present for C modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Предопределённые изменяемые атрибуты : «:attr:`__name__`» - имя данного модуля; «:attr:`__doc__`» - строка описания данного модуля, или иначе значение «:const:`None`» ; «:attr:`__file__`» - путь файла, из которого загружен данный модуль, если он был загружен из файла. Атрибут «:attr:`__file__`» отсутствует в модулях на “C” , которые статически прилинкованы к интерпретатору; для модулей расширений, подгруженных динамически из общих библиотек - он является путём файла соответствующей общей библиотеки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom class types are typically created by class definitions (see section :ref:`class`).  A class has a namespace implemented by a dictionary object. Class attribute references are translated to lookups in this dictionary, e.g., ``C.x`` is translated to ``C.__dict__["x"]`` (although there are a number of hooks which allow for other means of locating attributes). When the attribute name is not found there, the attribute search continues in the base classes. This search of the base classes uses the C3 method resolution order which behaves correctly even in the presence of 'diamond' inheritance structures where there are multiple inheritance paths leading back to a common ancestor. Additional details on the C3 MRO used by Python can be found in the documentation accompanying the 2.3 release at http://www.python.org/download/releases/2.3/mro/.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Типы определяемых классов, как правило, создаются определением класса (смотрите раздел “Определения классов”  ). Класс имеет область имён реализованую в виде объекта словарь. Указания атрибутов класса преобразуются в поиск в этом словаре, например, «``C.x``» заменяется на «``C.__dict__["x"]``» (хотя есть ряд трюков, которые позволяют разместить атрибуты другим путём). Когда имя данного атрибута там не найдено, поиск атрибута продолжается в базовых классах. Такой поиск базовых классов использует порядок разрешения метода “C3”, который ведет себя правильно, даже в случае структуры наследования типа “diamond” , тоесть, где есть несколько путей наследования сходящихся обратно к одному общему предку. Дополнительную информацию об “C3 MRO” можно найти в документации, сопровождающей релиз 2.3 по адресу : http://www.python.org/download/releases/2.3/mro/  .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a class attribute reference (for class :class:`C`, say) would yield a class method object, it is transformed into an instance method object whose :attr:`__self__` attributes is :class:`C`.  When it would yield a static method object, it is transformed into the object wrapped by the static method object. See section :ref:`descriptors` for another way in which attributes retrieved from a class may differ from those actually contained in its :attr:`__dict__`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда указание на атрибут класса (назовём класс “C”) должно давать объект - метод класса – он преобразуется в объект - метод экземпляра, чей атрибут «:attr:`__self__`» имеет значение «``C``» . А когда это указание должно давать объект - статический метод – он преобразуется в тот же объект “обёрнутый” объектом - статическим методом. Другие варианты, того как атрибуты, получаемые из класса, могут отличаться от реально содержащихся в их атрибуте «:attr:`__dict__`» – смотрите в разделе “Реализация дескрипторов” :ref:`descriptors` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class attribute assignments update the class's dictionary, never the dictionary of a base class.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись значений в атрибуты класса модифицирует словарь этого класса, но ни в коем случае не соответствующий словарь базового класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class object can be called (see above) to yield a class instance (see below).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект класс может быть вызван (запущен на исполнение), как упомянуто выше, чтобы сгенерировать экземпляр класса (смотрите ниже).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special attributes: :attr:`__name__` is the class name; :attr:`__module__` is the module name in which the class was defined; :attr:`__dict__` is the dictionary containing the class's namespace; :attr:`__bases__` is a tuple (possibly empty or a singleton) containing the base classes, in the order of their occurrence in the base class list; :attr:`__doc__` is the class's documentation string, or None if undefined.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты: «:attr:`__name__`» - имя класса; «:attr:`__module__`» - имя модуля, в котором был определен этот класс; «:attr:`__dict__`» - словарь, содержащий область имён этого класса; «:attr:`__bases__`» - кортеж (возможно, пустой или с одним элементом (“singleton”)), содержащий базовые классы, в порядке их появления в списке базовых классов; «:attr:`__doc__`» - строка описания данного класса, или иначе значение «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class instance is created by calling a class object (see above).  A class instance has a namespace implemented as a dictionary which is the first place in which attribute references are searched.  When an attribute is not found there, and the instance's class has an attribute by that name, the search continues with the class attributes.  If a class attribute is found that is a user-defined function object, it is transformed into an instance method object whose :attr:`__self__` attribute is the instance.  Static method and class method objects are also transformed; see above under "Classes".  See section :ref:`descriptors` for another way in which attributes of a class retrieved via its instances may differ from the objects actually stored in the class's :attr:`__dict__`.  If no class attribute is found, and the object's class has a :meth:`__getattr__` method, that is called to satisfy the lookup.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Экземпляр класса создается путем вызова объекта класс (см. выше). Экземпляр класса имеет область имён, реализованную в виде словаря, который является первым местом, в котором ищутся атрибуты. Если атрибут здесь не найден, а класс этого экземпляра имеет атрибут с таким именем, поиск продолжается в атрибутах класса. Если становится известно, что некий атрибут класса является объектом функцией пользователя, он преобразуется в объект метод экземпляра, чей атрибут «:attr:`__self__`» является тем экземпляром. Статические методы и объекты методы класса также преобразуются, см. выше в разделе “Классы” . Смотрите также в разделе “Реализация дескрипторов” :ref:`descriptors` другой вариант того как атрибуты класса, полученного через его экземпляры, могут отличаться от объектов, на самом деле хранящихся в атрибуте «:attr:`__dict__`» этого класса. Если атрибут класса не найден, но класс этого объекта имеет метод «:meth:`__getattr__`» , то этот метод вызывается и возвращаемое им значение возвращается в качестве значения искомого атрибута.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute assignments and deletions update the instance's dictionary, never a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:`__delattr__` method, this is called instead of updating the instance dictionary directly.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись значения в атрибуты и их удаление обновляют словарь экземпляра. Если класс имеет методы «:meth:`__setattr__`» или «:meth:`__delattr__`» , то вызываются они - вместо обновления словаря экземпляра напрямую.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class instances can pretend to be numbers, sequences, or mappings if they have methods with certain special names.  See section :ref:`specialnames`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Экземпляры класса могут вести себя как числа, последовательности или отображения, если у них есть методы с определёнными специальными именами. См. раздел “Имена специальных методов” :ref:`specialnames` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special attributes: :attr:`__dict__` is the attribute dictionary; :attr:`__class__` is the instance's class.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты: «:attr:`__dict__`» - словарь атрибутов; «:attr:`__class__`» - класс данного экземпляра.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A file object represents an open file.  Various shortcuts are available to create file objects: the :func:`open` built-in function, and also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`makefile` method of socket objects (and perhaps by other functions or methods provided by extension modules).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Файловый объект представляет собой открытый файл. Файловые объекты создаются встроенной функцией «:func:`open`» , а также функциями «:func:`os.popen`» , «:func:`os.fdopen`» , и методом «:meth:`makefile`» объектов сокетов (и, возможно, другими функциями или методами, предоставляемыми модулями расширения ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to file objects corresponding to the interpreter's standard input, output and error streams; they are all open in text mode and therefore follow the interface defined by the :class:`io.TextIOBase` abstract class.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты «:obj:`sys.stdin`», «:obj:`sys.stdout`» и «:obj:`sys.stderr`» инициализируются в файловые объекты, соответствующие стандартным потокам ввода, вывода и ошибок интерпретатора. Все они открыты в текстовом режиме, и, таким образом, соответствуют интерфейсу, определённому в абстрактном классе «:class:`io.TextIOBase`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few types used internally by the interpreter are exposed to the user. Their definitions may change with future versions of the interpreter, but they are mentioned here for completeness.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Несколько типов, используемых для внутренних целей интерпретатором, предоставяются пользователю. Их определения могут измениться в будущих версиях интерпретатора, но они упоминаются здесь для полноты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code objects represent *byte-compiled* executable Python code, or :term:`bytecode`. The difference between a code object and a function object is that the function object contains an explicit reference to the function's globals (the module in which it was defined), while a code object contains no context; also the default argument values are stored in the function object, not in the code object (because they represent values calculated at run-time).  Unlike function objects, code objects are immutable and contain no references (directly or indirectly) to mutable objects.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты кода представляют собой скомпилированный в байт-код (:term:`bytecode`) исполняемый код Питона. Разница между объектом кода и объектом функции заключается в том, что объект функции содержит явное указание на область имён, в которой содержатся глобальные переменные функции (модуль, в котором она была определена), а объект кода не содержит указания на такой контекст; также в объекте функции хранятся значения по умолчанию аргументов, а в объекте кода их нет (так как они представляют собой значения, рассчитываемые во время выполнения). В отличие от объектов функций, объекты кода являются неизменяемыми и не содержать ссылок (прямо или косвенно) на изменяемые объекты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special read-only attributes: :attr:`co_name` gives the function name; :attr:`co_argcount` is the number of positional arguments (including arguments with default values); :attr:`co_nlocals` is the number of local variables used by the function (including arguments); :attr:`co_varnames` is a tuple containing the names of the local variables (starting with the argument names); :attr:`co_cellvars` is a tuple containing the names of local variables that are referenced by nested functions; :attr:`co_freevars` is a tuple containing the names of free variables; :attr:`co_code` is a string representing the sequence of bytecode instructions; :attr:`co_consts` is a tuple containing the literals used by the bytecode; :attr:`co_names` is a tuple containing the names used by the bytecode; :attr:`co_filename` is the filename from which the code was compiled; :attr:`co_firstlineno` is the first line number of the function; :attr:`co_lnotab` is a string encoding the mapping from bytecode offsets to line numbers (for details see the source code of the interpreter); :attr:`co_stacksize` is the required stack size (including local variables); :attr:`co_flags` is an integer encoding a number of flags for the interpreter.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты только для чтения: :attr:`co_name` содержит имя данной функции; :attr:`co_argcount` это количество позиционных аргументов (в том числе аргументов со значениями по умолчанию); :attr:`co_nlocals` это число локальных переменных, используемых функцией (включая аргументы); :attr:`co_varnames` кортеж, содержащий имена локальных переменных (начиная с имен аргументов); :attr:`co_cellvars` кортеж, содержащий имена локальных переменных, на которые ссылаются вложенные функции; :attr:`co_freevars` кортеж, содержащий имена свободных (нигде более не связанных) переменных; :attr:`co_code` строка, представляющая последовательность байт-код инструкций; :attr:`co_consts` кортеж, содержащий непосредственные данные используемые байт-кодом; :attr:`co_names` кортеж, содержащий имена, используемые байт-кодом; :attr:`co_filename` имя файла, из которого код был скомпилирован; :attr:`co_firstlineno` номер первой строки функции; :attr:`co_lnotab` текст, кодирующий соответствие смещения байт-кодов номерам строк текста программы (подробнее см. исходный код интерпретатора); :attr:`co_stacksize` требуемый размер стека (включая локальные переменные); :attr:`co_flags` целое число, в котором закодировано некоторое количество параметров(флагов) интерпретатора.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is set if the function uses the ``*arguments`` syntax to accept an arbitrary number of positional arguments; bit ``0x08`` is set if the function uses the ``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is set if the function is a generator.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие сигнальные биты определены внутри :attr:`co_flags` : бит ``0x04`` установлен, если данная функция использует синтаксис ``*arguments`` для принятия произвольного количеотва позиционных аргументов; бит ``0x08`` установлен, если данная функция использует синтаксис ``**keywords`` для принятия произвольных именованных аргументов; бит ``0x20`` установлен, если функция является генератором.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Future feature declarations (``from __future__ import division``) also use bits in :attr:`co_flags` to indicate whether a code object was compiled with a particular feature enabled: bit ``0x2000`` is set if the function was compiled with future division enabled; bits ``0x10`` and ``0x1000`` were used in earlier versions of Python.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция ``from __future__ import division`` также использует биты в :attr:`co_flags` для обозначения того, был ли объект-код скомпилирован со включенными определёнными свойствами. Так, бит ``0x2000`` установлен, если данная функция скомпилирована с задействованием ``future division`` . Биты ``0x10`` и ``0x1000`` использовались в более ранних версиях Питона.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other bits in :attr:`co_flags` are reserved for internal use.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Другие биты в :attr:`co_flags` - зарезервированы для внутреннего использования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a code object represents a function, the first item in :attr:`co_consts` is the documentation string of the function, or ``None`` if undefined.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если объект кода является функцией, то первый элемент в :attr:`co_consts` содержит текст описания (документацию) данной функции, или значение «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Frame objects represent execution frames.  They may occur in traceback objects (see below).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты-:term:`кадры&lt;execution frame object&gt;` реализуют кадры исполнения. Они могут встречаться в :term:`объектах раскрутки стека&lt;traceback object&gt;` (смотри́те далее) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special read-only attributes: :attr:`f_back` is to the previous stack frame (towards the caller), or ``None`` if this is the bottom stack frame; :attr:`f_code` is the code object being executed in this frame; :attr:`f_locals` is the dictionary used to look up local variables; :attr:`f_globals` is used for global variables; :attr:`f_builtins` is used for built-in (intrinsic) names; :attr:`f_lasti` gives the precise instruction (this is an index into the bytecode string of the code object).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты только для чтения: :attr:`f_back` указывает предыдущий кадр стека (в сторону вызывающего), или «:const:`None`» если это дно стека; :attr:`f_code` является объектом-кодом, выполняющимся в данном кадре; :attr:`f_locals` является словарём, использующимся для поиска локальных переменных; :attr:`f_globals` используется для глобальных переменных; :attr:`f_builtins` используется для встроенных (внутренних) имён; :attr:`f_lasti` дает точные инструкции (это индекс в массиве байт-кода у объекта кода) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special writable attributes: :attr:`f_trace`, if not ``None``, is a function called at the start of each source code line (this is used by the debugger); :attr:`f_lineno` is the current line number of the frame --- writing to this from within a trace function jumps to the given line (only for the bottom-most frame).  A debugger can implement a Jump command (aka Set Next Statement) by writing to f_lineno.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные перезаписываемые атрибуты: «:attr:`f_trace`» , если не «:const:`None`» , является функцией, вызываемою в начале каждой строки исходного кода (это используется отладчиком); «:attr:`f_lineno`» содержит номер текущей строки кадра – запись сюда изнутри функции отслеживания (трассирования) приводит к переходу на данную строку (только для самого нижнего кадра) . Отладчик может реализовать команду “Jump” , путём записи в «:attr:`f_lineno`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traceback objects represent a stack trace of an exception.  A traceback object is created when an exception occurs.  When the search for an exception handler unwinds the execution stack, at each unwound level a traceback object is inserted in front of the current traceback.  When an exception handler is entered, the stack trace is made available to the program. (See section :ref:`try`.) It is accessible as the third item of the tuple returned by ``sys.exc_info()``. When the program contains no suitable handler, the stack trace is written (nicely formatted) to the standard error stream; if the interpreter is interactive, it is also made available to the user as ``sys.last_traceback``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты раскрутки стека представляют раскрутку стека исключений. Объект раскрутки стека создается при возникновении исключения. Когда поиск обработчика исключения раскручивает стек вызовов, на каждом уровне новый объект раскрутки стека вставляется перед текущим. Когда обработчик исключения найден, раскрутка стека делается доступной для программы. (Смотри́те раздел :ref:`try` .) Она доступна в качестве третьего элемента кортежа, возвращаемого :func:`sys.exc_info` . Если программа не содержит подходящего обработчика, раскрутка стека выводится (в удобно оформленном виде) в стандартный поток ошибок, а если интерпретатор в интерактивном режиме, то она также доступна пользователю через :data:`sys.last_traceback` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special read-only attributes: :attr:`tb_next` is the next level in the stack trace (towards the frame where the exception occurred), or ``None`` if there is no next level; :attr:`tb_frame` points to the execution frame of the current level; :attr:`tb_lineno` gives the line number where the exception occurred; :attr:`tb_lasti` indicates the precise instruction.  The line number and last instruction in the traceback may differ from the line number of its frame object if the exception occurred in a :keyword:`try` statement with no matching except clause or with a finally clause.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальные атрибуты только для чтения: «:attr:`tb_next`» указывает следующий уровень в стеке (в сторону кадра, где произошло исключение) , или «:const:`None`» , если нет следующего уровня; «:attr:`tb_frame`» указывает на кадр исполнения текущего уровня; «:attr:`tb_lineno`» дает номер строки, где произошло исключение; «:attr:`tb_lasti`» указывает точную инструкцию. Номер строки и последняя команда в раскрутке может отличаться от номера строки соответствующего объекта кадра, если исключение произошло в инструкции «:keyword:`try`» не имеющей соответствующей ветви «:keyword:`except`» , или с ветвью «:keyword:`finally`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Slice objects are used to represent slices for :meth:`__getitem__` methods.  They are also created by the built-in :func:`slice` function.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты-срезы используются для хранения параметров для операции среза (которая может быть явно вызвана через метод «:meth:`__getitem__`» ) . Объект-срез также может быть создан встроенной функцией «:func:`slice`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special read-only attributes: :attr:`start` is the lower bound; :attr:`stop` is the upper bound; :attr:`step` is the step value; each is ``None`` if omitted. These attributes can have any type.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Особые атрибуты только для чтения::attr:`start` - нижняя граница;:attr:`stop` - верхняя граница;:attr:`step` - значение шага;все они по умолчанию имеют значение «:const:`None`» . Эти атрибуты могут быть любого типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Slice objects support one method:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объекты-срезы поддерживают один метод:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method takes a single integer argument *length* and computes information about the slice that the slice object would describe if applied to a sequence of *length* items.  It returns a tuple of three integers; respectively these are the *start* and *stop* indices and the *step* or stride length of the slice. Missing or out-of-bounds indices are handled in a manner consistent with regular slices.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот метод принимает один аргумент - целое число *length* и преобразовывает параметры среза (пропущенные, выходящие за границы (отрицательные или превышающие)) так, как они были бы преобразованы будучи применёнными (к любой) последовательности длины *length* (т. е. , например, граница среза, превышающая длину, заменяется на эту длину). Именно это преобразование производится при обычной записи срезов. Этот метод возвращает кортеж из 3 целых чисел, являющихся соответственно параметрами *start*, *stop*, *step* .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Static method objects provide a way of defeating the transformation of function objects to method objects described above. A static method object is a wrapper around any other object, usually a user-defined method object. When a static method object is retrieved from a class or a class instance, the object actually returned is the wrapped object, which is not subject to any further transformation. Static method objects are not themselves callable, although the objects they wrap usually are. Static method objects are created by the built-in :func:`staticmethod` constructor.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Статические методы обеспечивают способ предотвращения преобразования функций в методы, описанные выше. Статические методы могут быть посредниками (“обертками”) для любых других объектов, обычно для определяемых пользователем методов. Когда статический метод запрашивается из класса или экземпляра класса, то фактически возвращается объект, к которому тот является посредником (т.е. “обёрнутый объект”), если он в свою очередь не подлежит дальнейшей трансформации. Статические методы сами не являются исполнимыми, хотя те объекты, к которым они явлвются посредниками - обычно явлвются. Статические методы создаются при помощи встроенного конструктора :func:`staticmethod` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class method object, like a static method object, is a wrapper around another object that alters the way in which that object is retrieved from classes and class instances. The behaviour of class method objects upon such retrieval is described above, under "User-defined methods". Class method objects are created by the built-in :func:`classmethod` constructor.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Метод класса, как и статический метод, является посредником к другому объекту, изменяющим способ, которым этот объект извлекается из классов и экземпляров класса. Поведение метода класса при таком доступе описано выше, в разделе “Определяемые пользователем методы” . Методы классов создаются при помощи встроенного конструктора :func:`classmethod` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special method names</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Имена спецальных методов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class can implement certain operations that are invoked by special syntax (such as arithmetic operations or subscripting and slicing) by defining methods with special names. This is Python's approach to :dfn:`operator overloading`, allowing classes to define their own behavior with respect to language operators.  For instance, if a class defines a method named :meth:`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where mentioned, attempts to execute an operation raise an exception when no appropriate method is defined (typically :exc:`AttributeError` or :exc:`TypeError`).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Класс может реализовывать определенные операции, которые вызываются при использовании специального синтаксиса (например, арифметические операции или индексаця и срезы), путем определения методов со специальными именами. Это Питоновский подход к переопределению операторов, позволяющему классам определять их собственное поведение по отношению к операторам языка. Например, если класс определяет метод под названием «:meth:`__getitem__`» и «``x``» экземпляр этого класса, то «``x[i]``» приблизительно равно «``type(x).__getitem__(x, i)``» . За исключением тех случаев, где это особо оговорено – попытки исполнять операции вызывают исключение, если не определено соответствующего метода (обычно :exc:`AttributeError` или :exc:`TypeError` ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When implementing a class that emulates any built-in type, it is important that the emulation only be implemented to the degree that it makes sense for the object being modelled.  For example, some sequences may work well with retrieval of individual elements, but extracting a slice may not make sense.  (One example of this is the :class:`NodeList` interface in the W3C's Document Object Model.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При реализации класса, который эмулирует любой встроенный тип, важно, что эмуляция должна быть реализована только в той степени, в какой это имеет значение для моделируемого объекта. Например, некоторые последовательности могут хорошо работать с извлечением отдельных элементов, но срезы могут не иметь смысла. (Одним из примеров этого является интерфейс :class:`NodeList` в “W3C’s Document Object Model” .)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic customization</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Основные средства настройки классов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to create a new instance of class *cls*.  :meth:`__new__` is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument.  The remaining arguments are those passed to the object constructor expression (the call to the class).  The return value of :meth:`__new__` should be the new object instance (usually an instance of *cls*).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для создания нового экземпляра класса (назовём *cls*) . :meth:`__new__` – это статический метод (специальный, создаваемый автоматически) , который принимает в качестве первого аргумента класс, экземпляр которого требуется вернуть. Остальные аргументы такие же, какие передаются конструктору этого же объекта (в выражении «``cls()``» ) . «:meth:`__new__`» должен возвращать новый экземпляр объекта ( обычно экземпляр класса *cls* ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typical implementations create a new instance of the class by invoking the superclass's :meth:`__new__` method using ``super(currentclass, cls).__new__(cls[, ...])`` with appropriate arguments and then modifying the newly-created instance as necessary before returning it.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обычно применяется для создания нового экземпляра класса через вызов метода «:meth:`__new__`» у “суперкласса” данного класса, вызывая «``super(currentclass, cls).__new__(cls[, ...])``» с соответствующими аргументами, и затем модифицируя (при необходимости) новосозданный экземпляр перед его возвращением.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If :meth:`__new__` returns an instance of *cls*, then the new instance's :meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where *self* is the new instance and the remaining arguments are the same as were passed to :meth:`__new__`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если «:meth:`__new__`» возвращает экземпляр класса *cls* , то будет вызван метод «:meth:`__init__`» этого нового экземпляра : «``__init__(self[, ...])``» , где *self* – это данный новый экземпляр, а остальные аргументы – именно те, которые были переданы в «:meth:`__new__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If :meth:`__new__` does not return an instance of *cls*, then the new instance's :meth:`__init__` method will not be invoked.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если «:meth:`__new__`» не возвращает экземпляр класса *cls* , то метод «:meth:`__init__`» нового экземпляра не будет вызываться.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:meth:`__new__` is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation.  It is also commonly overridden in custom metaclasses in order to customize class creation.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:meth:`__new__`» главным образом нужен для того, чтобы дать возможность классам, производным от неизменяемых типов (таких как “int” , “str” , “tuple”) , настраивать создание экземпляров. Он к тому же часто переопределяется в метаклассах для настройки создания класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the instance is created.  The arguments are those passed to the class constructor expression.  If a base class has an :meth:`__init__` method, the derived class's :meth:`__init__` method, if any, must explicitly call it to ensure proper initialization of the base class part of the instance; for example: ``BaseClass.__init__(self, [args...])``.  As a special constraint on constructors, no value may be returned; doing so will cause a :exc:`TypeError` to be raised at runtime.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот метод вызывается при создании соответствующего экземпляра. Его аргументами становятся те, которые были переданы выражению конструктору класса. Если в базовом классе определён метод «:meth:`__init__`» , то метод «:meth:`__init__`» производного класса (если определён) должен явно вызывать его, чтобы гарантировать правильную инициализацию части экземпляра, соответствующей базовому классу ( например : «``BaseClass.__init__(self, [args...])``» ) . Для конструкторов есть особый запрет - они не должны возвращать какого-либо значения - иначе вызывается ошибка :exc:`TypeError` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the instance is about to be destroyed.  This is also called a destructor.  If a base class has a :meth:`__del__` method, the derived class's :meth:`__del__` method, if any, must explicitly call it to ensure proper deletion of the base class part of the instance.  Note that it is possible (though not recommended!) for the :meth:`__del__` method to postpone destruction of the instance by creating a new reference to it.  It may then be called at a later time when this new reference is deleted.  It is not guaranteed that :meth:`__del__` methods are called for objects that still exist when the interpreter exits.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот метод (называемый также деструктор) вызывается, когда данный экземпляр должен быть уничтожен. Если в базовом классе определён метод «:meth:`__del__`» , то метод «:meth:`__del__`» производного класса (если определён) должен явно вызывать его, чтобы гарантировать правильное удаление части экземпляра, соответствующей базовому классу. Заметьте, что метод «:meth:`__del__`» может (хотя это не рекомендуется) отложить удаление экземпляра, создав новую ссылку на него. Он может быть вызван потом, когда будет удалена эта новая ссылка. Не гарантируется, что методы «:meth:`__del__`» будут вызваны для объектов, существующих на момент закрытия интерпретатора.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``del x`` doesn't directly call ``x.__del__()`` --- the former decrements the reference count for ``x`` by one, and the latter is only called when ``x``'s reference count reaches zero.  Some common situations that may prevent the reference count of an object from going to zero include: circular references between objects (e.g., a doubly-linked list or a tree data structure with parent and child pointers); a reference to the object on the stack frame of a function that caught an exception (the traceback stored in ``sys.exc_info()[2]`` keeps the stack frame alive); or a reference to the object on the stack frame that raised an unhandled exception in interactive mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame alive).  The first situation can only be remedied by explicitly breaking the cycles; the latter two situations can be resolved by storing ``None`` in ``sys.last_traceback``. Circular references which are garbage are detected when the option cycle detector is enabled (it's on by default), but can only be cleaned up if there are no Python- level :meth:`__del__` methods involved. Refer to the documentation for the :mod:`gc` module for more information about how :meth:`__del__` methods are handled by the cycle detector, particularly the description of the ``garbage`` value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«``del x``» лишь уменьшает на 1 счётчик ссылок на «``x``» , а не вызывает напрямую «``x.__del__()``» , который вызывается только когда счётчик ссылок достигает ноля. Среди ситуаций, при которых счётчик ссылок на объект не может обнулиться, самыми обычными являются : циклические ссылки между объектами (например, список с двухсторонними связями, или древовидная структура данных с указателями на родителя и потомка) ; ссылка на объект в кадре стека функции, которая получила исключение (раскрутка стека, содержащаяся в «``sys.exc_info()[2]``» , имея ссылку на этот кадр стека, не даёт его уничтожить) ; или ссылка на объект в том кадре стека, в котором произошло необработанное исключение в интерактивном режиме (раскрутка стека, содержащаяся в «``sys.last_traceback``» , имея ссылку на этот кадр стека, не даёт его уничтожить) . Первая ситуация может быть исправлена только путем явного разрывания цикла, а две последние ситуации могут быть решены путём записи «:const:`None`» в «``sys.last_traceback``» . Циклические ссылки, являющиеся “мусором” , детектируются если включена опция обнаружения циклов (по умолчанию включена) , но могут быть удалены только если не задействованы методы Питоновского уровня «:meth:`__del__`» . Обратитесь к документации модуля «:mod:`gc`» за более подробной информацией о том, как детектор циклов обращается с методами «:meth:`__del__`» , в частности описание значения у ``garbage`` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the precarious circumstances under which :meth:`__del__` methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is invoked in response to a module being deleted (e.g., when execution of the program is done), other globals referenced by the :meth:`__del__` method may already have been deleted or in the process of being torn down (e.g. the import machinery shutting down).  For this reason, :meth:`__del__` methods should do the absolute minimum needed to maintain external invariants.  Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the :meth:`__del__` method is called.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>По причине ненадёжной ситуации, в которой вызываются методы «:meth:`__del__`» , исключения, возникающие при их исполнении, игнорируются, и вместо этого печатаются предупреждения в «``sys.stderr``» . Также, когда «:meth:`__del__`» вызывается для удаления модуля (например, когда исполнение программы завершено) , глобальные переменные, на которые ссылается метод «:meth:`__del__`» , могут уже быть удалены или в процессе удаления (например, отключение механизма импорта) . По этой причине методам «:meth:`__del__`» следует производить самый минимум необходимого для поддержания внешней целостности . Начиная с версии 1.5 , Питон гарантирует, что глобальные переменные, чьё имя начинается с одиночного подчёркивания, будут удалены из их модуля до удаления остальных глобальных переменных. Если нет других ссылок на такие глобальные переменные, то это может помочь убедиться, что импортированные модули ещё доступны в то время, когда вызывается метод «:meth:`__del__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called by the :func:`repr` built-in function to compute the "official" string representation of an object.  If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment).  If this is not possible, a string of the form ``&lt;...some useful description...&gt;`` should be returned. The return value must be a string object. If a class defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when an "informal" string representation of instances of that class is required.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается встроенной функцией «:func:`repr`» для вычисления «официального» текстового представления (текстовый объект) для исходного объекта. В тех случаях, когда это вообще возможно – это текст должен быть правильным выражением на Питоне, который, при его интерпретации, даст обратно объект с тем же значением (при условии такого же окружения) . А когда это не возможно – будет возвращён текст вида : «``&lt;…полезное описание…&gt;``» . Если в классе определён «:meth:`__repr__`» , но не определён «:meth:`__str__`» , то «:meth:`__repr__`» используется также и вместо «:meth:`__str__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is typically used for debugging, so it is important that the representation is information-rich and unambiguous.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это обычно используется для отладки, поэтому важно, чтобы это представление было информационно богатыми и недвусмысленным.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called by the :func:`str` built-in function and by the :func:`print` function to compute the "informal" string representation of an object.  This differs from :meth:`__repr__` in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead. The return value must be a string object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается встроенной функцией «:func:`str`» и функцией «:func:`print`» для вычисления “неформального” текстового представления (текстовый объект) для исходного объекта. Отличается от «:meth:`__repr__`» тем, что не обязан выдавать правильное выражение на Питоне, вместо этого может выдать более удобный или лаконичный текст.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called by the :func:`format` built-in function (and by extension, the :meth:`format` method of class :class:`str`) to produce a "formatted" string representation of an object. The ``format_spec`` argument is a string that contains a description of the formatting options desired. The interpretation of the ``format_spec`` argument is up to the type implementing :meth:`__format__`, however most classes will either delegate formatting to one of the built-in types, or use a similar formatting option syntax.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается встроенной функцией «:func:`format`» для получения “форматированого” текстового представления (текстовый объект) для исходного объекта. Аргумент «``format_spec``» является строкой, содержащей описание требуемых опций форматирования. Интерпретация этого аргумента полагается на реализацию метода «:meth:`__format__`» у соответствующего типа, хотя большинство классов будут перепоручать форматирование одному из встроенных типов, или использовать аналогичный синтаксис опций форматирования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See :ref:`formatspec` for a description of the standard formatting syntax.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Описание стандарта синтаксиса форматирования смотрите в :ref:`formatspec` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The return value must be a string object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Возвращаемое значение должно быть текстовым объектом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the so-called "rich comparison" methods. The correspondence between operator symbols and method names is as follows: ``x&lt;y`` calls ``x.__lt__(y)``, ``x&lt;=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x&gt;y`` calls ``x.__gt__(y)``, and ``x&gt;=y`` calls ``x.__ge__(y)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это так называемые методы “расширенного сравнения” (“rich comparison”) . Соответствие между символами операторов и именами методов такое : «``x&lt;y``» вызывает «``x.__lt__(y)``» , «``x&lt;=y``» вызывает «``x.__le__(y)``» , «``x==y``» вызывает «``x.__eq__(y)``» , «``x!=y``» вызывает «``x.__ne__(y)``» , «``x&gt;y``» вызывает «``x.__gt__(y)``» , «``x&gt;=y``» вызывает «``x.__ge__(y)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A rich comparison method may return the singleton ``NotImplemented`` if it does not implement the operation for a given pair of arguments. By convention, ``False`` and ``True`` are returned for a successful comparison. However, these methods can return any value, so if the comparison operator is used in a Boolean context (e.g., in the condition of an ``if`` statement), Python will call :func:`bool` on the value to determine if the result is true or false.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Метод расширенного сравнения может возвращать синглтон «``NotImplemented``» , если в нём не реализована операция сравнения для данной пары аргументов. По соглашению – в случае успешных сравнений возвращается «:const:`False`» или «:const:`True`» . Однако, эти методы могут возвращать любое значение – так что, если эти операторы сравнения используются там, где требуется логический (булев) результат (например условие инструкции «:keyword:`if`» ) , то Питон применит «:func:`bool`» к этим значениям (чтобы привести их к булеву типу) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no implied relationships among the comparison operators. The truth of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the operators will behave as expected.  See the paragraph on :meth:`__hash__` for some important notes on creating :term:`hashable` objects which support custom comparison operations and are usable as dictionary keys.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Нет неявно подразумеваемых соотношений между операторами сравнения. Истинность «``x==y``» не означает, что «``x!=y``» ложно. Таким образом, определяя «:meth:`__eq__`» , следует также определить «:meth:`__ne__`» – только тогда операторы будут вести себя, как ожидалось. Смотрите в пункте о «:meth:`__hash__`» некоторые важные замечания о создании хэшируемых объектов, которые поддерживают пользовательские операции сравнения и могут использоваться в качестве ключей словаря.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does); rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` and :meth:`__ne__` are their own reflection.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для этих методов нету реализации автоматической замены порядка аргументов (когда левый аргумент не поддерживает данную операцию, а правый поддерживает) . Но, вместо этого можно воспользоваться тем, что «:meth:`__lt__`» с «:meth:`__gt__`» , «:meth:`__le__`» с «:meth:`__ge__`» , «:meth:`__eq__`» с «:meth:`__ne__`» являются противоположностями друг друга (попарно) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arguments to rich comparison methods are never coerced.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для аргументов расширенных сравнений никогда не производится приведение типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To automatically generate ordering operations from a single root operation, see :func:`functools.total_ordering`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Об автоматической генерации операций сравнения на основе одной операции смотрите :func:`functools.total_ordering` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class does not define an :meth:`__eq__` method it should not define a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:`__hash__`, its instances will not be usable as items in hashable collections.  If a class defines mutable objects and implements an :meth:`__eq__` method, it should not implement :meth:`__hash__`, since the implementation of hashable collections requires that a key's hash value is immutable (if the object's hash value changes, it will be in the wrong hash bucket).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если класс не определяет метод «:meth:`__eq__`» , то он не должен определять метод «:meth:`__hash__`» , а если он определяет «:meth:`__eq__`» , но не определяет «:meth:`__hash__`» , то его экземпляры не смогут быть использованы как элементы хэшируемых множеств. Если класс определяет изменяемые объекты и реализует метод «:meth:`__eq__`» , то он не должен реализовывать «:meth:`__hash__`» , поскольку реализация хэшируемых множеств требует, чтобы значение хэша ключей было неизменяемым (если значение хэша ключа объекта изменяется, то оно может оказаться не в своей группе хэшей (“hash bucket”) (и будет пропущено при поиске) ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by default; with them, all objects compare unequal (except with themselves) and ``x.__hash__()`` returns ``id(x)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Определяемые пользователем классы по умолчанию имеют методы «:meth:`__eq__`» и «:meth:`__hash__`» , из-за которых все объекты экземпляров этих классов являются неравными друг другу (они равны только сами себе) , а «``x.__hash__()``» возвращает «``id(x)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes which inherit a :meth:`__hash__` method from a parent class but change the meaning of :meth:`__eq__` such that the hash value returned is no longer appropriate (e.g. by switching to a value-based concept of equality instead of the default identity based equality) can explicitly flag themselves as being unhashable by setting ``__hash__ = None`` in the class definition. Doing so means that not only will instances of the class raise an appropriate :exc:`TypeError` when a program attempts to retrieve their hash value, but they will also be correctly identified as unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike classes which define their own :meth:`__hash__` to explicitly raise :exc:`TypeError`).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Классы, которые наследуют метод «:meth:`__hash__`» из родительского класса, но изменяют значение «:meth:`__eq__`» так, что возвращаемое значение хэша уже теряет разумный смысл (например, переходя к концепции сравнения на основании значения вместо стандартного сравнения на основе уникальных идентификаторов) могут явным образом обозначить себя как нехэшируемые установив «``__hash__ = None``» в определении класса. Такое действие приведёт не только к тому, что экземпляры данного класса будут вызывать соответствующее исключение «:exc:`TypeError`» , когда программа попытается получить их значение хэша, но и к тому, что экземпляры будут правильно идентифицированы как нехэшируемые при проверке «``isinstance(obj, collections.Hashable)``» (в отличие от классов, которые определили собственный «:meth:`__hash__`» , явно вызывающий исключение «:exc:`TypeError`» ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class that overrides :meth:`__eq__` needs to retain the implementation of :meth:`__hash__` from a parent class, the interpreter must be told this explicitly by setting ``__hash__ = &lt;ParentClass&gt;.__hash__``. Otherwise the inheritance of :meth:`__hash__` will be blocked, just as if :attr:`__hash__` had been explicitly set to :const:`None`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если классу, переопределившему «:meth:`__eq__`» нужно оставить реализацию «:meth:`__hash__`» из родительского класса, то это нужно обязательно делать явным образом : «``__hash__ = &lt;ParentClass&gt;.__hash__``» . Иначе наследование «:meth:`__hash__`» будет блокировано, так же, как если бы «:meth:`__hash__`» был явно установлен в «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement truth value testing and the built-in operation ``bool()``; should return ``False`` or ``True``.  When this method is not defined, :meth:`__len__` is called, if it is defined, and the object is considered true if its result is nonzero.  If a class defines neither :meth:`__len__` nor :meth:`__bool__`, all its instances are considered true.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для реализации проверки значения на истинность и встроенной операции «:func:`bool`» . Должен возвращать «:const:`False`» или «:const:`True`» . Если этот метод не определён, то вызывается «:meth:`__len__`» , если тот определён, и, если результат ненулевой, то данный объект считается значащим «:const:`True`» . Если класс не определяет ни «:meth:`__len__`» , ни «:meth:`__bool__`» , то его экземпляры считаются значащими «:const:`True`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing attribute access</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Настройка доступа к атрибутам</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for ``self``).  ``name`` is the attribute name. This method should return the (computed) attribute value or raise an :exc:`AttributeError` exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается, когда искомый атрибут не найден в соответствующих местах (тоесть, он не является атрибутом экземпляра и не найден в дереве классов данного экземпляра) . ``name`` – имя атрибута. Этот метод должен возвращать значение (вычисленное) атрибута, или инициировать исключение «:exc:`AttributeError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that if the attribute is found through the normal mechanism, :meth:`__getattr__` is not called.  (This is an intentional asymmetry between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both for efficiency reasons and because otherwise :meth:`__getattr__` would have no way to access other attributes of the instance.  Note that at least for instance variables, you can fake total control by not inserting any values in the instance attribute dictionary (but instead inserting them in another object).  See the :meth:`__getattribute__` method below for a way to actually get total control over attribute access.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что если атрибут найден обычным способом, то «:meth:`__getattr__`» не вызывается. (Несимметричность в этом смысле между «:meth:`__getattr__`» и «:meth:`__setattr__`» создана намеренно. ) Это сделано и в целях эффективности и из-за того, что иначе у «:meth:`__getattr__`» не было бы никакой возможности доступа к другим атрибутам экземпляра. Кстати, по крайней мере для переменных экземпляра вы можете имитировать тотальный контроль за счёт непомещения их в словарь атрибутов данного экземпляра (а храня их в другом объекте) . Смотрите метод «:meth:`__getattribute__`» ниже, предоставляющий способ действительно полностью контролировать доступ к атрибутам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called unconditionally to implement attribute accesses for instances of the class. If the class also defines :meth:`__getattr__`, the latter will not be called unless :meth:`__getattribute__` either calls it explicitly or raises an :exc:`AttributeError`. This method should return the (computed) attribute value or raise an :exc:`AttributeError` exception. In order to avoid infinite recursion in this method, its implementation should always call the base class method with the same name to access any attributes it needs, for example, ``object.__getattribute__(self, name)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается безусловно (всегда, когда определён) для реализации доступа к атрибутам экземпляров данного класса. Если в классе также определён «:meth:`__getattr__`» , то он не будет вызван, если только «:meth:`__getattribute__`» не вызовет его явно или не инициирует исключение «:exc:`AttributeError`» . Этот метод нужен, чтобы возвращать значение (вычисленное) атрибута, или инициировать исключение «:exc:`AttributeError`» . Чтобы при доступе к нужным атрибутам избежать бесконечной рекурсии, в реализации этого метода всегда нужно вызывать метод базового класса с тем же именем, например, «``object.__getattribute__(self, name)``» (вместо «``self.name``») .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See :ref:`special-lookup`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот метод всё же может быть обойдён обращением к специальным методам в результате явного обращения с помощью специального синтаксиса языка или встроенных функций. Смотрите «Обращение к специальным методам» :ref:`special-lookup` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when an attribute assignment is attempted.  This is called instead of the normal mechanism (i.e. store the value in the instance dictionary). *name* is the attribute name, *value* is the value to be assigned to it.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается при попытке записи (назначения) атрибута. Он вызывается вместо стандартного механизма (тоесть, вместо сохранения значения в словаре экземпляра) . *name* – имя атрибута, *value* – значение, которое нужно под этим именем сохранить (назначить) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If :meth:`__setattr__` wants to assign to an instance attribute, it should call the base class method with the same name, for example, ``object.__setattr__(self, name, value)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если «:meth:`__setattr__`» хочет получить доступ к атрибуту экземпляра, ему следует вызывать метод базового класса с тем же именем, например, «``object.__setattr__(self, name, value)``» (вместо «``self.name``») .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like :meth:`__setattr__` but for attribute deletion instead of assignment.  This should only be implemented if ``del obj.name`` is meaningful for the object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Подобен «:meth:`__setattr__`» , только вместо назначения – удаляет атрибут. Реализовывать его следует только если «``del obj.name``» должен иметь какой-то специальный смысл для данного объекта.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when :func:`dir` is called on the object.  A list must be returned.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается, когда вызывается «:func:`dir`» с данным объектом в качестве аргумента . Должен возвращаться список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods only apply when an instance of the class containing the method (a so-called *descriptor* class) appears in the class dictionary of another class, known as the *owner* class.  In the examples below, "the attribute" refers to the attribute whose name is the key of the property in the owner class' :attr:`__dict__`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие методы служат для “перехвата” обращения к объекту, содержащему их. Но есть принципиальные ограничения. Эти методы задействуются только у тех объектов, у которых они определены в их классе (такой класс называется “описатель” ) , и которые (объекты) являются атрибутом другого класса (присутствуют в словаре атрибутов этого класса или его родительских классов) (такой класс называется “владелец” ) . В примерах, данных ниже, “данный атрибут” подразумевает тот атрибут, чьё имя является ключом словаря «:attr:`__dict__`» класса – владельца.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to get the attribute of the owner class (class attribute access) or of an instance of that class (instance attribute access). *owner* is always the owner class, while *instance* is the instance that the attribute was accessed through, or ``None`` when the attribute is accessed through the *owner*.  This method should return the (computed) attribute value or raise an :exc:`AttributeError` exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для получения “данного атрибута” класса-владельца (доступ к атрибуту класса) или экземпляра класса-владельца (доступ к атрибуту экземпляра) . Аргумент «*owner*» всегда – класс-владелец, а аргумент «*instance*» – это тот экземпляр, через который “данный атрибут” был получен или «:const:`None`» , когда “данный атрибут” был получен через “владельца” . Этот метод должен возвращать значение “данного атрибута” (вычисленное) , или инициировать исключение «:exc:`AttributeError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to set the attribute on an instance *instance* of the owner class to a new value, *value*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для установки (записи) значения *value* для “данного атрибута” в экземпляре *instance* “класса-владельца” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to delete the attribute on an instance *instance* of the owner class.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для удаления “данного атрибута” в экземпляре *instance* “класса-владельца” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoking Descriptors</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызов дескрипторов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behavior for attribute access is to get, set, or delete the attribute from an object's dictionary. For instance, ``a.x`` has a lookup chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and continuing through the base classes of ``type(a)`` excluding metaclasses.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обычно эффект доступа к атрибутам заключается в чтении, записи или удалении их из словаря объекта. Например, поиск «``a.x``» происходит в такой последовательности : «``a.__dict__['x']``» , затем «``type(a).__dict__['x']``» и далее в базовых классах класса «``type(a)``» , исключая метаклассы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead.  Where this occurs in the precedence chain depends on which descriptor methods were defined and how they were called.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Но, если значением искомого атрибута является объект, в котором определён один из дескрипторных методов, то Питон может обойти обычное поведение и вызвать вместо этого дескрипторный метод. На каком этапе последовательности поиска атрибута это произойдёт – зависит от того, какие дескрипторные методы были определены, и как они были вызваны.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If binding to an object instance, ``a.x`` is transformed into the call: ``type(a).__dict__['x'].__get__(a, type(a))``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При вызове через объект-экземпляр *a* : «``a.x``» преобразуется в вызов «``type(a).__dict__['x'].__get__(a, type(a))``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If binding to a class, ``A.x`` is transformed into the call: ``A.__dict__['x'].__get__(None, A)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При вызове через класс *A* : «``A.x``» преобразуется в вызов «``A.__dict__['x'].__get__(None, A)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>__slots__</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>__slots__</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, instances of classes have a dictionary for attribute storage.  This wastes space for objects having very few instance variables.  The space consumption can become acute when creating large numbers of instances.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>По умолчанию экземпляры классов имеют словарь для хранения атрибутов. Это расходует много места для объектов, имеющих мало своих переменных. Расход места может стать острым, при создании большого количества экземпляров.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default can be overridden by defining *__slots__* in a class definition. The *__slots__* declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable.  Space is saved because *__dict__* is not created for each instance.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это стандартное поведение можно отменить, определив «:attr:`__slots__`» в определении класса. «:attr:`__slots__`» получает последовательность переменных экземпляра и резервирует в каждом экземпляре только необходимое для хранения значений всех его переменных количество места. Место экономится, поскольку не создаётся «:attr:`__dict__`» для каждого экземпляра.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class variable can be assigned a string, iterable, or sequence of strings with variable names used by instances.  If defined in a class, *__slots__* reserves space for the declared variables and prevents the automatic creation of *__dict__* and *__weakref__* for each instance.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этой переменной класса можно назначить строку, итерируемый объект или последовательность строк с именами переменных, используемых экземплярами. В случае объявления его в классе, «:attr:`__slots__`» резервирует место для объявленных переменных и отменяет автоматическое создание «:attr:`__dict__`» и «:attr:`__weakref__`» для каждого экземпляра.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes on using *__slots__*</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Замечания по использованию «:attr:`__slots__`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When inheriting from a class without *__slots__*, the *__dict__* attribute of that class will always be accessible, so a *__slots__* definition in the subclass is meaningless.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При наследовании от класса без «:attr:`__slots__`» , атрибут «:attr:`__dict__`» этого класса будет всегда доступным, поэтому определение «:attr:`__slots__`» в подклассах бесполезно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without a *__dict__* variable, instances cannot be assigned new variables not listed in the *__slots__* definition.  Attempts to assign to an unlisted variable name raises :exc:`AttributeError`. If dynamic assignment of new variables is desired, then add ``'__dict__'`` to the sequence of strings in the *__slots__* declaration.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Без переменной «:attr:`__dict__`» экземплярам не могут быть назначены новые переменные, не перечисленные в определении «:attr:`__slots__`» . Попытки назначений не перечисленных имен переменных вызывают ошибку «:exc:`AttributeError`» . Если желательно динамическое назначение новых переменных, добавьте ``'__dict__'`` в последовательность строк в определении «:attr:`__slots__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without a *__weakref__* variable for each instance, classes defining *__slots__* do not support weak references to its instances. If weak reference support is needed, then add ``'__weakref__'`` to the sequence of strings in the *__slots__* declaration.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Без переменной «:attr:`__weakref__`» у каждого экземпляра – классы, в которых определён «:attr:`__slots__`» – не поддерживают «слабые» ссылки на свои экземпляры. Если поддержка слабых ссылок нужна, то к последовательности строк в объявлении «:attr:`__slots__`» добавьте «``'__weakref__'``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*__slots__* are implemented at the class level by creating descriptors (:ref:`descriptors`) for each variable name.  As a result, class attributes cannot be used to set default values for instance variables defined by *__slots__*; otherwise, the class attribute would overwrite the descriptor assignment.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:attr:`__slots__`» реализованы на уровне соответствующего класса посредством создания дескрипторов (смотрите “Реализация дескрипторов” :ref:`descriptors` ) для каждого имени переменной. В результате атрибуты класса не могут быть использованы для установки значений по-умолчанию для переменных у экземпляров, определённых посредством «:attr:`__slots__`» – иначе атрибуты этих классов могли бы переписать назначение этих дескрипторов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The action of a *__slots__* declaration is limited to the class where it is defined.  As a result, subclasses will have a *__dict__* unless they also define *__slots__* (which must only contain names of any *additional* slots).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эффект объявления «:attr:`__slots__`» распространяется только на тот класс, в котором этот атрибут определён. Таким образом : подклассы будут иметь атрибут «:attr:`__dict__`» , если сами также не определят «:attr:`__slots__`» (который должен содержать имена только дополнительных “слотов” ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class defines a slot also defined in a base class, the instance variable defined by the base class slot is inaccessible (except by retrieving its descriptor directly from the base class). This renders the meaning of the program undefined.  In the future, a check may be added to prevent this.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если класс определяет “слот” , который определён и в базовом классе, то та переменная экземпляра, которая определена “слотом” базового класса, будет недоступна (за исключением явного получения дескриптора через базовый класс) . Это делает неопределённым значение программы. В будущем для предотвращения этого может быть добавлена какая-либо проверка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nonempty *__slots__* does not work for classes derived from "variable-length" built-in types such as :class:`int`, :class:`str` and :class:`tuple`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Непустой атрибут «:attr:`__slots__`» не действует для классов, произведённых от встроенных типов “переменной длинны” , таких как :class:`int` , :class:`str` и :class:`tuple` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any non-string iterable may be assigned to *__slots__*. Mappings may also be used; however, in the future, special meaning may be assigned to the values corresponding to each key.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Любой перебираемый (“итерируемый”) объект, кроме текста – может быть назначен атрибуту «:attr:`__slots__`» . Отображения тоже могут быть использованы, однако, в будущем им может быть придан специальный смысл.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*__class__* assignment works only if both classes have the same *__slots__*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Назначение атрибуту «:attr:`__class__`» работает, только если оба класса имеют один и тот же «:attr:`__slots__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing class creation</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Управление созданием классов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, classes are constructed using :func:`type`. A class definition is read into a separate namespace and the value of class name is bound to the result of ``type(name, bases, dict)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>По умолчанию классы создаются с использованием «:func:`type`» . Определение класса “считывается” в отдельное пространство имён, и получившемуся результату ``type(name, bases, dict)`` назначается соответствующее имя класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the class definition is read, if a callable ``metaclass`` keyword argument is passed after the bases in the class definition, the callable given will be called instead of :func:`type`.  If other keyword arguments are passed, they will also be passed to the metaclass.  This allows classes or functions to be written which monitor or alter the class creation process:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда описание данного класса считывается, если передан исполнимый аргумент под ключевым словом «:keyword:`metaclass`» после базовых классов в определении класса, то этот исполнимый объект будет вызван вместо «:func:`type`» . Если переданы и другие именованные аргументы, то они также будут переданы этому метаклассу. Это позволяет писать классы или функции, которые отслеживают или изменяют процесс создания класса :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modifying the class dictionary prior to the class being created.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Модифицируя словарь данного класса перед тем, как данный класс будет создан.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returning an instance of another class -- essentially performing the role of a factory function.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Возвращая экземпляр другого класса, по сути исполняя роль функций-фабрик.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These steps will have to be performed in the metaclass's :meth:`__new__` method -- :meth:`type.__new__` can then be called from this method to create a class with different properties.  This example adds a new element to the class dictionary before creating the class::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эти шаги должны быть исполнены в методе «:meth:`__new__`» данного метакласса – затем из этого метода может быть вызван «:meth:`type.__new__`» для создания класса с другими свойствами. Следующий пример добавляет новый элемент к словарю данного класса перед созданием данного класса :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class metacls(type):     def __new__(mcs, name, bases, dict):         dict['foo'] = 'metacls was here'         return type.__new__(mcs, name, bases, dict)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>class metacls(type):     def __new__(mcs, name, bases, dict):         dict['foo'] = 'metacls was here'         return type.__new__(mcs, name, bases, dict)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can of course also override other class methods (or add new methods); for example defining a custom :meth:`__call__` method in the metaclass allows custom behavior when the class is called, e.g. not always creating a new instance.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Конечно, вы можете ещё и переопределять другие методы класса (или добавлять новые) . Например, определение метода «:meth:`__call__`» позволяет настроить то, как ведёт себя данный класс при вызове, например, чтобы он не каждый раз создавал новый экземпляр.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the metaclass has a :meth:`__prepare__` attribute (usually implemented as a class or static method), it is called before the class body is evaluated with the name of the class and a tuple of its bases for arguments.  It should return an object that supports the mapping interface that will be used to store the namespace of the class.  The default is a plain dictionary.  This could be used, for example, to keep track of the order that class attributes are declared in by returning an ordered dictionary.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если у данного класса есть атрибут «:meth:`__prepare__`» (обычно реализованный как класс или статический метод) , то он вызывается с именем данного класса и с кортежем его базовых классов в качестве аргументов – до исполнения (интерпретации) “тела” данного класса. Результатом должен быть объект, поддерживающий интерфейс отображения, который будет содержать область имён данного класса. По-умолчанию – это простой словарь. Это может использоваться, например, для запоминания (в возвращаемом упорядоченном словаре) того порядка, в котором атрибуты данного класса были объявлены.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The appropriate metaclass is determined by the following precedence rules:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Соответствующий метакласс определяется следующей последовательностью правил :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the ``metaclass`` keyword argument is passed with the bases, it is used.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если аргумент под именем «``metaclass``» передан с базовыми классами, то используется он.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, if there is at least one base class, its metaclass is used.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Иначе, если есть хотя бы один базовый класс, то используются его метаклассы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, the default metaclass (:class:`type`) is used.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Иначе – используется метакласс по умолчанию («:class:`type`») .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The potential uses for metaclasses are boundless. Some ideas that have been explored including logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Возможные применения для метаклассов неограничены. Наиболее разработаны следующие : логирование, проверка интерфейса, автоматическое делегирование, автоматическое создание свойств, посредники, среды исполнения, и т. д. .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of a metaclass that uses an :class:`collections.OrderedDict` to remember the order that class members were defined::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Далее дан пример метакласса, использующего «:class:`collections.OrderedDict`» для запоминания порядка, в котором члены класса были определены : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class OrderedClass(type):       @classmethod      def __prepare__(metacls, name, bases, **kwds):         return collections.OrderedDict()       def __new__(cls, name, bases, classdict):         result = type.__new__(cls, name, bases, dict(classdict))         result.members = tuple(classdict)         return result  class A(metaclass=OrderedClass):     def one(self): pass     def two(self): pass     def three(self): pass     def four(self): pass  &gt;&gt;&gt; A.members ('__module__', 'one', 'two', 'three', 'four')</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>class OrderedClass(type):       @classmethod      def __prepare__(metacls, name, bases, **kwds):         return collections.OrderedDict()       def __new__(cls, name, bases, classdict):         result = type.__new__(cls, name, bases, dict(classdict))         result.members = tuple(classdict)         return result  class A(metaclass=OrderedClass):     def one(self): pass     def two(self): pass     def three(self): pass     def four(self): pass  &gt;&gt;&gt; A.members ('__module__', 'one', 'two', 'three', 'four')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the class definition for *A* gets executed, the process begins with calling the metaclass's :meth:`__prepare__` method which returns an empty :class:`collections.OrderedDict`.  That mapping records the methods and attributes of *A* as they are defined within the body of the class statement. Once those definitions are executed, the ordered dictionary is fully populated and the metaclass's :meth:`__new__` method gets invoked.  That method builds the new type and it saves the ordered dictionary keys in an attribute called *members*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда происходит переход к исполнению определения класса *A* , то этот процесс начинается с вызова из метакласса метода «:meth:`__prepare__`» , который возвращает пустой объект «:class:`collections.OrderedDict`» . Это отображение записывает методы и атрибуты класса *A* , как если бы они были определены внутри тела этого класса. Когда эти определения исполнены – данный упорядоченый словарь полностью заполняется, и метод «:meth:`__new__`» метакласса вызывается. И последний создаёт новый тип и сохраняет ключи упорядоченого словаря в атрибуте «``members``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Emulating callable objects</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эмулирование исполнимых объектов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the instance is "called" as a function; if this method is defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, ...)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается, когда данный экземпляр вызывается как функция, если этот метод определён. «``x(arg1, arg2, ...)``» является краткой формой для «``x.__call__(arg1, arg2, ...)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Emulating container types</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эмулирование контейнерных типов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods can be defined to implement container objects.  Containers usually are sequences (such as lists or tuples) or mappings (like dictionaries), but can represent other containers as well.  The first set of methods is used either to emulate a sequence or to emulate a mapping; the difference is that for a sequence, the allowable keys should be the integers *k* for which ``0 &lt;= k &lt; N`` where *N* is the length of the sequence, or slice objects, which define a range of items.  It is also recommended that mappings provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:`popitem`, :meth:`copy`, and :meth:`update` behaving similar to those for Python's standard dictionary objects.  The :mod:`collections` module provides a :class:`MutableMapping` abstract base class to help create those methods from a base set of :meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable sequences should provide methods :meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and :meth:`sort`, like Python standard list objects.  Finally, sequence types should implement addition (meaning concatenation) and multiplication (meaning repetition) by defining the methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; they should not define other numerical operators.  It is recommended that both mappings and sequences implement the :meth:`__contains__` method to allow efficient use of the ``in`` operator; for mappings, ``in`` should search the mapping's keys; for sequences, it should search through the values.  It is further recommended that both mappings and sequences implement the :meth:`__iter__` method to allow efficient iteration through the container; for mappings, :meth:`__iter__` should be the same as :meth:`keys`; for sequences, it should iterate through the values.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие методы могут быть определены для реализации объектов-контейнеров. Контейнеры – это обычно последовательности (как списки или кортежи) или отображения (как словари) , но также могут быть реализованы другие виды. Первая группа следующих далее методов используется для эмуляции как последовательностей, так и отображений – разница в том, что для последовательностей допустимые ключи должны быть целым числом *k* в диапазоне «0 &lt;= k &lt; N» , где *N* равно длине данной последовательности, или быть объектом-срезом (который определяет диапазон элементов) . Также рекомендуется, чтобы отображения предоставляли методы : «:meth:`keys`» , «:meth:`values`» , «:meth:`items`» , «:meth:`get`» , «:meth:`clear`» , «:meth:`setdefault`» , «:meth:`pop`» , «:meth:`popitem`» , «:meth:`copy`» и «:meth:`update`» , дающие тот же эффект, что и в стандартных Питоновских словарях. Модуль «:mod:`collections`» предоставляет абстрактный базовый класс «:class:`MutableMapping`» , облегчающий создание этих методов на основе базового набора из : «:meth:`__getitem__`» , «:meth:`__setitem__`» , «:meth:`__delitem__`» и «:meth:`keys`» . Изменяемые последовательности могут предоставлять методы : «:meth:`append`» , «:meth:`count`» , «:meth:`index`» , «:meth:`extend`» , «:meth:`insert`» , «:meth:`pop`» , «:meth:`remove`» , «:meth:`reverse`» и «:meth:`sort`» – как у обычных Питоновских списков. И, наконец, типы-последовательности могут реализовать сложение (тоесть конкатенацию) и умножение (тоесть повтор) – через определение методов : «:meth:`__add__`» , «:meth:`__radd__`» , «:meth:`__iadd__`» , «:meth:`__mul__`» , «:meth:`__rmul__`» и «:meth:`__imul__`» (их описание – ниже) – эти типы не должны определять другие числовые операции. Рекомендуется и в отображениях и в последовательностях обеспечивать метод «:meth:`__contains__`» , который был бы эффективной реализацией оператора «:keyword:`in`» . Для отображений – «:keyword:`in`» должен искать в ключах этого отображения, а для последовательностей – в значениях. Кроме того, рекомендуется для отображений и последовательностей реализовывать метод «:meth:`__iter__`» для эффективного перебора элементов в этом контейнере. Для отображений – «:meth:`__iter__`» должен быть то же, что и «:meth:`keys`» , а для последовательностей этот метод должен перебирать значения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement the built-in function :func:`len`.  Should return the length of the object, an integer ``&gt;=`` 0.  Also, an object that doesn't define a :meth:`__bool__` method and whose :meth:`__len__` method returns zero is considered to be false in a Boolean context.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для реализации встроенной функции «:func:`len`» . Этот метод должен возвращать длину данного объекта в виде целого значения &gt;= 0 . Кроме этого, объект, в котором не определён метод «:meth:`__bool__`» и чей метод «:meth:`__len__`» возвращает ноль – считается ложью в контексте булевых операций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Slicing is done exclusively with the following three methods.  A call like ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Срезы производятся исключительно следующими тремя методами. Вызов вроде : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a[1:2] = b</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>a[1:2] = b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is translated to ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>преобразуется в : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a[slice(1, 2, None)] = b</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>a[slice(1, 2, None)] = b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and so forth.  Missing slice items are always filled in with ``None``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>и так далее. Отсутствующие параметры среза всегда заполняются значениями «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement evaluation of ``self[key]``. For sequence types, the accepted keys should be integers and slice objects.  Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the :meth:`__getitem__` method. If *key* is of an inappropriate type, :exc:`TypeError` may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), :exc:`IndexError` should be raised. For mapping types, if *key* is missing (not in the container), :exc:`KeyError` should be raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для реализации вычисления (получения) ``self[key]`` . Для типов-последовательностей – допустимые ключи должны быть целыми числами или специальными объектами-срезами. Заметьте, что особая интерпретация негативных индексов (если данный класс желает эмулировать тип-последовательность) распространяется и на метод «:meth:`__getitem__`» . Если *key* не подходящего типа, то может инициироваться «:exc:`TypeError`» , а если значение за пределами набора индексов данной последовательности (вследствие какой-либо оригинальной интерпретации негативных значений) – то должно инициироваться «:exc:`IndexError`» . Для отображающих типов, если *key* отсутствует (не в контейнере) – должно инициироваться «:exc:`KeyError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`for` loops expect that an :exc:`IndexError` will be raised for illegal indexes to allow proper detection of the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>циклы «:keyword:`for`» ожидают, что для недопустимых индексов будет инициировано «:exc:`IndexError`» , что нужно для правильного определения конца последовательности.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement assignment to ``self[key]``.  Same note as for :meth:`__getitem__`.  This should only be implemented for mappings if the objects support changes to the values for keys, or if new keys can be added, or for sequences if elements can be replaced.  The same exceptions should be raised for improper *key* values as for the :meth:`__getitem__` method.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для реализации назначения для ``self[key]`` . То же замечание об отрицательных индексах, что и для «:meth:`__getitem__`» . Этот метод должен быть реализован для отображений – только если эти объекты поддерживают изменение значений ключей, или если могут добавляться новые ключи, или для последовательностей, если элементы могут быть заменены. Для неправильных значений *key* исключения должны инициироваться также, как и для «:meth:`__getitem__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement deletion of ``self[key]``.  Same note as for :meth:`__getitem__`.  This should only be implemented for mappings if the objects support removal of keys, or for sequences if elements can be removed from the sequence.  The same exceptions should be raised for improper *key* values as for the :meth:`__getitem__` method.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для реализации удаления ``self[key]`` . То же замечание об отрицательных индексах, что и для «:meth:`__getitem__`» . Этот метод должен быть реализован для отображений – только если эти объекты поддерживают удаление ключей, или для последовательностей, если элементы могут быть удалены из этой последовательности. Для неправильных значений *key* исключения должны инициироваться также, как и для «:meth:`__getitem__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is called when an iterator is required for a container. This method should return a new iterator object that can iterate over all the objects in the container.  For mappings, it should iterate over the keys of the container, and should also be made available as the method :meth:`keys`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот метод у данного объекта-контейнера вызывается, когда нужен итератор для данного объекта. Этот метод должен возвращать новый объект-итератор, который будет перебирать все объекты в этом объекте-контейнере. Для отображений он должен перебирать ключи, и также должен быть доступен в качестве метода «:meth:`keys`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Iterator objects also need to implement this method; they are required to return themselves.  For more information on iterator objects, see :ref:`typeiter`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сами объекты-итераторы тоже должны реализовывать этот метод – для того, чтобы возвращать самих себя. Дополнительную информацию об объектах-итераторах смотрите в «Итерируемые типы» :ref:`typeiter` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called (if present) by the :func:`reversed` built-in to implement reverse iteration.  It should return a new iterator object that iterates over all the objects in the container in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается (если имеется) встроенной функцией «:func:`reversed`» для реализации перебора в обратном порядке. Этот метод должен возвращать новый объект-итератор, который будет перебирать в обратном порядке все объекты в данном объекте-контейнере.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the :meth:`__reversed__` method is not provided, the :func:`reversed` built-in will fall back to using the sequence protocol (:meth:`__len__` and :meth:`__getitem__`).  Objects that support the sequence protocol should only provide :meth:`__reversed__` if they can provide an implementation that is more efficient than the one provided by :func:`reversed`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если метод «:meth:`__reversed__`» не предоставлен, то встроенная функция «:func:`reversed`» будет использовать рассматриваемый в данном параграфе протокол последовательностей (а именно : «:meth:`__len__`» и «:meth:`__getitem__`» ) . Объекты, поддерживающие данный протокол должны предоставлять «:meth:`__reversed__`» , только если они могут обеспечить более эффективную реализацию, чем предлагает «:func:`reversed`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The membership test operators (:keyword:`in` and :keyword:`not in`) are normally implemented as an iteration through a sequence.  However, container objects can supply the following special method with a more efficient implementation, which also does not require the object be a sequence.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы проверки вхождения ( «:keyword:`in`» и «:keyword:`not in`» ) обычно реализуются через перебор последовательности. Однако, контейнерные объекты могут предоставлять перечисленные ниже специальные методы с более эффективной реализацией, при этом не обязательно, чтобы объекты были последовательностями.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement membership test operators.  Should return true if *item* is in *self*, false otherwise.  For mapping objects, this should consider the keys of the mapping rather than the values or the key-item pairs.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается для реализации операторов проверки членства. Должен возвращать «:const:`True`» , если *item* находится в *self* , иначе – «:const:`False`» . Для объектов-отображений при этом подразумеваются ключи, а не значения или пары ключ–значение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For objects that don't define :meth:`__contains__`, the membership test first tries iteration via :meth:`__iter__`, then the old sequence iteration protocol via :meth:`__getitem__`, see :ref:`this section in the language reference &lt;membership-test-details&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для объектов, в которых не определён «__contains__()» , проверка членства сначала пытается перебирать с помощью «__iter__()» , затем используя устаревший подход – с помощью «__getitem__()» ( подробнее в :ref:`соответствующем разделе &lt;membership-test-details&gt;` ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Emulating numeric types</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эмулирование числовых типов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods can be defined to emulate numeric objects. Methods corresponding to operations that are not supported by the particular kind of number implemented (e.g., bitwise operations for non-integral numbers) should be left undefined.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие методы могут быть определены для эмулирования числовых объектов. Методы, соответствующие операциям, не поддерживаемым данным конкретным видом реализуемого числа (например, побитовые операции для не целых чисел) – не следует определять.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are called to implement the binary arithmetic operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``&lt;&lt;``, ``&gt;&gt;``, ``&amp;``, ``^``, ``|``).  For instance, to evaluate the expression ``x + y``, where *x* is an instance of a class that has an :meth:`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an optional third argument if the ternary version of the built-in :func:`pow` function is to be supported.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данные методы вызываются для реализации двухоперандных операций ( «``+``», «``-``», «``*``», «``/``», «``//``», «``%``», «:func:`divmod`», «:func:`pow`», «``**``», «``&lt;&lt;``», «``&gt;&gt;``», «``&amp;``», «``^``», «``|``» ) . Например, для вычисления выражения ``x + y`` , где *x* является экземпляром класса, имеющего метод «:meth:`__add__`» – вызывается метод «``x.__add__(y)``» . Метод «:meth:`__divmod__`» должен быть эквивалентным использованию методов «:meth:`__floordiv__`» и «:meth:`__mod__`» , но он не должен соответствовать «:meth:`__truediv__`» . Заметьте, что «:meth:`__pow__`» должен быть определён принимающим необязательный третий аргумент, если должна поддерживаться трёхоперандная версия встроенной функции «:func:`pow`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those methods does not support the operation with the supplied arguments, it should return ``NotImplemented``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если какой-либо из указанных выше методов не поддерживает операцию над предоставленными аргументами – он должен вернуть значение «``NotImplemented``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are called to implement the binary arithmetic operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``&lt;&lt;``, ``&gt;&gt;``, ``&amp;``, ``^``, ``|``) with reflected (swapped) operands. These functions are only called if the left operand does not support the corresponding operation and the operands are of different types. [#]_  For instance, to evaluate the expression ``x - y``, where *y* is an instance of a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns *NotImplemented*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данные методы вызываются для реализации двухоперандных операций ( «``+``», «``-``», «``*``», «``/``», «``//``», «``%``», «:func:`divmod`», «:func:`pow`», «``**``», «``&lt;&lt;``», «``&gt;&gt;``», «``&amp;``», «``^``», «``|``» ) с обратным порядком операндов . Эти функции вызываются, только если первый (левый) операнд не поддерживает соответствующую операцию, а операнды разных типов. [#]_ (Для операндов одинакового типа – подразумевается, что если метод для “прямого” порядка (например, «:meth:`__add__()`» ) непримени́м, то данная операция вообще не поддерживается – поэтому “обратная” операция и не вызывается. ) Например : при вычислении выражения ``x - y`` , где *y* является экземпляром класса, имеющего метод «:meth:`__rsub__`» – вызывается «``y.__rsub__(x)``» , если «``x.__sub__(y)``» возвращает значение «``NotImplemented``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the coercion rules would become too complicated).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что трёхоперандное «:func:`pow`» не будет пытаться вызвать «:meth:`__rpow__`» (соответствующие правила приведения (перехода) были бы слишком сложны) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the right operand's type is a subclass of the left operand's type and that subclass provides the reflected method for the operation, this method will be called before the left operand's non-reflected method.  This behavior allows subclasses to override their ancestors' operations.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если тип правого операнда является подклассом класса левого операнда, и этот подкласс предоставляет для той же операции метод с обратным порядком операндов, то этот метод будет вызван до метода с прямым порядком у левого операнда. Такое поведение позволяет подклассам переопределять операции их предков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are called to implement the augmented arithmetic assignments (``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``&lt;&lt;=``, ``&gt;&gt;=``, ``&amp;=``, ``^=``, ``|=``).  These methods should attempt to do the operation in-place (modifying *self*) and return the result (which could be, but does not have to be, *self*).  If a specific method is not defined, the augmented assignment falls back to the normal methods.  For instance, to execute the statement ``x += y``, where *x* is an instance of a class that has an :meth:`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance of a class that does not define a :meth:`__iadd__` method, ``x.__add__(y)`` and ``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данные методы вызываются для реализации расширеных арифметических операций-назначений ( «``+=``», «``-=``», «``*=``», «``/=``», «``//=``», «``%=``», «``**=``», «``&lt;&lt;=``», «``&gt;&gt;=``», «``&amp;=``», «``^=``», «``|=``» ) . Эти методы должны пытаться выполнять операции “на месте” (изменяя *self*) и возвращать результат (который может, но не обязан быть *self* ) . Если специальный метод не определён, то операция использует обычные арифметические методы. Например, для вычисления выражения ``x += y`` , где *x* является экземпляром класса, имеющего метод «:meth:`__iadd__`» – вызывается «``x.__iadd__(y)``» . Если *x* является экземпляром класса, в котором не определён метод «:meth:`__iadd__`» , то используются «``x.__add__(y)``» и «``y.__radd__(x)``» – как для вычисления ``x + y`` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement the unary arithmetic operations (``-``, ``+``, :func:`abs` and ``~``).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данные методы вызываются для реализации однооперандных арифметических операций ( «``-``», «``+``», «:func:`abs`» и «``~``» ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement the built-in functions :func:`complex`, :func:`int`, :func:`float` and :func:`round`.  Should return a value of the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данные методы вызываются для реализации встроенных функций «:func:`complex`», «:func:`int`», «:func:`float`» и «:func:`round`» . Должны возвращать значение соответствующего типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called to implement :func:`operator.index`.  Also called whenever Python needs an integer object (such as in slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` functions). Must return an integer.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данный метод вызывается для реализации функции «:func:`operator.index`» . Также вызывается, когда Питону требуется целочисленный объект (например в срезах; или во встроенных функциях : «:func:`bin`», «:func:`hex`» и «:func:`oct`» ) . Должен возвращать целое число.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Statement Context Managers</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:dfn:`“Менеджеры контекста”&lt;context manager&gt;` для инструкции «:keyword:`with`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :dfn:`context manager` is an object that defines the runtime context to be established when executing a :keyword:`with` statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.  Context managers are normally invoked using the :keyword:`with` statement (described in section :ref:`with`), but can also be used by directly invoking their methods.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:dfn:`“Менеджер контекста”&lt;context manager&gt;` – это объект, который задаёт контекст, который должен быть установлен при исполнении инструкции «:keyword:`with`» . Такой менеджер контекста управляет входом, выходом, требуемым контекстом исполнения данного блока кода. Менеджеры контекста обычно вызываются через инструкцию «:keyword:`with`» (описание в разделе “Инструкция «:keyword:`with`»” :ref:`with` ) , но также могут использоваться через явный вызов их методов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typical uses of context managers include saving and restoring various kinds of global state, locking and unlocking resources, closing opened files, etc.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Характерное применение менеджеров контекста включает : сохранение и восстановление глобального состояния, блокирование и разблокирование ресурсов, закрытие открытых файлов, и т.д. .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information on context managers, see :ref:`typecontextmanager`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Дополнительную информацию смотрите в разделе :ref:`“Типы менеджеров контекста”&lt;typecontextmanager&gt;` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the runtime context related to this object. The :keyword:`with` statement will bind this method's return value to the target(s) specified in the :keyword:`as` clause of the statement, if any.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Входит в оперативный (существующий на стадии исполнения) контекст, относящийся к данному объекту. Инструкция «:keyword:`with`» будет назначать (связывать) возвращаемое значение этого метода целям (именам) заявленным в ветви «:keyword:`as`» , если таковая имеется.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exit the runtime context related to this object. The parameters describe the exception that caused the context to be exited. If the context was exited without an exception, all three arguments will be :const:`None`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выходит из оперативного (существующего на стадии исполнения) контекста, относящегося к данному объекту. Указанные параметры определяют, какое именно исключение привело к выходу из данного контекста. Если выход из данного контекста происходит без исключения, то все три аргумента будут «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an exception is supplied, and the method wishes to suppress the exception (i.e., prevent it from being propagated), it should return a true value. Otherwise, the exception will be processed normally upon exit from this method.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если дано исключение и данный метод собирается “подавить” это исключение (тоесть, не пропустить его дальше) , то он должен вернуть значение, эквивалентное «:const:`True`» . Иначе : по выходу из этого метода будет продолжена нормальная обработка данного исключения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that :meth:`__exit__` methods should not reraise the passed-in exception; this is the caller's responsibility.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что методы «:meth:`__exit__`» не должны перевызывать переданные внутрь них исключения – это обязанность вызвавшего кода.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special method lookup</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обращение к специальным методам</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object's type, not in the object's instance dictionary.  That behaviour is the reason why the following code raises an exception::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для определяемых пользователем классов, работа явных вызовов специальных методов гарантирована, только если эти методы определены в словаре класса данного объекта, а не экземпляра. Такое поведение приводит к тому, что следующий код приводит к исключению : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; class C(object): ...     pass ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; c.__len__ = lambda: 5 &gt;&gt;&gt; len(c) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: object of type 'C' has no len()</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; class C(object): ...     pass ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; c.__len__ = lambda: 5 &gt;&gt;&gt; len(c) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: object of type 'C' has no len()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rationale behind this behaviour lies with a number of special methods such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all objects, including type objects. If the implicit lookup of these methods used the conventional lookup process, they would fail when invoked on the type object itself::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Смысл в таком поведении заключается в том, что некоторые специальные методы, такие как «:meth:`__hash__`» и «:meth:`__repr__`» , реализованы во всех объектах, включая и объекты-типы. Если бы явное обращение к этим методам использовало стандартный процесс обращения, то они бы вызывали ошибку при применении к самому объекту-классу : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; 1 .__hash__() == hash(1) True &gt;&gt;&gt; int.__hash__() == hash(int) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: descriptor '__hash__' of 'int' object needs an argument</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; 1 .__hash__() == hash(1) True &gt;&gt;&gt; int.__hash__() == hash(int) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: descriptor '__hash__' of 'int' object needs an argument</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incorrectly attempting to invoke an unbound method of a class in this way is sometimes referred to as 'metaclass confusion', and is avoided by bypassing the instance when looking up special methods::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Неправильные попытки вызвать таким способом несвязанный метод класса иногда называют “путаница метаклассов” и справляются с этим, пропуская (обходя) экземпляр при доступе к специальным методам : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; type(1).__hash__(1) == hash(1) True &gt;&gt;&gt; type(int).__hash__(int) == hash(int) True</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; type(1).__hash__(1) == hash(1) True &gt;&gt;&gt; type(int).__hash__(int) == hash(int) True</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the :meth:`__getattribute__` method even of the object's metaclass::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В дополнение к пропуску любых атрибутов экземпляров с целью сохранения корректности – явный поиск специального метода, в общем случае, также пропускает метод «:meth:`__getattribute__`» даже в метаклассе данного объекта : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; class Meta(type): ...    def __getattribute__(*args): ...       print("Metaclass getattribute invoked") ...       return type.__getattribute__(*args) ... &gt;&gt;&gt; class C(object, metaclass=Meta): ...     def __len__(self): ...         return 10 ...     def __getattribute__(*args): ...         print("Class getattribute invoked") ...         return object.__getattribute__(*args) ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; c.__len__()                 # Explicit lookup via instance Class getattribute invoked 10 &gt;&gt;&gt; type(c).__len__(c)          # Explicit lookup via type Metaclass getattribute invoked 10 &gt;&gt;&gt; len(c)                      # Implicit lookup 10</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; class Meta(type): ...    def __getattribute__(*args): ...       print("Metaclass getattribute invoked") ...       return type.__getattribute__(*args) ... &gt;&gt;&gt; class C(object, metaclass=Meta): ...     def __len__(self): ...         return 10 ...     def __getattribute__(*args): ...         print("Class getattribute invoked") ...         return object.__getattribute__(*args) ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; c.__len__()                 # Явный поиск через экземпляр Class getattribute invoked 10 &gt;&gt;&gt; type(c).__len__(c)          # Явный поиск через класс Metaclass getattribute invoked 10 &gt;&gt;&gt; len(c)                      # Косвенный поиск 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bypassing the :meth:`__getattribute__` machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method *must* be set on the class object itself in order to be consistently invoked by the interpreter).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пропуск (обход) механизма «:meth:`__getattribute__`» в такой манере даёт значительное ограничение ради оптимизации по скорости в интерпретаторе, незначительно жертвуя удобством в обращении со специальными методами (специальный метод должен быть установлен в самом объекте-классе для того, чтобы быть нормально вызванным интерпретатором) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It *is* possible in some cases to change an object's type, under certain controlled conditions. It generally isn't a good idea though, since it can lead to some very strange behaviour if it is handled incorrectly.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В некоторых случаях, при выполнении определённых условий, *возможно таки* изменить тип объекта. В общем случае – это плохая практика, поскольку это может приводить к некоторым очень странным результатам при неосторожном обращении.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execution model</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Модель исполнения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naming and binding</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Именование и связывание</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:dfn:`Names` refer to objects.  Names are introduced by name binding operations. Each occurrence of a name in the program text refers to the :dfn:`binding` of that name established in the innermost function block containing the use.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:dfn:`Имена` указывают на обьекты. Имена вводятся операцииями :dfn:`связывания` (назначения) имён. Каждое появление имени в тексте программы указывает на то, что назначено этому имени в данном самом внутреннем функциональном блоке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :dfn:`block` is a piece of Python program text that is executed as a unit. The following are blocks: a module, a function body, and a class definition. Each command typed interactively is a block.  A script file (a file given as standard input to the interpreter or specified on the interpreter command line the first argument) is a code block.  A script command (a command specified on the interpreter command line with the '**-c**' option) is a code block.  The string argument passed to the built-in functions :func:`eval` and :func:`exec` is a code block.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:dfn:`Блок` - часть текста программы на Питоне, которая выполняется как одно целое. Блоками является следующее : модуль, тело функции и определение класса. Каждая команда, набранная интерактивно, является блоком. Файл скрипта (файл, заданный как стандартный ввод интерпретатора или указанный в первом аргументе командной строки интерпретатора) является блоком кода. Команда скрипта (команда указанная с опцией '**-c**' в командной строке интерпретатора) является блоком кода. Текстовый аргумент переданный встроенным функциям «:func:`eval`» и «:func:`exec`» тоже является блоком кода.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A code block is executed in an :dfn:`execution frame`.  A frame contains some administrative information (used for debugging) and determines where and how execution continues after the code block's execution has completed.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Блок кода выполняется в :dfn:`кадре исполнения`. Кадр содержит административную информацию (использующуюся для отладки), и определяет, где и как продолжается выполнение после завершения выполнения блока кода.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :dfn:`scope` defines the visibility of a name within a block.  If a local variable is defined in a block, its scope includes that block.  If the definition occurs in a function block, the scope extends to any blocks contained within the defining one, unless a contained block introduces a different binding for the name.  The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods -- this includes comprehensions and generator expressions since they are implemented using a function scope.  This means that the following will fail::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:dfn:`Область видимости`» определяет видимость имени внутри блока. Если локальная переменная определена в блоке, то ее область видимости включает этот блок. Если это определение происходит в блоке функции, то ее область видимости распространяется на любые блоки, содержащиеся в данном, если только содержащийся блок не вводит своё назначение данному имени. Область видимости имён, определенных в блоке класса ограничивается этим блоком класса; но она не распространяется на блоки кода методов - включая comprehensions и выражения генераторов, поскольку они реализованы с помощью функций (которые создают свою область видимости). Это означает, что следующее приведёт к ошибке :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class A:     a = 42     b = list(a + i for i in range(10))</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>class A:     a = 42     b = list(a + i for i in range(10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a name is used in a code block, it is resolved using the nearest enclosing scope.  The set of all such scopes visible to a code block is called the block's :dfn:`environment`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если имя упоминается в блоке кода, то его значение ищется последовательно переходя от данной области видимости к следующей непосредственно объемлющей её – и так далее – до первой содержащей определение данного имени. Множество всех таких областей видимости, используемых блоком кода - называется :dfn:`окружением` данного блока.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a name is bound in a block, it is a local variable of that block, unless declared as :keyword:`nonlocal`.  If a name is bound at the module level, it is a global variable.  (The variables of the module code block are local and global.)  If a variable is used in a code block but not defined there, it is a :dfn:`free variable`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если имя было назначено в блоке , то оно является локальной переменной этого блока, если не объявлено явно как не локальное – :keyword:`nonlocal` . Если имя назначено на уровне модуля - оно является глобальной переменной. (Переменные в блоке кода модуля являются с разных точек зрения и локальными и глобальными.) Если переменная используется в блоке кода но не определена непосредственно в нём (но определена в окружении), то она является “:dfn:`свободной переменной`” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a name is not found at all, a :exc:`NameError` exception is raised.  If the name refers to a local variable that has not been bound, a :exc:`UnboundLocalError` exception is raised.  :exc:`UnboundLocalError` is a subclass of :exc:`NameError`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда имя вообще не найдено - вызывается исключение «:exc:`NameError`» . Если это имя указывает на локальную переменную, которая ещё не была связана - вызывается исключение «:exc:`UnboundLocalError`» , которое является подклассом для «:exc:`NameError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following constructs bind names: formal parameters to functions, :keyword:`import` statements, class and function definitions (these bind the class or function name in the defining block), and targets that are identifiers if occurring in an assignment, :keyword:`for` loop header, or after :keyword:`as` in a :keyword:`with` statement or :keyword.`except` clause. The :keyword:`import` statement of the form ``from ... import *`` binds all names defined in the imported module, except those beginning with an underscore.  This form may only be used at the module level.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие конструкции назначают имена: формальные параметры функции, инструкция «:keyword:`import`» , определения класса и функции (они назначают имя класса или функции внутри определяющего блока) , и цели назначения, которые являются идентификаторами, когда встречаются в операциях назначения, заголовок цикла «:keyword:`for`» или после «:keyword:`as`» в инструкции «:keyword:`with`» или в выражении «:keyword:`except`» . Инструкция «:keyword:`import`» в форме «``from ... import *``» связывает все имена определённые в импортируемом модуле, за исключением начинающихся со знака подчёркивания. Эта форма может быть использована только на уровне модуля.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A target occurring in a :keyword:`del` statement is also considered bound for this purpose (though the actual semantics are to unbind the name).  It is illegal to unbind a name that is referenced by an enclosing scope; the compiler will report a :exc:`SyntaxError`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Цель назначения для инструкции «:keyword:`del`» также считается получившей назначение (хотя в действительности смысл в снятии связи с этого имени) . Не допустимо удалять назначение имени, упоминаемого снаружи данного блока – это приведет к сообщению об ошибке «:exc:`SyntaxError`» на этапе компилирования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each assignment or import statement occurs within a block defined by a class or function definition or at the module level (the top-level code block).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Любое назначение или импорт действует только в пределах блока класса, функции или модуля (он является самым высокоуровневым блоком кода) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a name binding operation occurs anywhere within a code block, all uses of the name within the block are treated as references to the current block.  This can lead to errors when a name is used within a block before it is bound.  This rule is subtle.  Python lacks declarations and allows name binding operations to occur anywhere within a code block.  The local variables of a code block can be determined by scanning the entire text of the block for name binding operations.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если операция связывания имени встречается где-либо внутри блока кода, то все упоминания этого имени внутри этого блока воспринимаются как обращения к текущему блоку. Это может приводить к ошибкам, когда в блоке имя используется до его обьявления. Это тонкое правило. Питон не страдает избытком деклараций и позволяет делать назначения именам в любом месте блока кода. Локальные для блока кода переменные определяются путём сканирования операций связывания имён по всему тексту блока.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the :keyword:`global` statement occurs within a block, all uses of the name specified in the statement refer to the binding of that name in the top-level namespace.  Names are resolved in the top-level namespace by searching the global namespace, i.e. the namespace of the module containing the code block, and the builtins namespace, the namespace of the module :mod:`builtins`.  The global namespace is searched first.  If the name is not found there, the builtins namespace is searched.  The global statement must precede all uses of the name.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если инструкция «:keyword:`global`» встречается внутри блока, то все использования данного имени, определённого в данной инструкции, обращаются к тому, что назначено этому имени в области имён верхнего уровня. Значение имени сначала ищется в глобальной области имён – тоесть в области имён соответствующего модуля, содержащего данный блок кода, и, если не найдено, то затем ищется в области имён «:mod:`builtins`» этого модуля. Инструкция «:keyword:`global`» должна предшествовать всем упоминаниям данного имени.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The builtins namespace associated with the execution of a code block is actually found by looking up the name ``__builtins__`` in its global namespace; this should be a dictionary or a module (in the latter case the module's dictionary is used).  By default, when in the :mod:`__main__` module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any other module, ``__builtins__`` is an alias for the dictionary of the :mod:`builtins` module itself.  ``__builtins__`` can be set to a user-created dictionary to create a weak form of restricted execution.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Встроенная область имён, ассоциирующаяся с данным исполнением кода блока, в действительности ищется под именем «``__builtins__``» в его глобальной области имён – и это должен быть словарь или модуль (в последнем случае используется соответствующий словарь этого модуля) . По умолчанию, для модуля «:mod:`__main__`» – «``__builtins__``» – это встроенный модуль «:mod:`builtins`» , а для любого другого модуля – «``__builtins__``» – это псевдоним непосредственно словаря встроенного модуля «:mod:`builtins`» . «``__builtins__``» может быть словарём, определённым пользователем, чтобы создать слабую форму исполнения с ограничениями.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users should not touch ``__builtins__``; it is strictly an implementation detail.  Users wanting to override values in the builtins namespace should :keyword:`import` the :mod:`builtins` module and modify its attributes appropriately.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пользователи не должны влазить в «``__builtins__``» - его содержание - это исключительно детали реализации. Пользователи, желающие переопределить значения в этом встроенном пространстве имён должны импортировать модуль «:mod:`builtins`» и модифицировать соответственно его атрибуты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The namespace for a module is automatically created the first time a module is imported.  The main module for a script is always called :mod:`__main__`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пространство имён для модуля автоматически создаётся, когда модуль в первый раз импортируется. Главный модуль скрипта всегда называется «:mod:`__main__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The global statement has the same scope as a name binding operation in the same block.  If the nearest enclosing scope for a free variable contains a global statement, the free variable is treated as a global.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`global`» остаётся в силе в тех же рамках, в каких действует связывание имени, произведённое в том же блоке. Если не связанная в данном блоке переменная (“свободная”) упоминается в нём в инструкции «:keyword:`global`» , то эта переменная считается глобальной.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution.  The namespace of the class definition becomes the attribute dictionary of the class.  Names defined at the class scope are not visible in methods.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Описание (код) класса является исполнимым (в момент создания объекта класса) и может упоминать и создавать имена. В этом случае к именам применяются обычные правила интерпретации имён. Область имён самого́ объекта класса становится словарём атрибутов этого класса. Имена определённые в пределах класса не видимы в методах класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interaction with dynamic features</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Взаимодействие с динамическими свойствами</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several cases where Python statements are illegal when used in conjunction with nested scopes that contain free variables.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Есть несколько случаев, в которых инструкции Питона являются недопустимыми при использовании совместно с вложенными блоками, содержащими не связанные там (“свободные”) переменные.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a variable is referenced in an enclosing scope, it is illegal to delete the name.  An error will be reported at compile time.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если переменная упоминается снаружи данного блока, то удалять её имя недопустимо. Это приведет к сообщению об ошибке на этапе компилирования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the wild card form of import --- ``import *`` --- is used in a function and the function contains or is a nested block with free variables, the compiler will raise a :exc:`SyntaxError`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если в функции используется вариант импорта всего - «``import *``» , и эта функция содержит блок или содержится в блоке в котором есть свободная переменная, то компилятор выдаёт ошибку «:exc:`SyntaxError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :func:`eval` and :func:`exec` functions do not have access to the full environment for resolving names.  Names may be resolved in the local and global namespaces of the caller.  Free variables are not resolved in the nearest enclosing namespace, but in the global namespace.  [#]_ The :func:`exec` and :func:`eval` functions have optional arguments to override the global and local namespace.  If only one namespace is specified, it is used for both.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Функции «:func:`eval`» и «:func:`exec`» не имеют доступа ко всему окружению для интерпретации имён. Значения имён могут искаться в локальной и в глобальной областях имён относительно места вызова. Свободные переменные не ищутся в области имён одним уровнем выше, за исключением глобальной. (Это ограничение происходит от того, что код, исполняемый этими инструкциями не доступен во время компиляции данного модуля.) Функции «:func:`eval`» и «:func:`exec`» имеют необязательные аргументы для переопределения глобальной и локальной областей имён. Если задан только один аргумент, то он используется для обеих областей.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exceptions</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исключения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exceptions are a means of breaking out of the normal flow of control of a code block in order to handle errors or other exceptional conditions.  An exception is *raised* at the point where the error is detected; it may be *handled* by the surrounding code block or by any code block that directly or indirectly invoked the code block where the error occurred.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исключения являются средством прерывания нормального хода исполнения кода для обработки ошибок или других исключительных ситуаций. Исключение возникает в месте, где обнаружена ошибка; оно может быть обработано в текущем блоке кода или в любом блоке кода, в котором прямо или косвенно вызван тот блок кода, который вызвал ошибку.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python interpreter raises an exception when it detects a run-time error (such as division by zero).  A Python program can also explicitly raise an exception with the :keyword:`raise` statement. Exception handlers are specified with the :keyword:`try` ... :keyword:`except` statement.  The :keyword:`finally` clause of such a statement can be used to specify cleanup code which does not handle the exception, but is executed whether an exception occurred or not in the preceding code.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Интерпретатор Питона исполняет исключение, когда обнаруживает ошибку исполнения (например деление на ноль) . Программа на Питоне также может явно вызывать исключение инструкцией «:keyword:`raise`» . Обработчики исключений задаются инструкцией «:keyword:`try` ... :keyword:`except`» . Ветвь «:keyword:`finally`» этой инструкции может быть использована для задания кода, который исполняется независимо от того, произошло ли исключение в соответствующем блоке «:keyword:`try` ... :keyword:`except`» ( и которая не является функцией, получающей как аргумент идентификатор ошибки, и не является собственно обработчиком ошибки) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python uses the "termination" model of error handling: an exception handler can find out what happened and continue execution at an outer level, but it cannot repair the cause of the error and retry the failing operation (except by re-entering the offending piece of code from the top).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Питон использует “ограничительную” модель обработки ошибок: обработчик исключения может проанализировать ситуацию и продолжить исполнение за пределами блока «:keyword:`try` ... :keyword:`except`» , но не может исправить причину ошибки и всё-таки выполнить сбойную операцию (не считая того, чтобы вызвать весь проблемный фрагмент с самого начала) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an exception is not handled at all, the interpreter terminates execution of the program, or returns to its interactive main loop.  In either case, it prints a stack backtrace, except when the exception is :exc:`SystemExit`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если для какой-то ошибки вообще не оказалось обработчика - интерпретатор прекращает выполнение данной программы или переходит к новому циклу - в случае интерактивного общения. В любом случае он выдаёт обратную раскрутку стека (“stack backtrace”) , кроме сучая исключения «:exc:`SystemExit`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exceptions are identified by class instances.  The :keyword:`except` clause is selected depending on the class of the instance: it must reference the class of the instance or a base class thereof.  The instance can be received by the handler and can carry additional information about the exceptional condition.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При исключительной ситуации для её обозначения создаётся экземпляр соответствующего класса ошибки. Обработчик (ветвь «:keyword:`except`») вызывается, если в нём указан класс или один из базовых классов произошедшей ошибки. Экземпляр класса ошибки может быть получен обработчиком и может содержать дополнительную информацию о ситуации ошибки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception messages are not part of the Python API.  Their contents may change from one version of Python to the next without warning and should not be relied on by code which will run under multiple versions of the interpreter.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сообщения о исключениях не являются частью API Питона. Их содержание может меняться от одной версии Питона к другой без предупреждения и код, который будет запускаться на разных версиях интерпретатора не должен полагаться на них.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also the description of the :keyword:`try` statement in section :ref:`try` and :keyword:`raise` statement in section :ref:`raise`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Также, смотрите разделы «Инструкция “:ref:`try`” » и «Инструкция “:ref:`raise`” » .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter explains the meaning of the elements of expressions in Python.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Этот раздел разъясняет значение элементов выражений на Питоне.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Syntax Notes:** In this and the following chapters, extended BNF notation will be used to describe syntax, not lexical analysis.  When (one alternative of) a syntax rule has the form</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>**Замечание о синтаксисе:** В этом и следующем разделах расширенная нотация BNF будет использоваться для описания синтаксиса, а не для лексического анализа. Когда (как одна из альтернатив) синтактическое правило имеет форму</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and no semantics are given, the semantics of this form of ``name`` are the same as for ``othername``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>и не даётся дальнейшей расшифровки, то такая формулировка подразумевает, что ``name`` значит то же, что и ``othername`` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arithmetic conversions</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Арифметические преобразования</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a description of an arithmetic operator below uses the phrase "the numeric arguments are converted to a common type," this means that the operator implementation for built-in types works that way:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда далее в описании арифметического оператора используется фраза “числовые аргументы преобразуются к общему типу” - это значит, что реализация операторов для встроенных типов работает следующим образом:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If either argument is a complex number, the other is converted to complex;</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если любой из аргументов является комплексным числом, то другое преобразуется к комплексному;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>otherwise, if either argument is a floating point number, the other is converted to floating point;</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>иначе, если любой из аргументов является числом “с плавающею точкой” , то другое преобразуется к этому типу;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>otherwise, both must be integers and no conversion is necessary.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>иначе – оба числа неизбежно целые, и никакого преобразования не требуется.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Atoms</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Атомы</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Atoms are the most basic elements of expressions.  The simplest atoms are identifiers or literals.  Forms enclosed in parentheses, brackets or braces are also categorized syntactically as atoms.  The syntax for atoms is:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Атомы являются самыми базовыми (наименьшими) элементами выражений. Простейшими атомами являются идентификаторы и непосредственная запись данных (“литералы”) . Формации заключённые в круглые, квадратные или фигурные скобки - тоже синтаксически относятся к атомам. Синтаксис атомов :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifiers (Names)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Идентификаторы (имена)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An identifier occurring as an atom is a name.  See section :ref:`identifiers` for lexical definition and section :ref:`naming` for documentation of naming and binding.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Идентификатор в роли атома является именем. Смотрите лексическое определение в разделе “Идентификаторы и ключевые слова” :ref:`identifiers` , а также документацию по именованию и связыванию в разделе “Именование и связывание” :ref:`naming` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the name is bound to an object, evaluation of the atom yields that object. When a name is not bound, an attempt to evaluate it raises a :exc:`NameError` exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда данное имя назначено обьекту - интерпретация этого атома даёт этот обьект. Когда имя не назначено чему-либо - попытка интерпретировать его вызывает исключение «:exc:`NameError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Private name mangling:** When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a :dfn:`private name` of that class. Private names are transformed to a longer form before code is generated for them.  The transformation inserts the class name in front of the name, with leading underscores removed, and a single underscore inserted in front of the class name.  For example, the identifier ``__spam`` occurring in a class named ``Ham`` will be transformed to ``_Ham__spam``.  This transformation is independent of the syntactical context in which the identifier is used.  If the transformed name is extremely long (longer than 255 characters), implementation defined truncation may happen.  If the class name consists only of underscores, no transformation is done.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Модифицирование локальных (частных) имён : Когда идентификатор, встретившийся в тексте определения класса, начинается с двух или более символов подчёркивания и не оканчивается двумя или более символами подчёркивания – он считается частным именем («:dfn:`private name`») данного класса. Частные имена заменяются на их длинную форму при генерации соответствующего кода. Эти длинные формы образуются добавлением в начале имени класса, у которого удаляются все подчёркивания в начале и ставится одно подчёркивание. Например : идентификатор «``__spam``» в классе «``Ham``» будет преобразован в «``_Ham__spam``» . Это преобразование не зависит от синтаксического контекста, в котором идентификатор был использован. Следует помнить, что в некоторых реализациях Питона может происходить обрезание имён, больших определённой длинны. Имена, состоящие только из подчёркиваний – не модифицируются.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Literals</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Непосредственная запись данных (константы, “литералы”)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python supports string and bytes literals and various numeric literals:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Питон поддерживает явную запись значений (константы) для текстов, байтов и различных типов чисел :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Evaluation of a literal yields an object of the given type (string, bytes, integer, floating point number, complex number) with the given value.  The value may be approximated in the case of floating point and imaginary (complex) literals.  See section :ref:`literals` for details.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Интерпретирование явной записи даёт в результате объект соответствующего типа (текст, байты, целое, с плавающей запятой, комплексное числа) с данным значением. В случае констант дробных и комплексных чисел значение может быть установлено приблизительно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the exception of bytes literals, these all correspond to immutable data types, and hence the object's identity is less important than its value. Multiple evaluations of literals with the same value (either the same occurrence in the program text or a different occurrence) may obtain the same object or a different object with the same value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>За исключением байтов – все они, по сути, соответствуют неизменяемым типам данных, и поэтому контроль идентичности такого объекта менее важен, чем значение объекта. Многократные упоминания явных записей с одинаковым значением (будь то многократный проход одного места программы или в разных местах) могут получать как тот же объект так и другой объект с таким же значением.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parenthesized forms</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Формы в скобках</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A parenthesized form is an optional expression list enclosed in parentheses:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Формы в скобках – это необязательный список выражений, заключённый в скобки :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An empty pair of parentheses yields an empty tuple object.  Since tuples are immutable, the rules for literals apply (i.e., two occurrences of the empty tuple may or may not yield the same object).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пустая пара скобок даёт объект - пустй кортеж. Поскольку кортежи являются неизменяемыми, то к ним применяются правила для констант (тоесть, два упоминания пустых кортежей могут получать как тот же объект так и другой объект с таким же значением) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that tuples are not formed by the parentheses, but rather by use of the comma operator.  The exception is the empty tuple, for which parentheses *are* required --- allowing unparenthesized "nothing" in expressions would cause ambiguities and allow common typos to pass uncaught.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что кортежи образуются не скобками, а использованием оператора запятая. Исключением является пустой кортеж, для которого пустые скобки *обязательны* (без которых могли бы возникать неоднозначности, и опечатки могли бы оставаться незамеченными) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Displays for lists, sets and dictionaries</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Отображения для списков, наборов и словарей</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For constructing a list, a set or a dictionary Python provides special syntax called "displays", each of them in two flavors:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для создания списков, наборов и словарей Питон предоставляет специальный синтаксис, называемый отображения “:term:`display`s” , для каждого в двух вариантах :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>either the container contents are listed explicitly, or</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>либо их содержимое перечисляется явно, либо</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common syntax elements for comprehensions are:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Общий синтаксис “сборок” :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comprehension consists of a single expression followed by at least one :keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` clauses. In this case, the elements of the new container are those that would be produced by considering each of the :keyword:`for` or :keyword:`if` clauses a block, nesting from left to right, and evaluating the expression to produce an element each time the innermost block is reached.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>“Компоновка” состоит из одного выражения, после которого идёт минимум одно ключевое слово «:keyword:`for`» после которого могут быть в любом количестве ключевые слова «:keyword:`for`» или «:keyword:`if`» . В случае, если таковые присутствуют, содержимое группы очередного из них – это то, что получается, если считать каждую группу «:keyword:`for`» или «:keyword:`if`» блоком, вложенным по отношению к тому, что левее, и интерпретировать это выражение, получая очередной элемент каждый раз, дойдя до самого внутреннего блока.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the comprehension is executed in a separate scope, so names assigned to in the target list don't "leak" in the enclosing scope.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что “компоновки” исполняются в отдельной области имён, поэтому имена, которым были назначения в списке приёмников, не “просачиваются” во внешнюю область.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list display is a possibly empty series of expressions enclosed in square brackets:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Отображение списка – это последовательность выражений (может быть пустая), заключённая в квадратные скобки :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list display yields a new list object, the contents being specified by either a list of expressions or a comprehension.  When a comma-separated list of expressions is supplied, its elements are evaluated from left to right and placed into the list object in that order.  When a comprehension is supplied, the list is constructed from the elements resulting from the comprehension.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись списка даёт в результате объект-список, содержание которого определено или перечислением выражений, или конструкцией генерации (компонования) списка (“comprehension”) . В первом варианте, когда дан список выражений, разделённых запятой – его элементы интерпретируются слева направо – и помещаются в объект-список в том же порядке. Во втором варианте, когда дана конструкция компоновки списка – список составляется из элементов, генерируемых этой конструкцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A set display is denoted by curly braces and distinguishable from dictionary displays by the lack of colons separating keys and values:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись множества обозначается фигурными скобками, и признаком, отличающим его от словаря, является отсутствие двоеточий – разделителей ключей и значений :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A set display yields a new mutable set object, the contents being specified by either a sequence of expressions or a comprehension.  When a comma-separated list of expressions is supplied, its elements are evaluated from left to right and added to the set object.  When a comprehension is supplied, the set is constructed from the elements resulting from the comprehension.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись множества даёт в результате изменяемый объект-множество, содержание которого определено или перечислением выражений, или конструкцией генерации (компонования) списков (“comprehension”) . В первом варианте, когда дан список выражений, разделённых запятой – его элементы интерпретируются слева направо – и добавляются к объекту-множеству. Во втором варианте, когда дана конструкция компоновки списков – множество составляется из элементов, генерируемых этой конструкцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An empty set cannot be constructed with ``{}``; this literal constructs an empty dictionary.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пустое множество не может быть создано с помощью обозначения «``{}``» – эта запись создаёт пустой словарь.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dictionary display is a possibly empty series of key/datum pairs enclosed in curly braces:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись словаря – это последовательность (может быть пустая) пар ключ – данные, заключённая в фигурные скобки :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dictionary display yields a new dictionary object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись словаря даёт в результате новый объект-словарь.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a comma-separated sequence of key/datum pairs is given, they are evaluated from left to right to define the entries of the dictionary: each key object is used as a key into the dictionary to store the corresponding datum.  This means that you can specify the same key multiple times in the key/datum list, and the final dictionary's value for that key will be the last one given.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если дана последовательность разделённых запятой пар : ключ - данные, то они интерпретируются с лева направо и множество всех ключей образуют множество имён элементов словаря, а соответствующие им данные становятся значениями этих элементов. При этом : если тот же ключ встречается в этой последовательности несколько раз, то только последнее значение, соответствующее ему, окажется в словаре-результате.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dict comprehension, in contrast to list and set comprehensions, needs two expressions separated with a colon followed by the usual "for" and "if" clauses. When the comprehension is run, the resulting key and value elements are inserted in the new dictionary in the order they are produced.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В конструкции сборки (генерации) словаря, в отличие от таковых для списков и множеств, должно присутствовать два выражения, разделённых двоеточием, за которыми следуют обычные конструкции «:keyword:`for`» и «:keyword:`if`» . При исполнении сборки каждая пара значений в качестве соответственно ключа и его значения вставляется в словарь в порядке генерации.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Restrictions on the types of the key values are listed earlier in section :ref:`types`.  (To summarize, the key type should be :term:`hashable`, which excludes all mutable objects.)  Clashes between duplicate keys are not detected; the last datum (textually rightmost in the display) stored for a given key value prevails.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ограничения того, каким типам могут принадлежать ключи (а не сопоставленные им объекты) – перечислены выше, в разделе “Иерархия стандартных типов” :ref:`types` . (Коротко : ключ должен быть хешируемого (:term:`hashable`) типа, что сразу исключает любые изменяемые типы. ) Коллизии между одинаковыми ключами не детектируются – просто последнее значение (самое правое, по тексту) , сохранённое под данным ключом, заменяет предыдущие значения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generator expressions</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Генераторные выражения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A generator expression is a compact generator notation in parentheses:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Генераторное выражение – это компактная форма записи генераторов в скобках :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A generator expression yields a new generator object.  Its syntax is the same as for comprehensions, except that it is enclosed in parentheses instead of brackets or curly braces.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Генераторное выражение даёт в результате новый объект-генератор. Синтаксис у этого выражения такой же, как и у генератора списка, за исключением того, что оно заключено в круглые скобки вместо квадратных или фигурных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables used in the generator expression are evaluated lazily when the :meth:`__next__` method is called for generator object (in the same fashion as normal generators).  However, the leftmost :keyword:`for` clause is immediately evaluated, so that an error produced by it can be seen before any other possible error in the code that handles the generator expression.  Subsequent :keyword:`for` clauses cannot be evaluated immediately since they may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in range(10) for y in bar(x))``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Переменные, используемые в генераторных выражениях, вычисляются отложенно, во время вызова метода «:meth:`__next__`» у объекта-генератора (так же, как и для обычных генераторов) . Однако, самое левое выражение «:keyword:`for`» вычисляется сразу же – поэтому ошибка в нём проявится раньше, чем в других частях кода, контролируемых данным генераторным выражением. Следующие (в том же генераторном выражении) «:keyword:`for`» – не могут интерпретироваться сразу же, поскольку они могут зависеть от «:keyword:`for`» слева. (Например : «``(x*y for x in range(10) for y in bar(x))``» . )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parentheses can be omitted on calls with only one argument.  See section :ref:`calls` for the detail.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Скобки можно пропустить при вызове функции, у которой один аргумент. (Смотрите раздел :ref:`calls` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`yield` expression is only used when defining a generator function, and can only be used in the body of a function definition.  Using a :keyword:`yield` expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ключевое слово «:keyword:`yield`» используется только для задания генераторной функции и может использоваться только внутри определения функции. Чтобы превратить определение обычной функции в определение генераторной – достаточно использовать в этом определении инструкцию «:keyword:`yield`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended.  The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transfered to the generator's caller.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Всё это делает генераторные функции похожими на со-процедуры (“coroutines”) : они выдают результат многократно, у них более одной точки входа и их исполнение может быть приостановлено. Единственное отличие в том, что генераторная функция не может управлять тем, что должно исполняться, после того, как она приостанавливается – контроль всегда возвращается туда, откуда этот генератор был вызван.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`yield` statement is allowed in the :keyword:`try` clause of a :keyword:`try` ...  :keyword:`finally` construct.  If the generator is not resumed before it is finalized (by reaching a zero reference count or by being garbage collected), the generator-iterator's :meth:`close` method will be called, allowing any pending :keyword:`finally` clauses to execute.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`yield`» допустима в ветви «:keyword:`try`» конструкции «:keyword:`try` ... :keyword:`finally`» . Если данный генератор не был завершён до его “деструкции” (вследствие достижения ноля счётчиком ссылок или действием “сборщика мусора”) , то будет вызван метод «:meth:`close`» данного генератора, что позволяет исполниться незавершённым ветвям «:keyword:`finally`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following generator's methods can be used to control the execution of a generator function:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Генераторная функция для управления её исполнением имеет следующие методы :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starts the execution of a generator function or resumes it at the last executed :keyword:`yield` expression.  When a generator function is resumed with a :meth:`__next__` method, the current :keyword:`yield` expression always evaluates to :const:`None`.  The execution then continues to the next :keyword:`yield` expression, where the generator is suspended again, and the value of the :token:`expression_list` is returned to :meth:`next`'s caller. If the generator exits without yielding another value, a :exc:`StopIteration` exception is raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Начинает исполнение генераторной функции или продолжает его с последней исполненной инструкции «:keyword:`yield`» . Если в результате вызова метода «:meth:`__next__`» генераторная функция продолжает работу, которая была приостановлена вызовом функции «:keyword:`yield`» , то эта «:keyword:`yield`» завершается, выдавая результат «:const:`None`» . Затем исполнение генератора продолжается до следующей инструкции «:keyword:`yield`» , где оно опять приостанавливается, а значение выражения-аргумента инструкции «:keyword:`yield`» возвращается в место вызова функции «:meth:`next`» . Если происходит выход из генератора не по инструкции «:keyword:`yield`» , то вызывается исключение «:exc:`StopIteration`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is normally called implicitly, e.g. by a :keyword:`for` loop, or by the built-in :func:`next` function.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В норме этот метод не вызывается прямо, а, например, косвенно циклом «:keyword:`for`» или встроенной функцией «:func:`next`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resumes the execution and "sends" a value into the generator function.  The ``value`` argument becomes the result of the current :keyword:`yield` expression.  The :meth:`send` method returns the next value yielded by the generator, or raises :exc:`StopIteration` if the generator exits without yielding another value.  When :meth:`send` is called to start the generator, it must be called with :const:`None` as the argument, because there is no :keyword:`yield` expression that could receive the value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Продолжает исполнение генераторной функции от последней исполненной инструкции «:keyword:`yield`» , которая теперь наконец завершается, выдавая в качестве своего результата аргумент ``value`` функции «:meth:`send`» . Затем исполнение генератора продолжается до следующей инструкции «:keyword:`yield`» , где оно опять приостанавливается, а значение выражения-аргумента инструкции «:keyword:`yield`» возвращается в место вызова функции «:meth:`send`» . Если происходит выход из генератора не по инструкции «:keyword:`yield`» , то вызывается исключение «:exc:`StopIteration`» (и возврат в «:meth:`send`» не происходит) . Если функция «:meth:`send`» вызывается для генератора, который ещё не был запущен и приостановлен посредством «:keyword:`yield`» , то она должна вызывается только с аргументом «:const:`None`» (потому, что нет функции «:keyword:`yield`» , ожидающей значение) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises an exception of type ``type`` at the point where generator was paused, and returns the next value yielded by the generator function.  If the generator exits without yielding another value, a :exc:`StopIteration` exception is raised.  If the generator function does not catch the passed-in exception, or raises a different exception, then that exception propagates to the caller.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Приводит к исключению типа «``type``» в том месте генератора, где он был остановлен. Если генератор перехватывает это исключение, то : или функция «:func:`throw`» возвращает следующее значение, выданное генератором, или, если генератор завершается без инструкции «:keyword:`yield`» , то вызывается исключение «:exc:`StopIteration`» . Если же генератор не перехватывает переданное ему исключение, или генерирует какое-либо исключение сам, то происходит возврат к функции «:func:`throw`» с этим исключением.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a simple example that demonstrates the behavior of generators and generator functions::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Простой пример, демонстрирующий поведение объектов-генераторов и генераторных функций :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; def echo(value=None): ...     print("Execution starts when 'next()' is called for the first time.") ...     try: ...         while True: ...             try: ...                 value = (yield value) ...             except Exception as e: ...                 value = e ...     finally: ...         print("Don't forget to clean up when 'close()' is called.") ... &gt;&gt;&gt; generator = echo(1) &gt;&gt;&gt; print(next(generator)) Execution starts when 'next()' is called for the first time. 1 &gt;&gt;&gt; print(next(generator)) None &gt;&gt;&gt; print(generator.send(2)) 2 &gt;&gt;&gt; generator.throw(TypeError, "spam") TypeError('spam',) &gt;&gt;&gt; generator.close() Don't forget to clean up when 'close()' is called.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; def echo(value=None): ...     print("Execution starts when 'next()' is called for the first time.") ...     try: ...         while True: ...             try: ...                 value = (yield value) ...             except Exception as e: ...                 value = e ...     finally: ...         print("Don't forget to clean up when 'close()' is called.") ... &gt;&gt;&gt; generator = echo(1) &gt;&gt;&gt; print(next(generator)) Execution starts when 'next()' is called for the first time. 1 &gt;&gt;&gt; print(next(generator)) None &gt;&gt;&gt; print(generator.send(2)) 2 &gt;&gt;&gt; generator.throw(TypeError, "spam") TypeError('spam',) &gt;&gt;&gt; generator.close() Don't forget to clean up when 'close()' is called.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The proposal for adding generators and the :keyword:`yield` statement to Python.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Предложение по добавлению в Питон генераторов и инструкции «:keyword:`yield`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The proposal to enhance the API and syntax of generators, making them usable as simple coroutines.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Предложение по улучшению API и синтаксиса генераторов, делающему их пригодными для простейшего параллельного программирования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primaries</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Первичные выражения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primaries represent the most tightly bound operations of the language. Their syntax is:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Первичные выражения – это базовые понятия, операции языка, такие как : взятие атрибута, взятие элемента(элементов) по индексу, вызов функции. У них следующий синтаксис :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute references</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обращение к атрибутам</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An attribute reference is a primary followed by a period and a name:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обращение к атрибуту состоит из другого первичного выражения (в том числе атома) после которого идёт точка и пото́м имя (атрибута) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The primary must evaluate to an object of a type that supports attribute references, which most objects do.  This object is then asked to produce the attribute whose name is the identifier (which can be customized by overriding the :meth:`__getattr__` method).  If this attribute is not available, the exception :exc:`AttributeError` is raised.  Otherwise, the type and value of the object produced is determined by the object.  Multiple evaluations of the same attribute reference may yield different objects.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Значением выражения «``primary``» должен быть объект, тип которого поддерживает обращение к атрибутам (таких типов – большинство) . К этим объектам делается запрос выдать атрибут с указанным именем («``identifier``») . Этот процесс может быть настроен переопределением метода «:meth:`__getattr__`» . Тип и значение возвращаемого атрибута задаётся объектом, которому тот принадлежит, причём каждое обращение к атрибуту может выдавать уже́ новый объект. Если этот атрибут недоступен, то вызывается исключение «:exc:`AttributeError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscriptions</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обращение к элементу по индексу</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A subscription selects an item of a sequence (string, tuple or list) or mapping (dictionary) object:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Взятие по индексу выделяет определённый элемент из последовательности (например, из строки, кортежа, списка) или из словаря :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The primary must evaluate to an object that supports subscription, e.g. a list or dictionary.  User-defined objects can support subscription by defining a :meth:`__getitem__` method.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Значением выражения «``primary``» должен быть объект, тип которого поддерживает взятие элемента по индексу. Определённые пользователем объекты тоже могут поддерживать взятие элемента – определив метод «:meth:`__getitem__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For built-in objects, there are two types of objects that support subscription:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Есть два типа встроенных объектов, поддерживающих взятие элемента по индексу :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the primary is a mapping, the expression list must evaluate to an object whose value is one of the keys of the mapping, and the subscription selects the value in the mapping that corresponds to that key.  (The expression list is a tuple except if it has exactly one item.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если «``primary``» является отображением (словарём) , то значением «``expression_list``» должен быть объект, являющийся одним из ключей данного отображения, и тогда извлекается значение, соответствующее данному ключу. «``expression_list``» является кортежем, если только в списке не ровно одно выражение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the primary is a sequence, the expression (list) must evaluate to an integer. If this value is negative, the length of the sequence is added to it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting value must be a nonnegative integer less than the number of items in the sequence, and the subscription selects the item whose index is that value (counting from zero).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если «``primary``» является последовательностью, то значением «``expression_list``» должно быть целое число. Если это число негативное, то к нему прибавляется длина последовательности (таким образом, «``x[-1]``» указывает на последний элемент в «``x``» ) . Результирующее значение должно быть неотрицательным целым меньшим длины данной последовательности. И в качестве результата извлекается элемент, чьим индексом является это значение (учитывая, что элементы номеруются с ноля) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A string's items are characters.  A character is not a separate data type but a string of exactly one character.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Элементами текстовых данных (“строк”) являются символы. Причём символ является не отдельным типом данных, а такою же строкой, но только из одного символа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Slicings</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>“Срезы”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A slicing selects a range of items in a sequence object (e.g., a string, tuple or list).  Slicings may be used as expressions or as targets in assignment or :keyword:`del` statements.  The syntax for a slicing:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Срез выделяет диапазон элементов в объекте-последовательности (например в строке, в кортеже) . Срезы могут использоваться и как выражения (дающие в результате значение) и как цель для назначения или инструкции «:keyword:`del`» . Синтаксис следующий :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is ambiguity in the formal syntax here: anything that looks like an expression list also looks like a slice list, so any subscription can be interpreted as a slicing.  Rather than further complicating the syntax, this is disambiguated by defining that in this case the interpretation as a subscription takes priority over the interpretation as a slicing (this is the case if the slice list contains no proper slice).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В этом формальном синтаксисе есть неоднозначность : что-либо, выглядящее как список выражений – одновременно выглядит как список срезов. Из-за этого любое взятие по индексу может быть интерпретировано как срез. Вместо дополнительного усложнения синтаксиса – двусмысленность снята тем, что в такой ситуации интерпретирование как взятие по индексу приоритетнее, чем как срез (именно это и происходит если в списке среза нет правильного среза) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calls</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызовы</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A call calls a callable object (e.g., a function) with a possibly empty series of arguments:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При вызове вызывается (исполняется) вызываемый (исполнимый) объект (например функция) , которому передаётся список параметров (может быть пустым) :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A trailing comma may be present after the positional and keyword arguments but does not affect the semantics.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>После позиционных и именованных аргументов может стоять конечная (лишняя) запятая – она не имеет никакого значения и на смысл не влияет.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The primary must evaluate to a callable object (user-defined functions, built-in functions, methods of built-in objects, class objects, methods of class instances, and all objects having a :meth:`__call__` method are callable).  All argument expressions are evaluated before the call is attempted.  Please refer to section :ref:`function` for the syntax of formal parameter lists.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Значением «``primary``» должен быть вызываемый объект (определяемая пользователем или встроенная функция, метод встроенного объекта, объект-класс, метод экземпляра класса или любой объект с методом «:meth:`__call__`» ) . Все выражения-аргументы вычисляются прежде, чем делается попытка вызова. Синтаксис списка “формальных” параметров в определении функции смотрите в разделе «Функции» :ref:`function` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If keyword arguments are present, they are first converted to positional arguments, as follows.  First, a list of unfilled slots is created for the formal parameters.  If there are N positional arguments, they are placed in the first N slots.  Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on).  If the slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, the value of the argument is placed in the slot, filling it (even if the expression is ``None``, it fills the slot).  When all arguments have been processed, the slots that are still unfilled are filled with the corresponding default value from the function definition.  (Default values are calculated, once, when the function is defined; thus, a mutable object such as a list or dictionary used as default value will be shared by all calls that don't specify an argument value for the corresponding slot; this should usually be avoided.)  If there are any unfilled slots for which no default value is specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of filled slots is used as the argument list for the call.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если даны именованные аргументы, то они сначала преобразуются в позиционные следующим образом. Сначала для “формальных” параметров создаётся список незаполненных мест. Если дано *N* позиционных аргументов, то они помещаются в *N* первых из этих мест. Далее для каждого именованного аргумента определяется, каким по счёту он идёт в формальных параметрах определения функции – и в такое же по счёту место помещается его значение (даже если это значение ««:const:`None`»» ) . Если это место оказывается уже́ занятым, то вызывается исключение «:exc:`TypeError`» . Когда все аргументы обработаны – места, оставшиеся необработанными заполняются соответствующими значениями по-умолчанию из определения функции. (Значения по-умолчанию вычисляются один раз – когда выполняется определение функции – таким образом, изменяемый объект, например список или словарь, использованный как значение по-умолчанию, будет сохраняться между вызовами функции, и его предыдущее значение будет доступно, если в него не будет передано значение в соответствующем аргументе при вызове. ) Если останутся незаполненными места, для которых нет значений по-умолчанию, то вызывается исключение «:exc:`TypeError`» . Заполненный таким образом список используется как список аргументов функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An implementation may provide built-in functions whose positional parameters do not have names, even if they are 'named' for the purpose of documentation, and which therefore cannot be supplied by keyword.  In CPython, this is the case for functions implemented in C that use :cfunc:`PyArg_ParseTuple` to parse their arguments.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В какой-либо реализации могут быть встроенные функции, чьи позиционные параметры не имеют имён (несмотря на то, что в ихней документации для удобства используются некие “имена” ) и, таким образом, эти параметры не могут быть переданы как именованные аргументы. Как пример – функции, реализованные на “C” с использованием «:cfunc:`PyArg_ParseTuple`» для разбора аргументов .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are more positional arguments than there are formal parameter slots, a :exc:`TypeError` exception is raised, unless a formal parameter using the syntax ``*identifier`` is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если дано больше аргументов, чем параметров в определении, то вызывается исключение «:exc:`TypeError`» , если только в определении не присутствует параметр с синтаксисом «``*identifier``» – в этом случае этот параметр получает кортеж, содержащий лишние аргументы (или пустой кортеж, если нет таковых) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any keyword argument does not correspond to a formal parameter name, a :exc:`TypeError` exception is raised, unless a formal parameter using the syntax ``**identifier`` is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если какой-либо именованный аргумент не соответствует имени параметра в определении, то вызывается исключение «:exc:`TypeError`» , если только в определении не присутствует параметр с синтаксисом «``**identifier``» – в этом случае этот параметр получает словарь (или пустой словарь, если нет лишних), содержащий лишние именованные аргументы, чьи имена становятся ключами – и они получают соответствующие значения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the syntax ``*expression`` appears in the function call, ``expression`` must evaluate to a sequence.  Elements from this sequence are treated as if they were additional positional arguments; if there are positional arguments *x1*,..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, *y1*, ..., *yM*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если в вызове функции встречается синтаксис «``*expression``» , то значением «``expression``» должна быть последовательность. Элементы из этой последовательности извлекаются и воспринимаются как дополнительные позиционные аргументы – тоесть, если в вызове даны позиционные аргументы *x1*,..., *xN* и «``expression``» даёт элементы *y1*, ..., *yM* , то это эквивалентно вызову с *M*+*N* штуками аргументов *x1*, ..., *xN*, *y1*, ..., *yM* .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A consequence of this is that although the ``*expression`` syntax may appear *after* some keyword arguments, it is processed *before* the keyword arguments (and the ``**expression`` argument, if any -- see below).  So::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следствием из этого является то, что, хотя «``*expression``» может идти *после* некоторых именованных аргументов, «``*expression``» обрабатывается *раньше* них (и раньше аргумента «``**expression``» ) . Таким образом :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; def f(a, b): ...  print(a, b) ... &gt;&gt;&gt; f(b=1, *(2,)) 2 1 &gt;&gt;&gt; f(a=1, *(2,)) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in ? TypeError: f() got multiple values for keyword argument 'a' &gt;&gt;&gt; f(1, *(2,)) 1 2</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; def f(a, b): ...  print(a, b) ... &gt;&gt;&gt; f(b=1, *(2,)) 2 1 &gt;&gt;&gt; f(a=1, *(2,)) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in ? TypeError: f() got multiple values for keyword argument 'a' &gt;&gt;&gt; f(1, *(2,)) 1 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is unusual for both keyword arguments and the ``*expression`` syntax to be used in the same call, so in practice this confusion does not arise.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Использование в вызове одновременно именованных аргументов и синтаксиса «``*expression``» является редким – только поэтому на практике редко возникают и соответствующие недоразумения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the syntax ``**expression`` appears in the function call, ``expression`` must evaluate to a mapping, the contents of which are treated as additional keyword arguments.  In the case of a keyword appearing in both ``expression`` and as an explicit keyword argument, a :exc:`TypeError` exception is raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если в вызове функции встречается синтаксис «``**expression``» , то значением «``expression``» должно быть отображение (словарь) . Элементы из этого отображения извлекаются и воспринимаются как дополнительные именованные аргументы. Если некий ключ (имя) присутствует и в «``expression``» и как явный именованный аргумент, то вызывается исключение «:exc:`TypeError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Formal parameters using the syntax ``*identifier`` or ``**identifier`` cannot be used as positional argument slots or as keyword argument names.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Параметры в определении, использующие синтаксис «``*identifier``» или «``**identifier``» , не могут быть использованы как позиционные получатели (как места́) или как имена именованных аргументов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A call always returns some value, possibly ``None``, unless it raises an exception.  How this value is computed depends on the type of the callable object.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызов всегда возвращает какое-либо значение (в частности «:const:`None`» ) – если только этот вызов не привёл к исключению. То, каким способом это значение вычисляется – зависит от типа вызываемого объекта.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code block for the function is executed, passing it the argument list.  The first thing the code block will do is bind the formal parameters to the arguments; this is described in section :ref:`function`.  When the code block executes a :keyword:`return` statement, this specifies the return value of the function call.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Функции передаётся список аргументов, и её блок кода исполняется. Первое, что происходит в блоке кода – это связывание имён “формальных” параметров с предоставленными аргументами (подробнее в разделе «Определение функций» :ref:`function` ) . Если в блоке кода исполняется инструкция «:keyword:`return`» , то она задаёт возвращаемое функцией значение – иначе, по-умолчанию, – возвращается «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is up to the interpreter; see :ref:`built-in-funcs` for the descriptions of built-in functions and methods.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Результат зависит от интерпретатора. Смотрите “Встроенные функции” :ref:`built-in-funcs`  .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A new instance of that class is returned.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Возвращается новый экземпляр этого класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding user-defined function is called, with an argument list that is one longer than the argument list of the call: the instance becomes the first argument.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Вызывается соответствующая пользовательская функция, к списку аргументов которой в начале подставляется дополнительный аргумент – соответствующий экземпляр (у которого вызывается метод) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class must define a :meth:`__call__` method; the effect is then the same as if that method was called.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В классе должен быть определён метод «:meth:`__call__`» (одноимённый метод определённый в самом экземпляре – игнорируется при простом вызове экземпляра ) , в остальном – аналогично вызову *метода* экземпляра класса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The power operator</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор возведения в степень</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The power operator binds more tightly than unary operators on its left; it binds less tightly than unary operators on its right.  The syntax is:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор степени имеет бо́льший приоритет, чем однооперандные операторы непосредственно слева, но меньший, чем однооперандные операторы непосредственно справа. Его синтаксис :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, in an unparenthesized sequence of power and unary operators, the operators are evaluated from right to left (this does not constrain the evaluation order for the operands): ``-1**2`` results in ``-1``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Таким образом в последовательности без кавычек из степени и однооперандных операторов вычисление выполняется с права налево (это не влияет на порядок действий вутри выражений операндов) : «``-1**2``» даёт результат «``-1``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The power operator has the same semantics as the built-in :func:`pow` function, when called with two arguments: it yields its left argument raised to the power of its right argument.  The numeric arguments are first converted to a common type, and the result is of that type.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор степени имеет тот же смысл, что и встроенная функция «:func:`pow`» – если вызывается с двумя аргументами : левый аргумент возводится в степень правого. Числовые аргументы сначала преобразуются к общему типу, и результат будет этого же типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For int operands, the result has the same type as the operands unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для целочисленных операндов результат тоже будет целым, если только второй операнд не негативный – в таком случае все аргументы преобразуются в дробные, и результат тоже будет дробный. Например : «``10**2``» даёт «``100``» , но «``10**-2``» даёт «``0.01``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. Raising a negative number to a fractional power results in a :class:`complex` number. (In earlier versions it raised a :exc:`ValueError`.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Возведение «``0.0``» в негативную степень вызывает исключение «:exc:`ZeroDivisionError`» . Возведение негативного числа в дробную степень даёт комплексное число (в прошлых версиях вызывалось исключение «:exc:`ValueError`» ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unary arithmetic and bitwise operations</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Однооперандные арифметические и побитовые операци</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All unary arithmetic and bitwise operations have the same priority:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Все однооперандные арифметические и побитовые операци имеют одинаковый приоритет :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The unary ``-`` (minus) operator yields the negation of its numeric argument.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«``-``» (минус) негативирует (умножает на «``-1``» ) свой числовой аргумент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The unary ``+`` (plus) operator yields its numeric argument unchanged.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«``+``» (плюс) не изменяет свой числовой аргумент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The unary ``~`` (invert) operator yields the bitwise inversion of its integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  It only applies to integral numbers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``~``» побитово инвертирует свой целочисленный аргумент, и для аргумента «``x``» определяется как «``-(x+1)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In all three cases, if the argument does not have the proper type, a :exc:`TypeError` exception is raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Во всех трёх случаях – если аргумент не требуемого типа, то вызывается исключение «:exc:`TypeError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Binary arithmetic operations</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Двухоперандные арифметические операции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The binary arithmetic operations have the conventional priority levels.  Note that some of these operations also apply to certain non-numeric types.  Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>У двухоперандных арифметических операций уровни приоритета соответствуют общепринятым. Заметьте, что некоторые из них также применяются для нечисловых типов. Кроме операции степени – среди них есть только два уровня приоритета : выше – для произведения и деления (одинаковый) , и ниже – для суммы и вычитания (одинаковый) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``*`` (multiplication) operator yields the product of its arguments.  The arguments must either both be numbers, or one argument must be an integer and the other must be a sequence. In the former case, the numbers are converted to a common type and then multiplied together.  In the latter case, sequence repetition is performed; a negative repetition factor yields an empty sequence.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``*``» (умножение) даёт произведение своих операндов. Операнды должны быть или оба чи́сла, или один – число, а другой последовательность. В первом случае – числа преобразуются к общему типу и перемножаются. Во втором – последовательность повторяется количество раз равное другому операнду, чьё отрицательное значение означает ноль повторений (пустая последовательность) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``/`` (division) and ``//`` (floor division) operators yield the quotient of their arguments.  The numeric arguments are first converted to a common type. Integer division yields a float, while floor division of integers results in an integer; the result is that of mathematical division with the 'floor' function applied to the result.  Division by zero raises the :exc:`ZeroDivisionError` exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы «``/``» (деление) и «``//``» (деление нацело) дают частное своих операндов. Операнды должны быть оба числа и они преобразуются к общему типу. Деление даёт в результате дробное число. Деление нацело даёт в результате целое число, получающееся из соответствующего дробного результата округлением функцией «:func:`floor`» . Деление на ноль вызывает исключение «:exc:`ZeroDivisionError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``%`` (modulo) operator yields the remainder from the division of the first argument by the second.  The numeric arguments are first converted to a common type.  A zero right argument raises the :exc:`ZeroDivisionError` exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo operator always yields a result with the same sign as its second operand (or zero); the absolute value of the result is strictly smaller than the absolute value of the second operand [#]_.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``%``» (остаток деления) даёт остаток деления первого операнда на второй. Операнды должны быть оба числами и они преобразуются к общему типу. При нолевом втором аргументе вызывается исключение «:exc:`ZeroDivisionError`» . Аргументы могут быть дробными числами, например, ``3.14%0.7`` равно ``0.34`` (поскольку ``3.14`` равно ``4*0.7 + 0.34`` ) . Результат всегда имеет знак, равный знаку делителя или же равен нолю. Модуль результата строго меньше модуля делителя. [#]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//y, x%y)``. [#]_.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы деления нацело и остатка связаны следующим равенством : «``x == (x//y)*y + (x%y)``» . Также они связаны со встроенной функцией «:func:`divmod`» : «``divmod(x, y) == (x//y, x%y)``» . [#]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to performing the modulo operation on numbers, the ``%`` operator is also overloaded by string objects to perform old-style string formatting (also known as interpolation).  The syntax for string formatting is described in the Python Library Reference, section :ref:`old-string-formatting`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В строковых объектах оператор «``%``» переопределён и используется для старого стиля форматирования текста (так называемые “interpolation” ) . Синтаксис такого форматирования определён в “Python Library Reference” раздел :ref:`old-string-formatting` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The floor division operator, the modulo operator, and the :func:`divmod` function are not defined for complex numbers.  Instead, convert to a floating point number using the :func:`abs` function if appropriate.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы деления нацело, взятие остатка и функция «:func:`divmod`» не определены для комплексных чисел – требуется явное преобразование в дробные функцией «:func:`abs`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``+`` (addition) operator yields the sum of its arguments.  The arguments must either both be numbers or both sequences of the same type.  In the former case, the numbers are converted to a common type and then added together.  In the latter case, the sequences are concatenated.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``+``» (сложение) даёт сумму своих аргументов. Аргументы должны быть или оба числами, или оба последовательностями одинакового типа. В первом случае – числа преобразуются к общему типу и складываются. Во втором – последовательности соединяются .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``-`` (subtraction) operator yields the difference of its arguments.  The numeric arguments are first converted to a common type.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``-``» (вычитание) даёт разность своих аргументов. Числовые аргументы сначала преобразуются к общему типу.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shifting operations</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операции сдвига</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The shifting operations have lower priority than the arithmetic operations:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операции сдвига имеют приоритет меньший, чем у арифметических операций :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These operators accept integers as arguments.  They shift the first argument to the left or right by the number of bits given by the second argument.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Аргументы должны быть целыми числами. Затем производится сдвиг двоичного представления первого аргумента соответственно влево или вправо на количество бит равное второму аргументу.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A right shift by *n* bits is defined as division by ``pow(2,n)``.  A left shift by *n* bits is defined as multiplication with ``pow(2,n)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сдвиг вправо определяется как целая часть от деления на 2 в степени второго аргумента («``a&gt;&gt;b``» = «``a / pow(2, b)``») . Сдвиг влево определяется как умножение на 2 в степени второго аргумента («``a&lt;&lt;b``» = «``a * pow(2, b)``») .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Binary bitwise operations</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Двоичные побитовые операции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each of the three bitwise operations has a different priority level:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Все эти три операции имеют разный приоритет :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``&amp;`` operator yields the bitwise AND of its arguments, which must be integers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``&amp;``» производит побитовую операцию “И” (“AND”) над целочисленными аргументами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, which must be integers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``^``» производит побитовую операцию “исключающее ИЛИ” (“XOR”) над целочисленными аргументами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which must be integers.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «``|``» производит побитовую операцию “ИЛИ” (“OR”) над целочисленными аргументами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comparisons</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сравнения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike C, all comparison operations in Python have the same priority, which is lower than that of any arithmetic, shifting or bitwise operation.  Also unlike C, expressions like ``a &lt; b &lt; c`` have the interpretation that is conventional in mathematics:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В отличие от “C” – все операции сравнения в Питоне имеют одинаковый приоритет, который ниже, чем у любых арифметических, сдвиговых или побитовых операций. Также, в отличие от “C” , выражения типа «``a &lt; b &lt; c``» интерпретируются, как это принято в математике.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comparisons yield boolean values: ``True`` or ``False``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сравнения дают в результате булевы значения : «:const:`True`» или «:const:`False`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comparisons can be chained arbitrarily, e.g., ``x &lt; y &lt;= z`` is equivalent to ``x &lt; y and y &lt;= z``, except that ``y`` is evaluated only once (but in both cases ``z`` is not evaluated at all when ``x &lt; y`` is found to be false).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сравнения могут соединяться в произвольные цепочки, например : «``x &lt; y &lt;= z``» эквивалентно «``x &lt; y and y &lt;= z``» , за исключением того, что «``y``» вычисляется только один раз (но в обоих вариантах «``z``» вообще не вычисляется, если «``x &lt; y``» не верно) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, *op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that each expression is evaluated at most once.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Общее правило : если *a*, *b*, *c*, ..., *y*, *z* – выражения, и *op1*, *op2*, ..., *opN* – операторы сравнения, то «``a op1 b op2 c ... y opN z``» является эквивалентом «``a op1 b and b op2 c and ... y opN z``» , за исключением того, что каждое выражение вычисляется только один раз.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* and *c*, so that, e.g., ``x &lt; y &gt; z`` is perfectly legal (though perhaps not pretty).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что «``a op1 b op2 c``» не подразумевает никаких сравнений «``a``» и «``c``» , так что, например, «``x &lt; y &gt; z``» абсолютно приемлемо (хотя и не очень красиво) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operators ``&lt;``, ``&gt;``, ``==``, ``&gt;=``, ``&lt;=``, and ``!=`` compare the values of two objects.  The objects need not have the same type. If both are numbers, they are converted to a common type.  Otherwise, the ``==`` and ``!=`` operators *always* consider objects of different types to be unequal, while the ``&lt;``, ``&gt;``, ``&gt;=`` and ``&lt;=`` operators raise a :exc:`TypeError` when comparing objects of different types that do not implement these operators for the given pair of types.  You can control comparison behavior of objects of non-built-in types by defining rich comparison methods like :meth:`__gt__`, described in section :ref:`customization`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы «``&lt;``» , «``&gt;``» , «``==``» , «``&gt;=``» , «``&lt;=``» и «``!=``» сравнивают значения двух объектов. Эти объекты не обязаны иметь одинаковый тип. Если оба являются числами, то они преобразуются к общему типу. Если не числа, то операторы «``==``» и «``!=``» всегда считают объекты отличающихся типов неравными, а операторы «``&lt;``» , «``&gt;``» , «``&gt;=``» и «``&lt;=``» вызывают «:exc:`TypeError`» для отличающихся типов, не имеющих реализации соответствующих операторов для данной пары типов. Вы можете контролировать поведение сравнения для объектов не встроенных типов, определяя методы расширенного сравнения типа «:meth:`__gt__`» , как описано в разделе “Основные средства настройки классов” :ref:`customization` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comparison of objects of the same type depends on the type:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сравнение объектов одинакового типа зависит от типа :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers are compared arithmetically.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Числа сравниваются арифметически.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values :const:`float('NaN')` and :const:`Decimal('NaN')` are special. The are identical to themselves, ``x is x`` but are not equal to themselves, ``x != x``.  Additionally, comparing any value to a not-a-number value will return ``False``.  For example, both ``3 &lt; float('NaN')`` and ``float('NaN') &lt; 3`` will return ``False``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Значения «:const:`float('NaN')`» и «:const:`Decimal('NaN')`» являются особыми. Они идентичны самим себе «``x is x``» , но не равны самим себе «``x != x``» . Более того, сравнение любого значения с “Not-a-Number” возвращает «:const:`False`» . Например : и «``3 &lt; float('NaN')``» и «``float('NaN') &lt; 3``» вернут «:const:`False`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bytes objects are compared lexicographically using the numeric values of their elements.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:term:`“Байты”&lt;bytes&gt;`» сравниваются поэлементно до первого несовпадения (лексикографически) , с использованием числовых значений их элементов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings are compared lexicographically using the numeric equivalents (the result of the built-in function :func:`ord`) of their characters. [#]_ String and bytes object can't be compared!</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>“Строки” сравниваются посимвольно до первого несовпадения (лексикографически) , с использованием числовых эквивалентов (возвращаемых встроенной функцией «:func:`ord`» ) для их элементов-симвлов. [#]_ “Строки” нельзя сравнивать с байтами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tuples and lists are compared lexicographically using comparison of corresponding elements.  This means that to compare equal, each element must compare equal and the two sequences must be of the same type and have the same length.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Кортежи и списки сравниваются поэлементно до первого несовпадения (лексикографически) . Это подразумевает, что для равенства – все соответствующие элементы должны быть равны и сами последовательности должны быть одинакового типа и одинаковой длины.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not equal, the sequences are ordered the same as their first differing elements.  For example, ``[1,2,x] &lt;= [1,2,y]`` has the same value as ``x &lt;= y``.  If the corresponding element does not exist, the shorter sequence is ordered first (for example, ``[1,2] &lt; [1,2,3]``).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если последовательности не равны, то они упорядочиваются по первым несовпадающим элементам. Например, «``[1,2,x] &lt;= [1,2,y]``» имеет тот же результат, что и «``x &lt;= y``» . Если соответствующий элемент отсутствует, то более короткая последовательность меньше (идёт раньше) , например : «``[1,2]``» &lt; «``[1,2,3]``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mappings (dictionaries) compare equal if and only if their sorted ``(key, value)`` lists compare equal. [#]_ Outcomes other than equality are resolved consistently, but are not otherwise defined. [#]_</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Отображения (словари) равны только если равны их отсортированные по ключу списки пар ключ-значение (в данной реализации такое сравнение производится эффективно – без реального конструирования списков или сортирования). [#]_ Другие результаты сравнения, кроме равенства – решаются соответственно, (?) но не определены иначе. [#]_ Предыдущие версии Питона использовали сравнение таких отсортированных списков (из пар ключ-значение) по первому несовпадающему элементу (тоесть, “лексикографически” ) , но это было слишком затратно для наиболее распространенного случая – проверки только на равенство. Ещё более ранние версии Питона сравнивали словари только по факту того один и тот же ли это объект, но это приводило к неожиданностям – поскольку люди ожидали иметь возможность проверять пуст ли словарь, сравнивая его с «``{}``» (новым пустым словарём) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sets and frozensets define comparison operators to mean subset and superset tests.  Those relations do not define total orderings (the two sets ``{1,2}`` and {2,3} are not equal, nor subsets of one another, nor supersets of one another).  Accordingly, sets are not appropriate arguments for functions which depend on total ordering.  For example, :func:`min`, :func:`max`, and :func:`sorted` produce undefined results given a list of sets as inputs.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Множества (“sets”) и фиксированные множества (“frozensets”) определяют операторы сравнения для реализации понятий подмножества и надмножества. Эти отношения не подразумевают определения полного упорядочивания (например, множества «``{1,2}``» и «``{2,3}``» ни равны, ни подмножество или надмножество одно для другого) . Соответственно – множества не являются годными аргументами для функций, результат которых зависит от полного упорядочивания. Например : «:func:`min`» , «:func:`max`» и «:func:`sorted`» выдают неопределённый результат, получив список множеств.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most other objects of built-in types compare unequal unless they are the same object; the choice whether one object is considered smaller or larger than another one is made arbitrarily but consistently within one execution of a program.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Большинство других объектов встроенных типов считаются неравными, за исключением случая, когда это оказывается один и тот же объект. Выбор того, считается ли один объект меньше другого, делается произвольно – но одинаково в течение всего исполнения программы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comparison of objects of the differing types depends on whether either of the types provide explicit support for the comparison.  Most numeric types can be compared with one another, but comparisons of :class:`float` and :class:`Decimal` are not supported to avoid the inevitable confusion arising from representation issues such as ``float('1.1')`` being inexactly represented and therefore not exactly equal to ``Decimal('1.1')`` which is.  When cross-type comparison is not supported, the comparison method returns ``NotImplemented``.  This can create the illusion of non-transitivity between supported cross-type comparisons and unsupported comparisons.  For example, ``Decimal(2) == 2`` and `2 == float(2)`` but ``Decimal(2) != float(2)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сравнение объектов различающихся типов зависит от того, предоставляет ли тип кого-либо из них явную поддержку для такого сравнения. Большинство числовых типов можно сравнивать друг с другом, но сравнение «:class:`float`» с «:class:`Decimal`» не поддерживается – для избежания неустранимой неясности, происходящей из особенностей представления (реализации) , например «``float('1.1')``» , чьё машинное представление является приближённым и, как следствие, является не строго равным «``Decimal('1.1')``» , чьё машинное представление строго соответствует записи. Когда межтиповое сравнение не поддерживается – возвращается «``NotImplemented``» . Это может создать иллюзию нетранзитивности между поддерживаемыми и неподдерживаемыми межтиповыми сравнениями. Например, «``Decimal(2) == 2``» и «``2 == float(2)``» , но «``Decimal(2) != float(2)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x in s`` evaluates to true if *x* is a member of *s*, and false otherwise.  ``x not in s`` returns the negation of ``x in s``.  All built-in sequences and set types support this as well as dictionary, for which :keyword:`in` tests whether a the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы «:keyword:`in`» и «:keyword:`not in`» проверяют на вхождение (членство) . «``x in s``» даёт результат «:const:`True`» если «``x``» является членом «``s``» – в остальных случаях – результат «:const:`False`» . Все встроенные последовательности и множества поддерживают эти инструкции, при этом для словаря подразумевается поиск во множестве его ключей. Для контейнерных типов – таких как список, кортеж, множество, фиксированное множество, словарь или «``collections.deque``» – выражение «``x in y``» является эквивалентом «``any(x is e or x == e for e in y)``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the string and bytes types, ``x in y`` is true if and only if *x* is a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty strings are always considered to be a substring of any other string, so ``"" in "abc"`` will return ``True``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для текстовых и байтовых типов «``x in y``» даёт результат «:const:`True`» только если «``x``» является подстрокой для «``y``» . Эквивалентом является «``y.find(x) != -1``» . Пустой текст считается подстрокой для любого текста, тоесть : «``"" in "abc"``» вернёт «:const:`True`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For user-defined classes which define the :meth:`__contains__` method, ``x in y`` is true if and only if ``y.__contains__(x)`` is true.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для пользовательских классов, в которых определён метод «:meth:`__contains__`» , результат операции «in» определяется исключительно этим методом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For user-defined classes which do not define :meth:`__contains__` but do define :meth:`__iter__`, ``x in y`` is true if some value ``z`` with ``x == z`` is produced while iterating over ``y``.  If an exception is raised during the iteration, it is as if :keyword:`in` raised that exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для пользовательских классов, в которых не определён метод «:meth:`__contains__`» , но определён метод «:meth:`__iter__`» , операция «``x in y``» даёт результат «:const:`True`» , если при переборе элементов «``y``» находится хотя бы одно такое значение «``z``» , что «``x == z``» . Если при этом переборе происходит исключение, то эффект таков, как если бы оно произошло в самой операции «:keyword:`in`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the old-style iteration protocol is tried: if a class defines :meth:`__getitem__`, ``x in y`` is true if and only if there is a non-negative integer index *i* such that ``x == y[i]``, and all lower integer indices do not raise :exc:`IndexError` exception.  (If any other exception is raised, it is as if :keyword:`in` raised that exception).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>И, наконец, делается попытка использовать протокол перебора в старом стиле : если в классе определён «:meth:`__getitem__`» , то «``x in y``» даёт в результате «:const:`True`» только если есть такое неотрицательный целый индекс «``i``» , что «``x == y[i]``» и все меньшие индексы не вызывают исключение «:exc:`IndexError`» . Если происходит исключение любого другого типа, то эффект таков, как если бы оно произошло в самой операции «:keyword:`in`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operator :keyword:`not in` is defined to have the inverse true value of :keyword:`in`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «:keyword:`not in`» определён как отрицание логического результата «:keyword:`in`» (над теми же операндами) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operators :keyword:`is` and :keyword:`is not` test for object identity: ``x is y`` is true if and only if *x* and *y* are the same object.  ``x is not y`` yields the inverse truth value. [#]_</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы «:keyword:`is`» и «:keyword:`is not`» проверяют на идентичность объекта : «``x is y``» даёт в результате «:const:`True`» только если «``x``» и «``y``» являются одним и тем же объектом. «``is not y``» даёт отрицание логического результата оператора «``is``» (над теми же операндами) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boolean operations</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Логические операции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: ``False``, ``None``, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets).  All other values are interpreted as true.  User-defined objects can customize their truth value by providing a :meth:`__bool__` method.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В контексте логических операций а также в выражениях-параметрах инструкций управления потоком программы (ветвления, циклы) – следующие значения интерпретируются как логическая ложь : «:const:`False`» , «:const:`None`» , число ноль любого типа, пустые строки, пустые контейнеры. Все остальные значения интерпретируются как логическая истина. Определённые пользователем объекты могут задать значение истинности определив метод «:meth:`__bool__`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operator :keyword:`not` yields ``True`` if its argument is false, ``False`` otherwise.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор «:keyword:`not`» даёт в результате «:const:`True`» , если его аргумент является ложью, иначе – даёт в результате «:const:`False`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The expression ``x and y`` first evaluates *x*; if *x* is false, its value is returned; otherwise, *y* is evaluated and the resulting value is returned.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для выражения «``x and y``» сначала вычисляется значение выражения «``x``» – если это значение ложно, то возвращается это значение (которое было до приведения к логическому типу) , иначе дальше вычисляется значение выражения «``y``» и оно возвращается (без приведения к логическому типу) в качестве значения операции «``and``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The expression ``x or y`` first evaluates *x*; if *x* is true, its value is returned; otherwise, *y* is evaluated and the resulting value is returned.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для выражения «``x or y``» сначала вычисляется значение выражения «``x``» – если это значение истинно, то возвращается это значение (которое было до приведения к логическому типу) , иначе дальше вычисляется значение выражения «``y``» и оно возвращается (без приведения к логическому типу) в качестве значения операции «``or``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and type they return to ``False`` and ``True``, but rather return the last evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string that should be replaced by a default value if it is empty, the expression ``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to invent a value anyway, it does not bother to return a value of the same type as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что ни «:keyword:`and`» , ни «:keyword:`or`» не ограничивают значение и тип результата значениями «:const:`False`» и «:const:`True`» , а просто возвращают в неизменном виде значение операнда, взятого последним. Это иногда может быть полезно – например, если «``s``» – текст, который, если он пустой, должен быть заменён на текст по-умолчанию, то выражение «``s or 'foo'``» даёт какраз такой эффект. Поскольку операция «:keyword:`not`» в любом случае должна сгенерировать новое значение, то она не заботится о том, чтобы вернуть значение того же типа, что и её аргумент, поэтому, например, «``not 'foo'``» выдаёт «:const:`False`» , а не «``''``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lambdas</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ламбда-функции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lambda forms (lambda expressions) have the same syntactic position as expressions.  They are a shorthand to create anonymous functions; the expression ``lambda arguments: expression`` yields a function object.  The unnamed object behaves like a function object defined with ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ламбда-выражения находятся в той же позиции, в которой ожидается обычное выражение. Они являются сокращённой формой создания анонимных функций. Выражение «``lambda arguments: expression``» возвращает вместо себя объект-функцию. Этот безымянный объект-функция ведёт себя, как если бы был определён так : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def &lt;lambda&gt;(arguments):     return expression</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>def &lt;lambda&gt;(arguments):     return expression</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See section :ref:`function` for the syntax of parameter lists.  Note that functions created with lambda forms cannot contain statements or annotations.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Смотрите синтаксис списка параметров в разделе «Определение функций» :ref:`function` . Заметьте, что функции, созданные ламбда-выражением, не могут содержать инструкций или аннотаций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expression lists</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Списки выражений</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An expression list containing at least one comma yields a tuple.  The length of the tuple is the number of expressions in the list.  The expressions are evaluated from left to right.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Список выражений, содержащий как минимум одну запятую, даёт в результате кортеж. Длинною кортежа считается количество его элементов (выражений в соответствующем списке) . Эти выражения вычисляются поочерёдно с лева направо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The trailing comma is required only to create a single tuple (a.k.a. a *singleton*); it is optional in all other cases.  A single expression without a trailing comma doesn't create a tuple, but rather yields the value of that expression. (To create an empty tuple, use an empty pair of parentheses: ``()``.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запятая в самом конце, после последнего элемента – требуется только для создания одноэлементного кортежа (“singleton” , “одиночка”) – в других случаях такая концевая запятая не требуется. Одиночное выражение без такой концевой запятой после него не создаёт кортеж, а просто возвращает само значение этого выражения. А для обозначения пустого кортежа используйте пустую пару круглых скобок : «`` ( ) ``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Evaluation order</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Очерёдность вычисления</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python evaluates expressions from left to right.  Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Питон обрабатывает (вычисляет) выражения с лева направо. Заметьте, что при обработке назначений – сначала обрабатывается правая часть (источник) , потом левая (получатель) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following lines, expressions will be evaluated in the arithmetic order of their suffixes::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В следующем коде числа на концах имён выражений соответствуют очерёдности их обработки : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>expr1, expr2, expr3, expr4 (expr1, expr2, expr3, expr4) {expr1: expr2, expr3: expr4} expr1 + expr2 * (expr3 - expr4) expr1(expr2, expr3, *expr4, **expr5) expr3, expr4 = expr1, expr2</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>expr1, expr2, expr3, expr4 (expr1, expr2, expr3, expr4) {expr1: expr2, expr3: expr4} expr1 + expr2 * (expr3 - expr4) expr1(expr2, expr3, *expr4, **expr5) expr3, expr4 = expr1, expr2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summary</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обобщение</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table summarizes the operator precedences in Python, from lowest precedence (least binding) to highest precedence (most binding).  Operators in the same box have the same precedence.  Unless the syntax is explicitly given, operators are binary.  Operators in the same box group left to right (except for comparisons, including tests, which all have the same precedence and chain from left to right --- see section :ref:`comparisons` --- and exponentiation, which groups from right to left).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующая таблица показывает приоритетность операторов в Питоне – от наименьшей приоритетности (слабейшая связь с операндами) к наивысшей (сильнейшая связь) . Операторы в одной ячейке имеют одинаковую приоритетность. Если синтаксис не указан явно – подразумеваются двухоперандные операторы. Операторы из одной ячейки приоритетности, идущие в коде подряд, исполняются с лева направо (кроме операторов сравнения и возведения в степень, у которых обратный порядок исполнения – смотрите :ref:`comparisons` ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Operator</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Описание</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`lambda`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:keyword:`lambda`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lambda expression</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ламбда-выражение</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`if` -- :keyword:`else`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:keyword:`if` -- :keyword:`else`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conditional expression</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражение условия</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`or`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:keyword:`or`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boolean OR</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Логическое ИЛИ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`and`</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:keyword:`and`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boolean AND</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Логическое И</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`not` *x*</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:keyword:`not` *x*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boolean NOT</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Логическое НЕ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`in`, :keyword:`not` :keyword:`in`, :keyword:`is`, :keyword:`is not`, ``&lt;``, ``&lt;=``, ``&gt;``, ``&gt;=``, ``!=``, ``==``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>:keyword:`in`, :keyword:`not` :keyword:`in`, :keyword:`is`, :keyword:`is not`, ``&lt;``, ``&lt;=``, ``&gt;``, ``&gt;=``, ``!=``, ``==``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comparisons, including membership tests and identity tests,</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сравнения, проверки на идентичность или вхождение</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``|``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``|``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bitwise OR</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Побитовое ИЛИ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``^``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``^``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bitwise XOR</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Побитовое Исключающее ИЛИ (XOR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``&amp;``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``&amp;``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bitwise AND</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Побитовое И</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``&lt;&lt;``, ``&gt;&gt;``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``&lt;&lt;``, ``&gt;&gt;``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shifts</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сдвиги</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``+``, ``-``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``+``, ``-``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Addition and subtraction</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Сложение и вычитание</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``*``, ``/``, ``//``, ``%``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``*``, ``/``, ``//``, ``%``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiplication, division, remainder</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Умножение, деление, остаток</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``+x``, ``-x``, ``~x``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``+x``, ``-x``, ``~x``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Positive, negative, bitwise NOT</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Позитивация, негативация, побитовое НЕ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``**``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``**``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exponentiation [#]_</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Степень [#]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscription, slicing, call, attribute reference</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Индексация, вызов, обращение к атрибуту</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``(expressions...)``, ``[expressions...]``, ``{key:datum...}``,</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``(expressions...)``, ``[expressions...]``, ``{key:datum...}``,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Binding or tuple display, list display, dictionary display,</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Записи (:term:`display`) : кортежа или списка получателей, списка, словаря, множества</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The power operator ``**`` binds less tightly than an arithmetic or bitwise unary operator on its right, that is, ``2**-1`` is ``0.5``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Оператор степени «``**``» имеет меньший приоритет, чем арифметические или побитовые однооперандные операторы непосредственно справа от него, так, например, «``2**-1``» даёт «``0.5``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Grammar specification</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Полная спецификация грамматики</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Дата</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lexical analysis</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Лексический анализ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Line structure</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Структура строк</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Python program is divided into a number of *logical lines*.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Программа на Питоне состоит из *условных (логических) строк*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logical lines</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Условные строки</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The end of a logical line is represented by the token NEWLINE.  Statements cannot cross logical line boundaries except where NEWLINE is allowed by the syntax (e.g., between statements in compound statements). A logical line is constructed from one or more *physical lines* by following the explicit or implicit *line joining* rules.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Условные строки состоят из одной или нескольких *физических строк*, объединённых по правилам явного или неявного *объединения строк*. Инструкции не могут пересекать границы условных строк, за исключением специальных случаев, предусмотренных синтаксисом (например, составные инструкции).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Physical lines</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Физические строки</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When embedding Python, source code strings should be passed to Python APIs using the standard C conventions for newline characters (the ``\n`` character, representing ASCII LF, is the line terminator).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>При встраивании Питона в другое приложение, строки исходного кода на Питоне следует передавать из этого приложения в API Питона, следуя стандартным соглашениям языка “C” для символов новой строки (тоесть, символ «``
``» , обозначающий ASCII LF ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Комментарии</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comment starts with a hash character (``#``) that is not part of a string literal, and ends at the end of the physical line.  A comment signifies the end of the logical line unless the implicit line joining rules are invoked. Comments are ignored by the syntax; they are not tokens.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Комментарий начинается с символа «``#``» (“решётка”), если тот не является частью записи текстовых данных, и продолжается до конца физической строки. Комментарий также обозначает конец условной строки, кроме тех случаев, когда происходит неявное объединение условных строк. Комментарии игнорируются при анализе текста программы и не являются лексемами (токенами).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explicit line joining</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Явное объединение строк</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two or more physical lines may be joined into logical lines using backslash characters (``\``), as follows: when a physical line ends in a backslash that is not part of a string literal or comment, it is joined with the following forming a single logical line, deleting the backslash and the following end-of-line character.  For example::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Две или более физических строк могут быть объединены в одну условную строку при помощи символа бэкслэш (``\``) следующим образом: когда строка заканчивается бэкслэшем, не являющимся частью текстовых данных или комментария, она объединяется со следующей, составляя единую условную строку, не включающую бэкслэш и следующий за ним символ окончания строки. Например:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if 1900 &lt; year &lt; 2100 and 1 &lt;= month &lt;= 12 \    and 1 &lt;= day &lt;= 31 and 0 &lt;= hour &lt; 24 \    and 0 &lt;= minute &lt; 60 and 0 &lt;= second &lt; 60:   # Looks like a valid date         return 1</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>if 1900 &lt; year &lt; 2100 and 1 &lt;= month &lt;= 12 \    and 1 &lt;= day &lt;= 31 and 0 &lt;= hour &lt; 24 \    and 0 &lt;= minute &lt; 60 and 0 &lt;= second &lt; 60:   # Looks like a valid date         return 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A line ending in a backslash cannot carry a comment.  A backslash does not continue a comment.  A backslash does not continue a token except for string literals (i.e., tokens other than string literals cannot be split across physical lines using a backslash).  A backslash is illegal elsewhere on a line outside a string literal.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Строка, оканчивающаяся бэкслэшем, не может содержать комментарий. Комментарий или другую лексему кроме текстовых данных, начатые на одной строке, нельзя продолжить с помощью бэкслэша на другой строке. Кроме конца физической строки бэкслэш допустим только внутри текстовых данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implicit line joining</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Неявное объединение строк</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expressions in parentheses, square brackets or curly braces can be split over more than one physical line without using backslashes. For example::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражения в скобках - круглых, квадратных либо фигурных - могут быть разделены на несколько физических строк без использования бэкслэша. Например:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>month_names = ['Januari', 'Februari', 'Maart',      # These are the                'April',   'Mei',      'Juni',       # Dutch names                'Juli',    'Augustus', 'September',  # for the months                'Oktober', 'November', 'December']   # of the year</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>month_names = ['Januari', 'Februari', 'Maart',      # These are the                'April',   'Mei',      'Juni',       # Dutch names                'Juli',    'Augustus', 'September',  # for the months                'Oktober', 'November', 'December']   # of the year</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blank lines</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пустые строки</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A logical line that contains only spaces, tabs, formfeeds and possibly a comment, is ignored (i.e., no NEWLINE token is generated).  During interactive input of statements, handling of a blank line may differ depending on the implementation of the read-eval-print loop.  In the standard interactive interpreter, an entirely blank logical line (i.e. one containing not even whitespace or a comment) terminates a multi-line statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Условные строки, содержащие только пробелы, знаки табуляции или перевода страницы и комментарии игнорируется (т.е. не создается лексемы “NEWLINE”). Во время интерактивного ввода операторов обработка пустой последовательности может отличаться в зависимости от реализации цикла чтение-вычисление-вывод. В стандартном интерактивном интерпретаторе полностью пустая условная строка (т.е. не содержащая даже пробел или комментарий) завершает многострочный оператор.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indentation</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:term:`Отступы`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indentation is rejected as inconsistent if a source file mixes tabs and spaces in a way that makes the meaning dependent on the worth of a tab in spaces; a :exc:`TabError` is raised in that case.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Отступы не принимаются из-за противоречивости, если исходный файл смешивает табуляции и пробелы таким образом, что делает смысл зависящим от размера табуляции в пробелах; в таком случае генерируется «:exc:`TabError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Cross-platform compatibility note:** because of the nature of text editors on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for the indentation in a single source file.  It should also be noted that different platforms may explicitly limit the maximum indentation level.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>**Замечание о кроссплатформенной совместимости:** из-за особенностей текстовых редакторов на не-UNIX платформах - не следует использовать смесь пробелов и табуляций для отступов в одном исодном файле. Также следует отметить, что различные платформы могут явно ограничивать максимальный уровень отступов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before the first line of the file is read, a single zero is pushed on the stack; this will never be popped off again.  The numbers pushed on the stack will always be strictly increasing from bottom to top.  At the beginning of each logical line, the line's indentation level is compared to the top of the stack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token is generated.  If it is smaller, it *must* be one of the numbers occurring on the stack; all numbers on the stack that are larger are popped off, and for each number popped off a DEDENT token is generated.  At the end of the file, a DEDENT token is generated for each number remaining on the stack that is larger than zero.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Перед чтением первой строки файла в стек записывается значение «0», это значение никогда не будет извлечено. Числа, заносимые в стек, будут строго возрастать. В начале каждой условной строки уровень отступа сравнивается с максимальным значением на верху стека; если они равны, то ничего не происходит. Если уровень отступа больше, то он заносится в стек, и создается одна лексема “INDENT” . Если уровень меньше, то это число уже должно быть в стеке; все числа, которые больше, удаляются, и для каждого удаленного числа создается лексема “DEDENT” . В конце файла лексемы “DEDENT” создаются для всех оставшихся в стеке чисел больше ноля.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def perm(l):         # Compute the list of all permutations of l     if len(l) &lt;= 1:                   return [l]     r = []     for i in range(len(l)):              s = l[:i] + l[i+1:]              p = perm(s)              for x in p:               r.append(l[i:i+1] + x)     return r</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>def perm(l):         # Compute the list of all permutations of l     if len(l) &lt;= 1:                   return [l]     r = []     for i in range(len(l)):              s = l[:i] + l[i+1:]              p = perm(s)              for x in p:               r.append(l[i:i+1] + x)     return r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def perm(l):                       # error: first line indented for i in range(len(l)):             # error: not indented     s = l[:i] + l[i+1:]         p = perm(l[:i] + l[i+1:])   # error: unexpected indent         for x in p:                 r.append(l[i:i+1] + x)             return r                # error: inconsistent dedent</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>def perm(l):                       # error: first line indented for i in range(len(l)):             # error: not indented     s = l[:i] + l[i+1:]         p = perm(l[:i] + l[i+1:])   # error: unexpected indent         for x in p:                 r.append(l[i:i+1] + x)             return r                # error: inconsistent dedent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whitespace between tokens</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Пробелы между лексемами</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except at the beginning of a logical line or in string literals, the whitespace characters space, tab and formfeed can be used interchangeably to separate tokens.  Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Кроме начала логической строки или в записи текстовых данных символы пробела, табуляции и перевода страницы могут быть взаимозаменяемы при разделении лексем. Эти символы необходимы между двумя лексемами только, если результат их объединения может быть интерпретирован как другая лексема (например : «``ab``» - это одна лексема, но «``a b``» - две лексемы) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other tokens</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Другие лексемы</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Besides NEWLINE, INDENT and DEDENT, the following categories of tokens exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. Whitespace characters (other than line terminators, discussed earlier) are not tokens, but serve to delimit tokens. Where ambiguity exists, a token comprises the longest possible string that forms a legal token, when read from left to right.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Кроме “NEWLINE” , “INDENT” и “DEDENT” , существуют следующие категории лексем: *идентификаторы*, *ключевые слова*, *литералы* (непосредственная запись данных) , *операторы* и *разделители*. Символы пробелов (кроме знаков конца строки, описанных ранее) не являются лексемами, а служат для их разделения. Если появляется неопределенность, лексема включает самую длинную возможную последовательность, представляющую собой действительную лексему (чтение происходит слева направо) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifiers and keywords</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Идентификаторы и ключевые слова</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identifiers (also referred to as *names*) are described by the following lexical definitions.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Идентификаторы (имена) имеют следующее лексическое определение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax of identifiers in Python is based on the Unicode standard annex UAX-31, with elaboration and changes as defined below; see also :pep:`3131` for further details.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Синтаксис идентификаторов в Питоне основывается на приложении “UAX-31” к стандарту “Unicode” , с переработкой и изменениями описанными ниже. Также смотрите дополнительные детали в :pep:`3131` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Within the ASCII range (U+0001..U+007F), the valid characters for identifiers are the same as in Python 2.x: the uppercase and lowercase letters ``A`` through ``Z``, the underscore ``_`` and, except for the first character, the digits ``0`` through ``9``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В ASCII диапазоне (U+0001..U+007F) в идентификаторах допустимы только те же символы, что и в Питоне 2.x : буквы с «``A``» по «``Z``» в верхнем и нижнем регистре, подчеркивание «``_``» и, кроме первого символа идентификатора, – цифры с «``0``» по «``9``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Unicode category codes mentioned above stand for:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Использованные выше обозначения категорий Юникода :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All identifiers are converted into the normal form NFC while parsing; comparison of identifiers is based on NFC.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Все идентификаторы при лексическом разборе конвертируются в нормализованную форму NFC; и сравнение идентификаторов производится уже в форме NFC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A non-normative HTML file listing all valid identifier characters for Unicode 4.1 can be found at http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Ненормативный HTML файл со списком всех символов Юникода 4.1 , доступных для использования в идентификаторах, представлен здесь: http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reserved classes of identifiers</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Зарезервированные классы идентификаторов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Certain classes of identifiers (besides keywords) have special meanings.  These classes are identified by the patterns of leading and trailing underscore characters:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Определенные классы идентификаторов (помимо ключевых слов) имеют особое значение. Эти классы определяются соответствующей комбинацией символов подчеркивания в начале и в конце.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not imported by ``from module import *``.  The special identifier ``_`` is used in the interactive interpreter to store the result of the last evaluation; it is stored in the :mod:`builtins` module.  When not in interactive mode, ``_`` has no special meaning and is not defined. See section :ref:`import`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Не импортируются инструкцией «``from module import *``» . Специальный идентификатор «``_``» используется интерактивным интерпретатором для хранения результата последнего вычисления, хранится он в модуле «:mod:`builtins`» . Не в интерактивном режиме «``_``» не имеет специального значения, не определен. (Смотрите раздел “Объявление импорта” :ref:`import` ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name ``_`` is often used in conjunction with internationalization; refer to the documentation for the :mod:`gettext` module for more information on this convention.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Имя «``_``» часто используется в связи с интернационализацией, смотрите документацию модуля «:mod:`gettext`» для получения информации по этой договоренности.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>System-defined names.  These names are defined by the interpreter and its implementation (including the standard library); applications should not expect to define additional names using this convention.  The set of names of this class defined by Python may be extended in future versions. See section :ref:`specialnames`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Определенные системой имена. Эти имена определяются интерпретатором и его реализацией (включая стандартную библиотеку). Приложения не должны определять дополнительные имена используя эту форму. Набор имен этого класса, определенных в Питоне, может быть расширен в будущих версиях. Смотрите раздел “Имена специальных методов” :ref:`specialnames` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class-private names.  Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between "private" attributes of base and derived classes. See section :ref:`atom-identifiers`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Частные имена класса. Имена этой категории, при использовании в рамках определения класса, автоматически модифицируются, чтобы избежать конфликтов имен между “частными” атрибутами базовых и производных классов. Смотрите в разделе “Идентификаторы (Имена)” :ref:`atom-identifiers` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Literals are notations for constant values of some built-in types.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>“Литералы” - это непосредственная запись постоянных значений некоторых встроенных типов данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String and Bytes literals</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Текстовые (“String”) и байтовые (“Bytes”) “литералы”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String literals are described by the following lexical definitions:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Непосредственная запись текстовых данных имеет следующее лексическое определение:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One syntactic restriction not indicated by these productions is that whitespace is not allowed between the :token:`stringprefix` or :token:`bytesprefix` and the rest of the literal. The source character set is defined by the encoding declaration; it is UTF-8 if no encoding declaration is given in the source file; see section :ref:`encodings`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Есть также одно синтаксическое ограничение, не отмеченное в этих определениях: знаки пробелов (пробела, табуляции, перевода страницы) не могут находится между строковым (:token:`stringprefix`) или байтовым (:token:`bytesprefix`) префиксом и остальной частью “литерала” . Набор символов кода программы определяется объявлением кодировки, по умолчанию: UTF-8, смотрите раздел «Объявление кодировки» :ref:`encodings` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In plain English: Both types of literals can be enclosed in matching single quotes (``'``) or double quotes (``"``).  They can also be enclosed in matching groups of three single or double quotes (these are generally referred to as *triple-quoted strings*).  The backslash (``\``) character is used to escape characters that otherwise have a special meaning, such as newline, backslash itself, or the quote character.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Говоря проще : оба типа “литералов” обрамляются с двух сторон одинаковыми кавычками : или по одной одинарной «``'``» , или по одной двойной «``"``» , или по три одинарных «``'''``» , или по три двойных «``"""``» (*утроенные кавычки*) . Символ бэкслэш «``\``» используется для “экранирования” (вставки в качестве простых печатных) символов, которые иначе бы имели особое значение, таких как знак новой строки, сам бэкслэш или кавычки и т.д. .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an instance of the :class:`bytes` type instead of the :class:`str` type.  They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Байтовым “литералам” должен предшествовать префикс «``'b'``» или «``'B'``» . Они создают экземпляр типа «:class:`bytes`» вместо типа «:class:`str`» . Этот тип может содержать только символы ASCII; байты с численным значением больше 127 записываются с помощью особых последовательностей символов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both string and bytes literals may optionally be prefixed with a letter ``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat backslashes as literal characters.  As a result, in string literals, ``'\U'`` and ``'\u'`` escapes in raw strings are not treated specially.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Строковые литералы могут опционально начинаться с букв «``'r'``» или «``'R'``» ; такие строки называются “сырыми” («:dfn:`raw strings`»), и считают бэкслэш обычным символом. В результате последовательности «``'\U'``» и «``'\u'``» специального значения в “сырых” строках не имеют.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In triple-quoted strings, unescaped newlines and quotes are allowed (and are retained), except that three unescaped quotes in a row terminate the string.  (A "quote" is the character used to open the string, i.e. either ``'`` or ``"``.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В текстовых данных в утроенных кавычках – могут присутствовать (и сохраняются как есть) “неэкранированные” знаки новой строки и кавычки (не в виде специальных последовательностей) , кроме трех “неэкранированных” кавычек подряд (того же вида, как и открывавшие), которые завершают запись текста.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings are interpreted according to rules similar to those used by Standard C.  The recognized escape sequences are:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если нет префикса «``'r'``» или «``'R'``» , специальные последовательности в строках интерпретируются согласно правилам стандартного “C” . Опознаются следующие специальные последовательности:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Escape Sequence</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Специальная последовательность</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Примечания</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\newline``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\newline``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backslash and newline ignored</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующая строка считается продолжением этой, а бэкслэш и перевод строки – отбрасываются</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\\``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\\``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backslash (``\``)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Бэкслэш (``\``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\'``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single quote (``'``)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Одинарная кавычка (``'``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\"``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\"``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Double quote (``"``)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Двойная кавычка (``"``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\a``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\a``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Bell (BEL)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Bell” (BEL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\b``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\b``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Backspace (BS)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Backspace” (BS)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\f``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\f``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Formfeed (FF)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Formfeed” (FF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\n``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\n``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Linefeed (LF)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Linefeed” (LF)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\r``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\r``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Carriage Return (CR)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Carriage Return” (CR)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\t``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\t``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Horizontal Tab (TAB)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Horizontal Tab” (TAB)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\v``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\v``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Vertical Tab (VT)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>ASCII “Vertical Tab” (VT)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\ooo``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\ooo``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Character with octal value *ooo*</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Символ с восьмиричным значением *ooo*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(1,3)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>(1,3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``\xhh``</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>``\xhh``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Character with hex value *hh*</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Символ с 16-ричным значением *hh*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(2,3)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>(2,3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Примечания:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As in Standard C, up to three octal digits are accepted.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Как и в стандартном “C” , принимается до трех восьмеричных знаков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike in Standard C, exactly two hex digits are required.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В отличие от стандартного “C” , принимается строго два 16-ричных знака.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a bytes literal, hexadecimal and octal escapes denote the byte with the given value. In a string literal, these escapes denote a Unicode character with the given value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В байтовых данных 16- и 8-ричные специальные последовательности обозначают байт с данным значением. В текстовых данных они обозначают символ Юникода с данным кодом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Individual code units which form parts of a surrogate pair can be encoded using this escape sequence.  Exactly four hex digits are required.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Отдельные коды, составляющие части суррогатной пары, могут быть закодированы при помощи специальных последовательностей. В отличие от стандартного “C” , требуется строго два 16-ричных знака.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., *the backslash is left in the string*.  (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.)  It is also important to note that the escape sequences only recognized in string literals fall into the category of unrecognized escapes for bytes literals.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В отличие от стандартного “C”, все неопознанные последовательности символов оставляются в тексте неизменными, т. е. *бэкслэш остается в тексте*. (Такое поведение полезно при отладке: если особая последовательность символов написана неправильно, то в том, что появляется на выходе легче заметить ошибку.) Кроме того, важно отметить, что управляющие последовательности опознающиеся только в записи текста попадают в категорию неопознанных последовательностей в записи байтовых данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Even in a raw string, string quotes can be escaped with a backslash, but the backslash remains in the string; for example, ``r"\""`` is a valid string literal consisting of two characters: a backslash and a double quote; ``r"\"`` is not a valid string literal (even a raw string cannot end in an odd number of backslashes).  Specifically, *a raw string cannot end in a single backslash* (since the backslash would escape the following quote character).  Note also that a single backslash followed by a newline is interpreted as those two characters as part of the string, *not* as a line continuation.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Даже в “сыром” тексте кавычки могут быть вставлены через бэкслэш, но бэкслэш остается в строке, например, «``r"\""``»является верной текстовой записью, состоящей из двух символов: бэкслэш и двойные кавычки; «``r"\"``» не является допустимой записью (даже “сырой” текст не может заканчиваться нечётным количеством бэкслэшей). В частности, *“сырой” текст не может оканчиваться одним бэкслэшем* (поскольку бэкслэш превращает следующую за ним кавычку в текст). Отметьте также, что один бэкслэш подряд, за которым сразу следует переход на новую строку интерпретируется как эти два символа, являющиеся частью строки, а *не* как продолжение строки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String literal concatenation</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Соединение текстовых записей (текстовых литералов)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple adjacent string or bytes literals (delimited by whitespace), possibly using different quoting conventions, are allowed, and their meaning is the same as their concatenation.  Thus, ``"hello" 'world'`` is equivalent to ``"helloworld"``.  This feature can be used to reduce the number of backslashes needed, to split long strings conveniently across long lines, or even to add comments to parts of strings, for example::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Допустимы несколько идущих подряд текстовых записей, разделённых пробелами (возможно, с использованием разных типов пар кавычек) - их значение эквивалентно значению одной текстовой записи, являющейся их соединением. Таким образом, «``"hello" 'world'``» эквивалентно «``"helloworld"``» . Эта особенность позволяет уменьшать количество необходимых бэкслэшей, удобно разделять длинные тексты на много физических строк, или даже добавлять комментарии к отдельным фрагментам текста, например:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>re.compile("[A-Za-z_]"       # letter or underscore            "[A-Za-z0-9_]*"   # letter, digit or underscore           )</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>re.compile("[A-Za-z_]"       # letter or underscore            "[A-Za-z0-9_]*"   # letter, digit or underscore           )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this feature is defined at the syntactical level, but implemented at compile time.  The '+' operator must be used to concatenate string expressions at run time.  Also note that literal concatenation can use different quoting styles for each component (even mixing raw strings and triple quoted strings).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обратите внимание, что это свойство определено на синтаксическом уровне, а реализуется во время компиляции. Для соединения фрагментов текста во время исполнения – должен использоваться оператор «``+``» . Заметьте также, что при соединении текста могут использоваться различные стили оформления для каждого фрагмента (даже смешивание “сырого” текста и в тройных кавычках) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numeric literals</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Непосредственная запись чисел</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three types of numeric literals: integers, floating point numbers, and imaginary numbers.  There are no complex literals (complex numbers can be formed by adding a real number and an imaginary number).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Существуют три формы непосредственной записи для чисел: целых, чисел с плавающей точкой, и мнимых чисел. Не существует непосредственной записи для комплексных чисел (они могут быть сформированы через операцию сложения действительного числа с мнимым).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that numeric literals do not include a sign; a phrase like ``-1`` is actually an expression composed of the unary operator '``-``' and the literal ``1``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что знак не является частью записи числа - такая формулировка, как «``-1``» , на самом деле является выражением, состоящим из однооперандного оператора «``-``» и числа «``1``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integer literals</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись целых чисел</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integer literals are described by the following lexical definitions:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись целых чисел имеет следующее лексическое определение:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no limit for the length of integer literals apart from what can be stored in available memory.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Нет ограничения длины записи числа, кроме размера доступной памяти.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that leading zeros in a non-zero decimal number are not allowed. This is for disambiguation with C-style octal literals, which Python used before version 3.0.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Обратите внимание, что нули в начале ненулевого десятичного числа не допускаются. Это сделано для отличения их от восьмеричной записи в стиле “C” , которая использовалась в Питоне до версии 3.0 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some examples of integer literals::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Некоторые примеры записи целых чисел: ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>7     2147483647                        0o177    0b100110111 3     79228162514264337593543950336     0o377    0x100000000       79228162514264337593543950336              0xdeadbeef</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>7     2147483647                        0o177    0b100110111 3     79228162514264337593543950336     0o377    0x100000000       79228162514264337593543950336              0xdeadbeef</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Floating point literals are described by the following lexical definitions:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись дробных чисел имеет следующее лексическое определение:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the integer and exponent parts are always interpreted using radix 10. For example, ``077e010`` is legal, and denotes the same number as ``77e10``. The allowed range of floating point literals is implementation-dependent. Some examples of floating point literals::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что в целой и экспонентной частях всегда подразумевается основание 10 . Например, ``077e010`` является допустимым и значит то же, что и ``77e10`` . Допустимый диапазон дробных чисел может различаться в разных реализациях. Примеры записи дробных чисел: ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3.14    10.    .001    1e100    3.14e-10    0e0</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>3.14    10.    .001    1e100    3.14e-10    0e0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that numeric literals do not include a sign; a phrase like ``-1`` is actually an expression composed of the unary operator ``-`` and the literal ``1``.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что знак не является частью записи числа - такая формулировка, как «``-1``» , на самом деле является выражением, состоящим из однооперандного оператора «``-``» и числа «``1``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imaginary literals</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись мнимых чисел</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imaginary literals are described by the following lexical definitions:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись мнимых чисел имеет следующее лексическое определение:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An imaginary literal yields a complex number with a real part of 0.0.  Complex numbers are represented as a pair of floating point numbers and have the same restrictions on their range.  To create a complex number with a nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  Some examples of imaginary literals::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Под мнимое число отводится комплексное число с действительной частью «0» . Комплексные числа представлены в виде пары чисел с плавающей точкой, которые имеют обычные ограничения диапазона их значений. Чтобы создать комплексное число с ненулевой действительной частью, нужно сложить обычное дробное число с мнимым числом, например, «``(3+4j)``» . Некоторые примеры записи мнимых чисел: ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3.14j   10.j    10j     .001j   1e100j  3.14e-10j</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>3.14j   10.j    10j     .001j   1e100j  3.14e-10j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Operators</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Операторы</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following tokens are operators::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие лексемы являются операторами:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+       -       *       **      /       //      % &lt;&lt;      &gt;&gt;      &amp;       |       ^       ~ &lt;       &gt;       &lt;=      &gt;=      ==      !=</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>+       -       *       **      /       //      % &lt;&lt;      &gt;&gt;      &amp;       |       ^       ~ &lt;       &gt;       &lt;=      &gt;=      ==      !=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delimiters</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Разделители</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following tokens serve as delimiters in the grammar::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие лексемы выполняют роль грамматических разделителей: ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(       )       [       ]       {       } ,       :       .       ;       @       = +=      -=      *=      /=      //=     %= &amp;=      |=      ^=      &gt;&gt;=     &lt;&lt;=     **=</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>(       )       [       ]       {       } ,       :       .       ;       @       = +=      -=      *=      /=      //=     %= &amp;=      |=      ^=      &gt;&gt;=     &lt;&lt;=     **=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The period can also occur in floating-point and imaginary literals.  A sequence of three periods has a special meaning as an ellipsis literal. The second half of the list, the augmented assignment operators, serve lexically as delimiters, but also perform an operation.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Точка также встречается в записи дробных и мнимых чисел. Последовательность из трех точек имеет особое значение - обозначение пропуска («:term:`ellipsis`»), вторая половина списка – расширенные операции присваивания – служат в качестве лексического разделителя, и одновременно выполняют операцию.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following printing ASCII characters have special meaning as part of other tokens or are otherwise significant to the lexical analyzer::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие печатные символы ASCII имеют особое значение в качестве части других лексем, и, таким образом, важны для лексического анализатора:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'       "       #       \</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>'       "       #       \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following printing ASCII characters are not used in Python.  Their occurrence outside string literals and comments is an unconditional error::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Следующие печатные символы ASCII не используются в Питоне. Их появление за пределами записи текстовых данных или комментариев безусловно является ошибкой:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$       ?       `</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>$       ?       `</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple statements</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Простые инструкции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple statements are comprised within a single logical line. Several simple statements may occur on a single line separated by semicolons.  The syntax for simple statements is:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Простые инструкции ограничены пределами одной условной строки. Но в одной условной строке может помещаться несколько простых инструкций, разделённых точкой с запятой «``;``» . Простые инструкции имеют следующий синтаксис :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expression statements are used (mostly interactively) to compute and write a value, or (usually) to call a procedure (a function that returns no meaningful result; in Python, procedures return the value ``None``).  Other uses of expression statements are allowed and occasionally useful.  The syntax for an expression statement is:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражение - инструкция используется (в основном интерактивно) для вычисления и показа значения, или (обычно) для вызова процедуры (это такая функция, которая не возвращает результата - а в Питоне возвращает формальный результат «:const:`None`» ) . Другие применения выражений - инструкций также возможны и бывают полезны. Выражения - инструкции имеют следующий синтаксис :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An expression statement evaluates the expression list (which may be a single expression).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражение - инструкция обрабатывает список выражений (в частности из одного выражения) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In interactive mode, if the value is not ``None``, it is converted to a string using the built-in :func:`repr` function and the resulting string is written to standard output on a line by itself (except if the result is ``None``, so that procedure calls do not cause any output.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В интерактивном режиме, если его результат не «:const:`None`» , то результат преобразуется в строку встроенной функцией «:func:`repr`» , и эта строка выдаётся на стандартный вывод (а если результат «:const:`None`» , то ничего не выводится) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assignment statements are used to (re)bind names to values and to modify attributes or items of mutable objects:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкции назначения используются для (пере)связывания имён со значениями и для изменения атрибутов или элементов изменяемых объектов :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(See section :ref:`primaries` for the syntax definitions for the last three symbols.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>(Смотри определения синтаксиса последних трёх обозначений в разделе «:ref:`primaries`» . )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция назначения последовательно назначает объект, получившийся в результате вычисления очередного выражения из списка выражений (учитывая, что этот список может содержать одно выражение или список, разделённый запятыми) - соответственно очередной цели из списка целей, в обоих списках - слева направо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assignment is defined recursively depending on the form of the target (list). When a target is part of a mutable object (an attribute reference, subscription or slicing), the mutable object must ultimately perform the assignment and decide about its validity, and may raise an exception if the assignment is unacceptable.  The rules observed by various types and the exceptions raised are given with the definition of the object types (see section :ref:`types`).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Назначение определяется рекурсивно – в зависимости от структуры цели назначения (например список) . Если цель является частью изменяемого объекта (атрибут, элемент по индексу) , то сам этот изменяемый объект должен в итоге выполнить назначение и решить допустимо ли оно и, если нужно, может инициировать исключение. Правила, которых придерживаются различные типы, и инициируемые ими исключения – определены в самих этих типах (смотрите раздел «Иерархия стандартных типов» :ref:`types` ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assignment of an object to a target list, optionally enclosed in parentheses or square brackets, is recursively defined as follows.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Назначение объекта списку целей, который может быть заключён в круглые или квадратные скобки, рекурсивно определяется следующим образом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target list is a single target: The object is assigned to that target.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если этот список целей фактически состоит из единственной цели, то данный объект назначается этой цели.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target list is a comma-separated list of targets: The object must be an iterable with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets. (This rule is relaxed as of Python 1.5; in earlier versions, the object had to be a tuple.  Since strings are sequences, an assignment like ``a, b = "xy"`` is now legal as long as the string has the right length.)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если этот список целей является перечнем целей, разделённых запятыми, то данный объект (источник) должен быть итерируемым и иметь столько же элементов (сколько целей в списке целей), и эти элементы назначаются соответствующим по счёту (слева направо) целям. (Это правило стало менее ограниченным с версии Питона 1.5 (до этого объект источник обязан был быть кортежем) . Теперь, поскольку текстовые данные являются последовательностями, назначение вроде «``a, b = "xy"``» является допустимым, при условии, что текст имеет строго соответствующую длину.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target list contains one target prefixed with an asterisk, called a "starred" target: The object must be a sequence with at least as many items as there are targets in the target list, minus one.  The first items of the sequence are assigned, from left to right, to the targets before the starred target.  The final items of the sequence are assigned to the targets after the starred target.  A list of the remaining items in the sequence is then assigned to the starred target (the list can be empty).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если в перечне целей присутствует цель, перед которой стоит одна звёздочка, то объект-источник должен быть последовательностью, у которой количество элементов больше или равно количеству целей минус один. Всем целям до цели со звёздочкой назначаются соответствующие по счёту элементы источника. Всем целям после цели со звёздочкой назначаются соответствующие по счёту с конца элементы источника. Перечень оставшихся элементов в последовательности-источнике назначается цели со звёздочкой (этот перечень может быть пустым) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Else: The object must be a sequence with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Иначе этот объект-источник должен быть последовательностью, у которой количество элементов равно количеству целей, и эти элементы назначаются соответствующим по счёту (слева направо) целям.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assignment of an object to a single target is recursively defined as follows.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Назначение объекта единственной цели определяется рекурсивно следующим образом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target is an identifier (name):</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если эта цель является идентификатором (именем) :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` statement in the current code block: the name is bound to the object in the current local namespace.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если это имя не упоминается в текущем блоке кода в инструкциях «:keyword:`global`» или «:keyword:`nonlocal`» , то это имя связывается с данным объектом в текущей области имён (тоесть, создаётся локальная переменная с этим именем) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise: the name is bound to the object in the global namespace or the outer namespace determined by :keyword:`nonlocal`, respectively.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Иначе это имя связывается с данным объектом соответственно в глобальной области имён или во внешней области имён, определённой «:keyword:`nonlocal`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name is rebound if it was already bound.  This may cause the reference count for the object previously bound to the name to reach zero, causing the object to be deallocated and its destructor (if it has one) to be called.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Данное имя переназначается, если оно уже было назначено. Это может привести к тому, что счётчик ссылок на тот объект, который был связан с данным именем, достигнет ноля, из-за чего у объекта будет вызван деструктор (если имеется) – и объект будет удалён.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target is a target list enclosed in parentheses or in square brackets: The object must be an iterable with the same number of items as there are targets in the target list, and its items are assigned, from left to right, to the corresponding targets.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если эта цель является перечнем целей, заключённым в круглые или квадратные скобки, то данный объект (источник) должен быть итерируемым и с тем же количеством элементов (как в перечне целей) , и эти элементы назначаются соответствующим по счёту (слева направо) целям.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target is an attribute reference: The primary expression in the reference is evaluated.  It should yield an object with assignable attributes; if this is not the case, :exc:`TypeError` is raised.  That object is then asked to assign the assigned object to the given attribute; if it cannot perform the assignment, it raises an exception (usually but not necessarily :exc:`AttributeError`).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если эта цель является указанием (ссылкой) на атрибут, то первичное выражение этой ссылки интерпретируется, что в результате должно дать объект с атрибутами, допускающими назначение – иначе инициируется «:exc:`TypeError`» . Этому полученному объекту предлагается назначить объект-источник соответствующему (своему) атрибуту – если он не может выполнить это назначение, то инициирует исключение (обычно, но не обязательно – «:exc:`AttributeError`» ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: If the object is a class instance and the attribute reference occurs on both sides of the assignment operator, the RHS expression, ``a.x`` can access either an instance attribute or (if no instance attribute exists) a class attribute.  The LHS target ``a.x`` is always set as an instance attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` do not necessarily refer to the same attribute: if the RHS expression refers to a class attribute, the LHS creates a new instance attribute as the target of the assignment::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Замечание. Если объект является экземпляром класса и данная ссылка на атрибут встречается с обеих сторон оператора назначения, то правое выражение может обращаться как к атрибуту экземпляра так и (если того нет) к атрибуту класса. А цель в левой части всегда подразумевает атрибут экземпляра – и если его не было, то он создаётся. Таким образом два одинаковых упоминания атрибута не обязательно обращаются к одному и тому же атрибуту : когда выражение в правой части обращается к атрибуту класса – то в левой создаётся новый атрибут экземпляра в качестве цели назначения : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Cls:     x = 3             # class variable inst = Cls() inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>class Cls:     x = 3             # class variable inst = Cls() inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This description does not necessarily apply to descriptor attributes, such as properties created with :func:`property`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это не обязательно относится к атрибутам-дескрипторам, например, созданным с помощью «:func:`property`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target is a subscription: The primary expression in the reference is evaluated.  It should yield either a mutable sequence object (such as a list) or a mapping object (such as a dictionary).  Next, the subscript expression is evaluated.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если цель является взятием (указанием) по индексу, то первичное выражение в этом указателе вычисляется. Оно должно давать или объект - изменяемую последовательность (например список) , или объект-отображение (например словарь) . Затем вычисляется выражение, определяющее индекс.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the primary is a mutable sequence object (such as a list), the subscript must yield an integer.  If it is negative, the sequence's length is added to it.  The resulting value must be a nonnegative integer less than the sequence's length, and the sequence is asked to assign the assigned object to its item with that index.  If the index is out of range, :exc:`IndexError` is raised (assignment to a subscripted sequence cannot add new items to a list).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если первичное выражение является изменяемой последовательностью (например списком) , то выражение, определяющее индекс, должно давать в результате целое число. Если это число отрицательное, то к нему прибавляется длина данной последовательности. Получившееся в результате значение должно быть неотрицательным целым, меньшим, чем длина данной последовательности. Затем к данной последовательности следует запрос назначить объект-источник элементу с данным значением индекса. Если индекс выходит за границы, то вызывается исключение «:exc:`IndexError`» (назначение последовательности по индексу не может добавлять новый элемент к списку) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the primary is a mapping object (such as a dictionary), the subscript must have a type compatible with the mapping's key type, and the mapping is then asked to create a key/datum pair which maps the subscript to the assigned object.  This can either replace an existing key/value pair with the same key value, or insert a new key/value pair (if no key with the same value existed).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если первичное выражение является объектом-отображением (например словарём) , то индекс должен иметь тип совместимый с типом ключей данного отображения, и данному отображению делается запрос создать пару ключ/данные, которая будет ставить в соответствие исходный индекс объекту-источнику. При этом может произойти как замещение уже существовавшей пары ключ/данные новой парой с тем же значением ключа, так и добавление новой пары ключ/данные (если не было ключа с таким значением) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For user-defined objects, the :meth:`__setitem__` method is called with appropriate arguments.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для объектов, определённых пользователем, вызывается метод «:meth:`__setitem__`» с соответствующими аргументами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the target is a slicing: The primary expression in the reference is evaluated.  It should yield a mutable sequence object (such as a list).  The assigned object should be a sequence object of the same type.  Next, the lower and upper bound expressions are evaluated, insofar they are present; defaults are zero and the sequence's length.  The bounds should evaluate to integers. If either bound is negative, the sequence's length is added to it.  The resulting bounds are clipped to lie between zero and the sequence's length, inclusive.  Finally, the sequence object is asked to replace the slice with the items of the assigned sequence.  The length of the slice may be different from the length of the assigned sequence, thus changing the length of the target sequence, if the object allows it.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если цель является срезом, то первичное выражение в этом указателе вычисляется. Оно должно давать в результате объект - изменяемую последовательность (например список) . Объект-источник должен быть объектом-последовательностью того же типа. Затем вычисляются выражения, определяющие нижнюю и верхнюю границы (если таковые присутствуют) , которые по умолчанию равны нолю и длине последовательности соответственно. Эти границы должны иметь целое значение. Если какая-либо из них отрицательна, к ней прибавляется длина последовательности. Получившиеся в результате границы обрезаются так, чтобы они входили в диапазон с ноля по длину последовательности. И, наконец, данному объекту-последовательности делается запрос заменить элементы попадающие в срез на элементы последовательности источника. Длина среза может отличаться от длины источника, если объект-цель это позволяет – в этом случае длина последовательности-цели изменится.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the current implementation, the syntax for targets is taken to be the same as for expressions, and invalid syntax is rejected during the code generation phase, causing less detailed error messages.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В текущей реализации синтаксис для целей взят точно таким же, как и для выражений, и ошибочный синтаксис не принимается в фазе генерации кода, приводя к менее детальным сообщениям об ошибках.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARNING: Although the definition of assignment implies that overlaps between the left-hand side and the right-hand side are 'safe' (for example ``a, b = b, a`` swaps two variables), overlaps *within* the collection of assigned-to variables are not safe!  For instance, the following program prints ``[0, 2]``::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Осторожно ! Хотя определение операции назначения подразумевает, что упоминание одного и того же объекта и в левой и в правой частях (“перекрытие”) является “безопасным” (например, «``a, b = b, a``» обменивает значения двух переменных) , “перекрытие” внутри перечисления переменных - целей назначения – не является “безопасным” ! Например, следующая программа печатает «``[0, 2]``» : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>x = [0, 1] i = 0 i, x[i] = 1, 2 print(x)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>x = [0, 1] i = 0 i, x[i] = 1, 2 print(x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The specification for the ``*target`` feature.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Спецификация для «``*target``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augmented assignment statements</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Расширенные инструкции назначения</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Расширенное назначение объединяет в одной инструкции операцию над двумя операндами (т.н. “бинарную”) и инструкцию назначения :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target.  The target is only evaluated once.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Расширенное назначение сначала определяет значение цели назначения (которая, в отличие от случая обычной операции назначения, не может быть распаковкой) и списка выражений, затем выполняет соответствующее двухоперандное действие, и затем этот результат назначает цели назначения. Начальное значение цели назначения вычисляется только один раз.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An augmented assignment expression like ``x += 1`` can be rewritten as ``x = x + 1`` to achieve a similar, but not exactly equal effect. In the augmented version, ``x`` is only evaluated once. Also, when possible, the actual operation is performed *in-place*, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Выражение расширенного назначения вроде «``x += 1``» можно переписать как «``x = x + 1``» , что даёт подобный, но не точно тот же эффект. В “расширенной” версии – «``x``» вычисляется только один раз. Также, когда это возможно, операция выполняется “*на месте*”, тоесть, вместо создания нового объекта и потом назначения его цели – сразу используется “старый” объект.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the exception of assigning to tuples and multiple targets in a single statement, the assignment done by augmented assignment statements is handled the same way as normal assignments. Similarly, with the exception of the possible *in-place* behavior, the binary operation performed by augmented assignment is the same as the normal binary operations.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>С учётом указанных выше оговорок (о кортежах и множественных целях) – назначения у расширенных назначений обрабатываются так же, как и обычные. Также и (за исключением исполнения “*на месте*” ) двухоперандная операция у расширенных назначений обрабатывается так же, как и обычная.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For targets which are attribute references, the same :ref:`caveat about class and instance attributes &lt;attr-target-note&gt;` applies as for regular assignments.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>К целям, являющимся ссылками на атрибуты, относится то же самое :ref:`предостережение о атрибутах классов и экземпляров&lt;attr-target-note&gt;`, как и для обычных назначений.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`assert` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`assert`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assert statements are a convenient way to insert debugging assertions into a program:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`assert`» (“подтверждение”) – это удобный способ вставить в программу контроль (промежуточных результатов) для наладочных целей.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simple form, ``assert expression``, is equivalent to ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для короткой формы – «``assert expression``» – эквивалентом является : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if __debug__:    if not expression: raise AssertionError</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>if __debug__:    if not expression: raise AssertionError</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extended form, ``assert expression1, expression2``, is equivalent to ::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>А для расширенной формы – «``assert expression1, expression2``» – эквивалентом является : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if __debug__:    if not expression1: raise AssertionError(expression2)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>if __debug__:    if not expression1: raise AssertionError(expression2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These equivalences assume that :const:`__debug__` and :exc:`AssertionError` refer to the built-in variables with those names.  In the current implementation, the built-in variable :const:`__debug__` is ``True`` under normal circumstances, ``False`` when optimization is requested (command line option -O).  The current code generator emits no code for an assert statement when optimization is requested at compile time.  Note that it is unnecessary to include the source code for the expression that failed in the error message; it will be displayed as part of the stack trace.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эти эквиваленты полагаются на встроенные переменные «:const:`__debug__`» и «:exc:`AssertionError`» . В текущей реализации Питона встроенная переменная «:const:`__debug__`» – по умолчанию имеет значение «:const:`True`» , а «:const:`False`» – в случае оптимизации командой «``-O``» . Нынешний генератор кода не генерирует никакого кода для инструкций «:keyword:`assert`» , когда запрошена компиляция с оптимизацией. Заметьте, что необязательно вставлять исходный код выражения, вызвавшего ошибку, в сообщение об ошибке – оно и так будет показано, как часть стека .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assignments to :const:`__debug__` are illegal.  The value for the built-in variable is determined when the interpreter starts.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Запись в переменную «:const:`__debug__`» – недопустима. Значение для этой встроенной переменной определяется при запуске интерпретатора.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`pass` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`pass`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`pass` is a null operation --- when it is executed, nothing happens. It is useful as a placeholder when a statement is required syntactically, but no code needs to be executed, for example::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:keyword:`pass`» – это “пустой” оператор – при его исполнении ничего не происходит. Он полезен как заместитель, когда какое либо выражение необходимо по синтаксису, но там не нужно исполнять никакого кода. Например : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def f(arg): pass    # a function that does nothing (yet)  class C: pass       # a class with no methods (yet)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>def f(arg): pass    # a function that does nothing (yet)  class C: pass       # a class with no methods (yet)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`del` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`del`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deletion is recursively defined very similar to the way assignment is defined. Rather that spelling it out in full details, here are some hints.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Удаление определяется рекурсивно – очень похоже на то, как определяется назначение. Вместо расписывания деталей грамматики – далее даны только некоторые подсказки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deletion of a target list recursively deletes each target, from left to right.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Удаление списка целей – рекурсивно удаляет каждую цель слева направо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deletion of a name removes the binding of that name from the local or global namespace, depending on whether the name occurs in a :keyword:`global` statement in the same code block.  If the name is unbound, a :exc:`NameError` exception will be raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Удаление имени удаляет назначение этому имени из локальной или глобальной области имён, в зависимости от того, объявлено ли это имя в инструкции «:keyword:`global`» в этом же самом блоке. Если данное имя не было назначенным (т.е. не было определено) , то инициируется исключение «:exc:`NameError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is illegal to delete a name from the local namespace if it occurs as a free variable in a nested block.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Недопустимо удаление имени из локальной области имён, если оно встречается в качестве “свободной” переменной во вложенном блоке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deletion of attribute references, subscriptions and slicings is passed to the primary object involved; deletion of a slicing is in general equivalent to assignment of an empty slice of the right type (but even this is determined by the sliced object).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Удаление ссылок на атрибуты, а также элементов по индексу и срезов – передаётся (перепоручается) содержащему их объекту. Удаление среза – в целом эквивалентно назначению пустого среза подходящего типа (но даже это определяется (контролируется) объектом, подвергающимся срезу) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`return` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`return`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`return` may only occur syntactically nested in a function definition, not within a nested class definition.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:keyword:`return`» может встречаться только синтаксически непосредственно внутри определения функции, но не внутри вложенных определений классов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an expression list is present, it is evaluated, else ``None`` is substituted.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если (в качестве параметров) дан список выражений, то он вычисляется – иначе подразумевается «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`return` leaves the current function call with the expression list (or ``None``) as return value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:keyword:`return`» делает выход из текущего вызова функции с указанным списком выражений (или «:const:`None`» ) в качестве возвращаемого этой функцией значения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :keyword:`return` passes control out of a :keyword:`try` statement with a :keyword:`finally` clause, that :keyword:`finally` clause is executed before really leaving the function.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда «:keyword:`return`» передаёт управление изнутри инструкции «:keyword:`try`» имеющей ветвь «:keyword:`finally`» , ветвь «:keyword:`finally`» исполняется до фактического выхода из этой функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a generator function, the :keyword:`return` statement is not allowed to include an :token:`expression_list`.  In that context, a bare :keyword:`return` indicates that the generator is done and will cause :exc:`StopIteration` to be raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>В функции-генераторе инструкция «:keyword:`return`» не может иметь синтаксический элемент «:token:`expression_list`» , тоесть вообще каких-либо аргументов. В этом контексте «:keyword:`return`» без аргументов – является сигналом того, что генератор завершил работу, и приведёт к вызову «:exc:`StopIteration`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`yield` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`yield`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`yield` statement is only used when defining a generator function, and is only used in the body of the generator function. Using a :keyword:`yield` statement in a function definition is sufficient to cause that definition to create a generator function instead of a normal function. When a generator function is called, it returns an iterator known as a generator iterator, or more commonly, a generator.  The body of the generator function is executed by calling the :func:`next` function on the generator repeatedly until it raises an exception.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`yield`» используется только при определении функций-генераторов и встречается только внутри такой функции. Использование инструкции «:keyword:`yield`» в какой-либо функции – является однозначным сигналом, который приводит к тому, что данное определение вместо обычной функции создаёт функцию-генератор. При вызове функции-генератора – она возвращает итератор, также называемый : “итератор-генератор” , или просто : “генератор” . Тело функции-генератора исполняется посредством вызова функции «:func:`next`» , применённой к данному генератору, повторяясь до получения исключения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a :keyword:`yield` statement is executed, the state of the generator is frozen and the value of :token:`expression_list` is returned to :meth:`next`'s caller.  By "frozen" we mean that all local state is retained, including the current bindings of local variables, the instruction pointer, and the internal evaluation stack: enough information is saved so that the next time :func:`next` is invoked, the function can proceed exactly as if the :keyword:`yield` statement were just another external call.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда исполняется инструкция «:keyword:`yield`» – состояние содержащей её функции-генератора замораживается, а значение аргументов «:keyword:`yield`» («:token:`expression_list`») возвращается в место вызова функции «:meth:`next`» . Под “замораживается” подразумевается то, что всё локальное состояние сохраняется, включая текущие связывания (значения) локальных переменных, указатель на инструкцию (с которой продолжать) и внутренний стек вычислений. Тоесть сохраняется исчерпывающая информация для того, чтобы, когда в следующий раз будет вызвана инструкция «:meth:`next`» , функция-генератор могла продолжаться точно также, как если бы вместо инструкции «:keyword:`yield`» был какой-либо вызов внешней функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The proposal that, among other generator enhancements, proposed allowing :keyword:`yield` to appear inside a :keyword:`try` ... :keyword:`finally` block.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Предложение, которое помимо других улучшений генератора, предполагает разрешение инструкции «:keyword:`yield`» внутри блока «:keyword:`try` ... :keyword:`finally`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`raise` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`raise`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no expressions are present, :keyword:`raise` re-raises the last exception that was active in the current scope.  If no exception is active in the current scope, a :exc:`TypeError` exception is raised indicating that this is an error (if running under IDLE, a :exc:`queue.Empty` exception is raised instead).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если не заданы выражения, то «:keyword:`raise`» перевызывает последнее исключение, которое было активно в текущей области. А если в текущей области нет активных исключений, то вызывается исключение «:exc:`TypeError`» , сигнализирующее о неопределённой ошибке (при работе под “IDLE” вызывается исключение «:exc:`queue.Empty`» ) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, :keyword:`raise` evaluates the first expression as the exception object.  It must be either a subclass or an instance of :class:`BaseException`. If it is a class, the exception instance will be obtained when needed by instantiating the class with no arguments.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если выражения заданы, то «:keyword:`raise`» расценивает первое как объект-исключение – оно должно быть или экземпляром или подклассом «:class:`BaseException`» . В последнем случае, если потребуется, соответствующий экземпляр исключения будет сгенерирован из этого класса без аргументов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :dfn:`type` of the exception is the exception instance's class, the :dfn:`value` is the instance itself.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Типом данного исключения является класс экземпляра данного исключения, а значением является сам этот экземпляр.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A traceback object is normally created automatically when an exception is raised and attached to it as the :attr:`__traceback__` attribute, which is writable. You can create an exception and set your own traceback in one step using the :meth:`with_traceback` exception method (which returns the same exception instance, with its traceback set to its argument), like so::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Объект трассировки в норме создаётся автоматически, когда инициируется исключение, и присоединяется к этому исключению в качестве изменяемого атрибута «:attr:`__traceback__`» . Вы можете создать исключение и установить собственный объект трассировки за один шаг, используя метод исключения – «:meth:`with_traceback`» (который возвращает тот же экземпляр исключения, но с его объектом трассировки установленным в значение аргумента) . Например : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>raise Exception("foo occurred").with_traceback(tracebackobj)</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>raise Exception("foo occurred").with_traceback(tracebackobj)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``from`` clause is used for exception chaining: if given, the second *expression* must be another exception class or instance, which will then be attached to the raised exception as the :attr:`__cause__` attribute (which is writable).  If the raised exception is not handled, both exceptions will be printed::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Часть после ключевого слова «``from``» используется для связывания исключений : если это второе выражение задано, оно должно быть ещё одним классом или экземпляром исключения – этот объект будет присоединён к вызываемому (основному) исключению как изменяемый атрибут «:attr:`__cause__`» . Если вызванное исключение не обработано, то будут напечатаны оба исключения : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; try: ...     print(1 / 0) ... except Exception as exc: ...     raise RuntimeError("Something bad happened") from exc ... Traceback (most recent call last):   File "&lt;stdin&gt;", line 2, in &lt;module&gt; ZeroDivisionError: int division or modulo by zero  The above exception was the direct cause of the following exception:  Traceback (most recent call last):   File "&lt;stdin&gt;", line 4, in &lt;module&gt; RuntimeError: Something bad happened</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; try: ...     print(1 / 0) ... except Exception as exc: ...     raise RuntimeError("Something bad happened") from exc ... Traceback (most recent call last):   File "&lt;stdin&gt;", line 2, in &lt;module&gt; ZeroDivisionError: int division or modulo by zero  The above exception was the direct cause of the following exception:  Traceback (most recent call last):   File "&lt;stdin&gt;", line 4, in &lt;module&gt; RuntimeError: Something bad happened</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A similar mechanism works implicitly if an exception is raised inside an exception handler: the previous exception is then attached as the new exception's :attr:`__context__` attribute::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Подобный же механизм работает неявно, если исключение инициировано внутри обработчика исключения : предыдущее исключение присоединяется как новый атрибут «:attr:`__context__`» исключения :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; try: ...     print(1 / 0) ... except: ...     raise RuntimeError("Something bad happened") ... Traceback (most recent call last):   File "&lt;stdin&gt;", line 2, in &lt;module&gt; ZeroDivisionError: int division or modulo by zero  During handling of the above exception, another exception occurred:  Traceback (most recent call last):   File "&lt;stdin&gt;", line 4, in &lt;module&gt; RuntimeError: Something bad happened</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>&gt;&gt;&gt; try: ...     print(1 / 0) ... except: ...     raise RuntimeError("Something bad happened") ... Traceback (most recent call last):   File "&lt;stdin&gt;", line 2, in &lt;module&gt; ZeroDivisionError: int division or modulo by zero  During handling of the above exception, another exception occurred:  Traceback (most recent call last):   File "&lt;stdin&gt;", line 4, in &lt;module&gt; RuntimeError: Something bad happened</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional information on exceptions can be found in section :ref:`exceptions`, and information about handling exceptions is in section :ref:`try`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Дополнительную информацию об исключениях смотрите в разделе “:ref:`exceptions`” , а об обработке исключений – в разделе “:ref:`try`” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`break` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`break`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`break` may only occur syntactically nested in a :keyword:`for` or :keyword:`while` loop, but not nested in a function or class definition within that loop.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:keyword:`break`» может встречаться только находясь синтаксически непосредственно внутри цикла «:keyword:`for`» или «:keyword:`while`» , но не внутри определения функции или класса, находящегося внутри этого цикла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It terminates the nearest enclosing loop, skipping the optional :keyword:`else` clause if the loop has one.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Эта инструкция прекращает ближайший объемлющий цикл, пропуская его ветвь «:keyword:`else`» , если она есть.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control target keeps its current value.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если цикл «:keyword:`for`» прекращён инструкцией «:keyword:`break`», то переменная-цель со значением текущего элемента перебираемого множества – сохраняет своё значение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :keyword:`break` passes control out of a :keyword:`try` statement with a :keyword:`finally` clause, that :keyword:`finally` clause is executed before really leaving the loop.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда «:keyword:`break`» прекращает цикл, находясь внутри инструкции «:keyword:`try`» , имеющей ветвь «:keyword:`finally`» , то эта ветвь выполняется раньше выхода из цикла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`continue` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`continue`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:keyword:`continue` may only occur syntactically nested in a :keyword:`for` or :keyword:`while` loop, but not nested in a function or class definition or :keyword:`finally` clause within that loop.  It continues with the next cycle of the nearest enclosing loop.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>«:keyword:`continue`» может встречаться только находясь синтаксически внутри цикла «:keyword:`for`» или «:keyword:`while`» , но не внутри определения функции или класса или внутри ветви «:keyword:`finally`», находящихся внутри этого цикла. Эта инструкция продолжает выполнение ближайшего объемлющего цикла с нового прохода.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :keyword:`continue` passes control out of a :keyword:`try` statement with a :keyword:`finally` clause, that :keyword:`finally` clause is executed before really starting the next loop cycle.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда «:keyword:`continue`» исполняется внутри инструкции «:keyword:`try`» , имеющей ветвь «:keyword:`finally`» , то эта ветвь выполняется раньше нового прохода цикла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`import` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`import`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import statements are executed in two steps: (1) find a module, and initialize it if necessary; (2) define a name or names in the local namespace (of the scope where the :keyword:`import` statement occurs). The statement comes in two forms differing on whether it uses the :keyword:`from` keyword. The first form (without :keyword:`from`) repeats these steps for each identifier in the list. The form with :keyword:`from` performs step (1) once, and then performs step (2) repeatedly. For a reference implementation of step (1), see the :mod:`importlib` module.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкции «import» исполняются в два шага:1: находится модуль, и, если необходимо, инициализируется;2: определяется имя (или имена) в данной локальной области имён (тоесть, в той, где находится данная инструкция «:keyword:`import`» ) .Инструкция бывает двух видов : с ключевым словом «:keyword:`from`» и без. Форма без «:keyword:`from`» повторяет указанные два шага для каждого идентификатора в списке. Форма с «:keyword:`from`» исполняет шаг 1 однократно, а затем исполняет шаг 2 многократно. Подробнее об реализации шага 1 смотрите в модуле «:mod:`importlib`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To understand how step (1) occurs, one must first understand how Python handles hierarchical naming of modules. To help organize modules and provide a hierarchy in naming, Python has a concept of packages. A package can contain other packages and modules while modules cannot contain other modules or packages. From a file system perspective, packages are directories and modules are files. The original `specification for packages &lt;http://www.python.org/doc/essays/packages.html&gt;`_ is still available to read, although minor details have changed since the writing of that document.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Для понимания того, что происходит на первом шаге, нужно понимать, как Питон управляется с иерархическим именованием модулей. Для удобства организации модулей и возможности иерархического именования в Питоне есть своя концепция пакетов. Пакет может содержать другие пакеты и модули, тогда как модули не могут содержать ни других модулей ни пакетов. С точки зрения файловой системы – пакеты являются директориями (“каталогами”, “папками”) , а модули являются файлами. Оригинальная `спецификация пакетов&lt;http://www.python.org/doc/essays/packages.html&gt;`_ ещё доступна для чтения, хотя незначительные детали изменились со времени её написания.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the name of the module is known (unless otherwise specified, the term "module" will refer to both packages and modules), searching for the module or package can begin. The first place checked is :data:`sys.modules`, the cache of all modules that have been imported previously. If the module is found there then it is used in step (2) of import unless :keyword:`None` is found in :data:`sys.modules`, in which case :exc:`ImportError` is raised.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Когда имя модуля становится известно (когда не указано иное – термин “модуль” будет подразумевать как модули, так и пакеты) – начинается поиск этого модуля или пакета. Сначала проверяется «:data:`sys.modules`» – это кэш всех модулей, которые уже́ были импортированы. Если искомый модуль там найден, то он и используется на шаге 2 импортирования. Но если в «:data:`sys.modules`» для этого имени найдено «:const:`None`» , то вызывается «:exc:`ImportError`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the module is not found in the cache, then :data:`sys.meta_path` is searched (the specification for :data:`sys.meta_path` can be found in :pep:`302`). The object is a list of :term:`finder` objects which are queried in order as to whether they know how to load the module by calling their :meth:`find_module` method with the name of the module. If the module happens to be contained within a package (as denoted by the existence of a dot in the name), then a second argument to :meth:`find_module` is given as the value of the :attr:`__path__` attribute from the parent package (everything up to the last dot in the name of the module being imported). If a finder can find the module it returns a :term:`loader` (discussed later) or returns :keyword:`None`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если модуль не найден в кэше, то производится поиск в «:data:`sys.meta_path`» (спецификацию «:data:`sys.meta_path`» можно посмотреть в “:pep:`302`” ) . Этот объект является списком объектов “:term:`finder`” , которые запрашиваются по порядку на предмет того, знают ли они как загружать данный модуль, посредством вызова их метода «:meth:`find_module`» с именем данного модуля. Если оказывается, что данный модуль содержится внутри пакета (как следует из наличия точки в имени) , то второй аргумент у «:meth:`find_module`» представляет собой значение атрибута «:attr:`__path__`» из родительского пакета (всё вплоть до последней точки в имени данного импортируемого модуля) . Если “:term:`finder`” может найти модуль, то он возвращает “загрузчик” (будет рассмотрено далее) , иначе возвращает «:const:`None`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If none of the finders on :data:`sys.meta_path` are able to find the module then some implicitly defined finders are queried. Implementations of Python vary in what implicit meta path finders are defined. The one they all do define, though, is one that handles :data:`sys.path_hooks`, :data:`sys.path_importer_cache`, and :data:`sys.path`.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Если ни один из “:term:`finder`” в «:data:`sys.meta_path`» не оказался способен найти модуль, тогда запрашиваются какие-либо не явно определённые “:term:`finder`” . Реализации Питона различаются в том, каким неявным путём определяются “:term:`finder`” . Однако, одно, что все они определяют – то, что контролирует «:data:`sys.path_hooks`» , «:data:`sys.path_importer_cache`» , «:data:`sys.path`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Future statements</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция “future”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :dfn:`future statement` is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python.  The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language.  It allows use of the new features on a per-module basis before the release in which the feature becomes standard.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция “future” является особым случаем инструкции «:keyword:`import`» и является указанием компилятору о том, что данный модуль нужно компилировать, используя синтаксис либо семантику, которые будут доступны в указанной будущей версии Питона. Инструкция “future” нацелена на облегчение миграции на новые версии Питона, в которых будут введены несовместимые изменения. Это позволяет использовать новые возможности (для этого потребуется установить соответствующие модули) до версии языка, в которой они станут стандартными.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A future statement must appear near the top of the module.  The only lines that can appear before a future statement are:</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция “future” должна располагаться перед кодом модуля. До неё могут быть только следующие строки :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the module docstring (if any),</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>строка документации модуля (если есть) ,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>comments,</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>коментарии,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>blank lines, and</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>пустые строки,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>other future statements.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>другие инструкции “future” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The features recognized by Python 3.0 are ``absolute_import``, ``division``, ``generators``, ``unicode_literals``, ``print_function``, ``nested_scopes`` and ``with_statement``.  They are all redundant because they are always enabled, and only kept for backwards compatibility.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Питон 3.0 знает следующие свойства : «``absolute_import``» , «``division``» , «``generators``» , «``unicode_literals``» , «``print_function``» , «``nested_scopes``» , «``with_statement``» . Но все они уже́ устарели, поскольку уже́ встроены в язык и всегда доступны, и сохранены только для обратной совместимости.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A future statement is recognized and treated specially at compile time: Changes to the semantics of core constructs are often implemented by generating different code.  It may even be the case that a new feature introduces new incompatible syntax (such as a new reserved word), in which case the compiler may need to parse the module differently.  Such decisions cannot be pushed off until runtime.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция “future” распознаётся и обрабатывается особым образом на этапе компиляции, поскольку изменения в семантике базовых конструкций зачастую реализуются путём генерации и подстановки совсем другого кода (соответствующего текущей версии языка) . Может даже быть так, что новое свойство вводит новый несовместимый синтаксис (например, новое зарезервированное слово) , в результате чего компилятору необходимо интерпретировать данный модуль совсем по-другому. Такие меры не могут быть отложены до этапа исполнения программы (“runtime”) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For any given release, the compiler knows which feature names have been defined, and raises a compile-time error if a future statement contains a feature not known to it.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Компилятор знает, какие имена будущих свойств определены в конкретной данной версии и инициирует ошибку этапа компилирования, если инструкция “future” содержит свойство, которое ему не известно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The direct runtime semantics are the same as for any import statement: there is a standard module :mod:`__future__`, described later, and it will be imported in the usual way at the time the future statement is executed.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>За исключением указанного выше – на этапе исполнения имеет тот же смысл, что и любое выражение «:keyword:`import`» , тоесть : имеется стандартный модуль «:mod:`__future__`» (описано далее) , и он будет импортирован обычным образом в момент исполнения соответствующей инструкции “future” .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting runtime semantics depend on the specific feature enabled by the future statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Влияние на выполнение программы сильно зависит от того, какие свойства задействованы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is nothing special about the statement::</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Заметьте, что следующая инструкция не интерпретируется как-либо исключительно : ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import __future__ [as name]</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>import __future__ [as name]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is not a future statement; it's an ordinary import statement with no special semantics or syntax restrictions.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Это не инструкция “future” – это обычная инструкция «:keyword:`import`» без каких-либо исключительных смысла или синтаксиса.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code compiled by calls to the built-in functions :func:`exec` and :func:`compile` that occur in a module :mod:`M` containing a future statement will, by default, use the new syntax or semantics associated with the future statement.  This can be controlled by optional arguments to :func:`compile` --- see the documentation of that function for details.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Код, компилируемый посредством встроенных функций «:func:`exec`» и «:func:`compile`» , вызываемых из модуля, содержащего инструкцию “future” , по-умолчанию тоже испытывает эффект этой инструкции – интерпретируется с соответствующими новыми синтаксисом и смыслом. Для «:func:`compile`» этот эффект можно контролировать через необязательный аргумент (подробности смотрите в документации по данной функции) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A future statement typed at an interactive interpreter prompt will take effect for the rest of the interpreter session.  If an interpreter is started with the :option:`-i` option, is passed a script name to execute, and the script includes a future statement, it will be in effect in the interactive session started after the script is executed.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция “future” , введённая на запрос интерактивного интерпретатора, будет оказывать эффект до конца работы интерпретатора. Если интерпретатор был запущен с опцией «:option:`-i`» и именем скрипта, и этот скрипт содержит инструкцию “future” , то она будет в силе и после перехода к интерактивной сессии после завершения скрипта.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The original proposal for the __future__ mechanism.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Исходное предложение по механизму «``__future__``» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`global` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`global`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`global` statement is a declaration which holds for the entire current code block.  It means that the listed identifiers are to be interpreted as globals.  It would be impossible to assign to a global variable without :keyword:`global`, although free variables may refer to globals without being declared global.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Действие инструкции «:keyword:`global`» распространяется на весь текущий блок кода. Она указывает, что перечисленные в ней идентификаторы должны интерпретироваться как глобальные. Может оказаться невозможным получить доступ к некой глобальной переменной без инструкции «:keyword:`global`» , но переменные, не связанные в данной области имён, обращаются к глобальным переменным – не будучи объявленными как глобальные.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Names listed in a :keyword:`global` statement must not be used in the same code block textually preceding that :keyword:`global` statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Идентификаторы, перечисленные в инструкции «:keyword:`global`» не должны использоваться в том же блоке кода выше по тексту, чем эта инструкция.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Names listed in a :keyword:`global` statement must not be defined as formal parameters or in a :keyword:`for` loop control target, :keyword:`class` definition, function definition, or :keyword:`import` statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Идентификаторы, перечисленные в инструкции «:keyword:`global`» не должны объявляться как параметры в определении функции, или как “цель” в конструкции цикла «:keyword:`for`» , или в определениях класса или функции, или в инструкции «:keyword:`import`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current implementation does not enforce the latter two restrictions, but programs should not abuse this freedom, as future implementations may enforce them or silently change the meaning of the program.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Текущая реализация не навязывает эти два последних ограничения, но всё-же программам не следует злоупотреблять этой свободой, поскольку будущие реализации могут ввести эти ограничения или, не выдавая сообщения об ошибке, интерпретировать по-другому.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Programmer's note:** the :keyword:`global` is a directive to the parser.  It applies only to code parsed at the same time as the :keyword:`global` statement. In particular, a :keyword:`global` statement contained in a string or code object supplied to the built-in :func:`exec` function does not affect the code block *containing* the function call, and code contained in such a string is unaffected by :keyword:`global` statements in the code containing the function call.  The same applies to the :func:`eval` and :func:`compile` functions.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>**Замечание для программистов :** «:keyword:`global`» – это указание, предназначенное анализатору текста (парсеру) . Оно относится только к коду, обрабатываемому одновременно с этой инструкцией «:keyword:`global`» . В норме – инструкция «:keyword:`global`» , содержащаяся в строке или в объекте-коде, передаваемых во встроенную функцию «:func:`exec`» , не влияет на блок кода, в котором этот вызов функции содержится. И обратно, код, содержащийся в такого рода тексте, не испытывает действия инструкции «:keyword:`global`» , находящейся в коде, из которого сделан вызов этой функции с текстом. То же относится и к функциям «:func:`eval`» и «:func:`compile`» .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`nonlocal` statement</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`nonlocal`»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :keyword:`nonlocal` statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope.  This is important because the default behavior for binding is to search the local namespace first.  The statement allows encapsulated code to rebind variables outside of the local scope besides the global (module) scope.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Инструкция «:keyword:`nonlocal`» приводит к тому, что перечисленные в ней идентификаторы будут указывать на объекты, на которые они указывали в ближайшей внешней области имён. Это принципиально отличается от поведения связывания по-умолчанию, при котором сначала происходит поиск в локальной области имён. Эта инструкция позволяет изолированному (инкапсулированному) коду возвращать связывание переменных, существовавшее у них за пределами данной локальной области имён помимо того, что относится к глобальной (на уровне модуля) области имён.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Names listed in a :keyword:`nonlocal` statement, unlike to those listed in a :keyword:`global` statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Имена, перечисленные в инструкции «:keyword:`nonlocal`» , в отличие от тех, что перечислены в инструкции «:keyword:`global`» , обязаны указывать на уже́ существующие назначения в непосредственно объемлющей области имён (та область, в которой новые связывания могли бы быть созданы, не может быть установлена однозначно) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Names listed in a :keyword:`nonlocal` statement must not collide with pre-existing bindings in the local scope.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Среди имён, перечисленных в инструкции «:keyword:`nonlocal`» не должно быть тех, что уже́ существуют в этой локальной области имён.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The specification for the :keyword:`nonlocal` statement.</seg>
      </tuv>
      <tuv xml:lang="ru">
        <seg>Спецификация инструкции «:keyword:`nonlocal`» .</seg>
      </tuv>
    </tu>
  </body>
</tmx>
