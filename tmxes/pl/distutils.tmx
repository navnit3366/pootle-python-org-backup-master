<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.1.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>API Reference</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podręcznik sprzęgów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.core` --- Core Distutils functionality</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.core` --- Bazowa użyteczność modułu Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`distutils.core` module is the only module that needs to be installed to use the Distutils. It provides the :func:`setup` (which is called from the setup script). Indirectly provides the  :class:`distutils.dist.Distribution` and :class:`distutils.cmd.Command` class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`distutils.core` jest jedynym modułem, który należy zainstalować aby korzystać z Distutils. Zawiera zadanie :func:`setup`, które jest wywoływane w skryptach instalacyjnych. Pośrednio, dostarcza także klas :class:`distutils.dist.Distribution` i :class:`distutils.cmd.Command`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic do-everything function that does most everything you could ever ask for from a Distutils method. See XXXXX</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawowe robiące-wszystko zadanie, która zajmuje się wszystkim, czego tylko można oczekiwać od metody Distutils. Zob. XXXXX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setup function takes a large number of arguments. These are laid out in the following table.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie setup przyjmuje znaczną ilość argumentów. Ich opis można znaleźć w poniższej tabeli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>argument name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nazwa parametru</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>value</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wartość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>type</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*name*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*name*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a string</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ciąg znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*version*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*version*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version number of the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Numer wersji pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See :mod:`distutils.version`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz :mod:`distutils.version`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*description*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*description*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A single line describing the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pojedyncza linia opisująca pakiet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*long_description*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*long_description*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Longer description of the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dłuższy opis pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*author*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*author*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the package author</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Imię i nazwisko autora pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*author_email*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*author_email*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The email address of the package author</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Adres e-mail autora pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*maintainer*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*maintainer*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the current maintainer, if different from the author</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Imię osoby aktualnie opiekujacej się pakietem, jeśli jest inna niż jego autor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*maintainer_email*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*maintainer_email*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The email address of the current maintainer, if different from the author</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Adres e-mail osoby aktualnie opiekujacej się pakietem, jeśli jest inna niż jego autor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*url*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*url*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A URL for the package (homepage)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Adres URL pakietu (strona domowa)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a URL</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>URL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*download_url*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*download_url*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A URL to download the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Adres URL, spod którego można ściągnąć pakiet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*packages*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*packages*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of Python packages that distutils will manipulate</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista pakietów języka pytonowskiego, na których distutils będzie operować</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a list of strings</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista ciągów znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*py_modules*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*py_modules*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of Python modules that distutils will manipulate</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista modułów języka pytonowskiego, na których distutils będzie operować</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*scripts*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*scripts*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of standalone script files to be built and installed</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista wykonywalnych skryptów, które zostaną zbudowane i zainstalowane</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*ext_modules*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*ext_modules*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of Python extensions to be built</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista rozszerzeń Pythona, które zostaną zbudowane</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of  instances of :class:`distutils.core.Extension`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista przykładów uogólnienia :class:`distutils.core.Extension`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*classifiers*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*classifiers*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of categories for the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista kategorii, do których należy pakiet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of available categorizations is at http://pypi.python.org/pypi?:action=list_classifiers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista dostępnych kategorii znajduje się pod adresem http://pypi.python.org/pypi?:action=list_classifiers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*distclass*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*distclass*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the :class:`Distribution` class to use</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie, która zostanie użyte zamiast :class:`Distribution`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A subclass of :class:`distutils.core.Distribution`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podrzędne uogólnienie :class:`distutils.core.Distribution`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*script_name*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*script_name*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the setup.py script - defaults to ``sys.argv[0]``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa skryptu setup.py - domyslnie ``sys.argv[0]``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*script_args*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*script_args*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arguments to supply to the setup script</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Argumenty do przekazania do skryptu instalacyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*options*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*options*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default options for the setup script</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>domyślne opcje dla skryptu instalacyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*license*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*license*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The license for the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Licencja pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*keywords*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*keywords*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Descriptive meta-data, see :pep:`314`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opisowe dane o danych, zob. :pep:`314`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*platforms*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*platforms*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*cmdclass*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*cmdclass*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A mapping of command names to :class:`Command` subclasses</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Słownik mapujący nazwy poleceń do uogólnień podrzędnych uogólnienia :class:`Command`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a dictionary</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>słownik</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*data_files*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*data_files*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A list of data files to install</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista plików z danymi do zainstalowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a list</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*package_dir*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*package_dir*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A mapping of package to directory names</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Słownik mapujący nazwy pakietów języka pytonowskiego na nazwy katalogów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run a setup script in a somewhat controlled environment, and return  the :class:`distutils.dist.Distribution` instance that drives things.   This is useful if you need to find out the distribution meta-data  (passed as keyword args from *script* to :func:`setup`), or  the contents of the config files or command-line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj skrypt instalacyjny w umiarkowanie kontrolowanym środowisku i zwróć przykład uogólnienia :class:`distutils.dist.Distribution`, która napędza rzeczy. Przydatne, gdy potrzebujesz uzyskać informacje o danych dystrybucji (przekazane jako nazwane argumenty ze skryptu *script* dla zadania :func:`setup`), lub zawartość plików konfiguracyjnych, czy też linii poleceń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*script_name* is a file that will be read and run with :func:`exec`.  ``sys.argv[0]`` will be replaced with *script* for the duration of the call.  *script_args* is a list of strings; if supplied, ``sys.argv[1:]`` will be replaced by *script_args* for the duration  of the call.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*script_name* jest nazwą pliku, który zostanie wykonany przy pomocy :func:`exec`. Na czas wykonania, ``sys.argv[0]`` zostanie zastąpione wartością *script*, a ``sys.argv[1:]`` przez *script_args* , jeśli ten parametr został określony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*stop_after* tells :func:`setup` when to stop processing; possible  values:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*stop_after* informuje zadanie :func:`setup` kiedy powininno się zatrzymać; Możliwe wartości:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>description</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*init*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*init*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop after the :class:`Distribution` instance has been created  and populated with the keyword arguments to :func:`setup`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skończ po tym jak zostanie przygotowany przykład uogólnienia :class:`Distribution` i wypełniona nazwanymi parametrami z wywołania zadania :func:`setup`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*config*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*config*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop after config files have been parsed (and their data stored in the :class:`Distribution` instance)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj po wczytaniu plików konfiguracji (i po zachowaniu danych w przykładzie uogólnienia :class:`Distribution`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*commandline*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*commandline*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop after the command-line (``sys.argv[1:]`` or  *script_args*) have been parsed (and the data stored in the :class:`Distribution` instance.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj po wczytaniu linii poleceń (``sys.argv[1:]`` lub *script_args*) (a dane zachowane w przykładzie uogólnienia :class:`Distribution`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*run*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*run*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop after all commands have been run (the same as  if :func:`setup` had been called in the usual way). This is the default value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przerwij uruchomienie po tym jak wszystkie polecenia zostaną wykonane. Daje to taki sam efekt jak zwyczajne uruchomienie zadania :func:`setup`. To jest wartość domyślna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the :mod:`distutils.core` module exposed a number of  classes that live elsewhere.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Co więcej, moduł :mod:`distutils.core` zawiera sporo uogólnień które znajdują się także gdzie indziej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Extension` from :mod:`distutils.extension`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Extension` z modułu :mod:`distutils.extension`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Command` from :mod:`distutils.cmd`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>uogólnienie :class:`Command` z modułu :mod:`distutils.cmd`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Distribution` from :mod:`distutils.dist`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Distribution` z modułu :mod:`distutils.dist`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A short description of each of these follows, but see the relevant module for the full reference.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poniżej znajduje się krótki opis każdej z nich, ale pełen podręcznik znajdziesz w dokumentacji odpowiedniego modułu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Extension class describes a single C or C++extension module in a setup script. It accepts the following keyword arguments in its constructor</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie Extension opisuje pojedynczy moduł rozszerzenia C lub C++ w skrypcie instalacyjnym. Przyjmuje następujące parametry kluczowe w swoim konstruktorze.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the full name of the extension, including any packages --- ie. *not* a filename or pathname, but Python dotted name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pełna nazwa rozszerzenia, zawierająca dowolne pakiety --- tj. *nie* nazwa pliku czy nazwa ścieżki dostępu, ale wykropkowana nazwa pliku w języku pytonowskim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>string</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ciąg znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*sources*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*sources*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of source filenames, relative to the distribution root (where the setup script lives), in Unix form (slash- separated) for portability. Source files may be C, C++, SWIG (.i), platform-specific resource files, or whatever else is recognized by the :command:`build_ext` command as source for a Python extension.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista źródłowych nazw plików, względem katalogu głównego instalacji (tam gdzie znajduje się skrypt instalacyjny), w postaci Unixowej (oddzielonej "slash"-ami) dla przenośności. Pliki źródłowe mogą być C, C++, SWIG (.i), szczególne dla maszyny pliki zasobów, lub cokolwiek innego jest rozpoznane przez komendę :command:`build_ext` jako źródło rozszerzenia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*include_dirs*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*include_dirs*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of directories to search for C/C++ header files (in Unix form for portability)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista katalogów do przeszukania pod kątem plików nagłówkowych C/C++ (w Unixowej postaci dla przenośności)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*define_macros*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*define_macros*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of macros to define; each macro is defined using a 2-tuple ``(name, value)``, where *value* is either the string to define it to or ``None`` to define it without a particular value (equivalent of ``#define FOO`` in source or :option:`-DFOO` on Unix C compiler command line)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista makropoleceń do określenia; każde makropolecenie jest zdefiniowane używając 2-krotkę ``(nazwa, wartość)``, gdzie *wartość* jest albo ciągiem znaków do zdefiniowania go lub ``żaden`` z ang. - ``None`` do zdefiniowania go bez szczególnej wartości (równoważny ``#define FOO`` w źródle lub opcji :option:`-DFOO` w linii poleceń kompilatora dla Unixa)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(string, string) tuple or (name, ``None``)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>krotka (ciąg znaków, ciąg znaków) lub (nazwa, ``None``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*undef_macros*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*undef_macros*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of macros to undefine explicitly</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista makropoleceń do wyłączenia definicji jawnie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*library_dirs*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*library_dirs*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of directories to search for C/C++ libraries at link time</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista katalogów do przeszukania pod kątem bibliotek C/C++ w czasie łączenia źródeł</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*libraries*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*libraries*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of library names (not filenames or paths) to link against</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista nazw bibliotek (nie nazw plików czy nazw ścieżek) do przeprowadzenia łączenia źródeł.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*runtime_library_dirs*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*runtime_library_dirs*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of directories to search for C/C++ libraries at run time (for shared extensions, this is when the extension is loaded)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista katalogów do przeszukania pod kątem bibliotek C/C++ w czasie wykonania programu (dla współdzielonych rozszerzeń, to jest moment gdy rozszerzenie jest ładowane)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*extra_objects*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*extra_objects*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of extra files to link with (eg. object files not implied by 'sources', static library that must be explicitly specified, binary resource files, etc.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista dodatkowych plików do podłączenia (np. plików przedmiotowych nie wynikających ze 'źródeł', statyczna biblioteka która musi być jawnie wyszczególniona, pliki zasobów binarnych, itp.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*extra_compile_args*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*extra_compile_args*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>any extra platform- and compiler-specific information to use when compiling the source files in 'sources'. For platforms and compilers where a command line makes sense, this is typically a list of command-line arguments, but for other platforms it could be anything.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dowolne dodatkowe szczególne dla maszyny lub szczególne dla środowiska informacje do użycia podczas kompilacji plików źródłowych w 'źródłach'. Dla maszyn i kompilatorów gdzie ma sens wiersz poleceń, to jest zwykle lista parametrów wiersza polecenia, ale dla innych maszyn/kompilatorów to może być cokolwiek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*extra_link_args*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*extra_link_args*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>any extra platform- and compiler-specific information to use when linking object files together to create the extension (or to create a new static Python interpreter). Similar interpretation as for 'extra_compile_args'.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dowolne dodatkowe szczególne dla maszyny lub kompilatora informacje do użycia podczas łączenia plików przedmiotów razem aby stworzyć rozszerzenie (lub by stworzyć nowy statyczny program interpretujący polecenia języka pytonowskiego). Podobna interpretacja jak dla 'extra_compile_args'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*export_symbols*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*export_symbols*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of symbols to be exported from a shared extension. Not used on all platforms, and not generally necessary for Python extensions, which typically export exactly one symbol: ``init`` + extension_name.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista symboli do wystawienia na zewnątrz ze współdzielonego rozszerzenia. Nie używane na wszystkich maszynach, i zwykle nie konieczne dla rozszerzeń języka pytonowskiego, który zwykle wystawia dokładnie jeden symbol: ``init`` + extension_name.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*depends*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*depends*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of files that the extension depends on</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista plików od którego rozszerzenie zależy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*language*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*language*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>extension language (i.e. ``'c'``, ``'c++'``, ``'objc'``). Will be detected from the source extensions if not provided.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>język rozszerzeń (tj. ``'c'``, ``'c++'``, ``'objc'``). Zostanie wykryty ze źródeł rozszerzenia jeśli nie zostanie dostarczony jawnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Distribution` describes how to build, install and package up a Python software package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Distribution` określa jak zbudować, zainstalować i zapakować pakiet oprogramowania języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the :func:`setup` function for a list of keyword arguments accepted  by the Distribution constructor. :func:`setup` creates a Distribution instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz zadanie :func:`setup` dla listy parametrów kluczowych akceptowanych przez konstruktor dystrybucji. Zadanie :func:`setup` tworzy przykład dystrybucji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Command` class (or rather, an instance of one of its subclasses) implement a single distutils command.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Command` (lub raczej, przykład jednego z jej uogólnień podrzędnych) wypełnia pojedynczą komendę distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.ccompiler` --- CCompiler base class</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.ccompiler` --- Uogólnienie podstawowe kompilatora C </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the abstract base class for the :class:`CCompiler` classes.  A :class:`CCompiler` instance can be used for all the compile  and link steps needed to build a single project. Methods are provided to  set options for the compiler --- macro definitions, include directories,  link path, libraries and the like.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza abstrakcyjne podstawowe uogólnienie dla uogólnień pochodnych :class:`CCompiler`. Przykład uogólnienia :class:`CCompiler` można użyć dla wszystkich kroków kompilacji i łączenia źródeł potrzebnych do zbudowania pojedynczego projektu. Sposoby postępowania są dostarczone aby ustawić opcje kompilatora --- makrodefinicje, katalogi łączenia źródeł, biblioteki i tym podobne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the following functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza następujące zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate linker options for searching library directories and linking with specific libraries.  *libraries* and *library_dirs* are, respectively, lists of library names (not filenames!) and search directories.  Returns a list of command-line options suitable for use with some compiler (depending on the two format strings passed in).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Generuj opcje łączenia źródeł dla przeszukiwania katalogów bibliotek i łączenia ze poszczególnymi bibliotekami. *libraries* i *library_dirs* są, odpowiednio, listami nazw bibliotek* (nie nazwami plików!) i katalogami poszukiwania. Zwraca listę opcji wiersza-poleceń odpowiednią dla użycia z danym kompilatorem (w zależności od dwóch ciągów formatujących przekazanych do wewnątrz).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate C pre-processor options (:option:`-D`, :option:`-U`, :option:`-I`) as used by at least two types of compilers: the typical Unix compiler and Visual C++. *macros* is the usual thing, a list of 1- or 2-tuples, where ``(name,)`` means undefine (:option:`-U`) macro *name*, and ``(name, value)`` means define (:option:`-D`) macro *name* to *value*.  *include_dirs* is just a list of directory names to be added to the header file search path (:option:`-I`). Returns a list of command-line options suitable for either Unix compilers or Visual C++.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Generuj opcje pre-procesora C (:option:`-D`, :option:`-U`, :option:`-I`) jak w użyciu przez przynajmniej dwa rodzaje kompilatorów: typowy kompilator Unixa i Visual C++. *makrodefinicje* są typową rzeczą, lista 1- lub 2-krotek gdzie ``(nazwa,)`` oznacza zdjęcie definicji (:option:`-U`) makrodefinicji *nazwa*, a ``(nazwa,wartość)`` oznacza definicję (:option:`-D`) makrodefinicji *nazwa* pod *wartość*. *include_dirs* jest po prostu listą nazw katalogów do dodania do ścieżki poszukiwania plików nagłówkowych (:option:`-I`). Zwraca listę opcji wiersza poleceń odpowiednich dla zarówno kompilatora Unixa jak i Visual C++. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Determine the default compiler to use for the given platform.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustala domyślny kompilator do użytku na danej maszynie i danym środowisku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*osname* should be one of the standard Python OS names (i.e. the ones returned by ``os.name``) and *platform* the common value returned by ``sys.platform`` for the platform in question.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*osname* powinna być jedną ze standardowych nazw systemu operacyjnego języka pytonowskiego (tj. te zwracane przez ``os.name``) i *platform* często wartość  zwracana przez ``sys.platform`` dla danego środowiska na danej maszynie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default values are ``os.name`` and ``sys.platform`` in case the parameters are not given.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartości domyślne są ``os.name`` i ``sys.platform`` w razie gdyby parametry nie były dane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Factory function to generate an instance of some CCompiler subclass for the supplied platform/compiler combination. *plat* defaults to ``os.name`` (eg. ``'posix'``, ``'nt'``), and *compiler*  defaults to the default compiler for that platform. Currently only ``'posix'`` and ``'nt'`` are supported, and the default compilers are "traditional Unix interface" (:class:`UnixCCompiler` class) and Visual C++ (:class:`MSVCCompiler` class).  Note that it's perfectly possible to ask for a Unix compiler object under Windows, and a Microsoft compiler object under Unix---if you supply a value for *compiler*, *plat* is ignored.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie fabryczne generujące przykłady pewnego podrzędnego uogólnienia względem uogólnienia CCompiler dla dostarczonej kombinacji środowiska/kompilatora. *plat* zmienia się domyślnie na ``os.name`` (np. ``'posix'``, ``'nt'``), i *kompilator* (z ang. - *compiler* ) zmienia się domyślnie na domyślny kompilator dla danego środowiska. Obecnie tylko ``'posix'`` i ``'nt'`` są wspierane a domyślnymi kompilatorami są "tradycyjny sprzęg Unixa" (uogólnienie :class:`UnixCCompiler`) i Visual C++ (uogólnienie :class:`MSVCCompiler`). Zauważ, że jest całkowicie możliwe zapytanie o przedmiot kompilowany Unixa pod Windows, i przedmiot kompilatora Microsoftu pod Unixem --- jeśli dostarczysz wartość dla *kompilatora* (z ang. *compiler*), *plat* jest ignorowana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print list of available compilers (used by the :option:`--help-compiler` options to :command:`build`, :command:`build_ext`, :command:`build_clib`).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisuje listę dostępnych kompilatorów (używaną przez opcję :option:`--help-compiler` dla budowania - :command:`build`, budowania rozszerzeń - :command:`build_ext` i budowania bibliotek C - :command:`build_clib`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The abstract base class :class:`CCompiler` defines the interface that  must be implemented by real compiler classes.  The class also has  some utility methods used by several compiler classes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjne podstawowe uogólnienie :class:`CCompiler` określa sprzęgi które muszą być wypełnione przez rzeczywiste uogólnienia kompilatorów. Uogólnienie także ma pewne użyteczne sposoby postępowania używane przez kilka uogólnień kompilatorów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic idea behind a compiler abstraction class is that each instance can be used for all the compile/link steps in building a single project.  Thus, attributes common to all of those compile and link steps --- include directories, macros to define, libraries to link against, etc. --- are attributes of the compiler instance.  To allow for variability in how individual files are treated, most of those attributes may be varied on a per-compilation or per-link basis.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawową sprawą stojącą za abstrakcyjnym uogólnieniem kompilatora jest to, że każdy przykład może być użyty dla wszystkich kroków kompilacji/łączenia plików w budowaniu pojedynczego projektu. Zatem właściwości wspólne dla wszystkich kroków kompilacji i łączenia --- zawarcie katalogów, makrodefinicje do zdefiniowania, biblioteki do podłączenia itp. --- są właściwościami przykładu kompilatora. Aby umożliwić różnorodność w tym, jak pojedyncze pliki są traktowane, większość z tych właściwości może być zróżnicowanych na poziomie poszczególnych kompilacji i poszczególnych złączeń plików.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The constructor for each subclass creates an instance of the Compiler object. Flags are *verbose* (show verbose output), *dry_run* (don't actually execute the steps) and *force* (rebuild everything, regardless of dependencies). All of these flags default to ``0`` (off). Note that you probably don't want to instantiate :class:`CCompiler` or one of its subclasses directly - use the :func:`distutils.CCompiler.new_compiler` factory function instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor każdego podrzędnego uogólnienia tworzy przykład przedmiotu Kompilatora. Flagami są *verbose* (pokaż słowny wynik), *dry_run* (z ang. "na sucho" - właściwie nie wykonuj kroków) i *force* (przebuduj wszystko, niezależnie do zależności). Wszystkie te flagi domyślnie są równe ``0`` (wyłączone). Zauważ, że prawdopodobnie nie potrzebujesz dawać przykładu uogólnienia :class:`CCompiler` lub jednego z jego uogólnień podrzędnych w bezpośredni sposób - zamiast tego możesz użyć fabrykującego zadania :func:`distutils.CCompiler.new_compiler`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods allow you to manually alter compiler options for  the instance of the Compiler class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sposoby postępowania pozwalają ręcznie zmienić opcje kompilacji dla przykładu uogólnienia Kompilatora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *dir* to the list of directories that will be searched for header files. The compiler is instructed to search directories in the order in which they are supplied by successive calls to :meth:`add_include_dir`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj *dir do listy katalogów które będą przeszukiwane pod kątem plików nagłówkowych. Kompilator ma zadanie przeszukać katalogi w kolejności w której zostaną mu dostarczone przez kolejne wywołania sposobu postępowania :meth:`add_include_dir`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the list of directories that will be searched to *dirs* (a list of strings). Overrides any preceding calls to :meth:`add_include_dir`; subsequent calls to :meth:`add_include_dir` add to the list passed to :meth:`set_include_dirs`. This does not affect any list of standard include directories that the compiler may search by default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw listę katalogów które będą zprzeszukiwane na *dirs* (listę ciągów znaków). Obchodzi wszystkie poprzednie wywołania sposobu postępowania :meth:`add_include_dir`; następne wywołania sposobu postępowania :meth:`add_include_dir` dodają pozycje do listy przekazywanej do sposobu postępowania :meth:`set_include_dirs`. Nie ma to wpływu na żadną listę standardowych katalogów załączanych które kompilator przeszukuje domyślnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *libname* to the list of libraries that will be included in all links driven by this compiler object.  Note that *libname* should \*not\* be the name of a file containing a library, but the name of the library itself: the actual filename will be inferred by the linker, the compiler, or the compiler class (depending on the platform).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj *libname* do listy bibliotek, które zostaną załączona we wszystkich złączeniach źródeł przeprowadzonych przez ten przedmiot kompilatora. Zauważ, że *libname* \*nie\* powinien być nazwą pliku zawierającego bibliotekę, ale nazwą biblioteki samą w sobie: konkretna nazwa pliku zostanie wywiedziona przez program łączący źródła, kompilator lub uogólnienie kompilatora (w zależności od maszyny/środowiska).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The linker will be instructed to link against libraries in the order they were supplied to :meth:`add_library` and/or :meth:`set_libraries`.  It is perfectly valid to duplicate library names; the linker will be instructed to link against libraries as many times as they are mentioned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Program łączący będzie miał za zadanie łączyć z bibliotekami w kolejności w jakiej zostały mu dostarczone do :meth:`add_library` i/lub :meth:`set_libraries`. Jest to całkowicie na miejscu duplikować nazwy bibliotek; program łączący zostanie pokierowany aby łączyć z bibliotekami tak wiele razy jak są one wymienione. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the list of libraries to be included in all links driven by this compiler object to *libnames* (a list of strings).  This does not affect any standard system libraries that the linker may include by default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw listę bibliotek do podłączenia we wszystkich złączeniach prowadzonych przez ten przedmiot kompilatora na *libnames* (listę ciągów znaków). Nie wpływa to na żadne standardowe systemowe biblioteki które program łączący mógł załączyć automatycznie. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *dir* to the list of directories that will be searched for libraries specified to :meth:`add_library` and :meth:`set_libraries`.  The linker will be instructed to search for libraries in the order they are supplied to :meth:`add_library_dir` and/or :meth:`set_library_dirs`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj katalog *dir* do listy katalogów które będą przeszukiwane pod kątem bibliotek wyszczególnionych dla sposobów postępowania :meth:`add_library` i :meth:`set_libraries`. Program łączący pliki źródłowe zostanie poprowadzony aby poszukiwał bibliotek w kolejności w której są one dostarczone do sposobów postępowania :meth:`add_library_dir` i/lub :meth:`set_library_dirs`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the list of library search directories to *dirs* (a list of strings).  This does not affect any standard library search path that the linker may search by default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustal listę katalogów poszukiwań bibliotek na *dirs* (listę ciągów znaków). To nie wpływa na żadną standardową ścieżkę poszukiwania bibliotek którą program łączący mógłby poszukiwać domyślnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *dir* to the list of directories that will be searched for shared libraries at runtime.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj katalog ( z ang. - *dir*) do listy katalogów które będą przeszukiwane pod kątem współdzielonych bibliotek w czasie wykonywania programu po skompilowaniu go do postaci wynikowej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the list of directories to search for shared libraries at runtime to *dirs* (a list of strings).  This does not affect any standard search path that the runtime linker may search by default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw listę katalogów do przeszukania na obecność współdzielonych bibliotek w czasie wykonania wynikowego programu na *dirs* ( - z ang. katalogi)  (w postaci listy ciągów znaków). To nie wpływa na żadne standardowe ścieżki poszukiwań, które program łączący z programem wynikowym mógłby poszukiwać domyślnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a preprocessor macro for all compilations driven by this compiler object. The optional parameter *value* should be a string; if it is not supplied, then the macro will be defined without an explicit value and the exact outcome depends on the compiler used (XXX true? does ANSI say anything about this?)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdefiniuj makropolecenie preprocesora dla wszystkich kompilacji prowadzonych przez obiekt kompilatora. Opcjonalny parametr *value* ( - z ang. - wartość) powinien być ciągiem znaków; jeśli nie jest dostarczony, wtedy makropolecenie będzie zdefiniowane bez jawnej wartości i konkretny wynik zależeć będzie on użytego kompilatora (XXX na prawdę? czy  ANSI mówi coś na ten temat?)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Undefine a preprocessor macro for all compilations driven by this compiler object.  If the same macro is defined by :meth:`define_macro` and undefined by :meth:`undefine_macro` the last call takes precedence (including multiple redefinitions or undefinitions).  If the macro is redefined/undefined on a per-compilation basis (ie. in the call to :meth:`compile`), then that takes precedence.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyłącz makrodefinicję preprocesora dla wszystkich kompilacji prowadzonych przez ten obiekt kompilujący. Jeśli ta sama makrodefinicja jest zdefiniowana przez sposób postępowania :meth:`define_macro` i odłączane przez :meth:`undefine_macro` ostatnie wywołanie ma pierwszeństwo (włączając w to wielokrotnie powtarzane redefinicje i odwołania definicji). Jeśli makrodefinicja jest ponownie definiowane/odwoływane za każdym razem gdy następuje nowa kompilacja (tj. w momencie wywołania sposobu postępowania :meth:`compile`), wtedy to ostatnie ma pierwszeństwo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *object* to the list of object files (or analogues, such as explicitly named library files or the output of "resource compilers") to be included in every link driven by this compiler object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj *przedmiot* do listy plików przedmiotów (lub analogów, takich jak jawnie nazwane pliki bibliotek lub wyjście "kompilatora zasobów") aby był załączony w każdym złączeniu źródeł prowadzonym przez ten obiekt kompilacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the list of object files (or analogues) to be included in every link to *objects*.  This does not affect any standard object files that the linker may include by default (such as system libraries).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw listę plików przedmiotów (lub analogów) aby były załączane w każdym łączu do *przedmiotów* (z ang. - *objects*). To nie wpływa na żadne standardowe pliki przedmiotów które program łączący mógłby załączać automatycznie (takich jak biblioteki systemowe).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods implement methods for autodetection of compiler  options, providing some functionality similar to GNU :program:`autoconf`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sposoby postępowania wypełniają sposoby postępowania dla automatycznego wykrywania opcji kompilatora, dostarczając pewnych użyteczności podobnych do programu GNU :program:`autoconf`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Detect the language of a given file, or list of files. Uses the  instance attributes :attr:`language_map` (a dictionary), and  :attr:`language_order` (a list) to do the job.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykryj język danego pliku, lub listy plików, Używa właściwości przykładu :attr:`language_map` (słownika) i :attr:`language_order` (listy) aby wykonać co należy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Search the specified list of directories for a static or shared library file *lib* and return the full path to that file.  If *debug* is true, look for a debugging version (if that makes sense on the current platform).  Return ``None`` if *lib* wasn't found in any of the specified directories.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przeszukaj wyszczególnioną listę katalogów na obecność pliku statycznej lub współdzielonej biblioteki *lib* i zwraca pełną ścieżkę do tego pliku. Jeśli *debug* jest prawdziwy, poszukaj wersji debugującej (jeśli ma to sens na obecnej maszynie/środowisku). Zwróć ``Żaden`` ( - z ang. - ``None`` ) jeśli biblioteka *lib* nie została znaleziona w żadnym z określonych katalogów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a boolean indicating whether *funcname* is supported on the current platform.  The optional arguments can be used to augment the compilation environment by providing additional include files and paths and libraries and paths.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wartość typu boolean (prawda/fałsz) wskazującą czy *funcname* - z ang. nazwa zadania jest wspierana na obecnej maszynie/środowisku. Opcjonalne parametru mogą być użyte aby wzbogacić środowisko kompilacji przez dostarczenie dodatkowych plików źródłowych do załączenia i ścieżek dostępu do nich i bibliotek i ścieżek dostępu do nich.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the compiler option to add *dir* to the list of directories searched for libraries.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć opcję kompilatora aby dodać katalog - *dir* do listy katalogów przeszukiwanych pod kątem bibliotek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the compiler option to add *dir* to the list of libraries linked into the shared library or executable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć opcję kompilatora dodającą katalog - *dir* do listy bibliotek załączonych do współdzielonej biblioteki lub pliku wykonywalnego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the compiler option to add *dir* to the list of directories searched for runtime libraries.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć opcję kompilatora dodającą katalog - *dir* do listy katalogów poszukiwań bibliotek czasu wykonania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the executables (and options for them) that will be run to perform the various stages of compilation.  The exact set of executables that may be specified here depends on the compiler class (via the 'executables' class attribute), but most will have:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określ pliki wykonywalne (i opcje dla nich) które będą uruchamiane aby wykonać różne kroki kompilacji. Dokładny zbiór plików wykonywalnych,  który może być tutaj określony zależy od uogólnienia kompilatora (przez właściwość - uogólnienie 'executables' - z ang. - wykonywalne), ale większość będzie miała:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>attribute</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>właściwość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*compiler*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*compiler*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the C/C++ compiler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>kompilator C/C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*linker_so*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*linker_so*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>linker used to create shared objects and libraries</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>program łączący używany do tworzenia współdzielonych przedmiotów i bibliotek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*linker_exe*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*linker_exe*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>linker used to create binary executables</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>program łączący używany do tworzenia binariów wykonywalnych - programów w kodzie maszynowym</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*archiver*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*archiver*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static library creator</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>kreator statycznych bibliotek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On platforms with a command-line (Unix, DOS/Windows), each of these is a string that will be split into executable name and (optional) list of arguments. (Splitting the string is done similarly to how Unix shells operate: words are delimited by spaces, but quotes and backslashes can override this.  See :func:`distutils.util.split_quoted`.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na platformach z linią komend (Unix, DOS/Windows), każdy z tych jest ciągiem, który będzie podzielony na nazwę programu wykonywalnego i (opcjonalną) listę parametrów. (Podział ciągu znaków dokonywany jest podobnie do tego, jak działają powłoki Unixa: słowa są zakańczane spacjami, ale cudzysłowy i skośniki mogą pomóc to obejść. Zobacz :func:`distutils.util.split_quoted`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods invoke stages in the build process.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sposoby postępowania wywołują stadia procesu budowania ze źródeł.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compile one or more source files. Generates object files (e.g.  transforms a :file:`.c` file to a :file:`.o` file.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompiluje jeden lub więcej plików źródłowych. Generuje pliki przedmiotowe (np. zamienia plik :file:`.c` na plik :file:`.o`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*sources* must be a list of filenames, most likely C/C++ files, but in reality anything that can be handled by a particular compiler and compiler class (eg. :class:`MSVCCompiler` can handle resource files in *sources*).  Return a list of object filenames, one per source filename in *sources*.  Depending on the implementation, not all source files will necessarily be compiled, but all corresponding object filenames will be returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*źródła* - z ang. - *sources* muszą być listą nazw plików, najprawdopodobniej pliki C/C++, ale w rzeczywistości wszystko co może być obsłużone przez konkretny kompilator i uogólnienie kompilatora (np. :class:`MSVCCompiler` może obsłużyć pliki zasobów w źródłach - z ang. - *sources*. W zależności od wypełnienia, nie wszystkie pliki źródłowe koniecznie będą kompilowane, ale wszystkie odpowiadające nazwy plików przedmiotów będą zwrócone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *output_dir* is given, object files will be put under it, while retaining their original path component.  That is, :file:`foo/bar.c` normally compiles to :file:`foo/bar.o` (for a Unix implementation); if *output_dir* is *build*, then it would compile to :file:`build/foo/bar.o`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *output_dir* ( z ang. - katalog wyjściowy) jest dany, pliki przedmiotowe zostaną do niego włożone, zachowując ich oryginalne ścieżki. To jest, plik :file:`foo/bar.c` normalnie kompilowany jest do pliku :file:`foo/bar.o` (dla wypełnienia Unixowego); jeśli *output_dir* jest *build*, wtedy to skompilowane byłoby do :file:`build/foo/bar.o`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*macros*, if given, must be a list of macro definitions.  A macro definition is either a ``(name, value)`` 2-tuple or a ``(name,)`` 1-tuple. The former defines a macro; if the value is ``None``, the macro is defined without an explicit value.  The 1-tuple case undefines a macro.  Later definitions/redefinitions/undefinitions take precedence.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*macros*, jeśli podane, muszą być listą  makrodefinicji. Makrodefinicja jest albo 2-krotką ``(name, value)`` lub 1-krotką ``(name,)``. Pierwsze określa makrodefinicję; jeśli wartość jest ``Żadna`` - z ang. - ``None``, wtedy makro jest zdefiniowane bez jawnej wartości. 1-krotka odwołuje makrodefinicję. Później definicje/powtórne definicje/odwołania definicji mają pierwszeństwo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*include_dirs*, if given, must be a list of strings, the directories to add to the default include file search path for this compilation only.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*include_dirs*, jeśli podane, muszą być listą ciągów znaków, katalogami do dodania do domyślnych ścieżek załączania plików źródłowych wyłącznie dla tej kompilacji. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*debug* is a boolean; if true, the compiler will be instructed to output debug symbols in (or alongside) the object file(s).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*debug* jest wartością boolowską (z ang. - boolean od nazwiska); jeśli prawdziwa kompilator będzie wykonywał polecenie wypuszczania symboli debugowania do (lub obok) pliku przedmiotowego ( - z ang. - object file) lub plików.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*extra_preargs* and *extra_postargs* are implementation-dependent. On platforms that have the notion of a command-line (e.g. Unix, DOS/Windows), they are most likely lists of strings: extra command-line arguments to prepend/append to the compiler command line.  On other platforms, consult the implementation class documentation.  In any event, they are intended as an escape hatch for those occasions when the abstract compiler framework doesn't cut the mustard.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*extra_preargs* i *extra_postargs* są zależne od wypełnienia. Na maszynach, które respektują pojęcie wiersza poleceń (np. Unix, DOS/Windows), są one najpewniej listami ciągów znaków: dodatkowe parametry wiersza poleceń do wstawiania przed/dokładania na koniec wiersza poleceń kompilatora. Na innych maszynach, zobacz dokumentację wypełnienia uogólnień. W każdym przypadku, są one przeznaczone jako wyjście awaryjne na te okazje gdy ramy abstrakcyjnego kompilatora nie są w stanie pomieścić tego co trzeba. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*depends*, if given, is a list of filenames that all targets depend on.  If a source file is older than any file in depends, then the source file will be recompiled.  This supports dependency tracking, but only at a coarse granularity.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*depends* - z ang. - *zależy*, jeśli podane lista nazw plików, od których wszystkie cele zależą. Jeśli źródłowy plik jest starszy niż dowolny plik w tej liście, wtedy plik źródłowy zostanie powtórnie skompilowany.  To wspiera śledzenie zależności, ale tylko w zgrubnej skali wielkości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises :exc:`CompileError` on failure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza :exc:`CompileError` na błędzie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link a bunch of stuff together to create a static library file. The "bunch of stuff" consists of the list of object files supplied as *objects*, the extra object files supplied to :meth:`add_link_object` and/or :meth:`set_link_objects`, the libraries supplied to :meth:`add_library` and/or :meth:`set_libraries`, and the libraries supplied as *libraries* (if any).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Połącz (powiąż) wiechcie przedmiotów  razem aby stworzyć plik statycznej biblioteki. "Wiechcie przedmiotów" składają się z listy plików przedmiotów dostarczonych jak *przedmioty* ( - z ang. - *objects*), dodatkowe pliki przedmiotów dostarczone do :meth:`add_link_object` i/lub :meth:`set_link_objects`, biblioteki dostarczone do :meth:`add_library` i/lub :meth:`set_libraries`, i biblioteki dostarczone jako *biblioteki* (jeśli jakiekolwiek).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*output_libname* should be a library name, not a filename; the filename will be inferred from the library name.  *output_dir* is the directory where the library file will be put. XXX defaults to what?</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*output_libname* powinien być nazwą biblioteki, nie nazwą pliku; nazwa pliku będzie wywiedziona z nazwy biblioteki. *output_dir* jest katalogiem gdzie plik biblioteki będzie włożony. XXX jaka jest wartość domyślna?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*debug* is a boolean; if true, debugging information will be included in the library (note that on most platforms, it is the compile step where this matters: the *debug* flag is included here just for consistency).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*debug* jest typu boolowskiego (z ang. - boolean); jeśli prawdziwa informacja o odpluskwianiu będzie załączana do biblioteki (zauważ, że w większości maszyn/środowisk, to jest krok kompilacji gdzie ma to znaczenie: flaga *debug* użyta jest tu dla spójności).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*target_lang* is the target language for which the given objects are being compiled. This allows specific linkage time treatment of certain languages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*target_lang* jest docelowym językiem dla którego dane przedmioty są kompilowane. To pozwala na specjalne traktowanie w czasie łączenia dla niektórych języków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises :exc:`LibError` on failure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza :exc:`LibError` w razie błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link a bunch of stuff together to create an executable or shared library file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Łączy wiecheć rzeczy razem żeby stworzyć plik wykonywalny lub współdzielony plik biblioteki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "bunch of stuff" consists of the list of object files supplied as *objects*. *output_filename* should be a filename.  If *output_dir* is supplied, *output_filename* is relative to it (i.e. *output_filename* can provide directory components if needed).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"wiecheć rzeczy" składa się z listy przedmiotowych plików dostarczonych jako *przedmioty* ( - z ang. - *objects*) . *output_filename* powinno być nazwą pliku. Jeśli *output_dir* jest dostarczony, *output_filename* jest zależny od niego (tj. *output_filename* może dostarczać składowe katalogów jeśli potrzeba).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*libraries* is a list of libraries to link against.  These are library names, not filenames, since they're translated into filenames in a platform-specific way (eg. *foo* becomes :file:`libfoo.a` on Unix and :file:`foo.lib` on DOS/Windows).  However, they can include a directory component, which means the linker will look in that specific directory rather than searching all the normal locations.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*libraries* jest listą bibliotek do podłączenia. Są to nazwy bibliotek, nie nazwy plików, gdyż są tłumaczone na nazwy plików w zależny od maszyny/środowiska sposób (np. *foo* staje się :file:`libfoo.a` w Unixie i :file:`foo.lib` w DOS/Windows). Jednakże mogą zawierać składnik katalogu który oznacza że program łączący biblioteki będzie poszukiwał w tym szczególnym katalogu zamiast przeszukiwać wszystkie zwykłe lokalizacje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*library_dirs*, if supplied, should be a list of directories to search for libraries that were specified as bare library names (ie. no directory component).  These are on top of the system default and those supplied to :meth:`add_library_dir` and/or :meth:`set_library_dirs`.  *runtime_library_dirs* is a list of directories that will be embedded into the shared library and used to search for other shared libraries that \*it\* depends on at run-time.  (This may only be relevant on Unix.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*library_dirs*, jeśli dostarczono, powinno być listą katalogów do przeszukania w poszukiwaniu bibliotek które zostały określone jako skąpe nazwy bibliotek (tj. bez składnika katalogu). Te są na wierzchu domyślnych dla systemu i tych dostarczonych do sposobów postępowania :meth:`add_library_dir` i/lub :meth:`set_library_dirs`. *runtime_library_dirs* jest listą katalogów które będą załączone do współdzielonej biblioteki i użyte do przeszukania pod kątem innych współdzielonych bibliotek od których \*one\* zależą w czasie-wykonania. (To może być istotne tylko w Unixie.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*export_symbols* is a list of symbols that the shared library will export. (This appears to be relevant only on Windows.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*export_symbols* jest listą symboli które współdzielona biblioteka będzie wystawiać na zewnątrz. (To wydaje się mieć znaczenie tylko w Windows.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*debug* is as for :meth:`compile` and :meth:`create_static_lib`,  with the slight distinction that it actually matters on most platforms (as opposed to :meth:`create_static_lib`, which includes a *debug* flag mostly for form's sake).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*debug* jest tak, jak dla sposobu postępowania :meth:`compile` (z ang. - kompiluj) i :meth:`create_static_lib`, z małą różnicą, że ma jednak znaczenie na większości maszyn/środowisk (w przeciwieństwie do :meth:`create_static_lib`, które zawiera flagę *debug* głównie dla zachowania formalności).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*extra_preargs* and *extra_postargs* are as for :meth:`compile`  (except of course that they supply command-line arguments for the particular linker being used).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*extra_preargs* i *extra_postargs* są takie jak dla sposobu postępowania :meth:`compile` (z wyjątkiem tego, że dostarczają parametry wiersza poleceń dla szczególnego programu łączącego biblioteki będącego w użyciu).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises :exc:`LinkError` on failure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza :exc:`LinkError` w przypadku wystąpienia błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link an executable.  *output_progname* is the name of the file executable, while *objects* are a list of object filenames to link in. Other arguments  are as for the :meth:`link` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podłącz plik wykonywalny. *output_progname* jest nazwą pliku wykonywalnego, podczas gdy *objects* jest listą nazw plików przedmiotów do podłączenia. Inne parametry są takie jak dla sposobu postępowania :meth:`link`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link a shared library. *output_libname* is the name of the output  library, while *objects* is a list of object filenames to link in.  Other arguments are as for the :meth:`link` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podłącz plik współdzielonej biblioteki. *output_libname* jest nazwą wynikowej biblioteki, podczas gdy *objects* jest listą nazw plików przedmiotów do załączenia. Inne parametry są takie jak dla sposobu postępowania :meth:`link`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Link a shared object. *output_filename* is the name of the shared object that will be created, while *objects* is a list of object filenames  to link in. Other arguments are as for the :meth:`link` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podłącz współdzielony przedmiot. *output_filename* jest nazwą współdzielonego przedmiotu który zostanie utworzony, podczas gdy *objects* jest listą nazw plików przedmiotów do załączenia. Inne parametry są takie, jak dla sposobu postępowania :meth:`link`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preprocess a single C/C++ source file, named in *source*. Output will be written to file named *output_file*, or *stdout* if *output_file* not supplied. *macros* is a list of macro definitions as for :meth:`compile`, which will augment the macros set with :meth:`define_macro` and :meth:`undefine_macro`. *include_dirs* is a list of directory names that will be added to the  default list, in the same way as :meth:`add_include_dir`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przygotuj wstępnie pojedynczy plik źródłowy C/C++ którego nazwa jest wymieniona w *source*. Wynik zostanie wpisany do pliku nazwanego *output_file*, lub *stdout* jeśli *output_file* nie został dostarczony. *macros* jest listą makrodefinicji, jak dla :meth:`compile`, który wzbogaca zbiór makr o :meth:`define_macro` i :meth:`undefine_macro`. *include_dirs* jest listą nazw katalogów, które będą dodane do listy domyślnej, w ten sam sposób jak przy użyciu sposobu postępowania :meth:`add_include_dir`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises :exc:`PreprocessError` on failure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza :exc:`PreprocessorError` w przypadku błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following utility methods are defined by the :class:`CCompiler` class, for use by the various concrete subclasses.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sposoby postępowania pomocnicze są zdefiniowane przez uogólnienie :class:`CCompiler`, dla użycia przez różne konkretne uogólnienia podrzędne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the filename of the executable for the given *basename*.  Typically for non-Windows platforms this is the same as the basename,  while Windows will get a :file:`.exe` added.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca nazwę pliku wykonywalnego dla danego *basename* - *nazwy podstawowej*. Typowo dla nie-Windowsowych maszyn/środowisk to jest tak samo jak nazwa podstawowa, podczas gdy Windows dostanie :file:`.exe` dodatkowo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the filename for the given library name on the current platform. On Unix a library with *lib_type* of ``'static'`` will typically  be of the form :file:`liblibname.a`, while a *lib_type* of ``'dynamic'``  will be of the form :file:`liblibname.so`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca nazwę pliku dla danej nazwy biblioteki na aktualnej maszynie/środowisku. Na Unixie biblioteka o *lib_type* ``'static'`` ( - z ang. - statycznej ) będzie w formie :file:`liblibname.a`, podczas gdy *lib_type* ``'dynamic'`` będzie w formie :file:`liblibname.so`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the name of the object files for the given source files. *source_filenames* should be a list of filenames.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca nazwę pliku przedmiotów dla danych plików źródłowych. *source_filenames* powinno być listą nazw plików.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the name of a shared object file for the given file name *basename*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca nazwę pliku współdzielonych przedmiotów dla danych nazw plików *basename*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invokes :func:`distutils.util.execute` This method invokes a  Python function *func* with the given arguments *args*, after  logging and taking into account the *dry_run* flag. XXX see also.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołuje zadanie :func:`distutils.util.execute`. Ten sposób postępowania wywołuje zadanie języka pytonowskiego *func* z danymi parametrami *args*, po logowaniu i wzięciu pod uwagę flagi *dry_run*. XXX Zob. też.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invokes :func:`distutils.util.spawn`. This invokes an external  process to run the given command. XXX see also.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołuje zadanie :func:`distutils.util.spawn`. To wzywa zewnętrzny proces do wywołania danej komendy. XXX Zob. też.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invokes :func:`distutils.dir_util.mkpath`. This creates a directory  and any missing ancestor directories. XXX see also.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołuje :func:`distutils.dir_util.mkpath`. To tworzy katalog i wszystkie brakujące katalogi nadrzędne. XXX Zob. też.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invokes :meth:`distutils.file_util.move_file`. Renames *src* to  *dst*.  XXX see also.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołuje sposób postępowania :meth:`distutils.file_util.move_file` Zmienia nazwę z *src* ( - z ang. - źródło ) do *dst* ( - z ang. - cel ). XXX Zob. też.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a message using :func:`distutils.log.debug`. XXX see also.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz wiadomość używając zadania :func:`distutils.log.debug`. XXX Zob. też.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a warning message *msg* to standard error.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisz wiadomość ostrzeżenia *msg* na standardowe wyjście błędów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the *debug* flag is set on this :class:`CCompiler` instance, print  *msg* to standard output, otherwise do nothing.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli flaga *debug* jest ustawiona w tym przykładzie :class:`CCompiler`, wypisz *msg* na standardowe wyjście, w przeciwnym razie nie rób nic.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.unixccompiler` --- Unix C Compiler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.unixccompiler` --- kompilator C Unixa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :class:`UnixCCompiler` class, a subclass of :class:`CCompiler` that handles the typical Unix-style command-line  C compiler:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:`UnixCCompiler`, uogólnienie podrzędne względem uogólnienia :class:`CCompiler` który obsługuje typowy kompilator języka C wiersza polecenia w stylu Unixowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>macros defined with :option:`-Dname[=value]`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>makrodefinicje określone z opcją :option:`-Dname[=value]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>macros undefined with :option:`-Uname`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>makrodefinicje których definicja została odwołana opcją :option:`-Uname`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include search directories specified with :option:`-Idir`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załączony katalog poszukiwania plików nagłówkowych określony z opcją :option:`-Idir`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>libraries specified with :option:`-llib`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>biblioteki określone z opcją :option:`-llib`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>library search directories specified with :option:`-Ldir`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>katalogi do przeszukania na obecność bibliotek określone z opcją :option:`-Ldir`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compile handled by :program:`cc` (or similar) executable with :option:`-c` option: compiles :file:`.c` to :file:`.o`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>kompilacja obsługiwana przez :program:`cc` (lub podobny) wykonywalny z opcją :option:`-c`: kompiluje plik :file:`.c` do pliku :file:`.o`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link static library handled by :program:`ar` command (possibly with :program:`ranlib`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podłącz statyczną bibliotekę obsługiwane przez komendę :program:`ar` (możliwie z programem :program:`ranlib`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link shared library handled by :program:`cc` :option:`-shared`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podłącz współdzieloną bibliotekę obsługiwaną przez program :program:`cc` z opcją :option:`-shared`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.msvccompiler` --- Microsoft Compiler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł :mod:`distutils.msvccompiler` --- Kompilator Microsoftu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides :class:`MSVCCompiler`, an implementation of the abstract :class:`CCompiler` class for Microsoft Visual Studio. Typically, extension modules need to be compiled with the same compiler that was used to compile Python. For Python 2.3 and earlier, the compiler was Visual Studio 6. For Python 2.4 and 2.5, the compiler is Visual Studio .NET 2003. The AMD64 and Itanium binaries are created using the Platform SDK.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:MSVCCompiler`, wypełnienie abstrakcyjnych uogólnień dla Microsoft Visual Studio. Typowo moduły rozszerzające wymagają kompilacji przez ten sam kompilator który był użyty do kompilacji języka pytonowskiego. Dla języka pytonowskiego 2.3 i wcześniejszych kompilatorem było Visual Studio 6. Dla języka pytonowskiego 2.4 i 2.5 kompilatorem było Visual Studio .NET 2003. Pliki wynikowe dla AMD64 i Itanium są tworzone używając Platformy SDK.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`MSVCCompiler` will normally choose the right compiler, linker etc. on its own. To override this choice, the environment variables *DISTUTILS_USE_SDK* and *MSSdk* must be both set. *MSSdk* indicates that the current environment has been setup by the SDK's ``SetEnv.Cmd`` script, or that the environment variables had been registered when the SDK was installed; *DISTUTILS_USE_SDK* indicates that the distutils user has made an explicit choice to override the compiler selection by :class:`MSVCCompiler`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`MSVCCompiler` będzie zwykle wybierał właściwy kompilator i program łączący automatycznie. Aby obejść ten wybór, zmienne środowiskowe *DISTUTILS_USE_SDK* i *MSSdk* muszą obie być ustawione. *MSSdk* wskazuje, że obecne środowisko zostało ustawione przez skrypt ``SetEnv.Cmd`` należący do SDK (z ang. zestaw rozwijania oprogramowania), lub że zmienne środowiskowe były zarejestrowane gdy SDK było instalowane; *DISTUTILS_USE_SDK* wskazuje że użytkownik distutils jawnie dokonał obejścia wyboru kompilatora przez uogólnienie :class:`MSVCCompiler`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.bcppcompiler` --- Borland Compiler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.bcppcompiler` --- Kompilator Borlanda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides :class:`BorlandCCompiler`, an subclass of the abstract :class:`CCompiler` class for the Borland C++ compiler.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:`BorlandCCompiler`, jako podrzędne uogólnienie abstrakcyjnego uogólnienia :class:`CCompiler` dla kompilatora C++ firmy Borland.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.cygwincompiler` --- Cygwin Compiler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.cygwincompiler` --- kompilator cygwina</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :class:`CygwinCCompiler` class, a subclass of :class:`UnixCCompiler` that handles the Cygwin port of the GNU C compiler to Windows.  It also contains the Mingw32CCompiler class which handles the mingw32 port of GCC (same as cygwin in no-cygwin mode).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:`CygwinCCompiler`, podrzędne uogólnienie uogólnienia :class:`UnixCCompiler`, które obsługuje cygwinowski przekład kompilatora GNU C do Windows. Zawiera także uogólnienie Mingw32CCompiler które obsługuje przekład kompilatora GCC o nazwie mingw32 (taki sam jak cygwin w trybie no-cygwin).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.emxccompiler` --- OS/2 EMX Compiler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.emxccompiler` --- kompilator OS/2 EMX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the EMXCCompiler class, a subclass of :class:`UnixCCompiler` that handles the EMX port of the GNU C compiler to OS/2.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie EMXCCompiler, podrzędne uogólnienie uogólnienia :class:`UnixCCompiler` które obsługuje przekład EMX kompilatora GNU C na system OS/2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.archive_util` ---  Archiving utilities</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.archive_util` --- użytki archiwizujące</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides a few functions for creating archive files, such as tarballs or zipfiles.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza kilku zadań  do tworzenia plików archiwów, takich jak archiwa tar (z ang. tarball) lub pliki zip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an archive file (eg. ``zip`` or ``tar``).  *base_name*  is the name of the file to create, minus any format-specific extension;  *format* is the archive format: one of ``zip``, ``tar``,  ``ztar``, or ``gztar``. *root_dir* is a directory that will be the root directory of the archive; ie. we typically ``chdir`` into *root_dir* before  creating the archive.  *base_dir* is the directory where we start  archiving from; ie. *base_dir* will be the common prefix of all files and directories in the archive.  *root_dir* and *base_dir* both default to the current directory.  Returns the name of the archive file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz plik archiwum (np. ``zip`` lub ``tar``). *base_name* jest nazwą pliku do utworzenia bez uwzględniania szczególnych dla formatowania rozszerzeń; *format* jest formatem archiwum: jednym z ``zip``, ``tar``, lub ``gztar``. *root_dir* jest katalogiem który będzie nadrzędnym katalogiem archiwum; tj. często zmieniamy katalog (chdir - z ang. - polecenie zmiany katalogu) na *root_dir* przed utworzeniem archiwum. *base_dir* jest katalogiem gdzie zaczyna się archiwizacja; tj *base_dir* będzie wspólnym przedrostkiem wszystkich plików i katalogów w archiwum. *root_dir* i *base_dir* domyślnie są równe katalogowi bierzącemu. Zwraca nazwę pliku archiwum.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'Create an (optional compressed) archive as a tar file from all files in and under *base_dir*. *compress* must be ``'gzip'`` (the default),  ``'compress'``, ``'bzip2'``, or ``None``.  Both :program:`tar` and the compression utility named by *compress* must be on the  default program search path, so this is probably Unix-specific.  The  output tar file will be named :file:`base_dir.tar`, possibly plus the appropriate compression extension (:file:`.gz`, :file:`.bz2` or :file:`.Z`).  Return the output filename.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>'Stwórz (opcjonalnie skompresowane) archiwum jak plik tar ze wszystkich plików spod *base_dir*. *compress* musi być jednym z ``'gzip'`` (domyślne), ``'compress'``, ``'bzip2'`` lub ``żaden`` - z ang. - ``None``. Zarówno program :program:`tar` jak program użytkowy kompresji nazwany przez *compress* muszą być na domyślnej ścieżce poszukiwania programów, więc jest to raczej szczególne-dla-Unixa. Wynikowy plik tar zostanie nazwany :file:`base_dir.tar`, możliwe, że wraz z odpowiednim rozszerzeniem formatu kompresji (:file:`.gz`, :file:`.bz2` lub :file:`.Z`). Zwraca wynikową nazwę pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a zip file from all files in and under *base_dir*.  The output zip file will be named *base_dir* + :file:`.zip`.  Uses either the  :mod:`zipfile` Python module (if available) or the InfoZIP :file:`zip`  utility (if installed and found on the default search path).  If neither  tool is available, raises :exc:`DistutilsExecError`.   Returns the name of the output zip file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stwórz plik zip ze wszystkich plików wewnątrz katalogu i podkatalogów *base_dir*. Wynikowy plik zip będzie nazwany *base_dir* + :file:`.zip` Używa modułu języka pytonowskiego :mod:`zipfile` (jeśli jest dostępny) lub programu zip ze zestawu InfoZIP (jeśli jest zainstalowany i znajduje się na domyślnej ścieżce poszukiwania).  Jeśli żadne z narzędzi nie jest dostępne, zgłasza wyjątek :exc:`DistutilsExecError`. Zwraca nazwę wynikowego pliku zip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.dep_util` --- Dependency checking</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.dep_util` --- sprawdzanie zależności</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides functions for performing simple, timestamp-based dependency of files and groups of files; also, functions based entirely  on such timestamp dependency analysis.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza zadań dla prowadzenia prostych opartych o stemple czasowe sprawdzania zależności między plikami i grupami plików; także funkcje oparte całkowicie o taką analizę zależności stempli czasowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return true if *source* exists and is more recently modified than *target*, or if *source* exists and *target* doesn't. Return false if both exist and *target* is the same age or newer  than *source*. Raise :exc:`DistutilsFileError` if *source* does not exist.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć prawdę jeśli *źródło* - z ang. - *source* istnieje i zostało zmodyfikowanie bardziej niedawno niż *cel* - z ang. - *target* lub jeśli *source* istnieje a *target* nie. Zwróć fałsz jeśli oba istnieją, a *target* jest z tej samej daty/czasu lub nowsza niż *source*. Zgłasza :exc:`DistutilsFileError`, jeśli *source* nie istnieje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Walk two filename lists in parallel, testing if each source is newer than its corresponding target.  Return a pair of lists (*sources*, *targets*) where source is newer than target, according to the semantics of :func:`newer`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przejdź po dwóch listach nazw równolegle, testując czy każde źródło jest nowsze niż odpowiadający mu cel. Zwraca parę list (*źródła*,*cele*) gdzie źródła jest nowsze  niż cel, zgodnie ze składnią :func:`newer` - z ang. - nowszy).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return true if *target* is out-of-date with respect to any file listed in *sources*  In other words, if *target* exists and is newer than every file in *sources*, return false; otherwise return true. *missing* controls what we do when a source file is missing; the default (``'error'``) is to blow up with an :exc:`OSError` from  inside :func:`os.stat`; if it is ``'ignore'``, we silently drop any missing source files; if it is ``'newer'``, any missing source files make us assume that *target* is out-of-date (this is handy in "dry-run" mode: it'll make you pretend to carry out commands that wouldn't work because inputs are missing, but that doesn't matter because you're not actually going to run the commands).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć prawdę jeśli *cel* jest nieaktualny względem dowolnego pliku na liście *sources*. Innymi słowy, jeśli *cel* istnieje i jest nowszy niż każdy plik wśród *źródeł*, zwróć fałsz; w innym przypadku zwróć prawdę; *missing* ( - z ang. - brakujący) kontroluje co zrobić gdy brakuje pliku wśród źródeł; domyślnym działaniem jest ``'error'`` ( - z ang. - błąd) wybuchnięcie z błędem :exc:`OSError` z wnętrza :func:`os.stat`; jeśli jest ``'ignore'``, po cichu pomijamy jakiekolwiek brakujące pliki; jeśli jest ``'newer'`` - z ang. - ``'nowsze'``, jakiekolwiek brakujące pliki źródłowe dają nam założenie, że *cel* - z ang. *target* jest nieaktualny (jest to poręczne w trybie "działania na sucho" - z ang. - "dry-run": spowoduje to konieczność udawania że wykonujesz polecenia które nie zadziałałyby gdyż źródła są brakujące, ale to nie ma znaczenia, gdyż tak na prawdę nie masz zamiaru ich uruchomić).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.dir_util` --- Directory tree operations</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.dir_util` --- operacje drzewa katalogowego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides functions for operating on directories and trees of directories.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza zadań dla operowania na katalogach i drzewach katalogowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a directory and any missing ancestor directories.  If the directory already exists (or if *name* is the empty string, which means the current directory, which of course exists), then do nothing.  Raise :exc:`DistutilsFileError` if unable to create some directory along the way (eg. some sub-path exists, but is a file rather than a directory).  If *verbose* is true, print a one-line summary of each mkdir to stdout.  Return the list of directories actually created.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz katalog i wszystkie brakujące nadrzędne katalogi. Jeśli katalog już istnieje (lub jeśli *nazwa* pliku jest pustym ciągiem znaków, co oznacza aktualny katalog, który oczywiście istnieje), wtedy nie rób nic. Zgłoś :exc:`DistutilsFileError` jeśli nie było możliwe utworzenie jakiegoś katalogu po drodze (np. pewna podścieżka już istnieje ale jest raczej plikiem niż katalogiem). Jeśli *verbose* jest prawdą, wypisz jedno-wierszowe podsumowanie dla każdego mkdir ( - z ang. - polecenie stwórz katalog) na stdout ( - z ang. - standardowe wyjście). Zwróć listę katalogów właściwie utworzonych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create all the empty directories under *base_dir* needed to put *files* there. *base_dir* is just the a name of a directory which doesn't necessarily exist yet; *files* is a list of filenames to be interpreted relative to *base_dir*. *base_dir* + the directory portion of every file in *files* will be created if it doesn't already exist.  *mode*, *verbose* and *dry_run* flags  are as for :func:`mkpath`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz wszystkie puste katalogi pod *base_dir* potrzebne do włożenia *plików* ( - z ang. - *files*) tam. *base_dir* jest tylko nazwą katalogu który jeszcze nie koniecznie istnieje; *pliki* ( z ang. - *files*) jest listą nazw plików do interpretacji względem *base_dir*. *base_dir* + porcja katalogu każdego pliku w *files* zostanie utworzona jeśli jeszcze nie istnieje. Flagi *mode*, *verbose* i *dry_run* działają tak, jak w :func:`mkpath`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy an entire directory tree *src* to a new location *dst*.  Both *src* and *dst* must be directory names.  If *src* is not a directory, raise :exc:`DistutilsFileError`.  If *dst* does  not exist, it is created with :func:`mkpath`.  The end result of the  copy is that every file in *src* is copied to *dst*, and  directories under *src* are recursively copied to *dst*. Return the list of files that were copied or might have been copied, using their output name. The return value is unaffected by *update* or *dry_run*: it is simply the list of all files under *src*, with the names changed to be under *dst*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skopiuj całe drzewo katalogowe *src* do nowej lokacji *dst*. Zarówno *src* jak *dst* muszą być nazwami katalogów. Jeśli *src* nie jest katalogiem, zgłoś :exc:`DistutilsFileError`. Jeśli *dst* nie istnieje, jest tworzony za pomocą zadania :func:`mkpath`. Rezultat kopiowania jest taki że wszystkie pliki z *src* są kopiowane do *dst* a katalogi pod *src* są rekursywnie kopiowane do *dst*. Zwróć listę plików, które zostały skopiowane lub mogły być skopiowane, używając ich nazw wynikowych. Na Wartość zwracaną nie ma wpływu *update* ani *dry_run*: jest ona listą wszystkich plików pod *src*, z nazwami zmienionymi aby były pod *dst*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*preserve_mode* and *preserve_times* are the same as for :func:`copy_file` in :mod:`distutils.file_util`; note that they only apply to regular files, not to directories.  If *preserve_symlinks* is true, symlinks will be copied as symlinks (on platforms that support them!); otherwise (the default), the destination of the symlink will be copied.  *update* and *verbose* are the same as for :func:`copy_file`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*preserve_mode* i *preserve_times* są takie same, jak dla zadania :func:`copy_file` w :mod:`distutils.file_util`; zauważ, że odnoszą się one tylko do zwykłych plików, nie do katalogów. Jeśli *preserve_symlinks* jest prawdziwe, symlinks zostanie skopiowane jako symlinks (na maszynach/środowiskach które wspierają je!); w przeciwnym przypadku (domyślnie), przeznaczenie symlinka zostanie skopiowane. *update* i *verbose* są takie same jak dla zadania :func:`copy_file`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Recursively remove *directory* and all files and directories underneath it. Any errors are ignored (apart from being reported to ``sys.stdout`` if *verbose* is true).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wgłębnie usuwaj *katalog* i wszystkie pliki i katalogi pod nim się znajdujące. Jakiekolwiek błędy są ignorowane ( z wyjątkiem raportowania ich do ``sys.stdout``, jeśli flaga *verbose* ( - z ang. - "wymownie") jest prawdziwa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**\*\*** Some of this could be replaced with the shutil module? **\*\***</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**\*\*** Część z tych rzeczy mogłoby być zamienione na moduł shutil? **\*\***</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.file_util` --- Single file operations</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.file_util` --- Operacje na pojedynczym pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module contains some utility functions for operating on individual files.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł zawiera pewne użyteczne zadania dla operowania na pojedynczych plikach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy file *src* to *dst*. If *dst* is a directory, then *src* is copied there with the same name; otherwise, it must be a filename. (If the file exists, it will be ruthlessly clobbered.) If *preserve_mode* is true (the default), the file's mode (type and permission bits, or whatever is analogous on the current platform) is copied. If *preserve_times* is true (the default), the last-modified and last-access times are copied as well. If *update* is true, *src* will only be copied if *dst* does not exist, or if *dst* does exist but is older than *src*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kopiuj plik *src* do *dst*. Jeśli *dst* jest katalogiem, wtedy *src* jst kopiowany tam z tą samą nazwą; w przeciwnym przypadku, musi być nazwą pliku. (Jeśli plik istnieje, zostanie bezwzględnie podmieniony.) Jeśli *preserve_mode* (z ang. - tryb zachowywania) jest prawdziwy (domyślnie), tryb pliku (typ i bity praw dostępu lub cokolwiek jest analogicznego na obecnej maszynie/środowisku) jest kopiowane. Jeśli *preserve_times* jest prawdziwe (domyślnie), czasy ostatniej modyfikacji i ostatniego dostępu są kopiowane na równi. Jeśli *update* jest prawdziwe, *src* będzie kopiowane tylko jeśli *dst* nie istnieje, lub jeśli *dst* istnieje ale jest starsze niż *src*. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*link* allows you to make hard links (using :func:`os.link`) or symbolic links (using :func:`os.symlink`) instead of copying: set it to ``'hard'`` or ``'sym'``; if it is ``None`` (the default), files are copied. Don't set *link* on systems that don't support it: :func:`copy_file` doesn't check if hard or symbolic linking is available.  It uses :func:`_copy_file_contents` to copy file contents.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*link* pozwala tworzyć sztywne połączenia (używając :func:`os.link`) lub symboliczne linki (używając :func:`os.symlink`) zamiast kopiowania: ustaw je na ``'hard'`` lub ``'sym'``. jeśli jest ``None`` (domyślnie) pliki są kopiowane. Nie ustawiaj *link*-ów na systemach które nie wspierają ich: :func:`copy_file` nie sprawdza czy twarde lub symboliczne połączenia są dostępne. Używa :func:`_copy_file_contents` do skopiowania zawartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a tuple ``(dest_name, copied)``: *dest_name* is the actual  name of the output file, and *copied* is true if the file was copied  (or would have been copied, if *dry_run* true).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć krotkę ``(dest_name, copied)``: *dest_name* jest faktyczną nazwą pliku wynikowego, i *kopiowane* ( - z ang. - *copied*) jest prawdziwe, jeśli plik został skopiowany (lub mógłby był być skopiowany, gdyby *dry_run* było prawdziwe).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move file *src* to *dst*. If *dst* is a directory, the file will be moved into it with the same name; otherwise, *src* is just renamed to *dst*.  Returns the new full name of the file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przenieś *src* do *dst*. Jeśli *dst* jest katalogiem, plik zostanie przeniesiony do niego z tą samą nazwą; w przeciwnym przypadku, nazwa *src*  zwyczajnie jest zmieniana na *dst*. Zwracana jest nowa pełna nazwa pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handles cross-device moves on Unix using :func:`copy_file`.  What about other systems?</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługuje przenoszenie pomiędzy urządzeniami na Unixie przy użyciu :func:`copy_file`. Co z innymi systemami?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a file called *filename* and write *contents* (a sequence of strings without line terminators) to it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stwórz plik nazwany *filename* i zapisz *zawartość* (sekwencje ciągów znaków bez końców linii) do niego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.util` --- Miscellaneous other utility functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.util` --- Różnorakie inne zadania użytkowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module contains other assorted bits and pieces that don't fit into  any other utility module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł zawiera inne różności które nie pasują do innych modułów użytkowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a string that identifies the current platform.  This is used mainly to distinguish platform-specific build directories and platform-specific built distributions.  Typically includes the OS name and version and the architecture (as supplied by 'os.uname()'), although the exact information included depends on the OS; eg. for IRIX the architecture isn't particularly important (IRIX only runs on SGI hardware), but for Linux the kernel version isn't particularly important.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć ciąg, który identyfikuje obecną maszynę/środowisko. To jest używane głównie do odróżnienia szczególne dla maszyny/środowiska katalogi budowania i szczególne dla maszyny/środowiska zbudowane pakiety dystrybucyjne. Typowo zawiera nazwę systemu operacyjnego i wersję i architekturę ( dostarczone przez 'os.uname()'), chociaż dokładna informacja zawarta zależy od systemu operacyjnego; np dla IRIXa architektura nie jest szczególnie istotna (IRIX działa tylko na sprzęcie SGI), ale dla Linuxa wersja jądra nie jest szczególnie istotna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples of returned values:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady zwracanych wartości:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``linux-i586``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``linux-i586``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``linux-alpha``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``linux-alpha``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``solaris-2.6-sun4u``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``solaris-2.6-sun4u``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``irix-5.3``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``irix-5.3``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``irix64-6.2``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``irix64-6.2``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For non-POSIX platforms, currently just returns ``sys.platform``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla nie-POSIXowych środowisk/maszyn, obecnie zwraca tylko ``sys.platform``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Mac OS X systems the OS version reflects the minimal version on which binaries will run (that is, the value of ``MACOSX_DEPLOYMENT_TARGET`` during the build of Python), not the OS version of the current system.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla systemów Mac OS X wersja systemu operacyjnego oddaje wersję minimum na której programy będą działać (to jest, wartość ``MACOSX_DEPLOYMENT_TARGET`` w czasie budowy języka pytonowskiego), nie wersja systemu operacyjnego obecnej maszyny/środowiska.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For universal binary builds on Mac OS X the architecture value reflects the univeral binary status instead of the architecture of the current processor. For 32-bit universal binaries the architecture is ``fat``, for 64-bit universal binaries the architecture is ``fat64``, and for 4-way universal binaries the architecture is ``universal``. Starting from Python 2.7 and Python 3.2 the architecture ``fat3`` is used for a 3-way universal build (ppc, i386, x86_64) and ``intel`` is used for a univeral build with the i386 and x86_64 architectures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla uniwersalnych binarnych budów na Mac OS X wartość architektury oddaje uniwersalny status binarny zamiast architektury obecnego procesora. Dla 32-bitowych uniwersalnych pakietów wykonywalnych architektura jest ``fat`` ( - z ang. - ``gruba``), dla 64-bitowych uniwersalnych pakietów binarnych architektura jest ``fat64``, a dla 4-drożnych uniwersalnych pakietów wykonywalnych architektura jest ``uniwersalna``. Zaczynając od języka pytonowskiego w wersji 2.7 i języka pytonowskiego w wersji 3.2 architektura ``fat3`` jest używana dla 3-drożnego uniwersalnej budowy (ppc, i386, x86_64) i ``intel`` jest używana dla uniwersalnej budowy z architekturami i386 i x86_64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples of returned values on Mac OS X:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykładami zwracanych wartości na Mac OS X:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``macosx-10.3-ppc``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``macosx-10.3-ppc``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``macosx-10.3-fat``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``macosx-10.3-fat``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``macosx-10.5-universal``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``macosx-10.5-universal``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``macosx-10.6-intel``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``macosx-10.6-intel``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return 'pathname' as a name that will work on the native filesystem, i.e. split it on '/' and put it back together again using the current directory separator. Needed because filenames in the setup script are always supplied in Unix style, and have to be converted to the local convention before we can actually use them in the filesystem.  Raises :exc:`ValueError` on non-Unix-ish systems if *pathname* either  starts or ends with a slash.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć 'pathname' - 'ścieżkę' jako nazwę, którą będzie pracowała na zastanym systemie plików, tj. rozdzieli je na znaku '/' ukośnika i złoży na powrót używając aktualnego separatora katalogów. Potrzebne ponieważ nazwy plików w skrypcie instalacyjno przygotowawczym są zawsze dostarczane w stylu Unixowym, i musi być konwertowane do lokalnych zwyczajów zanim będzie można właściwie użyć ich w systemie plików. Zgłasza :exc:`ValueError` na nie-Unixowych systemach jeśli *nazwa katalogu* - *pathname* zaczyna się bądź kończy ukośnikiem ( - z ang. - slash)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return *pathname* with *new_root* prepended.  If *pathname* is relative, this is equivalent to ``os.path.join(new_root,pathname)`` Otherwise, it requires making *pathname* relative and then joining the two, which is tricky on DOS/Windows.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć *pathname* ( ścieżkę dostępu ) z *new_root* ( nowym korzeniem ) dopisanym z przodu. Jeśli *nazwaścieżki* ( - z ang. - *pathname*)  jest względna, to jest to równoważne ``os.path.join(new_root,pathname)`` W przeciwnym przypadku wymaga uczynienia *nazwyścieżki* względną a potem połączenia obydwu, co może powodować kłopoty w DOS/Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that 'os.environ' has all the environment variables we guarantee that users can use in config files, command-line options, etc.  Currently this includes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapewnia że 'os.environ' ma wszystkie zmienne środowiskowe, które gwarantuje się, że użytkownik może użyć w plikach konfiguracyjnych, opcjach wiersza poleceń itp. Obecnie to zawiera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:envvar:`HOME` - user's home directory (Unix only)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:envvar:`HOME` - katalog domowy użytkownika (tylko Unix)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:envvar:`PLAT` - description of the current platform, including hardware and OS (see :func:`get_platform`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:envvar:`PLAT` - opis obecnej maszyny/środowiska, zawierając sprzęt i system operacyjny (zob. :func:`get_platform`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform shell/Perl-style variable substitution on *s*.  Every occurrence of ``$`` followed by a name is considered a variable, and variable is substituted by the value found in the *local_vars* dictionary, or in ``os.environ`` if it's not in *local_vars*. *os.environ* is first checked/augmented to guarantee that it contains certain values: see :func:`check_environ`.  Raise :exc:`ValueError` for any variables not found in either *local_vars* or ``os.environ``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj podstawienie na *s* w stylu Perla/powłoki systemu. Każde wystąpienie ``$`` po którym występuje nazwa jest uważane za zmienną, i zmienna jest podmieniana przez wartość znajdującą się w słowniku *local_vars*, lub w ``os.environ`` jeśli nie jest w *local_vars* ( - z ang. - lokalne zmienne). *os.environ* jest wpierw sprawdzana/wzbogacana aby zagwarantować że zawiera odpowiednie wartości: zobacz :func:`check_environ`. Zgłasza :exc:`ValueError` dla jakichkolwiek zmiennych nie znajdujących się w *local_vars* lub ``os.environ``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this is not a fully-fledged string interpolation function. A valid ``$variable`` can consist only of upper and lower case letters, numbers and an underscore. No { } or ( ) style quoting is available.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że to nie jest w-pełni-rozwinięte zadanie rozszerzania ciągów znaków. Prawidłowe ``$variable`` może składać się tylko z liter małych i dużych, cyfr i podkreślnika. Żadne { } ani ( ) cytaty nie są dostępne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate a useful error message from an :exc:`EnvironmentError`  (:exc:`IOError` or :exc:`OSError`) exception object.   Handles Python 1.5.1 and later styles, and does what it can to deal with  exception objects that don't have a filename (which happens when the error  is due to a two-file operation, such as :func:`rename` or  :func:`link`).  Returns the error message as a string prefixed  with *prefix*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Generuj użyteczną wiadomość o błędzie z przedmiotu wyjątku :exc:`EnvironmentError` (:exc:`IOError` lub :exc:`OSError`). Obsługuje styl języka pytonowskiego 1.5.1 i późniejszych i robi co się da aby poradzić sobie z przedmiotami sytuacji wyjątkowych, które nie mają nazwy pliku (co się zdarza gdy błąd został spowodowany dwu-plikową operacją, taką jak :func:`rename` albo :func:`link`). Zwraca wiadomość o błędzie jako ciąg znaków z przedrostkiem *prefix*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Split a string up according to Unix shell-like rules for quotes and backslashes. In short: words are delimited by spaces, as long as those spaces are not escaped by a backslash, or inside a quoted string. Single and double quotes are equivalent, and the quote characters can be backslash-escaped.  The backslash is stripped from any two-character escape sequence, leaving only the escaped character.  The quote characters are stripped from any quoted string.  Returns a list of words.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podziel ciąg znaków zgodnie z Unixowymi zasadami podobnymi-do-powłokowych dotyczącymi cytowania i skośników. Po krótce: słowa są ograniczone spacjami, tak długo jak te spacje nie są poprzedzone przez skośnik, lub wewnątrz cytowanego ciągu znaków. Pojedyncze lub podwójne cytowanie są równoważne i znaki cytowania mogą być poprzedzone skośnikiem. Skośnik jest zdejmowany z każdej dwu-znakowej sekwencji ucieczkowej, zostawiając tylko uciekający znak. Znak cytowania jest zdejmowany z każdego cytowanego ciągu znaków. Zwraca listę słów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform some action that affects the outside world (for instance, writing to the filesystem).  Such actions are special because they are disabled by the *dry_run* flag.  This method takes  care of all that bureaucracy for you; all you have to do is supply the function to call and an argument tuple for it (to embody the "external action" being performed), and an optional message to print.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj pewne działanie, które wpływa na świat zewnętrzny (np. zapis do systemu plików). Takie działania są szczególne gdyż są zablokowane przez flagę *działania_na_sucho* ( - z ang. - *dry_run*). Ta metoda zajmuje się całą biurokracją za ciebie; wszystko co musisz zrobić to dostarczyć zadanie do wykonania i jego krotkę parametrów dla niego (aby wcielić "zewnętrzną akcję" w trakcie jej wykonania), i nieobowiązkowy komunikat do wypisania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a string representation of truth to true (1) or false (0).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień reprezentację ciągu znaków z prawdy na prawdę (1) lub fałsz (0). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>True values are ``y``, ``yes``, ``t``, ``true``, ``on``  and ``1``; false values are ``n``, ``no``, ``f``, ``false``,  ``off`` and ``0``.  Raises :exc:`ValueError` if *val*  is anything else.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartościami prawdy są ``y``, ``yes``, ``t``, ``true``, ``on``  i ``1``; wartościami fałszu są ``n``, ``no``, ``f``, ``false``,  ``off`` i ``0``.  Zgłasza :exc:`ValueError` jeśli *val*  jest czymkolwiek innym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Byte-compile a collection of Python source files to either :file:`.pyc` or :file:`.pyo` files in the same directory.  *py_files* is a list of files to compile; any files that don't end in :file:`.py` are silently skipped. *optimize* must be one of the following:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompiluj-bajtowo kolekcję plików źródłowych języka pytonowskiego, aby były :file:`.pyc` lub :file:`.pyo` plikami w tym samym katalogu. *py_files* jest listą plikówdo skompilowania; dowolne pliki które nie kończą się na :file:`.py` są pomijane bez jawnego rozgłaszania. *optymalizuj* musi być jednym z następujących:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``0`` - don't optimize (generate :file:`.pyc`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``0`` - nie optymalizuj (generuj :file:`.pyc`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``1`` - normal optimization (like ``python -O``)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``1`` - normalna optymalizacja (jak ``python -O``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``2`` - extra optimization (like ``python -OO``)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``2`` - extra optymalizacja (jak ``python -OO``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *force* is true, all files are recompiled regardless of timestamps.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *force* jest prawdziwa, wszystkie pliki są ponownie kompilowane niezależnie od stempla czasowego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source filename encoded in each :term:`bytecode` file defaults to the filenames listed in *py_files*; you can modify these with *prefix* and *basedir*. *prefix* is a string that will be stripped off of each source filename, and *base_dir* is a directory name that will be prepended (after *prefix* is stripped).  You can supply either or both (or neither) of *prefix* and *base_dir*, as you wish.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa pliku źródłowego zakodowana w każdym pliku o kęsowym kodowaniu  ( - z ang. - :term:`bytecode`) domyślnie nazwy plików z listy w *py_files*; możesz modyfikować je za pomocą *prefix* i *basedir*. *prefix* jest ciągiem znaków z którego będzie zdjęte każda nazwa pliku źródłowego, a *base_dir* jest nazwą katalogu który będzie doklejony z przodu (po tym, jak *prefix* zostanie zdjęty). Możesz dostarczyć którąkolwiek, albo obie (albo żadną) z *prefix* i *base_dir*, jak sobie życzysz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *dry_run* is true, doesn't actually do anything that would affect the filesystem.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *suchy_start* jest prawdziwy, nie robi nic co mogłoby wpłynąć na system plików.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Byte-compilation is either done directly in this interpreter process with the standard :mod:`py_compile` module, or indirectly by writing a temporary script and executing it.  Normally, you should let :func:`byte_compile` figure out to use direct compilation or not (see the source for details).  The *direct* flag is used by the script generated in indirect mode; unless you know what you're doing, leave it set to ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompilacja-kęsowa jest albo robiona bezpośrednio w procesie programu interpretującego polecenia języka pytonowskiego ze standardowym modułem :mod:`py_compile` albo pośrednio przez zapis tymczasowego skryptu i wykonanie go. Zwykle, powinno się pozwolić zadaniu :func:`byte_compile` odgadnąć czy użyć bezpośredniej kompilacji czy nie (zobacz źródła po szczegóły). Flaga *bezpośrednio* jest używana przez skrypt generowany w trybie pośrednim; z wyjątkiem sytuacji gdy wiesz co robisz, zostaw to ustawienie ustawione na ``None`` ( - z ang. Żaden).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a version of *header* escaped for inclusion in an :rfc:`822` header, by ensuring there are 8 spaces space after each newline. Note that it does no other modification of the string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wersję *nagłówka* "zauciekniętą" dla włączenia w nagłówek :rfc:`822`, przez zapewnienie że jest 8 spacji miejsca po każdej nowej linii. Zauważ, że nie tworzy to żadnej innej modyfikacji ciągu znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.dist` --- The Distribution class</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.dist` --- Uogólnienie dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :class:`Distribution` class, which represents the module distribution being built/installed/distributed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:`Distribution`, które reprezentuje dystrybucję modułu w budowie/instalacji/dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.extension` --- The Extension class</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.extension` --- Klasa rozszerzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :class:`Extension` class, used to describe C/C++ extension modules in setup scripts.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:`Extension`, używane do opisu modułów rozszerzających C/C++ w skryptach instalacyjnych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.debug` --- Distutils debug mode</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.debug` --- tryb odpluskwiania distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the DEBUG flag.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza flagę DEBUG.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.errors` --- Distutils exceptions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.errors` --- wyjątki distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provides exceptions used by the Distutils modules.  Note that Distutils modules may raise standard exceptions; in particular, SystemExit is usually raised for errors that are obviously the end-user's fault (eg. bad command-line arguments).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcza wyjątki używane przez moduły Distutils. Zauważ, że moduły Distutils mogą zgłaszać standardowe wyjątki; w szczególności SystemExit jest zwykle zgłaszany dla błędów które są w oczywisty sposób z winy użytkownika końcowego (np. nieprawidłowe parametry wywołania z wiersza poleceń).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module is safe to use in ``from ... import *`` mode; it only exports symbols whose names start with ``Distutils`` and end with ``Error``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł jest bezpieczny w użyciu w trybie ``from ... import *``; eksportuje tylko symbole, których nazwy zaczynają się na ``Distutils`` a kończą na ``Error``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.fancy_getopt` --- Wrapper around the standard getopt module</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.fancy_getopt` --- Opakowanie wokół standardowego modułu getopt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides a wrapper around the standard :mod:`getopt`  module that provides the following additional features:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza opakowanie wokół standardowego modułu :mod:`getopt` który dostarcza następujące dodatkowe możliwości:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>short and long options are tied together</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>krótkie i długie opcje są powiązane razem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>options have help strings, so :func:`fancy_getopt` could potentially  create a complete usage summary</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcje mają ciągi znaków pomocy, więc zadanie :func:`fancy_getopt` może potencjalnie służyć stworzeniu całkowitego podsumowania użytkowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>options set attributes of a passed-in object</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcje ustawiają właściwości przekazanego przedmiotu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>boolean options can have "negative aliases" --- eg. if :option:`--quiet` is the "negative alias" of :option:`--verbose`, then :option:`--quiet` on the command line sets *verbose* to false.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcje typu boolean (prawda/fałsz) mogą mieć "negatywne aliasy" --- np. jeśli :option:`--quiet` jest "negatywnym aliasem" opcji :option:`--verbose`, wtedy opcja :option:`--quiet` w linii poleceń ustawia tryb *wymowny* (z ang. - *verbose*) na fałsz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**\*\*** Should be replaced with :mod:`optik` (which is also now known as :mod:`optparse` in Python 2.3 and later). **\*\***</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**\*\*** Powinno być zastąpione :mod:`optik` (który także teraz znany jest jako :mod:`optparse` w języku pytonowskim w wersji 2.3 i późniejszych). **\*\***</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrapper function. *options* is a list of ``(long_option, short_option, help_string)`` 3-tuples as described in the constructor for :class:`FancyGetopt`. *negative_opt* should be a dictionary mapping option names to option names, both the key and value should be in the *options* list. *object* is an object which will be used to store values (see the :meth:`getopt` method of the :class:`FancyGetopt` class). *args* is the argument list. Will use ``sys.argv[1:]`` if you  pass ``None`` as *args*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie opakowujące. *options* jest listą ``(long_option, short_option, help_string)`` 3-krotki jak opisano w konstruktorze dla uogólnienia :class:`FancyGetopt`. *negative_opt* powinno być słownikiem mapującym nazwy opcji do nazw opcji, zarówno klucz i wartość powinny być na liście *options*. *object* jest przedmiotem który zostanie użyty aby przechować wartości (zobacz sposób postępowania :meth:`getopt` uogólnienia :class:`FancyGetopt`). *args* jest listą parametrów. Będzie użyte ``sys.argv[1:]`` jeśli przekażesz ``None`` jako *args*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wraps *text* to less than *width* wide.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zawija *text* do mniej niż *width* szerokości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The option_table is a list of 3-tuples: ``(long_option, short_option, help_string)``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>option_table ( - z ang. - tabela opcji) jest listą 3-krotek: ``(long_option, short_option, help_string)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an option takes an argument, its *long_option* should have ``'='`` appended; *short_option* should just be a single character, no ``':'`` in any case. *short_option* should be ``None`` if a *long_option*  doesn't have a corresponding *short_option*. All option tuples must have long options.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli opcja bierze parametr, *long_option* ( - z ang. - długa opcja ) powinna mieć ``'='`` doklejona z tyłu; *short_option* ( - z ang. - krótka opcja ) powinna być tylko pojedynczym znakiem, ``':'`` w każdym przypadku *short_option* powinno być ``None`` jeśli *long_option* nie ma odpowiadającego *short_option*. Wszystkie krotki opcji muszą mieć długie opcje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`FancyGetopt` class provides the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`FancyGetopt` dostarcza następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse command-line options in args. Store as attributes on *object*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przetwarzaj opcje wiersza-polecenia w args. Zachowaj właściwości w *object*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *args* is ``None`` or not supplied, uses ``sys.argv[1:]``.  If *object* is ``None`` or not supplied, creates a new :class:`OptionDummy` instance, stores option values there, and returns a tuple ``(args, object)``.  If *object* is supplied, it is modified in place and :func:`getopt` just returns *args*; in both cases, the returned *args* is a modified copy of the passed-in *args* list, which is left untouched.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *args* jest ``None`` lub nie dostarczono, używa ``sys.argv[1:]``. Jeśli *object* jest ``None`` lub nie dostarczono, tworzy nowy przykład uogólnienia :class:`OptionDummy`, zachowuje wartości tam, i zwraca krotę ``(args, object)``. Jeśli *object* jest dostarczony, jest modyfikowany w miejscu i zadanie :func:`getopt` zwraca po prostu *args*; w obu przypadkach, zwracane *args* są zmodyfikowaną kopią przekazanej listy *args*, która pozostawiona jest bez zmian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the list of ``(option, value)`` tuples processed by the previous run of :meth:`getopt`  Raises :exc:`RuntimeError` if :meth:`getopt` hasn't been called yet.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca listę krotek ``(option, value)`` przetworzonych przez poprzednie wykonanie :meth:`getopt`. Zgłasza :exc:`RuntimeError` jeśli :meth:`getopt` nie zostało jeszcze wywołane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate help text (a list of strings, one per suggested line of output) from the option table for this :class:`FancyGetopt` object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wytwarza tekst pomocy (listę ciągów znaków, jeden na sugerowaną linię wyjścia) z tabeli opcji dla tego przedmiotu :class:`FancyGetopt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If supplied, prints the supplied *header* at the top of the help.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli dostarczono, wypisuje dostarczony *nagłówek* ( - z ang. - *header* ) na górze pomocy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.filelist` --- The FileList class</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.filelist` --- uogólnienie FileList</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :class:`FileList` class, used for poking about the filesystem and building lists of files.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienie :class:`FileList`, używaną do działań wokół systemu plików i budowania list plików.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.log` --- Simple PEP 282-style logging</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.log` --- Proste logowanie w stylu PEP 282</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.spawn` --- Spawn a sub-process</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.spawn` --- Utwórz podproces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :func:`spawn` function, a front-end to  various platform-specific functions for launching another program in a  sub-process. Also provides :func:`find_executable` to search the path for a given executable name.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza zadanie :func:`spawn`, sprzęg dostępu do różnych szczególnych dla maszyny/środowiska zadań służących uruchamianiu innych programów w pod-procesie. Dostarcza także zadanie :func:`find_executable` do przeszukiwania ścieżki pod kątem danej nazwy pliku wykonywalnego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.sysconfig` --- System configuration information</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.sysconfig` --- informacje o konfiguracji systemu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`distutils.sysconfig` module provides access to Python's low-level configuration information.  The specific configuration variables available depend heavily on the platform and configuration. The specific variables depend on the build process for the specific version of Python being run; the variables are those found in the :file:`Makefile` and configuration header that are installed with Python on Unix systems.  The configuration header is called :file:`pyconfig.h` for Python versions starting with 2.2, and :file:`config.h` for earlier versions of Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`distutils.sysconfig` dostarcza dostęp do informacji o niskopoziomowej konfiguracji języka pytonowskiego. Szczególne zmienne konfiguracji dostępne zależą silnie od maszyny/środowiska i konfiguracji. Poszczególne zmienne zależą od procesu budowania szczególnych wersji języka pytonowskiego będących uruchomianymi; zmiennymi są te znajdujące się w pliku :file:`Makefile` i nagłówek konfiguracji które są instalowane z językiem pytonowskim w systemie Unix. Nagłówek konfiguracji zwany jest :file:`pyconfig.h` dla wersji języka pytonowskiego zaczynając od wersji 2.2 i pliku :file:`config.h` dla wcześniejszych wersji języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some additional functions are provided which perform some useful manipulations for other parts of the :mod:`distutils` package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pewne dodatkowe zadania są dostarczone, które wykonują pewne użyteczne operacje dla innych części pakietu :mod:`distutils`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result of ``os.path.normpath(sys.prefix)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rezultat ``os.path.normpath(sys.prefix)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result of ``os.path.normpath(sys.exec_prefix)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rezultat ``os.path.normpath(sys.exec_prefix)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the value of a single variable.  This is equivalent to ``get_config_vars().get(name)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wartość pojedynczej zmiennej. Jest to równoważne ``get_config_vars().get(name)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a set of variable definitions.  If there are no arguments, this returns a dictionary mapping names of configuration variables to values.  If arguments are provided, they should be strings, and the return value will be a sequence giving the associated values. If a given name does not have a corresponding value, ``None`` will be included for that variable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć zbiór definicji zmiennych. Jeśli nie ma parametrów, zwraca słownik mapujący nazwy zmiennych konfiguracji do ich wartości. Jeśli dostarczono parametry, powinny być ciągami znaków, a wartość zwracana będzie będzie sekwencją dającą skojarzone wartości. Jeśli dana nazwa nie ma odpowiadającej wartości, ``None`` będzie załączone dla tej zmiennej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the full path name of the configuration header.  For Unix, this will be the header generated by the :program:`configure` script; for other platforms the header will have been supplied directly by the Python source distribution.  The file is a platform-specific text file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć pełną nazwę ścieżki nagłówka konfiguracji. Dla Unix-a to będzie nagłówek wytworzony przez skrypt konfiguracji :program:`configure`; dla innych maszyn/środowisk będzie dostarczany bezpośrednio przez rozprowadzenie źródłowe języka pytonowskiego. Plik jest zależnym od maszyny/środowiska tekstowym plikiem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the full path name of the :file:`Makefile` used to build Python.  For Unix, this will be a file generated by the :program:`configure` script; the meaning for other platforms will vary.  The file is a platform-specific text file, if it exists. This function is only useful on POSIX platforms.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć pełną nazwę ścieżki pliku :file:`Makefile` użytego do budowania języka Pyton-owskiego. Dla Unix-a będzie to plik wytworzony przez skrypt konfiguracji :program:`configure`; znaczenie dla innych maszyn/środowisk może być różne. Plik jest szczególnym-dla-środowiska plikiem tekstowym, jeśli istnieje. To zadanie jest użyteczne tylko w środowisku POSIX-owym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the directory for either the general or platform-dependent C include files.  If *plat_specific* is true, the platform-dependent include directory is returned; if false or omitted, the platform-independent directory is returned. If *prefix* is given, it is used as either the prefix instead of :const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if *plat_specific* is true.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć katalog dla zarówno ogólnych jak i zależnych-od-środowiska plików załączanych C. Jeśli *plat_specific* (z ang. - zależne_od_środowiska) jest prawdziwe, katalog załączanych plików źródłowych zależnych od środowiska jest zwracany; jeśli fałszywe lub pominięte katalog plików niezależnych-od-środowiska jest zwracany. Jeśli dany jest *przedrostek* ( - z ang. - *prefix*), jest on używany jako prefiks zamiast :const:`PREFIX`, lub jako przedrostek-pliku-wykonywalnego zamiast :const:`EXEC_PREFIX` jeśli *plat_specific* ( - z ang. - szczególny dla środowiska ) jest prawdziwe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the directory for either the general or platform-dependent library installation.  If *plat_specific* is true, the platform-dependent include directory is returned; if false or omitted, the platform-independent directory is returned.  If *prefix* is given, it is used as either the prefix instead of :const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if *plat_specific* is true.  If *standard_lib* is true, the directory for the standard library is returned rather than the directory for the installation of third-party extensions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć katalog dla ogólnej lub zależnej-od-środowiska instalacji biblioteki. Jeśli flaga *plat_specific* ( - szczególny dla środowiska ) jest prawdziwa zależny od środowiska katalog jest zwracany; jeśli fałszywa lub pominięta niezależny-od środowiska katalog jest zwracany. Jeśli *prefix* jest dany, jest używany zarówno jako przedrostek zamiast :const:`PREFIX`, lub jako przedrostek-pliku-wykonywalnego zamiast :const:`EXEC_PREFIX` jeśli flaga *plat_specific* jest prawdziwa. Jeśli flaga *standard_lib* jest prawdziwa, katalog dla standardowej biblioteki jest zwracany zamiast katalogu dla instalowania rozszerzeń od firm-trzecich.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following function is only intended for use within the :mod:`distutils` package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadanie jest tylko przeznaczone do użycia wewnątrz pakietu :mod:`distutils`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do any platform-specific customization of a :class:`distutils.ccompiler.CCompiler` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj szczególne-dla-środowiska dostosowania przykładu uogólnienia :class:`distutils.ccompiler.CCompiler`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is only needed on Unix at this time, but should be called consistently to support forward-compatibility.  It inserts the information that varies across Unix flavors and is stored in Python's :file:`Makefile`.  This information includes the selected compiler, compiler and linker options, and the extension used by the linker for shared objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest tylko potrzebne w Unix-ie w tym czasie, ale powinno być wywoływane konsekwentnie dla zapewnienia zgodności-z-przyszłymi-wersjami. Wstawia informację, która zmienia się w zależności od odmiany Unix-a i jest przechowywana w pliku :file:`Makefile` języka Pyton-owskiego. Ta informacja zawiera wybrany kompilator, opcje kompilatora i programu łączącego pliki wynikowe, i rozszerzenie używane przez program łączący pliki wynikowe dla współdzielonych przedmiotów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is even more special-purpose, and should only be used from Python's own build procedures.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest nawet bardziej szczególnego przeznaczenia, i powinno być tylko używane z procedur budowania języka Pyton-owskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inform the :mod:`distutils.sysconfig` module that it is being used as part of the build process for Python.  This changes a lot of relative locations for files, allowing them to be located in the build area rather than in an installed Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Informuj moduł :mod:`distutils.sysconfig`, który jest używany jako część procesu budowy języka Pyton-owskiego. To zmienia wiele względnych położeń plików, pozwalając im aby były umieszczane w przestrzeni budowy raczej zamiast w miejscu instalacji języka Pyton-owskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.text_file` --- The TextFile class</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.text_file` --- uogólnienie TextFile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the :class:`TextFile` class, which gives an interface  to text files that (optionally) takes care of stripping comments, ignoring  blank lines, and joining lines with backslashes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza uogólnienia :class:`TextFile`, które daje sprzęg dostępu do plików tekstowych, które (opcjonalnie) zajmuje się oczyszczaniem z komentarzy, ignorowaniem pustych linii, i łączeniem linii ze skośnikami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class provides a file-like object that takes care of all  the things you commonly want to do when processing a text file  that has some line-by-line syntax: strip comments (as long as ``#``  is your comment character), skip blank lines, join adjacent lines by escaping the newline (ie. backslash at end of line), strip leading and/or trailing whitespace.  All of these are optional and independently controllable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie dostarcza przedmiot pliko-podobny który zajmuje się wszystkimi rzeczami których zwykle oczekuje się przy przetwarzaniu pliku tekstowego, który ma pewną składnię linia-po-linii: zdejmowania komentarzy (tak długo jak ``#`` jest twoim znakiem komentarza), pomijania pustych linii, łączenia sąsiednich linii przez ucieczkowanie znaku nowej linii (tj. użycie skośnika na końcu linii), zdejmowania poprzedzających i zakańczających białych znaków. Wszystkie te są opcjonalne i kontrolowane niezależnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class provides a :meth:`warn` method so you can generate  warning messages that report physical line number, even if the  logical line in question spans multiple physical lines.  Also  provides :meth:`unreadline` for implementing line-at-a-time lookahead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie dostarcza sposób postępowania :meth:`warn` tak, aby wytwarzać wiadomości ostrzegawcze, które raportują fizyczny numer linii, nawet jeśli logicznie oczekiwana linia rozciąga się na kilka fizycznych linii. Dostarcza także sposób postępowania :meth:`unreadline` ( - z ang. - cofnij wczytywanie ) dla wypełnienia czytania całej-linii-na-raz z wyprzedzeniem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`TextFile` instances are create with either *filename*, *file*, or both. :exc:`RuntimeError` is raised if both are ``None``. *filename* should be a string, and *file* a file object (or something that provides :meth:`readline` and :meth:`close`  methods).  It is recommended that you supply at least *filename*,  so that :class:`TextFile` can include it in warning messages.  If *file* is not supplied, :class:`TextFile` creates its own using the :func:`open` built-in function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnienia :class:`TextFile` są tworzone z nazwą *filename*, *file* lub obydwiema na raz. Błąd :exc:`RuntimeError` jest zgłaszany jeśli oba są ``None``. nazwa pliku *filename* powinna być ciągiem znaków, zaś *file* przedmiotem pliku ( lub czymś co dostarcza sposobów postępowania :meth:`readline` i :meth:`close`). Polecane jest dostarczenie przynajmniej *nazwy pliku* ( - z ang. - *filename*) tak, aby uogólnienie :class:`TextFile` mogło zawrzeć je w wiadomościach ostrzeżeń. Jeśli *plik* ( - z ang. - *file* ) nie jest dostarczony :class`TextFile` tworzy swój własny używając wbudowane zadania :func:`open`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The options are all boolean, and affect the values returned by :meth:`readline`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcje są wszystkie typu bool-owskiego i mają wpływ na zwracane wartości przez :meth:`readline`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>option name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nazwa opcji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>domyślne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*strip_comments*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*strip_comments* ( - z ang. -*zdejmuj_komentarze*)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>strip from ``'#'`` to end-of- line, as well as any whitespace leading up to the ``'#'``\ ---unless it is escaped by a backslash</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zdejmue zza ``'#'`` aż do końca-linii, zarówno, jak wszystkie białe znaki prowadzące do znaku ``'#'``\ ---chyba że zostanie poprzedzony znakiem skośnika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>true</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>prawda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*lstrip_ws*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*lstrip_ws*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>strip leading whitespace from each line before returning it</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zdejmuj wszystkie wiodące białe znaki z każdej linii przed zwróceniem jej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>false</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>fałsz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*rstrip_ws*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*rstrip_ws*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>strip trailing whitespace (including line terminator!) from each line before returning it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zdejmij kończące białe znaki (włączając w to znak końca linii!) z każdej linii przed zwróceniem jej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*skip_blanks*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*skip_blanks*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>skip lines that are empty \*after\* stripping comments and whitespace.  (If both lstrip_ws and rstrip_ws are false, then some lines may consist of solely whitespace: these will \*not\* be skipped, even if *skip_blanks* is true.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pomiń linie które są puste \*po\* zdjęciu komentarzy i białych znaków. (Jeśli zarówno lstrip_ws i rstrip_ws są fałszywe, wtedy niektóre linie mogą składać się wyłącznie z białych znaków: te \*nie\* będą pominięte, nawet jeśli *skip_blanks* jest prawdziwe.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*join_lines*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*join_lines*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if a backslash is the last non-newline character on a line after stripping comments and whitespace, join the following line to it to form one logical line; if N consecutive lines end with a backslash, then N+1 physical lines will be joined to form one logical line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>jeśli skośnik jest ostatnim znakiem nie będącym znakiem nowej linii w wierszu po zdjęciu komentarzy i białych znaków, dołącz następną linię do tej aby utworzyć linię logiczną; jeśli N kolejnych linii kończy się skośnikiem wtedy N+1 fizycznych linii będzie połączonych w jedną logiczną linię.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*collapse_join*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*collapse_join*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>strip leading whitespace from lines that are joined to their predecessor; only matters if ``(join_lines and not lstrip_ws)``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zdejmij wiodące białe znaki z linii które są dołączone do ich poprzedników; ma znaczenie tylko jeśli ``(join_lines i nie lstrip_ws)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that since *rstrip_ws* can strip the trailing newline, the semantics of :meth:`readline` must differ from those of the built-in file object's :meth:`readline` method!  In particular, :meth:`readline`  returns ``None`` for end-of-file: an empty string might just be a  blank line (or an all-whitespace line), if *rstrip_ws* is true  but *skip_blanks* is not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że od kiedy *rstrip_ws* może zdjąć kończący znak nowej linii, składnia sposobu postępowania :meth:`readline` musi różnić się od tej należącej do wbudowanego sposobu postępowania :meth:`readline` w odniesieniu do przedmiotu uogólnienia pliku. W szczególności sposób postępowania :meth:`readline` zwraca ``None`` ( - z ang. - ``Żaden`` ) dla końca-pliku ( - z ang. - end-of-file) : pusty ciąg znaków może być po prostu pustą linią (lub linią białych znaków), jeśli *rstrip_ws* jest prawdziwe ale *skip_blanks* nie jest.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a new file *filename*.  This overrides any *file* or *filename* constructor arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Otwórz nowy plik *filename*. To omija wszystkie parametry konstruktora *file* lub *filename*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the current file and forget everything we know about it (including the filename and the current line number).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamknij obecny plik i zapomnij wszystko co wiadomo na jego temat (włączając w to nazwę pliku i aktualny numer wiersza).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print (to stderr) a warning message tied to the current logical line in the current file.  If the current logical line in the file spans multiple physical lines, the warning refers to the whole range, such as ``"lines 3-5"``.  If *line* is supplied,  it overrides the current line number; it may be a list or tuple  to indicate a range of physical lines, or an integer for a  single physical line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisz (na stderr) wiadomość ostrzeżenia dowiązaną do aktualnej logicznej linii w obecnym pliku. Jeśli aktualna logiczna linia w pliku rozciąga się na kilka fizycznych linii, ostrzeżenie odnosi się do całego zakresu np. ``"linie 3-5"``. Jeśli (*line* - z ang. - linia) jest dostarczona nadpisuje ona aktualny numer linii; może być listą, krotką aby zaznaczyć zakres fizycznych linii, lub liczbę całkowitą dla pojedynczej fizycznej linii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read and return a single logical line from the current file (or from an internal buffer if lines have previously been "unread" with :meth:`unreadline`).  If the *join_lines* option  is true, this may involve reading multiple physical lines concatenated into a single string.  Updates the current line number,  so calling :meth:`warn` after :meth:`readline` emits a warning  about the physical line(s) just read.  Returns ``None`` on end-of-file,  since the empty string can occur if *rstrip_ws* is true but  *strip_blanks* is not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj i zwróć pojedynczą logiczną linię z aktualnego pliku (lub z wewnętrznej przestrzeni wymiany jeśli linie były przedtem "cofnięte" (- z ang. - "unread" ) przy użyciu sposobu postępowania :meth:`unreadline`). Jeśli opcja *join_lines* jest prawdziwa, może to oznaczać wczytanie kilku fizycznych linii złączonych w jeden ciąg znaków.   Uaktualnia aktualny numer wiersza, więc wywołanie sposobu postępowania :meth:`warn` po sposobie postępowania :meth:`readline` wysyła ostrzeżenie o aktualnie wczytanych fizycznych lini(ach). Zwraca ``Żaden`` - z ang. - ``None`` przy końcu-pliku, gdyż pusty ciąg znaków może zdarzyć się, jeśli *rstrip_ws* jest prawdziwe ale *strip_blanks* nie jest.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read and return the list of all logical lines remaining in the current file. This updates the current line number to the last line of the file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj i zwróć listę wszystkich logicznych linii pozostałych w obecnym pliku. To aktualizuje obecny numer wiersza na ostatni wiersz pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Push *line* (a string) onto an internal buffer that will be checked by future :meth:`readline` calls.  Handy for implementing a parser with line-at-a-time lookahead. Note that lines that are "unread" with :meth:`unreadline` are not subsequently re-cleansed (whitespace  stripped, or whatever) when read with :meth:`readline`. If multiple calls are made to :meth:`unreadline` before a call to :meth:`readline`, the lines will be returned most in most recent first order.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pchnij *linię* (ciąg znaków) na wewnętrzną przestrzeń wymiany, która zostanie sprawdzona przez przyszłe wywołania sposobu postępowania :meth:`readline`. Poręczne przy wypełnianiu programu wczytującego jedną-linię-na-raz z wyprzedzeniem. Zauważ, że linie,  które są "cofane" ( - z ang. - "unread" ) sposobem postępowania :meth:`unreadline` nie są powtórnie czyszczone (z białych znaków, lub jakkolwiek) gdy są wczytywane za pomocą sposobu postępowania :meth:`readline`. Jeśli wielokrotne  wykonywane są odwołania do :meth:`unreadline` przed wywołaniem sposobu postępowania :meth:`readline` linie zostaną zwrócone w kolejności najmniej dawnego na początku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.version` --- Version number classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.version` --- uogólnienia numerów wersji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.cmd` --- Abstract base class for Distutils commands</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.cmd` --- Abstrakcyjne uogólnienie podstawowe dla komend modułu Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module supplies the abstract base class :class:`Command`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza abstrakcyjnych uogólnień podstawowych :class:`Command`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abstract base class for defining command classes, the "worker bees" of the Distutils.  A useful analogy for command classes is to think of them as subroutines with local variables called *options*.  The options are declared in :meth:`initialize_options` and defined (given their final values) in :meth:`finalize_options`, both of which must be defined by every command class. The distinction between the two is necessary because option values might come from the outside world (command line, config file, ...), and any options dependent on other options must be computed after these outside influences have been processed --- hence :meth:`finalize_options`.  The body of the subroutine, where it does all its work based on the values of its options, is the :meth:`run` method, which must also be implemented by every command class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjne uogólnienie podstawowe dla definiowania uogólnień poleceń, "pracowitych pszczółek" Distutils. Użytecznym porównaniem uogólnień poleceń jest myślenie o nich jak o podprogramach z lokalnymi zmiennymi zwanymi *opcjami*. Opcje są deklarowane sposobem postępowania :meth:`initialize_options` i określane (znając ich ostateczne wartości) w sposobie postępowania :meth:`finalize_options`, z których obie muszą być zdefiniowane przez każde uogólnienie polecenia. Rozróżnienie pomiędzy nimi jest konieczne ponieważ wartości opcji mogą przychodzić z zewnętrznego świata (wiersz poleceń, plik konfiguracji, ...), i dowolne opcje zależne od innych opcji muszą być obliczone po tym, jak  te zewnętrzne wpływy zostaną przetworzone --- stąd :meth:`finalize_options`. Ciałem podprogramu, gdzie wykonuje całą swoją pracę opartą o wartości swoich opcji, jest sposób postępowania :meth:`run`, który musi być określony przez każde uogólnienie polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class constructor takes a single argument *dist*, a  :class:`Distribution` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>konstruktor uogólnienia pobiera pojedynczy paramter *dist* - przykład uogólnienia - :class:`Distribution`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command` --- Individual Distutils commands</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command` --- indywidualne polecenia Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.bdist` --- Build a binary installer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.bdist` --- Zbuduj binarną wersję instalatora</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.bdist_packager` --- Abstract base class for packagers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.bdist_packager` --- abstrakcyjne uogólnienie podstawowe dla pakowaczy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.bdist_dumb` --- Build a "dumb" installer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.bdist_dumb` --- Zbuduj "głupi" instalator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.bdist_msi` --- Build a Microsoft Installer binary package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.bdist_msi` --- Zbuduj  instalator Microsoftu w postaci binarnej paczki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Builds a `Windows Installer`_ (.msi) binary package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Buduje `Instalator Windowsa` _ (.msi) w postaci paczki binarnej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most cases, the ``bdist_msi`` installer is a better choice than the ``bdist_wininst`` installer, because it provides better support for Win64 platforms, allows administrators to perform non-interactive installations, and allows installation through group policies.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W większości przypadków, instalator ``bdist_msi`` jest lepszym rozwiązaniem niż ``bdist_wininst``, ponieważ dostarcza to lepszego wsparcia dla środowiska Win64, pozwala administratorom wykonywać zaplanowane instalacje i pozwala na instalacje przez uprawnienia grup.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.bdist_rpm` --- Build a binary distribution as a Redhat RPM and SRPM</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.bdist_rpm` --- Zbuduj dystrybucję binarną jako pakiet Redhat-a RPM i SRPM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.bdist_wininst` --- Build a Windows installer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.bdist_wininst` --- Zbuduj instalator Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.sdist` --- Build a source distribution</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.sdist` --- Zbuduj dystrybucję źródeł.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.build` --- Build all files of a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.build` --- Zbuduj wszystkie pliki w pakiecie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.build_clib` --- Build any C libraries in a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.build_clib` --- Zbuduj wszystkie biblioteki C w pakiecie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.build_ext` --- Build any extensions in a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.build_ext` --- Zbuduj wszystkie rozszerzenia w pakiecie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.build_py` --- Build the .py/.pyc files of a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.build_py` --- Zbuduj pliki .py/.pyc w pakiecie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative implementation of build_py which also runs the 2to3 conversion library on each .py file that is going to be installed. To use this in a setup.py file for a distribution that is designed to run with both Python 2.x and 3.x, add::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Alternatywne wypełnienie build_py, które także uruchamia bibliotekę konwersji 2to3 na każdym pliku .py, który zostanie zainstalowany. Aby użyć tego w pliku setup.py dla dystrybucji która jest zaprojektowana aby działać zarówno z językiem pytonowskim 2.x jak i 3.x, dodaj::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try:    from distutils.command.build_py import build_py_2to3 as build_py except ImportError:    from distutils.command.build_py import build_py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>try:    from distutils.command.build_py import build_py_2to3 as build_py except ImportError:    from distutils.command.build_py import build_py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to your setup.py, and later::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>do twojego setup.py, i później::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cmdclass = {'build_py':build_py}</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cmdclass = {'build_py':build_py}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to the invocation of setup().</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>do wywołania setup().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.build_scripts` --- Build the scripts of a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.build_scripts` --- Zbuduj skrypty pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.clean` --- Clean a package build area</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.clean` --- Wyczyść przestrzeń budowy pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.config` --- Perform package configuration</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.config` --- Wykonaj konfigurację pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.install` --- Install a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.install` --- Instaluj pakiet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.install_data` --- Install data files from a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.install_data` --- Instaluj pliki danych z pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.install_headers` --- Install C/C++ header files from a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.install_headers` --- Zainstaluj pliki nagłówkowe C/C++ z pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.install_lib` --- Install library files from a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.install_lib` --- Instaluj pliki bibliotek z pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.install_scripts` --- Install script files from a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.install_scripts` --- Instaluj pliki skryptów z pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`distutils.command.register` --- Register a module with the Python Package Index</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`distutils.command.register` --- Zarejestruj moduł na indeksie pakietów języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``register`` command registers the package with the Python Package  Index. This is described in more detail in :pep:`301`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>komenda ``register`` rejestruje pakiet na indeksie pakietów języka pytonowskiego ( - z ang. - Python Package Index ). Jest to opisane bardziej szczegółowo w :pep:`301`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new Distutils command</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie nowego polecenia Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section outlines the steps to create a new Distutils command.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta sekcja opisuje kroki prowadzące do utworzenia nowego polecenia Distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A new command lives in a module in the :mod:`distutils.command` package. There is a sample template in that directory called  :file:`command_template`. Copy this file to a new module with the same name as the new command you're implementing. This module should implement a class with the same name as the module (and the command). So, for instance, to create the command ``peel_banana`` (so that users can run ``setup.py peel_banana``), you'd copy :file:`command_template`  to :file:`distutils/command/peel_banana.py`, then edit it so that it's implementing the class :class:`peel_banana`, a subclass of :class:`distutils.cmd.Command`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nowe polecenie żyje w module w pakiecie :mod:`distutils.command`. W tamtym katalogu istnieje przykład nowego polecenia nazwany :file:`command_template`. Skopiuj go do nowego modułu o tej samej nazwie jak polecenie które wypełniasz. Ten moduł powinien wypełniać szczegóły uogólnienia o tej samej nazwie jak moduł (i jak polecenie). Więc na przykład, aby utworzyć polecenie ``obrac_banan`` (tak, aby użytkownik mógł uruchomić ``setup.py obrac_banan``), potrzeba skopiować plik :file:`command_template` do :file:`distutils/command/obrac_banan.py`, potem zmienić jego zawartość tak, aby wypełnić sens uogólnienia polecenia :class:`obrac_banan`, podrzędnego względem :class:`distutils.cmd.Command`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subclasses of :class:`Command` must define the following methods.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienia podrzędne względem uogólnienia :class:`Command` muszą określać następujące sposoby postępowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set default values for all the options that this command supports.  Note that these defaults may be overridden by other commands, by the setup script, by config files, or by the command-line.  Thus, this is not the place to code dependencies between options; generally, :meth:`initialize_options` implementations are just a bunch of ``self.foo = None`` assignments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustal wartości domyślne dla wszystkich opcji które to polecenie wspiera. Zwróć uwagę, że te wartości domyślne mogą na nowo zdefiniowane przez inne polecenia, przez skrypty ustawiające, przez pliki konfiguracyjne, lub przez wiersz-poleceń. Zatem nie jest to miejsce aby zakodowywać zależności pomiędzy opcjami; W ogóle wypełnienia :meth:`initialize_options` są po prostu wiechciem przypisań ``self.foo = None``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set final values for all the options that this command supports. This is always called as late as possible, ie.  after any option assignments from the command-line or from other commands have been done.  Thus, this is the place to to code option dependencies: if *foo* depends on *bar*, then it is safe to set *foo* from *bar* as long as *foo* still has the same value it was assigned in :meth:`initialize_options`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw końcowe wartości dla wszystkich opcji które to polecenie wspiera. To jest zawsze wywoływane tak późno jak tylko się da, tj. po tym jak jakiekolwiek przypisania opcji z wiersza poleceń lub innych poleceń zostały przeprowadzone. Zatem, to jest miejsce aby zakodować zależności opcji: jeśli *foo* zależy od *bar*, wtedy można bezpiecznie ustawić *foo* przy użyciu *bar* tak długo jak *foo* wciąż ma tą samą wartość jaka była mu przypisana przez sposób postępowania :meth:`initialize_options`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A command's raison d'etre: carry out the action it exists to perform, controlled by the options initialized in :meth:`initialize_options`, customized by other commands, the setup script, the command-line, and config files, and finalized in :meth:`finalize_options`.  All terminal output and filesystem interaction should be done by :meth:`run`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sens ist-nie-nia po-le-ce-nia: wypełnić działanie do jakiego jest przeznaczone, kontrolowane przez opcje inicjowane w sposobie postępowania :meth:`initialize_options`, dostosowywane przez inne polecenia, skrypty ustawień, wiersz poleceń, pliki konfiguracji, i kończone w sposobie postępowania :meth:`finalize_options`. Wszystkie wypisywania na terminal i współdziałanie z systemem plików powinno odbywać się w sposobie postępowania :meth:`run`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*sub_commands* formalizes the notion of a "family" of commands, eg. ``install`` as the parent with sub-commands ``install_lib``, ``install_headers``, etc.  The parent of a family of commands defines *sub_commands* as a class attribute; it's a list of 2-tuples ``(command_name, predicate)``, with *command_name* a string and *predicate* a function, a string or None. *predicate* is a method of the parent command that determines whether the corresponding command is applicable in the current situation.  (Eg. we ``install_headers`` is only applicable if we have any C header files to install.)  If *predicate* is None, that command is always applicable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*sub_commands* formalizuje pomysł "rodziny" poleceń, np. ``install`` jako rodzica z pod-poleceniami ``install_lib``, ``install_headers``, itd. Rodzic rodziny poleceń określa *sub_commands* - z ang - *pod-polecenia* jako właściwość uogólnienia; jest listą 2-krotek ``(nazwa_polecenia, predykat)`` z *nazwą_polecenia* - z ang. - *command_name* - ciągiem znaków i *predykatem* - z ang. - *predicate* - funkcją, ciągiem znaków lub niczym - z ang. - None. *predykat* - z ang. - *predicate*  jest sposobem postępowania polecenia nadrzędnego, która ustala czy odpowiadające polecenie jest właściwe w danej sytuacji. (Np. ``install_headers`` jest tylko właściwe jeśli mamy jakieś pliki nagłówkowe C do zainstalowania.) Jeśli *predykat* jest Żaden - z ang. - None, to polecenie jest zawsze właściwe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*sub_commands* is usually defined at the \*end\* of a class, because predicates can be methods of the class, so they must already have been defined.  The canonical example is the :command:`install` command.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*pod_polecenia* - z ang. - *sub_commands* jest zwykle określane na \*końcu\* z ang. - \*end\* uogólnienia, gdyż predykaty mogą być sposobami postępowania uogólnienia, więc muszą być już zdefiniowane. Najwłaściwszym przykładem jest polecenie :command:`install`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Built Distributions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie Zbudowanych Dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A "built distribution" is what you're probably used to thinking of either as a "binary package" or an "installer" (depending on your background).  It's not necessarily binary, though, because it might contain only Python source code and/or byte-code; and we don't call it a package, because that word is already spoken for in Python.  (And "installer" is a term specific to the world of mainstream desktop systems.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Zbudowana dystrybucja" jest pewnie tym do czego przyzwyczaiłeś się myśleć gdy napotykasz "binarny pakiet" lub "instalator" (w zależności od twoich dotychczasowych doświadczeń). Nie jest ona jednak koniecznie binarna, gdyż może zawierać tylko kod w języku pytonowskim i/lub kod-kęsowy; i nie nazywamy jej pakietem, gdyż ten termin jest już zarezerwowany w języku pytonowskim. (Zaś "instalator" jest terminem szczególnym dla świata systemów typu desktop głównego nurtu.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A built distribution is how you make life as easy as possible for installers of your module distribution: for users of RPM-based Linux systems, it's a binary RPM; for Windows users, it's an executable installer; for Debian-based Linux users, it's a Debian package; and so forth.  Obviously, no one person will be able to create built distributions for every platform under the sun, so the Distutils are designed to enable module developers to concentrate on their specialty---writing code and creating source distributions---while an intermediary species called *packagers* springs up to turn source distributions into built distributions for as many platforms as there are packagers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zbudowana dystrybucja to sposób w jaki możesz ułatwić życie tak bardzo jak to jest możliwe dla osób instalujących dystrybucję twojego modułu: dla użytkowników systemu Linux opartego o pakiety RPM, jest to binarny RPM; dla użytkowników Windows, jest to wykonywalny instalator; dla użytkowników systemu Linux opartego o Debiana jest to pakiet Debiana, itd. Oczywiście nikt przy zdrowych zmysłach nie jest w stanie tworzyć zbudowanych dystrybucji dla każdej maszyny/środowiska pod słońcem, więc Distutils są pomyślane tak aby umożliwić twórcom modułów skupienie się na tym na czym się znają najlepiej---pisaniu kodu i tworzeniu dystrybucji źródłowej---podczas gdy kasta pośrednicząca zwana *pakieciarzami* narodziła się aby zamieniać dystrybucje źródłowe w zbudowane dystrybucje dla tak wielu maszyn/środowisk jak wielu jest pakieciarzy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, the module developer could be his own packager; or the packager could be a volunteer "out there" somewhere who has access to a platform which the original developer does not; or it could be software periodically grabbing new source distributions and turning them into built distributions for as many platforms as the software has access to.  Regardless of who they are, a packager uses the setup script and the :command:`bdist` command family to generate built distributions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oczywiście twórca modułu mógłby być swoim własnym pakieciarzem; lub pakieciarz mógłby być wolontariuszem "tam gdzieś" w szerokim świecie - kimś kto ma dostęp do maszyny/środowiska do którego pierwotny twórca nie ma; lub mógłby być oprogramowaniem regularnie pobierającym nowe dystrybucje źródłowe i zamieniających je w zbudowane dystrybucje dla tak wielu maszyn/środowisk do jak wielu ten program miałby dostęp. Niezależnie od tego, kim jest, pakieciarz korzysta ze skryptu instalacyjnego i rodziny poleceń :command:`bdist` do wytwarzania zbudowanych dystrybucji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a simple example, if I run the following command in the Distutils source tree::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jako prosty przykład, jeśli uruchomię następujące polecenie na drzewie źródeł Distutils::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then the Distutils builds my module distribution (the Distutils itself in this case), does a "fake" installation (also in the :file:`build` directory), and creates the default type of built distribution for my platform.  The default format for built distributions is a "dumb" tar file on Unix, and a simple executable installer on Windows.  (That tar file is considered "dumb" because it has to be unpacked in a specific location to work.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wtedy Distutils buduje dystrybucję mojego modułu (samo Distutils w tym przypadku), wykonuje "fałszywą" instalację (także w katalogu :file:`build`), i tworzy domyślny rodzaj zbudowanej dystrybucji dla mojej maszyny/środowiska. Domyślnym formatem dla zbudowanych dystrybucji jest "durny" plik tar na Unix-ie, i prosty wykonywalny instalator w Windows. (Ten plik tar jest uznawany za "głupi" gdyż musi zostać rozpakowany w szczególnym miejscu aby mógł zadziałać.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the above command on a Unix system creates :file:`Distutils-1.0.{plat}.tar.gz`; unpacking this tarball from the right place installs the Distutils just as though you had downloaded the source distribution and run ``python setup.py install``.  (The "right place" is either the root of the filesystem or  Python's :file:`{prefix}` directory, depending on the options given to the :command:`bdist_dumb` command; the default is to make dumb distributions relative to :file:`{prefix}`.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Więc, powyższe polecenie tworzy w systemie Unix plik :file:`Distutils`1.0.{plat}.tar.gz`; rozpakowanie tego tarball-a z właściwego miejsca instaluje Distutils tak, jakbyś ściągnął dystrybucję źródłową i uruchomił ``python setup.py install`` ("właściwe miejsce" to zarówno katalog nadrzędny systemu plików lub katalog :file:`{prefix}` języka pytonowskiego, zależnie od opcji przekazanych poleceniu :command:`bdist_dumb`; domyślnie jest to robienie niezbyt-mądrej dystrybucji w odniesieniu do :file:`{prefix}`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, for pure Python distributions, this isn't any simpler than just running ``python setup.py install``\ ---but for non-pure distributions, which include extensions that would need to be compiled, it can mean the difference between someone being able to use your extensions or not.  And creating "smart" built distributions, such as an RPM package or an executable installer for Windows, is far more convenient for users even if your distribution doesn't include any extensions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oczywiście, dla czystych dystrybucji języka pytonowskiego, to nie jest w żaden sposób prostsze niż po prostu uruchomienie ``python setup.py install``\ ---ale dla dystrybucji "nie"-czystych, które zawierają rozszerzenia które wymagają kompilacji, może to mieć znaczenie dla kogoś kto będzie mógł użyć twoich rozszerzeń lub nie. Zaś tworzenie "inteligentnie" zbudowanych dystrybucji, takich jak pakiet RPM lub instalator wykonywalny dla Windows, jest dużo prostsze dla użytkowników nawet jeśli twoja dystrybucja nie zawiera żadnych rozszerzeń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :command:`bdist` command has a :option:`--formats` option, similar to the :command:`sdist` command, which you can use to select the types of built distribution to generate: for example, ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenie :command:`bdist` ma opcję :option:`--formats`, podobną do polecenia :command:`sdist` które możesz użyć aby wybrać rodzaje zbudowanej dystrybucji do wygenerowania: na przykład, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist --format=zip</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist --format=zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>would, when run on a Unix system, create :file:`Distutils-1.0.{plat}.zip`\ ---again, this archive would be unpacked from the root directory to install the Distutils.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mogłoby gdy uruchomione na systemie Unix-owym, stworzyć plik :file:`Distutils-1.0.{plat}.zip`\---znów, to archiwum mogłoby być rozpakowane z katalogu nadrzędnego systemu plików w celu zainstalowania Distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The available formats for built distributions are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostępne formaty dla zbudowanych dystrybucji to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Format</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Notatki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``gztar``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``gztar``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gzipped tar file (:file:`.tar.gz`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gzip-nięty plik tar (:file:`.tar.gz`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(1),(3)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(1),(3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``ztar``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``ztar``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compressed tar file (:file:`.tar.Z`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>skompresowany plik tar (file`.tar.Z`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(3)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``tar``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``tar``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tar file (:file:`.tar`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>plik tar (:file:`.tar`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``zip``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``zip``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zip file (:file:`.zip`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>plik zip (:file:`.zip`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(2),(4)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(2),(4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``rpm``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``rpm``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RPM</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>RPM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(5)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``pkgtool``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``pkgtool``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solaris :program:`pkgtool`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Solarisowe narzędzie :program:`pkgtool`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``sdux``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``sdux``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HP-UX :program:`swinstall`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>program systemu HP-UX :program:`swinstall`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``wininst``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``wininst``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>self-extracting ZIP file for Windows</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>samo-rozpakowujące się archiwum ZIP dla Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(4)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``msi``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``msi``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft Installer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalator Microsoft</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwagi:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default on Unix</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>domyślne dla Unix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default on Windows</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>domyślne dla Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>requires external utilities: :program:`tar` and possibly one of :program:`gzip`, :program:`bzip2`, or :program:`compress`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wymaga zewnętrznych użytków: :program:`tar`-a i prawdopodobnie jednego z programów: :program:`gzip`, programu :program:`bzip2`, lub programu :program:`compress`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>requires either external :program:`zip` utility or :mod:`zipfile` module (part of the standard Python library since Python 1.6)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wymaga zewnętrznego programu użytkowego :program:`zip` lub modułu :mod:`zipfile` (części standardowej biblioteki języka pytonowskiego od wersji 1.6 języka pytonowskiego)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>requires external :program:`rpm` utility, version 3.0.4 or better (use ``rpm --version`` to find out which version you have)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wymaga zewnętrznego programu użytkowego :program:`rpm`, w wersji 3.0.4 lub lepszej (użyj ``rpm --version`` aby dowiedzieć się, którą wersję posiadasz)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to use the :command:`bdist` command with the :option:`--formats` option; you can also use the command that directly implements the format you're interested in.  Some of these :command:`bdist` "sub-commands" actually generate several similar formats; for instance, the :command:`bdist_dumb` command generates all the "dumb" archive formats (``tar``, ``ztar``, ``gztar``, and ``zip``), and :command:`bdist_rpm` generates both binary and source RPMs.  The :command:`bdist` sub-commands, and the formats generated by each, are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie musisz używać polecenia :command:`bdist` z opcją :option:`--formats`; możesz także użyć polecenia które bezpośrednio wypełnia format którym się interesujesz. Niektóre z tych podrzędnych poleceń :command:`bdist` właściwie generuje kilka podobnych formatów; na przykład polecenie :command:`bdist_dumb` wytwarza wszystkie "głupie" formaty archiwum (``tar``, ``ztar``, ``gztar``, i ``zip``), a polecenie :command:`bdist_rpm` wytwarza zarówno binarne jak i źródłowe pakiety RPM. Podrzędne polecenia :command:`bdist`, i formaty wytworzone przez każdy z nich, to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Formats</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Formaty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`bdist_dumb`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`bdist_dumb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tar, ztar, gztar, zip</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>tar, ztar, gztar, zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`bdist_rpm`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`bdist_rpm`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>rpm, srpm</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>rpm, srpm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`bdist_wininst`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`bdist_wininst`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>wininst</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wininst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`bdist_msi`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`bdist_msi`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>msi</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>msi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following sections give details on the individual :command:`bdist_\*` commands.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące paragrafy opowiadają w szczegółach o poszczególnych poleceniach :command:`bdist_\*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating dumb built distributions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie głupich zbudowanych dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**\*\*** Need to document absolute vs. prefix-relative packages here, but first I have to implement it! **\*\***</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**\*\*** Potrzebuję udokumentować bezwzględne vs. względne -zależne-od-przedrostka pakiety tuta, ale wscześniej muszę je wypełnić! **\*\***</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating RPM packages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie pakietów RPM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The RPM format is used by many popular Linux distributions, including Red Hat, SuSE, and Mandrake.  If one of these (or any of the other RPM-based Linux distributions) is your usual environment, creating RPM packages for other users of that same distribution is trivial. Depending on the complexity of your module distribution and differences between Linux distributions, you may also be able to create RPMs that work on different RPM-based distributions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Format RPM jest używany przez wiele popularnych dystrybucji Linuxa, włączając w to Red Hat, SuSE, i Mandrake. Jeśli jeden z nich (lub jakiekolwiek inne oparte o RPM dystrybucje Linuxa) są twoim typowym środowiskiem, tworzenie pakietów RPM dla innych użytkowników tej samej dystrybucji jest trywialne. W zależności od złożoności dystrybucji twojego modułu i różnic pomiędzy dystrybucjami Linux-a możesz być w stanie stworzyć RPMy, które współpracują z różnymi opartymi-o-RPM dystrybucjami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual way to create an RPM of your module distribution is to run the :command:`bdist_rpm` command::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwykłym sposobem na utworzenie RPMu twojej dystrybucji modułu jest uruchomienie polecenia :command:`bdist_rpm`:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist_rpm</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist_rpm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or the :command:`bdist` command with the :option:`--format` option::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lub polecenia :command:`bdist` z opcją :option:`--format`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist --formats=rpm</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist --formats=rpm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The former allows you to specify RPM-specific options; the latter allows  you to easily specify multiple formats in one run.  If you need to do both, you can explicitly specify multiple :command:`bdist_\*` commands and their options::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To pierwsze pozwala ci określić szczególne-dla-RPM opcje; to ostatnie pozwala Ci łatwo tworzyć wiele formatów za jednym zamachem. Jeśli potrzebujesz zrobić obydwu, możesz jawnie wyszczególnić wiele poleceń :command:`bdist_\*` i ich opcji::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist_rpm --packager="John Doe &lt;jdoe@example.org&gt;" \                 bdist_wininst --target_version="2.0"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist_rpm --packager="John Doe &lt;jdoe@example.org&gt;" \                 bdist_wininst --target_version="2.0"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating RPM packages is driven by a :file:`.spec` file, much as using the Distutils is driven by the setup script.  To make your life easier, the :command:`bdist_rpm` command normally creates a :file:`.spec` file based on the information you supply in the setup script, on the command line, and in any Distutils configuration files.  Various options and sections in the :file:`.spec` file are derived from options in the setup script as follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie pakietu RPM jest napędzane plikiem :file:`.spec`, tak jak używanie Distutils jest napędzane skryptem instalacyjnym. Aby ułatwić ci życie, polecenie :command:`bidst_rpm` zwykle tworzy plik :file:`.spec` oparte o informację którą mu dostarczasz w skrypcie instalacyjnym, w wierszu poleceń, i w plikach konfiguracyjnych Distutils. Różne opcje i sekcje w pliku :file:`.spec` są pochodnymi po opcjach w skrypcie instalacyjnym w następujący sposób: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RPM :file:`.spec` file option or section</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>plik RPM :file:`.spec` opcja lub sekcja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distutils setup script option</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcja skryptu instalacyjnego Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`name`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summary (in preamble)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podsumowanie (w preambule)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`description`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`description`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wersja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`version`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`version`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vendor</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostawca</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`author` and :option:`author_email`, or  --- &amp; :option:`maintainer` and :option:`maintainer_email`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`author` i :option:`author_email`, lub  --- &amp; :option:`maintainer` i :option:`maintainer_email`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copyright</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Licencja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`license`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`license`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Url</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>adres Url</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`url`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`url`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%description (section)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>%opis (sekcja)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`long_description`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`long_description`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, there are many options in :file:`.spec` files that don't have corresponding options in the setup script.  Most of these are handled through options to the :command:`bdist_rpm` command as follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowo, istnieje wiele opcji w plikach :file:`.spec` które nie muszą mieć odpowiadających opcji w skrypcie instalacyjnym. Większość z tych jest obsługiwana przez opcje polecenia :command:`bdist_rpm` jak następuje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`bdist_rpm` option</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`bdist_rpm` option</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default value</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wartość domyślna</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Release</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`release`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`release`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"1"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"1"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Group</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Grupa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`group`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`group`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Development/Libraries"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Rozwój/Biblioteki"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`vendor`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`vendor`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(see above)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(zobacz powyżej)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packager</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pakujący</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`packager`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`packager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(none)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(żaden)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provides</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcza</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`provides`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`provides`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wymaga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`requires`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`requires`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conflicts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konflikty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`conflicts`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`conflicts`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obsoletes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zbędne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`obsoletes`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`obsoletes`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distribution</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dystrybucja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`distribution_name`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`distribution_name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BuildRequires</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ZbudowanieWymaga</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`build_requires`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`build_requires`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Icon</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obrazek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`icon`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:option:`icon`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, supplying even a few of these options on the command-line would be tedious and error-prone, so it's usually best to put them in the setup configuration file, :file:`setup.cfg`\ ---see section :ref:`setup-config`.  If you distribute or package many Python module distributions, you might want to put options that apply to all of them in your personal Distutils configuration file (:file:`~/.pydistutils.cfg`).  If you want to temporarily disable this file, you can pass the --no-user-cfg option to setup.py.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oczywiście, dostarczenie nawet kilku z tych opcji w wierszu poleceń byłoby nużące i podatne na błędy, więc zazwyczaj najlepiej jest umieścić je w pliku konfiguracji instalacji, :file:`setup.cfg`\ ---zobacz rozdział :ref:`setup-config`. Jeśli rozprowadzasz lub pakujesz wiele dystrybucji modułów języka pytonowskiego, może się zdarzyć, że będziesz wolał umieścić opcje które odnoszą się do nich wszystkich w twoim osobistym pliku konfiguracji Distutils (:file:`~/.pydistutils.cfg`). Jeśli chcesz tymczasowo wyłączyć ten plik możesz przekazać opcję --no-user-cfg do setup.py.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three steps to building a binary RPM package, all of which are handled automatically by the Distutils:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją trzy kroki do zbudowania binarnego pakietu RPM, z których wszystkie są obsługiwane automatycznie przez Distutils:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create a :file:`.spec` file, which describes the package (analogous  to the Distutils setup script; in fact, much of the information in the  setup script winds up in the :file:`.spec` file)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utwórz plik :file:`.spec`, który opisuje pakiet (analogiczny do skryptu instalacyjnego Distutils; w rzeczywistości, większość informacji w skrypcie instalacyjnym ląduje do pliku :file:`.spec`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the source RPM</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>stwórz źródłowy RPM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the "binary" RPM (which may or may not contain binary code, depending on whether your module distribution contains Python extensions)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>stwórz "binarny" pakiet RPM (który może zawierać lub może nie zawierać kodu binarnego, w zależności od tego czy dystrybucja modułu zawiera rozszerzenia języka pytonowskiego) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally, RPM bundles the last two steps together; when you use the Distutils, all three steps are typically bundled together.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwykle, pakiet RPM gromadzi dwa ostatnie kroki razem; gdy używasz Distutils, wszystkie trzy kroki są zwyczajowo zgromadzone razem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish, you can separate these three steps.  You can use the :option:`--spec-only` option to make :command:`bdist_rpm` just create the :file:`.spec` file and exit; in this case, the :file:`.spec` file will be written to the "distribution directory"---normally :file:`dist/`, but customizable with the :option:`--dist-dir` option.  (Normally, the :file:`.spec` file winds up deep in the "build tree," in a temporary directory created by :command:`bdist_rpm`.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli wolisz, możesz rozdzielić te trzy kroki. Możesz użyć opcji :option:`--spec-only` aby polecenie :command:`bdist_rpm` po prostu stworzyło plik :file:`.spec` i zakończyło wykonanie; w tym przypadku plik :file:`.spec` zostanie zapisany do "katalogu dystrybucji" --- zwykle :file:`dist/`, ale z możliwością zmiany za pomocą opcji :option:`--dist-dir`. (Normalnie, plik :file:`.spec` jest umieszczany głęboko zagrzebany w strukturze "katalogów budowania", w katalogu tymczasowym stworzonym przez polecenie :command:`bdist_rpm`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating Windows Installers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie Instalatorów Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executable installers are the natural format for binary distributions on Windows.  They display a nice graphical user interface, display some information about the module distribution to be installed taken from the metadata in the setup script, let the user select a few options, and start or cancel the installation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonywalne instalatory są zwykłym formatem dla binarnych dystrybucji w Windows. Wyświetlają miły graficzny sprzęg użytkownika, wyświetlają pewne informacje o dystrybucji modułu do zainstalowania wziętej z opisu pakietu ze skryptu instalacyjnego, pozwalają użytkownikowi wybrać kilka opcji, i zacząć lub anulować instalację. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the metadata is taken from the setup script, creating Windows installers is usually as easy as running::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ponieważ meta-dane wzięte są ze skryptu instalacyjnego, tworzenie instalatorów Windows jest zwykle tak proste jak uruchomienie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist_wininst</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist_wininst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or the :command:`bdist` command with the :option:`--formats` option::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lub polecenia :command:`bdist` z opcją :option:`--format`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist --formats=wininst</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist --formats=wininst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a pure module distribution (only containing pure Python modules and packages), the resulting installer will be version independent and have a name like :file:`foo-1.0.win32.exe`.  These installers can even be created on Unix platforms or Mac OS X.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz masz czystą dystrybucję z modułami (zawierającą tylko moduły pytonowskie i pakiety), wynikowy instalator będzie niezależny od wersji i będzie miał nazwę jako: :file:`foo-1.0.win32.exe` Takie instalatory mogą nawet być tworzone na maszynie/środowisku Unix-owym lub na Mac OS X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a non-pure distribution, the extensions can only be created on a Windows platform, and will be Python version dependent. The installer filename will reflect this and now has the form :file:`foo-1.0.win32-py2.0.exe`.  You have to create a separate installer for every Python version you want to support.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz "nie"czystą dystrybucję, rozszerzenia mogą być tylko tworzone na maszynie/środowisku Windowsowym, i będą zależne od wersji języka pytonowskiego. Nazwa pliku instalatora będzie odzwierciedlać to i będzie miała postać :file:`foo-1.0.win32-py2.0.exe`. Musisz utworzyć oddzielny instalator dla każdej wersji języka pytonowskiego, którą zamierzasz wspierać.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installer will try to compile pure modules into :term:`bytecode` after installation on the target system in normal and optimizing mode.  If you don't want this to happen for some reason, you can run the :command:`bdist_wininst` command with the :option:`--no-target-compile` and/or the :option:`--no-target-optimize` option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalator będzie próbował skompilować moduły czystej dystrybucji do postaci kodu kęsowego ( - z ang. - :term:`bytecode`) po instalacji na docelowym systemie w normalnym i zoptymalizowanym trybie. Jeśli nie chcesz aby to nastąpiło z pewnych powodów, możesz uruchomić polecenie :command:`bdist_wininst` z opcją :option:`--no-target-compile` i/lub opcją `--no-target-optimize`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the installer will display the cool "Python Powered" logo when it is run, but you can also supply your own 152x261 bitmap which must be a Windows :file:`.bmp` file with the :option:`--bitmap` option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie instalator pokazuje bajeranckie logo "Python Powered" w czasie uruchomienia, ale możesz dostarczyć także swoją własną bitmapę o wielkości 152x261 która musi być windowsowskim plikiem bitmapy :file:`.bmp` za pomocą opcji :option:`--bitmap`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installer will also display a large title on the desktop background window when it is run, which is constructed from the name of your distribution and the version number.  This can be changed to another text by using the :option:`--title` option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalator wyświetli także duży tytuł na tle okna pulpitu gdy będzie uruchamiany, który będzie skonstruowany z nazwy dystrybucji i numeru wersji. Można to zmienić na inny tekst przy użyciu opcji :option:`--title`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installer file will be written to the "distribution directory" --- normally :file:`dist/`, but customizable with the :option:`--dist-dir` option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Plik instalatora będzie zapisany do "katalogu dystrybucji" --- zwykle :file:`dist/`, ale można to dostosować opcją :option:`--dist-dir`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-compiling on Windows</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Krzyżowa-kompilacja w Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Python 2.6, distutils is capable of cross-compiling between Windows platforms.  In practice, this means that with the correct tools installed, you can use a 32bit version of Windows to create 64bit extensions and vice-versa.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poczynając od języka pytonowskiego 2.6, distutils jest w stanie krzyżowo-kompilować pomiędzy maszynami/środowiskami windowsowskimi. W praktyce, to oznacza, że z właściwymi narzędziami zainstalowanymi, możesz użyć 32bitowej wersji Windows aby utworzyć 64bitowe rozszerzenia i odwrotnie (64 bitowego Windowsa aby utworzyć 32 bitowe rozszerzenia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build for an alternate platform, specify the :option:`--plat-name` option to the build command.  Valid values are currently 'win32', 'win-amd64' and 'win-ia64'.  For example, on a 32bit version of Windows, you could execute::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zbudować dla odmiennych maszyn/środowisk, użyj opcji :option:`--plat-name` dla polecenia budowania. Właściwe wartości to obecnie 'win32', 'win-amd64' i 'win-ia64'. Na przykład na 32bitowej wersji Windows możesz wykonać::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py build --plat-name=win-amd64</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py build --plat-name=win-amd64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to build a 64bit version of your extension.  The Windows Installers also support this option, so the command::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>aby zbudować 64bitową wersję rozszerzenia. Instalatory Windows także wspierają tą opcję, więc polecenie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py build --plat-name=win-amd64 bdist_wininst</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py build --plat-name=win-amd64 bdist_wininst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>would create a 64bit installation executable on your 32bit version of Windows.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>stworzyłoby 64-bitowy plik wykonywalny instalacji na twojej 32-bitowej wersji Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To cross-compile, you must download the Python source code and cross-compile Python itself for the platform you are targetting - it is not possible from a binary installtion of Python (as the .lib etc file for other platforms are not included.)  In practice, this means the user of a 32 bit operating system will need to use Visual Studio 2008 to open the :file:`PCBuild/PCbuild.sln` solution in the Python source tree and build the "x64" configuration of the 'pythoncore' project before cross-compiling extensions is possible.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby krzyżowo kompilować, musisz pobrać kod źródłowy języka pytonowskiego i krzyżowo-kompilować sam język pytonowski dla maszyny/środowiska docelowego - nie jest to możliwe z poziomu binarnej instalacji języka pytonowskiego (jako, że pliki .lib itp. dla innych   maszyn/środowisk nie są załączone.) W praktyce, to oznacza że użytkownik 32 bitowego systemu operacyjnego będzie potrzebował użyć Visual Studio 2008 aby otworzyć rozwiązanie :file:`PCBuild/PCbuild.sln` w drzewie źródłowym i zbudować konfigurację "x64" projektu 'pythoncore' przed tym, jak krzyżowa kompilacja rozszerzeń będzie możliwa. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that by default, Visual Studio 2008 does not install 64bit compilers or tools.  You may need to reexecute the Visual Studio setup process and select these tools (using Control Panel-&gt;[Add/Remove] Programs is a convenient way to check or modify your existing install.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że domyślnie, Visual Studio 2008 nie instaluje kompilatorów 64-bitowych kompilatorów ani narzędzi. Możesz potrzebować przejść jeszcze raz proces instalacyjny Visual Studio i wybrać te narzędzia (używanie Panelu Sterowania-&gt;[Dodaj/Usuń] Programy jest wygodnym sposobem aby sprawdzić lub zmodyfikować istniejącą instalację.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Postinstallation script</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt poinstalacyjny</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Python 2.3, a postinstallation script can be specified with the :option:`--install-script` option.  The basename of the script must be specified, and the script filename must also be listed in the scripts argument to the setup function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zaczynając od wersji 2.3 języka pytonowskiego, skrypt poinstalacyjny może być specyfikowany z opcją :option:`--install-script`. Nazwa bazowa skryptu musi być określona, i nazwa pliku skryptu musi także być na liście skryptów jako parametr do zadania instalacji. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This script will be run at installation time on the target system after all the files have been copied, with ``argv[1]`` set to :option:`-install`, and again at uninstallation time before the files are removed with ``argv[1]`` set to :option:`-remove`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten skrypt będzie uruchamiany w czasie instalacji na docelowej maszynie/środowisku po tym, jak wszystkie pliki zostaną skopiowane, z ``argv[1]`` ustawionym na :option:`-install`, i znów w czasie odinstalowywania przed tym, jak pliki zostaną usunięte z ``argv[1]`` ustawioną na :option:`-remove`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installation script runs embedded in the windows installer, every output (``sys.stdout``, ``sys.stderr``) is redirected into a buffer and will be displayed in the GUI after the script has finished.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt instalacyjny uruchamia się załączony w instalatorze windows, każde wyjście (``sys.stdout``, ``sys.stderr``) jest przekierowane do bufora i zostanie wyświetlona w GUI (sprzęgu graficznym użytkownika) po tym jak skrypt się zakończy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some functions especially useful in this context are available as additional built-in functions in the installation script.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niektóre zadania szczególnie użyteczne w tym kontekście są dostępne jako dodatkowe wbudowane zadania w skrypcie instalacyjnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These functions should be called when a directory or file is created by the postinstall script at installation time.  It will register *path* with the uninstaller, so that it will be removed when the distribution is uninstalled. To be safe, directories are only removed if they are empty.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te zadania powinny być uruchamiane gdy katalog lub plik jest tworzony przez skrypt poinstalacyjny w czasie instalacji. Zarejestruje on *ścieżkę* w programie odinstalowującym, tka, aby był usunięty gdy dystrybucja jest odinstalowywana. Dla bezpieczeństwa, katalogi są usuwane tylko, jeśli są puste.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function can be used to retrieve special folder locations on Windows like the Start Menu or the Desktop.  It returns the full path to the folder. *csidl_string* must be one of the following strings::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie może być używane do pobierania szczególnych miejsc w Windows takich jak menu Start lub pulpit. Zwraca pełną ścieżkę dostępu do folderu. *csidl_string* musi być jednym z następujących ciągów znaków::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"CSIDL_APPDATA"  "CSIDL_COMMON_STARTMENU" "CSIDL_STARTMENU"  "CSIDL_COMMON_DESKTOPDIRECTORY" "CSIDL_DESKTOPDIRECTORY"  "CSIDL_COMMON_STARTUP" "CSIDL_STARTUP"  "CSIDL_COMMON_PROGRAMS" "CSIDL_PROGRAMS"  "CSIDL_FONTS"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"CSIDL_APPDATA"  "CSIDL_COMMON_STARTMENU" "CSIDL_STARTMENU"  "CSIDL_COMMON_DESKTOPDIRECTORY" "CSIDL_DESKTOPDIRECTORY"  "CSIDL_COMMON_STARTUP" "CSIDL_STARTUP"  "CSIDL_COMMON_PROGRAMS" "CSIDL_PROGRAMS"  "CSIDL_FONTS"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the folder cannot be retrieved, :exc:`OSError` is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli folder nie może być pobrany wyjątek :exc:`OSError` jest zgłaszany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which folders are available depends on the exact Windows version, and probably also the configuration.  For details refer to Microsoft's documentation of the :cfunc:`SHGetSpecialFolderPath` function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To, które katalogi są dostępne zależy od wersji Windows, i prawdopodobnie też od konfiguracji. DLa szczegółów zajrzyj do dokumentacji Microsoftu dotyczącej zadania :cfunc:`SHGetSpecialFolderPath.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function creates a shortcut. *target* is the path to the program to be started by the shortcut. *description* is the description of the shortcut. *filename* is the title of the shortcut that the user will see. *arguments* specifies the command line arguments, if any. *workdir* is the working directory for the program. *iconpath* is the file containing the icon for the shortcut, and *iconindex* is the index of the icon in the file *iconpath*.  Again, for details consult the Microsoft documentation for the :class:`IShellLink` interface.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie tworzy skrót. *cel* ( - z ang. - *target* ) jest ścieżką do programu do uruchomienia przez skrót. *description* jest opisem skrótu. *filename* jest tytułem skrótu który użytkownik zobaczy. *arguments* określa parametry wiersza polecenia, jeśli jakieś mają wystąpić. *workdir* jest katalogiem roboczym dla programu. *iconpath* jest ścieżką dostępu do pliku zawierającego obrazek dla skrótu, zaś *iconindex* jest indeksem obrazka w pliku *iconpath*. Znów po więcej szczegółów zwróć się do dokumentacji Microsoftu pod hasłem sprzęgu :class:`IShellLink`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vista User Access Control (UAC)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kontrola Dostępu Użytkowników (UAC) z Visty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Python 2.6, bdist_wininst supports a :option:`--user-access-control` option.  The default is 'none' (meaning no UAC handling is done), and other valid values are 'auto' (meaning prompt for UAC elevation if Python was installed for all users) and 'force' (meaning always prompt for elevation).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zaczynając od wersji 2.6 języka pytonowskiego, bdist_wininst wspiera opcję :option:`--user-access-control`. Domyślna wartość jest 'none' - z ang. - 'żaden' (oznaczająca że żadna kontrola dostępu użytkownika nie jest w użyciu), zaś inne prawidłowe wartości są 'auto' (oznaczające zapytanie dla podniesienia UAC jeśli programy języka pytonowskiego były instalowane dla wszystkich użytkowników) i 'force' - z ang. - 'zmuś' (oznaczająca zawsze zapytania o zezwolenie).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Reference</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podręcznik poleceń</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing modules: the :command:`install` command family</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalowanie modułów: rodzina poleceń :command:`install`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The install command ensures that the build commands have been run and then runs the subcommands :command:`install_lib`, :command:`install_data` and :command:`install_scripts`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenie install zapewnia, że polecenia budowy zostały uruchomione a potem uruchamia podrzędne polecenia :command:`install_lib`, :command:`install_data` i :command:`install_scripts`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`install_data`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`install_data`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command installs all data files provided with the distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To polecenie instaluje wszystkie pliki danych dostarczone do dystrybucji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`install_scripts`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`install_scripts`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command installs all (Python) scripts in the distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To polecenie instaluje wszystkie skrypty języka pytonowskiego w dystrybucji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the Setup Configuration File</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pisanie pliku konfiguracyjnego instalacji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often, it's not possible to write down everything needed to build a distribution *a priori*: you may need to get some information from the user, or from the user's system, in order to proceed.  As long as that information is fairly simple---a list of directories to search for C header files or libraries, for example---then providing a configuration file, :file:`setup.cfg`, for users to edit is a cheap and easy way to solicit it.  Configuration files also let you provide default values for any command option, which the installer can then override either on the command-line or by editing the config file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Często nie jest możliwe zapisanie wszystkiego potrzebnego do zbudowania dystrybucji *a priori*: możesz potrzebować zdobyć pewne informacje od użytkownika, lub z systemu użytkownika, w celu przejścia dalej. O ile ta informacje jest raczej prosta---lista katalogów do przeszukania na okoliczność plików nagłówkowych C lub bibliotek, dla przykładu---potem dostarczając plik konfiguracji, :file:`setup.cfg`, dla użytkowników aby poddać go edycji jest tanim i łatwym sposobem aby ją uzyskać. Pliki konfiguracji także pozwalają ci dostarczyć domyślne wartości dla dowolnych opcji polecenia, które instalator może wtedy obejść zarówno w linii poleceń lub przez edycję pliku konfiguracyjnego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setup configuration file is a useful middle-ground between the setup script ---which, ideally, would be opaque to installers [#]_---and the command-line to the setup script, which is outside of your control and entirely up to the installer.  In fact, :file:`setup.cfg` (and any other Distutils configuration files present on the target system) are processed after the contents of the setup script, but before the command-line.  This has  several useful consequences:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Plik konfiguracji instalacji jest użytecznym złotym-środkiem pomiędzy skryptem instalacyjnym --- który idealnie byłby przezroczysty dla instalatorów [#]_ ---i wierszem-poleceń do skryptu instalacyjnego, który jest poza twoją kontrolą i całkowicie zależnym od instalatora. W rzeczywistości, plik :file:`setup.cfg` (i jakiekolwiek inne pliki konfiguracji Distutils obecne w docelowym systemie) jest przetwarzany po zawartości skryptu instalacyjnego, ale przed linią-poleceń. Ma to kilka użytecznych konsekwencji:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>installers can override some of what you put in :file:`setup.py` by editing :file:`setup.cfg`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalatory mogą obejść część tego co umieścisz w pliku :file:`setup.py` przez edycję :file:`setup.cfg`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can provide non-standard defaults for options that are not easily set in :file:`setup.py`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>możesz dostarczyć niestandardowe wartości domyślne dla opcji, które niełatwo się ustawia w pliku :file:`setup.py`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>installers can override anything in :file:`setup.cfg` using the command-line options to :file:`setup.py`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalatory mogą obejść wszystko w pliku :file:`setup.cfg` używając opcji wiersza-poleceń wywołującego skrypt :file:`setup.py`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic syntax of the configuration file is simple::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawowa składnia pliku konfiguracyjnego jest łatwa::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[command] option=value ...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>[command] option=value ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where *command* is one of the Distutils commands (e.g. :command:`build_py`, :command:`install`), and *option* is one of the options that command supports. Any number of options can be supplied for each command, and any number of command sections can be included in the file.  Blank lines are ignored, as are comments, which run from a ``'#'`` character until the end of the line.  Long option values can be split across multiple lines simply by indenting the continuation lines.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gdzie *command* jest jedną z komend Distutils (np. :command:`build_py`, :command:`install`) i *option* jest jedną z opcji, którą komenda wspiera. Dowolna liczba opci może być dostarczona do każdej komendy, i dowolna liczba sekcji komend może być wewnątrz pliku. Puste linie są ignorowane, tak jak komentarze, które zaczynają się od znaku ``'#'`` i ciągną aż do końca linii. Długie wartości opcji mogą być dzielone pomiędzy kilka linii prosto przez wcięcie linii kontynuacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find out the list of options supported by a particular command with the universal :option:`--help` option, e.g. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz poznać listę opcji wspieraną przez konkretną komendę za pomocą uniwersalnej opcji :option:`--help` np. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt; python setup.py --help build_ext [...] Options for 'build_ext' command:   --build-lib (-b)     directory for compiled extension modules   --build-temp (-t)    directory for temporary files (build by-products)   --inplace (-i)       ignore build-lib and put compiled extensions into the                        source directory alongside your pure Python modules   --include-dirs (-I)  list of directories to search for header files   --define (-D)        C preprocessor macros to define   --undef (-U)         C preprocessor macros to undefine   --swig-opts          list of SWIG command line options [...]</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt; python setup.py --help build_ext [...]Opcje dla komendy 'build_ext': --build-lib (-b) katalog dla skompilowanych modułów rozszerzeń --build-temp (-t) katalog dla plików tymczasowych (produktów ubocznych budowania) -- inplace (-i) ignoruj build-lib i umieść skompilowane rozszerzenia do katalogu źródeł obok twoich czystych modułów języka pytonowskiego --include-dirs (-I) lista katalogów do przeszukania w celu znalezienia plików nagłówkowych --define (-D) makra preprocesora do zdefiniowania --undef (-U) makra preprocesora do oddefiniowania --swig-opts lista opcji wiersza polecenia SWIG [...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that an option spelled :option:`--foo-bar` on the command-line  is spelled :option:`foo_bar` in configuration files.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że opcja przeliterowana :option:`--foo-bar` w wierszu-polecenia jet przeliterowana :option:`foo_bar` w plikach konfiguracji. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, say you want your extensions to be built "in-place"---that is, you have an extension :mod:`pkg.ext`, and you want the compiled extension file (:file:`ext.so` on Unix, say) to be put in the same source directory as your pure Python modules :mod:`pkg.mod1` and :mod:`pkg.mod2`.  You can always use the :option:`--inplace` option on the command-line to ensure this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, powiedzmy, że chcesz aby twoje rozszerzenia były zbudowane "w-miejscu"---to jest, masz rozszerzenie :mod:`pkg.ext`, i chcesz aby skompilowany plik rozszerzenia (:file:`ext.so` na Unix-ie, załóżmy) był umieszczony w tym samym katalogu źródłowym jak twoje czyste moduły języka pytonowskiego :mod:`pkg.mod1` i :mod:`pkg.mod2`. Możesz zawsze użyć opcji :option:`--inplace` w wierszu polecenia aby to zapewnić::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py build_ext --inplace</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py build_ext --inplace</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this requires that you always specify the :command:`build_ext` command explicitly, and remember to provide :option:`--inplace`. An easier way is to "set and forget" this option, by encoding it in :file:`setup.cfg`, the configuration file for this distribution::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ale to wymaga abyś zawsze określał polecenie :command:`build_ext` jawnie, i pamiętał dostarczyć :option:`--inplace`. Łatwiejszym sposobem jest "ustawić i zapomnieć" tą opcję, przez zakodowanie jej w pliku :file:`setup.cfg`, pliku konfiguracyjnego dla tej dystrybucji::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[build_ext] inplace=1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>[build_ext] inplace=1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will affect all builds of this module distribution, whether or not you explicitly specify :command:`build_ext`.  If you include :file:`setup.cfg` in your source distribution, it will also affect end-user builds---which is probably a bad idea for this option, since always building extensions in-place would break installation of the module distribution.  In certain peculiar cases, though, modules are built right in their installation directory, so this is conceivably a useful ability.  (Distributing extensions that expect to be built in their installation directory is almost always a bad idea, though.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To wpłynie na to, że wszystkie budowy dystrybucji tego modułu, niezależnie od tego czy jawnie wyszczególnisz komendę :command:`build_ext`. Jeśli zawrzesz plik :file:`setup.cfg` w twojej dystrybucji źródłowej, wpłynie ona także na budowy dystrybucji użytkownika końcowego---co jest prawdopodobnie złym pomysłem dla tej opcji, skoro budowanie rozszerzeń w -miejscu powodowałoby zawsze uszkodzenie instalacji dystrybucji modułu. W niektórych szczególnych przypadkach, jednakże, moduły są budowane w katalogu ich instalacji, więc jest to twórczo użyteczna umiejętność. (Rozprowadzanie rozszerzeń od których oczekuje się, że będą budowane w katalogu ich instalacji jest prawie zawsze jednak złym pomysłem.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example: certain commands take a lot of options that don't change from run to run; for example, :command:`bdist_rpm` needs to know everything required to generate a "spec" file for creating an RPM distribution.  Some of this information comes from the setup script, and some is automatically generated by the Distutils (such as the list of files installed).  But some of it has to be supplied as options to :command:`bdist_rpm`, which would be very tedious to do on the command-line for every run.  Hence, here is a snippet from the Distutils' own :file:`setup.cfg`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inny przykład: niektóre komendy biorą mnóstwo opcji które nie zmieniają się z wykonania na wykonanie; na przykład, polecenie :command:`bdist_rpm` potrzebuje wiedzieć wszystko, co jest wymagane do wygenerowania pliku "spec" dla utworzenia dystrybucji RPM. Niektóre z tych informacji pochodzą ze skryptu instalacyjnego, a część jest automatycznie generowana przez Distutils (takie jak lista plików zainstalowanych). Ale część z tego musi być dostarczona jako opcje do polecenia :command:`bdist_rpm`, co byłoby bardzo żmudne do wykonania z wiersza poleceń przy każdym uruchomieniu skryptu. Zatem tu jest urywek z własnego dla Distutils pliku :file:`setup.cfg`:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[bdist_rpm] release = 1 packager = Greg Ward &lt;gward@python.net&gt; doc_files = CHANGES.txt             README.txt             USAGE.txt             doc/             examples/</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>[bdist_rpm] release = 1 packager = Greg Ward &lt;gward@python.net&gt; doc_files = CHANGES.txt             README.txt             USAGE.txt             doc/             examples/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the :option:`doc_files` option is simply a whitespace-separated string split across multiple lines for readability.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że opcja :options:`doc_files` jest po prostu separowanym-białymi-znakami ciągiem znaków podzielonym na kilka linii dla czytelności.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz także</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on the configuration files is available in the manual for system administrators.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Więcej informacji o plikach konfiguracyjnych jest dostępnych w podręczniku dla administratorów systemu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Footnotes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwagi końcowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ideal probably won't be achieved until auto-configuration is fully supported by the Distutils.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten ideał prawdopodobnie nie zostanie osiągnięty dopóki auto-konfiguracja nie będzie w pełni wspierana przez Distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter provides a number of basic examples to help get started with distutils.  Additional information about using distutils can be found in the Distutils Cookbook.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział dostarcza pewną liczbę podstawowych przykładów mających pomóc zacząć pracę z distutils. Dodatkowe informacje o użyciu distutils można znaleźć w książce kucharskiej Distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Collection of recipes showing how to achieve more control over distutils.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kolekcja przepisów pokazujących jak osiągnąć większą kontrolę ponad distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pure Python distribution (by module)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czysta dystrybucja języka pytonowskiego (po modułach)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're just distributing a couple of modules, especially if they don't live in a particular package, you can specify them individually using the :option:`py_modules` option in the setup script.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli rozprowadzasz kilka modułów, szczególnie jeśli one nie żyją w szczególnym pakiecie, możesz określić je indywidualnie używając opcji :option:`py_modules` w skrypcie instalacyjnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the simplest case, you'll have two files to worry about: a setup script and the single module you're distributing, :file:`foo.py` in this example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W najprostszym przypadku, będziesz miał dwa pliki o które będziesz się musiał martwić: skrypt instalacyjny i pojedynczy moduł który rozprowadzasz, plik :file:`foo.py` w tym przypadku::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         foo.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         foo.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(In all diagrams in this section, *&lt;root&gt;* will refer to the distribution root directory.)  A minimal setup script to describe this situation would be::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(We wszystkich diagramach w tym rozdziale, *&lt;root&gt;* odnosił się będzie do katalogu głównego dystrybucji.) Minimalny plik skryptu instalacyjnego opisujący tę sytuację byłby::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foo',       version='1.0',       py_modules=['foo'],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foo',       version='1.0',       py_modules=['foo'],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the name of the distribution is specified independently with the :option:`name` option, and there's no rule that says it has to be the same as the name of the sole module in the distribution (although that's probably a good convention to follow).  However, the distribution name is used to generate filenames, so you should stick to letters, digits, underscores, and hyphens.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ też, że nazwa dystrybucji jest określona niezależnie z opcją :option:`name`, i nie ma reguły, która mówiłaby że musi być taki sam jak nazwa samego modułu w dystrybucji (chociaż to prawdopodobnie dobra konwencja której można się trzymać). Jednakże, nazwa dystrybucji jest używana do generowania nazw plików, więc powinieneś trzymać się liter, cyfr, podkreślnika i myślników.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since :option:`py_modules` is a list, you can of course specify multiple modules, eg. if you're distributing modules :mod:`foo` and :mod:`bar`, your setup might look like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odkąd opcja :option:`py_modules` jest listą, możesz oczywiście określić wiele modułów, np. jeśli rozprowadzasz moduły :mod:`foo` i :mod:`bar`, twój skrypt instalacyjny mógłby wyglądać następująco::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         foo.py         bar.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         foo.py         bar.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and the setup script might be  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i skrypt instalacyjny mógłby być::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       py_modules=['foo', 'bar'],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       py_modules=['foo', 'bar'],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put module source files into another directory, but if you have enough modules to do that, it's probably easier to specify modules by package rather than listing them individually.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz umieścić pliki źródłowe do innego katalogu, ale jeśli masz dość modułów aby to zrobić, prawdopodobnie jest łatwiej określić moduły przez nazwę pakietu zamiast wypisywać je pojedynczo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pure Python distribution (by package)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czysta dystrybucja języka pytonowskiego (przez pakiet)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have more than a couple of modules to distribute, especially if they are in multiple packages, it's probably easier to specify whole packages rather than individual modules.  This works even if your modules are not in a package; you can just tell the Distutils to process modules from the root package, and that works the same as any other package (except that you don't have to have an :file:`__init__.py` file).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz więcej niż kilka modułów do dystrybucji, szczególnie jeśli są one w kilku pakietach, pewnie łatwiej określić całe pakiety raczej niż indywidualne moduły. To działa nawet jeśli twoje moduły nie są w pakiecie; możesz powiedzieć Distutils aby przetworzył moduły z pakietu nadrzędnego, i to działa tak samo jak przy każdym innym pakiecie ( z wyjątkiem, że nie musisz mieć pliku :file:`__init__.py`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setup script from the last example could also be written as  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt instalacyjny z ostatniego przykładu mógłby także być napisany jako ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       packages=[''],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       packages=[''],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(The empty string stands for the root package.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Pusty ciąg znaków stoi zamiast nadrzędnego pakietu.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If those two files are moved into a subdirectory, but remain in the root package, e.g.::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli te dwa pliki są przesuwane do podkatalogu, ale znajdują się w nadrzędnym pakiecie, np.::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         src/      foo.py                   bar.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         src/      foo.py                   bar.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then you would still specify the root package, but you have to tell the Distutils where source files in the root package live::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wtedy musiałbyś określić pakiet nadrzędny, ale musisz powiedzieć Distutils gdzie pliki źródłowe znajdują się w pakiecie nadrzędnym::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'': 'src'},       packages=[''],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'': 'src'},       packages=[''],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More typically, though, you will want to distribute multiple modules in the same package (or in sub-packages).  For example, if the :mod:`foo`  and :mod:`bar` modules belong in package :mod:`foobar`, one way to layout your source tree is ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bardziej typowo, jednak, będziesz potrzebował rozprowadzić wiele modułów w tym samym pakiecie (lub pakietach podrzędnych). Na przykład: moduły :mod:`foo` i :mod:`bar` należą do pakietu :mod:`foobar`, jednym ze sposobów na rozłożenie twojego drzewa źródłowego jest::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         foobar/                  __init__.py                  foo.py                  bar.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         foobar/                  __init__.py                  foo.py                  bar.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is in fact the default layout expected by the Distutils, and the one that requires the least work to describe in your setup script::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest faktycznie domyślny układ oczekiwany przez Distutils, i jeden który wymaga najmniej pracy aby opisać w twoim pliku skryptu instalacji::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       packages=['foobar'],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       packages=['foobar'],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to put modules in directories not named for their package, then you need to use the :option:`package_dir` option again.  For example, if the :file:`src` directory holds modules in the :mod:`foobar` package::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli chcesz umieścić moduły w katalogach nie czerpiących nazw od swoich pakietów, wtedy potrzebujesz użyć jeszcze raz opcji :option:`package_dir`. Na przykład, jeśli katalog :file:`src` trzyma moduły w pakiecie :mod:`foobar`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         src/                  __init__.py                  foo.py                  bar.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         src/                  __init__.py                  foo.py                  bar.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an appropriate setup script would be  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>odpowiednim skryptem instalacyjnym byłoby::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'foobar': 'src'},       packages=['foobar'],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'foobar': 'src'},       packages=['foobar'],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, you might put modules from your main package right in the distribution root::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lub, mógłbyś umieścić moduły z twojego głównego pakietu od razu w katalogu nadrzędnym dystrybucji::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         __init__.py         foo.py         bar.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         __init__.py         foo.py         bar.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in which case your setup script would be  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w przypadku czego twój skrypt instalacyjny byłby następujący::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'foobar': ''},       packages=['foobar'],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'foobar': ''},       packages=['foobar'],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(The empty string also stands for the current directory.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Pusty ciąg znaków stoi także w miejscu obecnego katalogu.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have sub-packages, they must be explicitly listed in :option:`packages`, but any entries in :option:`package_dir` automatically extend to sub-packages. (In other words, the Distutils does *not* scan your source tree, trying to figure out which directories correspond to Python packages by looking for :file:`__init__.py` files.)  Thus, if the default layout grows a sub-package::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz pakiety podrzędne, muszą być jawnie wypisane w opcji :option:`packages`, ale jakiekolwiek wpisy w :option:`package_dir` automatycznie rozszerzają się do pakietów podrzędnych. (Innymi słowy, Distutils *nie* skanuje twojego drzewa źródeł, próbując zgadnąć które katalogi odpowiadają pakietom języka pytonowskiego przez poszukiwanie pliku :file:`__init__.py`.) Zatem, jeśli domyślny rozkład wytwarza podrzędny pakiet::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         foobar/                  __init__.py                  foo.py                  bar.py                  subfoo/                            __init__.py                            blah.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         foobar/                  __init__.py                  foo.py                  bar.py                  subfoo/                            __init__.py                            blah.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then the corresponding setup script would be  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wtedy odpowiadający skrypt instalacyjny byłby ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       packages=['foobar', 'foobar.subfoo'],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup setup(name='foobar',       version='1.0',       packages=['foobar', 'foobar.subfoo'],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Again, the empty string in :option:`package_dir` stands for the current directory.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Raz jeszcze, pusty ciąg znaków w :option:`package_dir` stoi za bieżący katalog.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Single extension module</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pojedynczy moduł rozszerzający</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension modules are specified using the :option:`ext_modules` option. :option:`package_dir` has no effect on where extension source files are found; it only affects the source for pure Python modules.  The simplest  case, a single extension module in a single C source file, is::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduły rozszerzające są określane używając opcji :option:`ext_modules`. opcja :option:`package_dir` nie ma wpływu na to gdzie pliki źródłowe rozszerzenia znajdują się; ma tylko wpływ na czysto pytonowskie moduły. W najprostszym przypadku, pojedynczy moduł rozszerzający w pojedynczym pliku źródłowym C jest:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;root&gt;/         setup.py         foo.c</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;root&gt;/         setup.py         foo.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the :mod:`foo` extension belongs in the root package, the setup script for this could be  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli rozszerzenie :mod:`foo` należy do głównego pakietu, skrypt instalacyjny dla tego mógłby wyglądać::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup from distutils.extension import Extension setup(name='foobar',       version='1.0',       ext_modules=[Extension('foo', ['foo.c'])],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup from distutils.extension import Extension setup(name='foobar',       version='1.0',       ext_modules=[Extension('foo', ['foo.c'])],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the extension actually belongs in a package, say :mod:`foopkg`, then</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli rozszerzenie właściwie należy do pakietu, powiedzmy :mod:`foopkg`, wtedy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With exactly the same source tree layout, this extension can be put in the :mod:`foopkg` package simply by changing the name of the extension::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Z dokładnie tym samym rozkładem drzewa źródłowego, to rozszerzenie mogłoby być umieszczone w pakiecie :mod:`foopkg` prosto przez zmianę nazwy rozszerzenia::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup from distutils.extension import Extension setup(name='foobar',       version='1.0',       ext_modules=[Extension('foopkg.foo', ['foo.c'])],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup from distutils.extension import Extension setup(name='foobar',       version='1.0',       ext_modules=[Extension('foopkg.foo', ['foo.c'])],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending Distutils</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerzanie Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distutils can be extended in various ways.  Most extensions take the form of new commands or replacements for existing commands.  New commands may be written to support new types of platform-specific packaging, for example, while replacements for existing commands may be made to modify details of how the command operates on a package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Distutils może być rozszerzane na różne sposoby. Większość rozszerzeń ma postać nowych komend lub zamienników istniejących komend. Nowe komendy mogą być zapisane aby wspierać nowe rodzaje szczególnych-dla-maszyny/środowiska sposobów pakowania, na przykład, podczas gdy zamienniki istniejących komend mogą być zmuszone do zmiany szczegółów tego jak komendy operują na pakiecie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most extensions of the distutils are made within :file:`setup.py` scripts that want to modify existing commands; many simply add a few file extensions that should be copied into packages in addition to :file:`.py` files as a convenience.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość rozszerzeń distutils robionych jest w obrębie skryptów :file:`setup.py` które ustalają zmiany istniejących poleceń; wiele po prostu dodaje kilka rozszerzeń pliku, które powinny być skopiowane do pakietów w załączeniu do plików :file:`.py` jako udogodnienie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most distutils command implementations are subclasses of the :class:`Command` class from :mod:`distutils.cmd`.  New commands may directly inherit from :class:`Command`, while replacements often derive from :class:`Command` indirectly, directly subclassing the command they are replacing.  Commands are required to derive from :class:`Command`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość wypełnień programowych poleceń distutils są pochodnymi uogólnieniami uogólnienia :class:`Command` z modułu :mod:`distutils.cmd`. Nowe polecenia mogą bezpośrednio dziedziczyć z uogólnienia :class:`Command`, podczas gdy zamienniki często dziedziczą po uogólnieniu :class:`Command` pośrednio, bezpośrednio dziedzicząc po poleceniu które zamieniają.  Oczekuje się, że polecenia będą dziedziczyły z uogólnienia :class:`Command`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating new commands</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Integrowanie nowych poleceń</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are different ways to integrate new command implementations into distutils.  The most difficult is to lobby for the inclusion of the new features in distutils itself, and wait for (and require) a version of Python that provides that support.  This is really hard for many reasons.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją różne sposoby na integrację wypełnień programowych nowych poleceń do distutils. Najtrudniej jest jest lobbować za włączeniem nowych właściwości do samego distutils, i czekać (i wymagać) na nową wersję języka pytonowskiego która będzie dawała to wsparcie. Jest to bardzo trudne z wielu powodów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most common, and possibly the most reasonable for most needs, is to include the new implementations with your :file:`setup.py` script, and cause the :func:`distutils.core.setup` function use them::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Najczęstszą i prawdopodobnie najbardziej rozsądną dla większości z potrzeb jest załączenie nowego wypełnienia programowego z twoim skryptem :file:`setup.py` i spowodowanie aby zadanie :func:`distutils.core.setup` ich użyło::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.command.build_py import build_py as _build_py from distutils.core import setup  class build_py(_build_py):     """Specialized Python source builder."""      # implement whatever needs to be different...  setup(cmdclass={'build_py': build_py},       ...)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.command.build_py import build_py as _build_py from distutils.core import setup  class build_py(_build_py):     """Wyspecjalizowane budowanie źródeł pytona."""      # wypełnij wszystko cokolwiek potrzeba aby było inne...  setup(cmdclass={'build_py': build_py},       ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach is most valuable if the new implementations must be used to use a particular package, as everyone interested in the package will need to have the new command implementation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To podejście jest najbardziej wartościowe jeśli nowe wypełnienia programowe muszą być użyte aby użyć konkretnego pakietu, jako że wszyscy zainteresowani tym pakietem będą potrzebowali dostać wypełnienie nowego polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beginning with Python 2.4, a third option is available, intended to allow new commands to be added which can support existing :file:`setup.py` scripts without requiring modifications to the Python installation.  This is expected to allow third-party extensions to provide support for additional packaging systems, but the commands can be used for anything distutils commands can be used for.  A new configuration option, :option:`command_packages` (command-line option :option:`--command-packages`), can be used to specify additional packages to be searched for modules implementing commands.  Like all distutils options, this can be specified on the command line or in a configuration file.  This option can only be set in the ``[global]`` section of a configuration file, or before any commands on the command line.  If set in a configuration file, it can be overridden from the command line; setting it to an empty string on the command line causes the default to be used.  This should never be set in a configuration file provided with a package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zaczynając od Pythona 2.4, trzecie wyjście jest możliwe, pomyślane aby pozwolić nowym poleceniom aby były dodawane co pomaga wspierać istniejące skrypty :file:`setup.py` bez potrzeby wprowadzania zmian do instalacji języka pytonowskiego. Oczekiwane jest umożliwienie rozszerzeniom pochodzącym od osób trzecich zapewnienie wsparcie dla dodatkowych systemów pakowania, ale polecenia mogą być używane dla dowolnej rzeczy do której polecenia distutils mogą być użyte. Nowa opcja konfiguracji, :option:`command_packages` (opcja wiersza-poleceń :option:`--command-packages`) może być użyta do określenia dodatkowych pakietów aby były przeszukiwane na obecność modułów wypełniających dane polecenie. Jak wszystkie opcje distutils, ta może być określona w wierszu poleceń jak i w pliku konfiguracyjnym. Ta opcja może tylko być ustawiona w rozdziale ``[global]`` ( - z ang. - ogólnym ) pliku konfiguracyjnego, lub zanim jakiekolwiek polecenia pojawią się w wierszu poleceń. Jeśli ustawiane w pliku konfiguracyjnym, można obejść to z wiersza poleceń; ustawienie tego na pusty ciąg znaków w wierszu poleceń powoduje użycie domyślnej wartości. Nie powinno być to ustawiane nigdy w pliku konfiguracyjnym dostarczonym w pakiecie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This new option can be used to add any number of packages to the list of packages searched for command implementations; multiple package names should be separated by commas.  When not specified, the search is only performed in the :mod:`distutils.command` package.  When :file:`setup.py` is run with the option :option:`--command-packages` :option:`distcmds,buildcmds`, however, the packages :mod:`distutils.command`, :mod:`distcmds`, and :mod:`buildcmds` will be searched in that order.  New commands are expected to be implemented in modules of the same name as the command by classes sharing the same name.  Given the example command line option above, the command :command:`bdist_openpkg` could be implemented by the class :class:`distcmds.bdist_openpkg.bdist_openpkg` or :class:`buildcmds.bdist_openpkg.bdist_openpkg`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta nowa opcja może być używana aby dodać dowolną ilość pakietów do listy pakietów przeszukiwanych pod kątem wypełnień poleceń; wielokrotne nazwy pakietów powinny być rozdzielone przecinkami. Gdy nie określono poszukiwanie jest wykonywane tylko w pakiecie :mod:`distutils.command`. Gdy plik :file:`setup.py` jest uruchamiany z opcjami :option:`--command-packages` :option:`distcmds,buildcmds`, jednakże pakiety :mod:`distutils.command`, :mod:`distcmds`, i :mod:`buildcmds` będą przeszukiwane w tej kolejności. Oczekuje się że nowe polecenia będą wypełniane w modułach tej samej nazwy jak polecenie przez uogólnienia podzielające tę samą nazwę. Wziąwszy przykładowe opcje wiersza poleceń z powyżej, polecenie :command:`bdist_openpkg` mogłoby być wypełnione przez uogólnienie :class:`distcmds.bdist_openpkg.bdist_openpkg` lub :class:`buildcmds.bdist_openpkg.bdist_openpkg`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding new distribution types</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodawanie nowych rodzajów dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commands that create distributions (files in the :file:`dist/` directory) need to add ``(command, filename)`` pairs to ``self.distribution.dist_files`` so that :command:`upload` can upload it to PyPI.  The *filename* in the pair contains no path information, only the name of the file itself.  In dry-run mode, pairs should still be added to represent what would have been created.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenia które tworzą dystrybucje (pliki w katalogu :file:`dist/`) wymagają dodania par ``command, filename)`` do ``self.distribution.dist_files`` tak aby polecenie :command:`upload` mogło załadować je do PyPI. Nazwa pliku w parze nie zawiera żadnej informacji o ścieżce, tylko nazwę samego pliku. W trybie uruchomienia-na-sucho, pary powinny wciąż być dodawane aby pokazywały co mogłoby powstać. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distributing Python Modules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dystrybucja modułów języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authors</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Autorzy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Greg Ward, Anthony Baxter</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Greg Ward, Anthony Baxter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Email</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Email</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>distutils-sig@python.org</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>distutils-sig@python.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|version|</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>|version|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|today|</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>|today|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes the Python Distribution Utilities ("Distutils") from the module developer's point of view, describing how to use the Distutils to make Python modules and extensions easily available to a wider audience with very little overhead for build/release/install mechanics.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten dokument opisuje Użytki Dystrybucji języka pytonowskiego ("Distutils") z punktu widzenia twórcy modułów, opisując jak używać Distutils aby uczynić moduły i rozszerzenia języka pytonowskiego łatwo dostępne dla szerszej grupy odbiorców z bardzo niewielkim narzutem przeznaczonym na mechanikę budowy/wydania/instalacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An Introduction to Distutils</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wprowadzenie do Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document covers using the Distutils to distribute your Python modules, concentrating on the role of developer/distributor: if you're looking for information on installing Python modules, you should refer to the :ref:`install-index` chapter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten dokument opisuje użycie Distutils do dystrybucji twoich modułów języka pytonowskiego koncentrując się na roli twórcy/dystrybutora: jeśli szukasz informacji o instalowaniu modułów języka pytonowskiego powinieneś odwołać się do rozdziału :ref:`install-index`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Concepts &amp; Terminology</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pojęcia i Terminy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Distutils is quite simple, both for module developers and for users/administrators installing third-party modules.  As a developer, your responsibilities (apart from writing solid, well-documented and well-tested code, of course!) are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użycie Distutils jest całkiem proste, zarówno dla twórców modułów jak i dla użytkowników/administratorów instalujących moduły ze strony osób trzecich. Jako twórca, twoim zadaniem (poza pisaniem porządnego, dobrze udokumentowanego i dobrze przetestowanego kodu, rzecz jasna!) są:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>write a setup script (:file:`setup.py` by convention)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>napisanie skryptu instalacyjnego (pliku :file:`setup.py` - zgodnie ze zwyczajem)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(optional) write a setup configuration file</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(opcjonalnie) napisanie pliku konfiguracji instalacji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create a source distribution</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utworzenie dystrybucji źródłowej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(optional) create one or more built (binary) distributions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(nadobowiązkowe) stworzyć jedną lub więcej zbudowaną (binarną) dystrybucję</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each of these tasks is covered in this document.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każde z tych zadań jest opisane w tym dokumencie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not all module developers have access to a multitude of platforms, so it's not always feasible to expect them to create a multitude of built distributions.  It is hoped that a class of intermediaries, called *packagers*, will arise to address this need.  Packagers will take source distributions released by module developers, build them on one or more platforms, and release the resulting built distributions.  Thus, users on the most popular platforms will be able to install most popular Python module distributions in the most natural way for their platform, without having to run a single setup script or compile a line of code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie wszyscy twórcy mają dostęp do wielu maszyn/środowisk, więc nie zawsze rozsądne jest oczekiwanie od nich tworzenia wielu zbudowanych dystrybucji. Jest oczekiwane że pewien zbiór pośredników, zwanych *pakowaczami*, powstanie aby zaradzić tym potrzebom. Pakowacze biorą dystrybucje źródłowe wypuszczonych przez twórców modułów, budują je na jednej lub większej liczbie maszyn/środowisk, i wypuszczają wynikłe zbudowane dystrybucje. Zatem, użytkownicy większości popularnych platform będą w stanie instalować większość popularnych dystrybucji modułów języka pytonowskiego w najbardziej naturalny sposób dla ich maszyn/środowisk, bez konieczności uruchomienia nawet jednego skryptu instalacyjnego ani kompilowania ani jednej linijki kodu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Simple Example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Prosty Przykład</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setup script is usually quite simple, although since it's written in Python, there are no arbitrary limits to what you can do with it, though you should be careful about putting arbitrarily expensive operations in your setup script. Unlike, say, Autoconf-style configure scripts, the setup script may be run multiple times in the course of building and installing your module distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt instalacyjny jest zwykle raczej prosty, chociaż od kiedy jest pisany w języku pytonowskim, nie ma odgórnych granic co można z nim zrobić, chociaż powinieneś być ostrożny w umieszczaniu dowolnie kosztownych operacji w swoim skrypcie instalacyjnym. W przeciwieństwie do dajmy na to skryptów konfiguracyjnych w stylu Autoconf-a, skrypt instalacyjny może być uruchamiany kilka razy w trakcie budowania i instalowania twojej dystrybucji modułu. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If all you want to do is distribute a module called :mod:`foo`, contained in a file :file:`foo.py`, then your setup script can be as simple as this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli wszystkim czego chcesz dokonać jest dystrybuowanie modułu nazwanego :mod:`foo` zawartego w pliku :file:`foo.py` wtedy twój plik skryptu instalacyjnego może być tak prosty jak::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some observations:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pewne obserwacje</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>most information that you supply to the Distutils is supplied as keyword arguments to the :func:`setup` function</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>większość informacji które dostarczasz do Distutils jest podawana jako parametry słów kluczowych do zadania :func:`setup`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>those keyword arguments fall into two categories: package metadata (name, version number) and information about what's in the package (a list of pure Python modules, in this case)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>te parametry słów kluczowych należą do dwóch kategorii: informacje o danych pakietu (- z ang. - metadata)  (nazwa, numer wersji) i informacja o tym co jest w pakiecie (lista czysto pytonowskich modułów, w tym przypadku)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>modules are specified by module name, not filename (the same will hold true for packages and extensions)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduły są określone przez nazwę modułu nie nazwę pliku (to samo odnosi się do pakietów i rozszerzeń)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it's recommended that you supply a little more metadata, in particular your name, email address and a URL for the project (see section :ref:`setup-script` for an example)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>polecane jest abyś dostarczył nieco więcej informacji o danych, w szczególności swoje imię, adres email i URL projektu (sięgnij do rozdziału :ref:`setup-script` po przykład)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a source distribution for this module, you would create a setup script, :file:`setup.py`, containing the above code, and run::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby utworzyć dystrybucję źródłową dla tego modułu, tworzysz skrypt instalacyjny, :file:`setup.py`, zawierający powyższy kod, i uruchamiasz::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which will create an archive file (e.g., tarball on Unix, ZIP file on Windows) containing your setup script :file:`setup.py`, and your module :file:`foo.py`. The archive file will be named :file:`foo-1.0.tar.gz` (or :file:`.zip`), and will unpack into a directory :file:`foo-1.0`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>które stworzy plik archiwum (np. plik tarball na Unix-ie, plik ZIP w Windowsie) zawierający twój skrypt instalacyjny - plik :file:`setup.py`, i twój moduł :file:`foo.py`. Archiwum będzie nazywało się :file:`foo-1.0.tar.gz` lub :file:`.zip`), i będzie odpakowywało się do katalogu :file:`foo-1.0`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an end-user wishes to install your :mod:`foo` module, all she has to do is download :file:`foo-1.0.tar.gz` (or :file:`.zip`), unpack it, and---from the :file:`foo-1.0` directory---run ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli użytkownik końcowy życzy sobie instalować twój moduł :mod:`foo`, wszystko co musi zrobić to ściągnąć plik :file:`foo-1.0.tar.gz` (lub :file:`.zip`), odpakować go, i---z katalogu :file:`foo-1.0`--- uruchomić ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py install</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which will ultimately copy :file:`foo.py` to the appropriate directory for third-party modules in their Python installation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>które ostatecznie kopiują plik :file:`foo.py` do odpowiedniego katalogu dla modułów pochodzących od osób trzecich w ich instalacji języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This simple example demonstrates some fundamental concepts of the Distutils. First, both developers and installers have the same basic user interface, i.e. the setup script.  The difference is which Distutils *commands* they use: the :command:`sdist` command is almost exclusively for module developers, while :command:`install` is more often for installers (although most developers will want to install their own code occasionally).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten prosty przykład demonstruje pewne podstawowe pojęcia Distutils. Po pierwsze zarówno twórcy modułów jak i instalujący je mają ten sam podstawowy sprzęg użytkownika tj. skrypt instalacyjny. Różnica polega na tym, którego *polecenia* ( - z ang. - *command* ) Distutils używają: polecenie :command:`sdist` jest prawie wyłącznie dla twórców modułów, podczas gdy :command:`install` jest częściej dla instalujących (chociaż większość twórców też będzie chciała zainstalować swój własny kod czasami).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to make things really easy for your users, you can create one or more built distributions for them.  For instance, if you are running on a Windows machine, and want to make things easy for other Windows users, you can create an executable installer (the most appropriate type of built distribution for this platform) with the :command:`bdist_wininst` command.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli chcesz uczynić rzeczy naprawdę łatwymi dla swoich użytkowników, możesz stworzyć jedną lub więcej zbudowaną dystrybucję dla nich. Na przykład, jeśli działasz na komputerze z Windows, i chcesz uczynić rzeczy łatwymi dla innych użytkowników Windowsa, możesz utworzyć wykonywalny instalator (najbardziej odpowiedni typ zbudowanej dystrybucji dla tej maszyny/środowiska) z poleceniem :command:`bdist_wininst`. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will create an executable installer, :file:`foo-1.0.win32.exe`, in the current directory.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utworzy wykonywalny instalator, :file:`foo-1.0.win32.exe`, w bierzącym katalogu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other useful built distribution formats are RPM, implemented by the :command:`bdist_rpm` command, Solaris :program:`pkgtool` (:command:`bdist_pkgtool`), and HP-UX :program:`swinstall` (:command:`bdist_sdux`).  For example, the following command will create an RPM file called :file:`foo-1.0.noarch.rpm`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inne użyteczne formaty dystrybucji to RPMy, wypełnione przez polecenie :command:`bdist_rpm`, program :program:`pkgtootl` Solarisa (:command:`bdist_pkgtool`), i program swinstall` dla HP-UX (:command:`bdist_sdux`). Na przykład, następujące polecenie utworzy plik RPM nazwany :file:`foo-1.0.noarch.rpm`:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(The :command:`bdist_rpm` command uses the :command:`rpm` executable, therefore this has to be run on an RPM-based system such as Red Hat Linux, SuSE Linux, or Mandrake Linux.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Polecenie :command:`bdist_rpm` używa polecenia wykonywalnego :command:`rpm`, zatem musi to być uruchamiane na opartym o RPMy systemie takim jak Linux Red Hat, Linux SuSE, lub Linux Mandrake.) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find out what distribution formats are available at any time by running ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz dowiedzieć się o tym które formaty dystrybucji są dostępne w każdej chwili uruchamiając::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist --help-formats</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist --help-formats</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>General Python terminology</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ogólne terminy języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're reading this document, you probably have a good idea of what modules, extensions, and so forth are.  Nevertheless, just to be sure that everyone is operating from a common starting point, we offer the following glossary of common Python terms:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli czytasz ten dokument, pewnie masz dobre pojęcie czym są moduły, rozszerzenia, itd. itp. Tym nie mniej, aby się upewnić że wszyscy operują ze wspólnego punktu początkowego, oferujemy następujący słowniczek wspólnych terminów języka pytonowskiego:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the basic unit of code reusability in Python: a block of code imported by some other code.  Three types of modules concern us here: pure Python modules, extension modules, and packages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podstawowa miara powtórnej użyteczności kodu w języku pytonowskim: blok kodu zaimportowany przez inny kod. Trzy typy modułów interesują nas tutaj: moduły czysto pytonowskie, moduły rozszerzające, i pakiety.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a module written in Python and contained in a single :file:`.py` file (and possibly associated :file:`.pyc` and/or :file:`.pyo` files).  Sometimes referred to as a "pure module."</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł napisany w języku pytonowskim i zawarty w pojedynczym pliku :file:`.py` (i możliwie związany plik :file:`.pyc` i/lub plik :file:`.pyo`) Czasami określane jako "czysty moduł."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a module written in the low-level language of the Python implementation: C/C++ for Python, Java for Jython. Typically contained in a single dynamically loadable pre-compiled file, e.g. a shared object (:file:`.so`) file for Python extensions on Unix, a DLL (given the :file:`.pyd` extension) for Python extensions on Windows, or a Java class file for Jython extensions.  (Note that currently, the Distutils only handles C/C++ extensions for Python.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł napisany w niskopoziomowym języku wypełnienia języka pytonowskiego: C/C++ dla języka pytonowskiego, Java dla języka Jytonowskiego. Typowo zawarty w pojedynczym dynamicznie ładowalnym uprzednio skompilowanym pliku, np. plik współdzielonych obiektów (- z ang. shared object - w skrócie so - :file:`.so`) dla rozszerzeń języka pytonowskiego dla Unix, i DLL (mając dane rozszerzenie :file:`.pyd`) dla rozszerzeń języka pytonowskiego na Windowsie, lub plik uogólnienia Javy dla języka rozszerzeń języka jytonowskiego. (Zauważ, że obecnie, Distutils obsługuje tylko rozszerzenia C/C++ dla języka pytonowskiego.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a module that contains other modules; typically contained in a directory in the filesystem and distinguished from other directories by the presence of a file :file:`__init__.py`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł który zawiera inne moduły; typowo przechowywany w katalogu w systemie plików i rozróżniany od innych katalogów przez obecność pliku :file:`__init__.py`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the root of the hierarchy of packages.  (This isn't really a package, since it doesn't have an :file:`__init__.py` file.  But we have to call it something.) The vast majority of the standard library is in the root package, as are many small, standalone third-party modules that don't belong to a larger module collection. Unlike regular packages, modules in the root package can be found in many directories: in fact, every directory listed in ``sys.path`` contributes modules to the root package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Korzeń hierarchii pakietów. (To nie jest właściwie pakiet, gdyż nie ma pliku :file:`__init__.py`. Ale musimy jakoś go nazwać.) Znaczna większość standardowej biblioteki jest w pakiecie korzenia, tak jak wiele małych, samodzielnych modułów osób-trzecich, które nie pasują do większej kolekcji modułów. W przeciwieństwie do typowych pakietów, moduły w pakiecie korzenia można znaleźć w wielu katalogach: w rzeczywistości, każdy katalog wypisany w ``sys.path`` dokłada moduły do pakietu korzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distutils-specific terminology</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Terminologia szczególna dla Distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following terms apply more specifically to the domain of distributing Python modules using the Distutils:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące terminy odnoszą się bardziej szczególnie do domeny dystrybucji modułów pytonowskich przy użyciu Distutils:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a collection of Python modules distributed together as a single downloadable resource and meant to be installed *en masse*.  Examples of some well-known module distributions are Numeric Python, PyXML, PIL (the Python Imaging Library), or mxBase.  (This would be called a *package*, except that term is already taken in the Python context: a single module distribution may contain zero, one, or many Python packages.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>kolekcja modułów języka pytonowskiego rozprowadzonych razem jako pojedynczy zasób do ściągnięcia i przeznaczony do *masowego* instalowania. Przykłady pewnych dobrze-znanych dystrybucji modułów to Numeryczny język pytonowski, PyXML, PIL (Biblioteka obrazowania w języku pytonowskim ( - z ang. - Python Imaging Library)) lub mxBase. (To byłoby nazwane *pakietem*, z wyjątkiem tego, że ten termin jest już zajęty w kontekście języka pytonowskiego: pojedyncza dystrybucja modułu może zawierać zero, jeden lub wiele pakietów.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a module distribution that contains only pure Python modules and packages. Sometimes referred to as a "pure distribution."</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dystrybucja modułów która zawiera tylko czysto pytonowskie moduły i pakiety. Czasami określana mianem "czystej dystrybucji."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a module distribution that contains at least one extension module.  Sometimes referred to as a "non-pure distribution."</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dystrybucja modułu która zawiera przynajmniej jeden moduł rozszerzeń. Czasami określana jako "nie-czysta dystrybucja."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the top-level directory of your source tree (or  source distribution); the directory where :file:`setup.py` exists.  Generally  :file:`setup.py` will be run from this directory.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nadrzędnego poziomu katalog twojego drzewa źródeł (inaczej dystrybucji źródeł); katalog w którym plik :file:`setup.py` jest umieszczony. Ogólnie plik :file:`setup.py` będzie uruchomiony z tego katalogu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering with the Package Index</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rejestrowanie w indeksie pakietów ( - z ang. - Package Index)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python Package Index (PyPI) holds meta-data describing distributions packaged with distutils. The distutils command :command:`register` is used to submit your distribution's meta-data to the index. It is invoked as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Indeks pakietów języka pytonowskiego ( - z ang. - Python Package Index - w skr. PyPI) przechowuje opisy dystrybucji zapakowanych za pomocą distutils. Polecenie distutils :command:`register` jest używane do dostarczenia twoich danych opisujących do indeksu. Jest on wywoływany jak następuje::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py register</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py register</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distutils will respond with the following prompt::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Distutils odpowie następującym potwierdzeniem::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>running register We need to know who you are, so please choose either:     1. use your existing login,     2. register as a new user,     3. have the server generate a new password for you (and email it to you), or     4. quit Your selection [default 1]:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>uruchamiając rejestrację musimy wiedzieć kim jesteś więc proszę wybierz: 1. zaloguj używając swojego istniejącego loginu, 2. zarejestruj jako nowy użytkownik, 3. serwer wygeneruje nowe hasło dla ciebie (i prześle je e-mailem) lub 4. wyjście Twój wybór [domyślnie 1]:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: if your username and password are saved locally, you will not see this menu.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ: jeśli twoje imię i hasło są zapisywane lokalnie, nie będziesz widział tego menu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have not registered with PyPI, then you will need to do so now. You should choose option 2, and enter your details as required. Soon after submitting your details, you will receive an email which will be used to confirm your registration.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli nie zarejestrowałeś swojego modułu w PyPI będziesz potrzebował zrobić to teraz. Powinieneś wybrać opcję 2, wpisać szczegóły jak wyznaczono. Niedługo po wpisaniu szczegółów, otrzymasz email który będzie używany aby potwierdzić twoją rejestrację.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you are registered, you may choose option 1 from the menu. You will be prompted for your PyPI username and password, and :command:`register` will then submit your meta-data to the index.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy już jesteś zarejestrowany, możesz wybrać opcję nr. 1 z menu. Będziesz zapytany o nazwę użytkownika i hasło PyPI i polecenie :command:`register` poda twoje dane o pakiecie do indeksu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may submit any number of versions of your distribution to the index. If you alter the meta-data for a particular version, you may submit it again and the index will be updated.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz dostarczyć dowolną liczbę wersji swojej dystrybucji do indeksu. Jeśli zmienisz treść danych o pakiecie dla konkretnej wersji, możesz podać je jeszcze raz a indeks zostanie zmieniony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyPI holds a record for each (name, version) combination submitted. The first user to submit information for a given name is designated the Owner of that name. They may submit changes through the :command:`register` command or through the web interface. They may also designate other users as Owners or Maintainers. Maintainers may edit the package information, but not designate other Owners or Maintainers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyPI przechowuje zapis każdej (nazwa, wersja) kombinacji przysłanej. Pierwszy użytkownik który dostarczy informację pod daną nazwą jest określany Właścicielem tej nazwy. Mogą podawać zmiany przez polecenie :command:`register` lub przez sprzęg sieciowy. Mogą także określić innych użytkowników jako Właścicieli lub osoby Utrzymujące. Osoby utrzymujące mogą zmieniać informacje o pakiecie ale nie mogą określać innych właścicieli ani osób utrzymujących.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default PyPI will list all versions of a given package. To hide certain versions, the Hidden property should be set to yes. This must be edited through the web interface.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie PyPI wypisuje wszystkie wersje danego pakietu. Aby ukryć pewne wersje, Ukryta własność powinna być ustawiona na tak. To musi być zmieniane przez sprzęg sieciowy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The .pypirc file</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>plik .pypirc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format of the :file:`.pypirc` file is as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>format pliku :file:`.pypirc` jest następujący::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[distutils] index-servers =     pypi  [pypi] repository: &lt;repository-url&gt; username: &lt;username&gt; password: &lt;password&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>[distutils] index-servers =     pypi  [pypi] repository: &lt;adres-repozytorium&gt; username:&lt;nazwa_użytkownika&gt; password: &lt;hasło&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *distutils* section defines a *index-servers* variable that lists the name of all sections describing a repository.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozdział *distutils* definiuje zmienną *serwery-indeksu* - z ang. - *index-servers* która wypisuje nazwę wszystkich sekcji opisujących repozytorium.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each section describing a repository defines three variables:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każda sekcja opisująca repozytorium określa trzy zmienne:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``http://www.python.org/pypi``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``http://www.python.org/pypi``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*username*, which is the registered username on the PyPI server.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*nazwę-użytkownika* ( - z ang. - *username* ), która jest zarejestrowaną nazwą użytkownika na serwerze PyPI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will be prompt to type it when needed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>będzie zapytaniem do wpisania jej gdy zajdzie taka potrzeba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to define another server a new section can be created and listed in the *index-servers* variable::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli chcesz określić inny serwer, nowa sekcja może być utworzona i wpisana w zmiennej *index-servers* ( z ang. - indeks serwerów ) ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[distutils] index-servers =     pypi     other  [pypi] repository: &lt;repository-url&gt; username: &lt;username&gt; password: &lt;password&gt;  [other] repository: http://example.com/pypi username: &lt;username&gt; password: &lt;password&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>[distutils] index-servers =     pypi     inne  [pypi] repository: &lt;repository-url&gt; username: &lt;username&gt; password: &lt;password&gt;  [inne] repository: http://example.com/pypi username: &lt;username&gt; password: &lt;password&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`register` can then be called with the -r option to point the repository to work with::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>polecenie :command:`register` ( - z ang. - rejestruj ) może być wywołane z opcją -r aby wskazać repozytorium z którym będzie pracować::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py register -r http://example.com/pypi</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py register -r http://example.com/pypi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For convenience, the name of the section that describes the repository may also be used::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla wygody, nazwa sekcji która opisuje repozytorium może także być użyta::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py register -r other</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py register -r inne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the Setup Script</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pisanie Skryptu Instalacyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setup script is the centre of all activity in building, distributing, and installing modules using the Distutils.  The main purpose of the setup script is to describe your module distribution to the Distutils, so that the various commands that operate on your modules do the right thing.  As we saw in section :ref:`distutils-simple-example` above, the setup script consists mainly of a call to :func:`setup`, and most information supplied to the Distutils by the module developer is supplied as keyword arguments to :func:`setup`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt instalacyjny jest w centrum wszystkich czynności podczas budowania, rozprowadzania i instalowania modułów przy użyciu Distutils. Głównym zadaniem skryptu instalacyjnego jest opisanie dystrybucji twojego modułu dla Distutils, tak aby różne polecenia które operują na twoich modułach robiły to prawidłowo. Jak widzieliśmy w rozdziale :ref:`distutils-simple-example` powyżej, skrypt instalacyjny składa się głównie z wywołania zadania :func:`setup`, i większość informacji dostarczonych do Distutils przez twórcę modułu jest dostarczonych jako parametrów kluczowych dla zadania :func:`setup`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's a slightly more involved example, which we'll follow for the next couple of sections: the Distutils' own setup script.  (Keep in mind that although the Distutils are included with Python 1.6 and later, they also have an independent existence so that Python 1.5.2 users can use them to install other module distributions.  The Distutils' own setup script, shown here, is used to install the package into Python 1.5.2.) ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tutaj jest trochę bardziej zaangażowany przykład, który będziemy śledzić przez następne parę rozdziałów: własny skrypt instalacyjny Distutils. (Pamiętaj, że chociaż Distutils są zawarte w języku pytonowskim 1.6 i wyższej, Distutils istnieją także niezależnie, tak, że użytkownicy języka pytonowskiego w wersji 1.5.2 mogą używać ich aby zainstalować dystrybucje innych modułów. Własny skrypt instalacyjny Distutils, pokazany tutaj, używany jest tutaj do zainstalowania pakietu dla języka pytonowskiego 1.5.2.) ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#!/usr/bin/env python  from distutils.core import setup  setup(name='Distutils',       version='1.0',       description='Python Distribution Utilities',       author='Greg Ward',       author_email='gward@python.net',       url='http://www.python.org/sigs/distutils-sig/',       packages=['distutils', 'distutils.command'],      )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#!/usr/bin/env python  from distutils.core import setup  setup(name='Distutils',       version='1.0',       description='Python Distribution Utilities',       author='Greg Ward',       author_email='gward@python.net',       url='http://www.python.org/sigs/distutils-sig/',       packages=['distutils', 'distutils.command'],      )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are only two differences between this and the trivial one-file distribution presented in section :ref:`distutils-simple-example`: more metadata, and the specification of pure Python modules by package, rather than by module.  This is important since the Distutils consist of a couple of dozen modules split into (so far) two packages; an explicit list of every module would be tedious to generate and difficult to maintain.  For more information on the additional meta-data, see section :ref:`meta-data`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją tylko dwie różnice pomiędzy tą i prostą jedno-plikową dystrybucją prezentowaną w rozdziale :ref:`distutils-simple-example`: więcej danych, i wyszczególnienie czysto pytonowskich modułów "przez pakiet", zamiast przez nazwę modułu. Jest to istotne skoro Distutils składają się z paru modułów rozdzielonych na (jak dotejpory) dwa pakiety; jawną listę wszystkich modułów byłaby żmudna w wytworzeniu i trudna w utrzymaniu. Po więcej informacji o dodatkowych danych o danych, sięgnij do rozdziału :ref:`meta-data` ( - z ang. - meta-dane - dane o danych).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that any pathnames (files or directories) supplied in the setup script should be written using the Unix convention, i.e. slash-separated.  The Distutils will take care of converting this platform-neutral representation into whatever is appropriate on your current platform before actually using the pathname.  This makes your setup script portable across operating systems, which of course is one of the major goals of the Distutils.  In this spirit, all pathnames in this document are slash-separated.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że jakiekolwiek nazwy ścieżek (plików lub katalogów) dostarczony w skrypcie instalacyjnym powinien być napisany używając konwencji Unixa, tj. separowanej-ukośnikami. Distutils zajmie się zamianą reprezentacji obojętnej wobec maszyny/środowiska zanim użycie ścieżki będzie możliwe. To sprawia że twój skrypt instalacyjny jest przenośny pomiędzy systemami operacyjnymi, co oczywiście jest jednym z głównych celów Distutils. W tym duchu nazwy ścieżek dostępu w tym dokumencie są separowane ukośnikiem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This, of course, only applies to pathnames given to Distutils functions.  If you, for example, use standard Python functions such as :func:`glob.glob` or :func:`os.listdir` to specify files, you should be careful to write portable code instead of hardcoding path separators::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To rzecz jasna, stosuje się tylko do nazw ścieżek danych dla zadań Distutils. Jeśli na przykład używasz zadań standardowych języka pytonowskiego takich jak :func:`glob.glob` lub :func:`os.listdir` aby określać pliki, powinieneś uważać aby pisać przenośny kod zamiast go usztywniać w sprawie separatorów ścieżek::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>glob.glob(os.path.join('mydir', 'subdir', '*.html')) os.listdir(os.path.join('mydir', 'subdir'))</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>glob.glob(os.path.join('mydir', 'subdir', '*.html')) os.listdir(os.path.join('mydir', 'subdir'))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listing whole packages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie list całych pakietów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`packages` option tells the Distutils to process (build, distribute, install, etc.) all pure Python modules found in each package mentioned in the :option:`packages` list.  In order to do this, of course, there has to be a correspondence between package names and directories in the filesystem.  The default correspondence is the most obvious one, i.e. package :mod:`distutils` is found in the directory :file:`distutils` relative to the distribution root. Thus, when you say ``packages = ['foo']`` in your setup script, you are promising that the Distutils will find a file :file:`foo/__init__.py` (which might be spelled differently on your system, but you get the idea) relative to the directory where your setup script lives.  If you break this promise, the Distutils will issue a warning but still process the broken package anyways.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`packages` mówi Distutils aby przetworzyć (zbudować, rozprowadzić, zainstalować, itp.) wszystkie czyste moduły języka pytonowskiego znajdujące się w każdym pakiecie z listy :option:`packages`. Aby tego dokonać oczywiście musi istnieć zależność między nazwami pakietów i katalogami w systemie plików. Domyślna zależność jest najoczywistsza, tj. pakiet :mod:`distutils` znajduje się w katalogu :file:`distutils` względem korzenia dystrybucji. Zatem gdy mówisz ``packages = ['foo']`` w skrypcie instalacyjnym, składasz obietnicę że Distutils znajdzie plik :file:`foo/__init__.py` (który może być przeliterowany inaczej w twoim systemie, ale wszyscy wiemy o co chodzi) względem katalogu gdzie znajduje się skrypt instalacyjny. Jeśli obietnica zostanie złamana, Distutils zgłosi ostrzeżenie ale przetworzy popsuty pakiet tak,czy inaczej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use a different convention to lay out your source directory, that's no problem: you just have to supply the :option:`package_dir` option to tell the Distutils about your convention.  For example, say you keep all Python source under :file:`lib`, so that modules in the "root package" (i.e., not in any package at all) are in :file:`lib`, modules in the :mod:`foo` package are in :file:`lib/foo`, and so forth.  Then you would put ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli użyjesz innej konwencji aby rozplanować twój katalog źródłowy, nie będzie to stanowić problemu: musisz tylko dostarczyć opcję :option:`package_dir` aby powiadomić Distutils o twojej konwencji. Dla przykładu, załóżmy, że trzymasz wszystkie pliki źródłowe w katalogu :file:`lib`, tak że moduły w nadrzędnym pakiecie - z ang. - "root package" (tj. właściwie w żadnym pakiecie w ogóle) będą w katalogu :file:`lib`, moduły w pakiecie :mod:`foo` będą w katalogu :file:`lib/foo` itd. Wtedy ustawisz ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package_dir = {'': 'lib'}</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>package_dir = {'': 'lib'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in your setup script.  The keys to this dictionary are package names, and an empty package name stands for the root package.  The values are directory names relative to your distribution root.  In this case, when you say ``packages = ['foo']``, you are promising that the file :file:`lib/foo/__init__.py` exists.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w swoim skrypcie instalacyjnym. Kluczami do tego słownika są nazwy pakietów, a nazwa pakietu pustego oznacza pakiet nadrzędny ( - z ang. - dosł. - "root package"). Wartościami są nazwy katalogów względne wobec katalogu głównego dystrybucji. W tym przypadku gdy mówisz ``packages = ['foo']``, składasz obietnicę że plik :file:`lib/foo/__init__.py` istnieje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possible convention is to put the :mod:`foo` package right in :file:`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would be written in the setup script as ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inną możliwą konwencją jest umieszczenie pakietu :mod:`foo` od razu w katalogu :file:`lib`, pakietu :mod:`foo.bar` w katalogu :file:`lib/bar` itd. To byłoby zapisane w skrypcie instalacyjnym jako ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package_dir = {'foo': 'lib'}</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>package_dir = {'foo': 'lib'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A ``package: dir`` entry in the :option:`package_dir` dictionary implicitly applies to all packages below *package*, so the :mod:`foo.bar` case is automatically handled here.  In this example, having ``packages = ['foo', 'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and :file:`lib/bar/__init__.py`.  (Keep in mind that although :option:`package_dir` applies recursively, you must explicitly list all packages in :option:`packages`: the Distutils will *not* recursively scan your source tree looking for any directory with an :file:`__init__.py` file.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wpis ``pakiet: katalog`` - z ang. - ``package: dir`` w słowniku :option:`package_dir` niejawnie odnosi się do wszystkich pakietów poniżej *pakietu* tak więc przypadek :mod:`foo.bar` jest automatycznie obsługiwany tutaj. W tym przykładzie posiadanie pakietów ``packages = ['foo', 'foo.bar']`` mówi Distutils aby poszukiwać pliku :file:`lib/__init__.py` i pliku :file:`lib/bar/__init__.py`. (Pamiętaj że chociaż opcja :option:`package_dir` ma zastosowanie rekursywne, musisz jawnie napisać listę wszystkich pakietów w opcji :option:`packages`: Distutils nie będzie rekursywnie skanować twojego drzewa źródłowego w poszukiwaniu jakiegokolwiek katalogu z plikiem :file:`__init__.py`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listing individual modules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie list pojedynczych modułów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a small module distribution, you might prefer to list all modules rather than listing packages---especially the case of a single module that goes in the "root package" (i.e., no package at all).  This simplest case was shown in section :ref:`distutils-simple-example`; here is a slightly more involved example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla małej dystrybucji modułu, mógłbyś chcieć wypisać wszystkie moduły zamiast wypisywać pakiety---szczególnie w przypadku pojedynczego modułu, który wchodzi w skład "nadrzędnego pakietu" - z ang. - "root package" (tj. żadnego pakietu wcale). Najprostszy przypadek został pokazany w sekcji :ref:`distutils-simple-example`; tutaj jest pokazany trochę bardziej zaangażowany przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>py_modules = ['mod1', 'pkg.mod2']</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>py_modules = ['mod1', 'pkg.mod2']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This describes two modules, one of them in the "root" package, the other in the :mod:`pkg` package.  Again, the default package/directory layout implies that these two modules can be found in :file:`mod1.py` and :file:`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And again, you can override the package/directory correspondence using the :option:`package_dir` option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To opisuje dwa moduły, jeden z nich w pakiecie "nadrzędnym" ( - z ang. - "root" ), drugi w pakiecie :mod:`pkg`. Znów domyślny rozkład pakietów/katalogów niejawnie zakłada że te dwa moduły można znaleźć w :file:`mod1.py` i :file:`pkg/mod2.py` i że :file:`pkg/__init__.py` istnieje zarówno. I znów, możesz obejść odpowiadanie pakietów/katalogów używając opcji :option:`package_dir`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Describing extension modules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opisywanie modułów rozszerzających</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just as writing Python extension modules is a bit more complicated than writing pure Python modules, describing them to the Distutils is a bit more complicated. Unlike pure modules, it's not enough just to list modules or packages and expect the Distutils to go out and find the right files; you have to specify the extension name, source file(s), and any compile/link requirements (include directories, libraries to link with, etc.).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak jak pisanie modułów rozszerzających języka pytonowskiego jest trochę bardziej skomplikowane niż pisanie czystych modułów języka pytonowskiego, opisywanie ich dla Distutils jest trochę bardziej skomplikowane. W przeciwieństwie do modułów czysto pytonowskich, nie wystarczy po prostu wypisać po prostu wszystkich modułów lub pakietów i oczekiwać, że Distutils znajdzie właściwe pliki; musisz określić nazwę rozszerzenia, plik(i) źródłowe, i wszystkie wymagania kompilacji i łączenia plików wynikowych (katalogi załączane, biblioteki z którymi nastąpi łączenie, itd.).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All of this is done through another keyword argument to :func:`setup`, the :option:`ext_modules` option.  :option:`ext_modules` is just a list of :class:`Extension` instances, each of which describes a single extension module. Suppose your distribution includes a single extension, called :mod:`foo` and implemented by :file:`foo.c`.  If no additional instructions to the compiler/linker are needed, describing this extension is quite simple::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystko to dokonuje się przez następny kluczowy parametr dla zadania :func:`setup` opcji :option:`ext_modules`. Opcja :option:`ext_modules` jest po prostu listą przykładów uogólnienia :class:`Extension`, z których każdy opisuje pojedynczy moduł rozszerzenia. Załóżmy że twoja dystrybucja zawiera jedno rozszerzenie, zwane :mod:`foo` i wypełnione przez :file:`foo.c`. Jeśli żadne dodatkowe instrukcje dla kompilatora, programu łączącego pliki wynikowe nie są potrzebne, opisywanie tego rozszerzenia jest całkiem proste::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension('foo', ['foo.c'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension('foo', ['foo.c'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Extension` class can be imported from :mod:`distutils.core` along with :func:`setup`.  Thus, the setup script for a module distribution that contains only this one extension and nothing else might be::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Extension` może być importowane z modułu :mod:`distutils.core` razem z zadaniem :func:`setup`. Zatem skrypt instalacyjny dla dystrybucji modułu, który zawiera tylko to rozszerzenie i nic więcej mógłby wyglądać::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup, Extension setup(name='foo',       version='1.0',       ext_modules=[Extension('foo', ['foo.c'])],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup, Extension setup(name='foo',       version='1.0',       ext_modules=[Extension('foo', ['foo.c'])],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Extension` class (actually, the underlying extension-building machinery implemented by the :command:`build_ext` command) supports a great deal of flexibility in describing Python extensions, which is explained in the following sections.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Extension` (właściwie leżąca pod spodem machina budowania rozszerzeń wypełniona przez polecenie :command:`build_ext` daje całkiem sporo możliwości w opisywaniu rozszerzeń języka pytonowskiego, które są opisywane w następnych paragrafach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension names and packages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwy i pakiety rozszerzeń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first argument to the :class:`Extension` constructor is always the name of the extension, including any package names.  For example, ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwszy parametr dla konstruktora :class:`Extension` jest zawsze nazwą rozszerzenia, zawierając jakiekolwiek nazwy pakietów. Na przykład, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension('foo', ['src/foo1.c', 'src/foo2.c'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension('foo', ['src/foo1.c', 'src/foo2.c'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>describes an extension that lives in the root package, while ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opisuje rozszerzenie które przebywa w nadrzędnym pakiecie, podczas gdy::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension('pkg.foo', ['src/foo1.c', 'src/foo2.c'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension('pkg.foo', ['src/foo1.c', 'src/foo2.c'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>describes the same extension in the :mod:`pkg` package.  The source files and resulting object code are identical in both cases; the only difference is where in the filesystem (and therefore where in Python's namespace hierarchy) the resulting extension lives.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opisuje tożsame rozszerzenie w pakiecie :mod:`pkg`. Pliki źródłowe i wynikający kod obiektowy są identyczne w obu przypadkach; jedyną różnicą jest gdzie w systemie plików (i stąd też gdzie w hierarchii przestrzeni nazw) wynikające rozszerzenie będzie przebywać.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a number of extensions all in the same package (or all under the same base package), use the :option:`ext_package` keyword argument to :func:`setup`.  For example, ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz pewną liczbę rozszerzeń wszystkich w tym samym pakiecie (lub wszystkie pod tym samym pakiecie bazowym), użyj kluczowego parametru :option:`ext_package` dla zadania :func:`setup`. Na przykład, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup(...,       ext_package='pkg',       ext_modules=[Extension('foo', ['foo.c']),                    Extension('subpkg.bar', ['bar.c'])],      )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup(...,       ext_package='pkg',       ext_modules=[Extension('foo', ['foo.c']),                    Extension('subpkg.bar', ['bar.c'])],      )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and :file:`bar.c` to :mod:`pkg.subpkg.bar`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>skompiluje plik :file:`foo.c` do rozszerzenia :mod:`pkg.foo`, i plik :file:`bar.c` do :mod:`pkg.subpkg.bar`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension source files</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pliki źródłowe rozszerzenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second argument to the :class:`Extension` constructor is a list of source files.  Since the Distutils currently only support C, C++, and Objective-C extensions, these are normally C/C++/Objective-C source files.  (Be sure to use appropriate extensions to distinguish C++\ source files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and Windows compilers.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Drugim parametrem dla konstuktora uogólnienia :class:`Extension` jest lista plików źródłowych. Ponieważ Distutils obecnie wspiera tylko rozszerzenia C, C++, i Obiektywny-C, te są zwykłymi plikami źródłowymi C/C++/Obiektywny-C. (Upewnij się że używasz właściwego rozszerzenia dla rozróżnienia źródłowych plików C++: pliki :file:`.cc` i :file:`.cpp` wydaje się że są rozpoznawane przez zarówno Unix-owe jak i  Windows-owe kompilatory.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can also include SWIG interface (:file:`.i`) files in the list; the :command:`build_ext` command knows how to deal with SWIG extensions: it will run SWIG on the interface file and compile the resulting C/C++ file into your extension.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednakże, możesz też załączyć sprzęg plików SWIG (:file:`.i`) na liście; polecenie :command:`build_ext` wie jak radzić sobie z rozszerzeniami SWIG: uruchomi SWIG na pliku sprzęgu i skompiluje wynikający plik C/C++ do twojego rozszerzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**\*\*** SWIG support is rough around the edges and largely untested! **\*\***</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**\*\*** Wsparcie dla SWIG jest ciężkie na brzegach i w większości nie przetestowane! **\*\***</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This warning notwithstanding, options to SWIG can be currently passed like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pomimo tego ostrzeżenia, opcje dla sprzęgu SWIG mogą być obecnie przekazywane w następujący sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup(...,       ext_modules=[Extension('_foo', ['foo.i'],                              swig_opts=['-modern', '-I../include'])],       py_modules=['foo'],      )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup(...,       ext_modules=[Extension('_foo', ['foo.i'],                              swig_opts=['-modern', '-I../include'])],       py_modules=['foo'],      )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or on the commandline like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lub w wierszu poleceń w następujący sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt; python setup.py build_ext --swig-opts="-modern -I../include"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt; python setup.py build_ext --swig-opts="-modern -I../include"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On some platforms, you can include non-source files that are processed by the compiler and included in your extension.  Currently, this just means Windows message text (:file:`.mc`) files and resource definition (:file:`.rc`) files for Visual C++. These will be compiled to binary resource (:file:`.res`) files and linked into the executable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na niektórych maszynach/środowiskach, możesz załączyć nie-źródłowe pliki które są przetwarzane przez kompilator i załączane w twoim rozszerzeniu. Obecnie, to po prostu oznacza pliki Windowsowych wiadomości tekstowych (:file:`.mc`) i definicji zasobów (:file:`.rc`) dla Visual C++. Te będą skompilowane do plików zasobów binarnych (:file:`.res`) i połączonych w plik wykonywalny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preprocessor options</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcje preprocesora</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Three optional arguments to :class:`Extension` will help if you need to specify include directories to search or preprocessor macros to define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Trzy opcjonalne parametry dla uogólnienia :class:`Extension` mogą pomóc jeśli potrzebujesz określić katalogi załączane do przeszukania lub makra preprocesora definiujące lub wyłączające definicję: ``include_dirs``, ``define_macros``, i ``undef_macros``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if your extension requires header files in the :file:`include` directory under your distribution root, use the ``include_dirs`` option::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, jeśli twoje rozszerzenie wymaga pliku nagłówkowego w katalogu :file:`include` pod twoim katalogiem nadrzędnym dystrybucji, użyj opcji ``include_dirs`` ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension('foo', ['foo.c'], include_dirs=['include'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension('foo', ['foo.c'], include_dirs=['include'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify absolute directories there; if you know that your extension will only be built on Unix systems with X11R6 installed to :file:`/usr`, you can get away with ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz także określić bezwzględne ścieżki katalogów tutaj; jeśli wiesz że twoje rozszerzenie będzie budowane tylko na systemie Unix-owym z X11R6 zainstalowanym do pliku :file:`/usr`, może Ci ujść na sucho nawet::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension('foo', ['foo.c'], include_dirs=['/usr/include/X11'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension('foo', ['foo.c'], include_dirs=['/usr/include/X11'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should avoid this sort of non-portable usage if you plan to distribute your code: it's probably better to write C code like  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Powinieneś unikać tego rodzaju nie-przenośnego użycia jeśli planujesz rozprowadzać swój kod: jest prawdopodobnie dużo lepiej pisać kod C w następujący sposób ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;X11/Xlib.h&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;X11/Xlib.h&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to include header files from some other Python extension, you can take advantage of the fact that header files are installed in a consistent way by the Distutils :command:`install_header` command.  For example, the Numerical Python header files are installed (on a standard Unix installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact location will differ according to your platform and Python installation.)  Since the Python include directory---\ :file:`/usr/local/include/python1.5` in this case---is always included in the search path when building Python extensions, the best approach is to write C code like  ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli potrzebujesz załączyć pliki nagłówkowe z pewnych innych rozszerzeń języka pytonowskiego, możesz skorzystać z faktu, że pliki nagłówkowe są instalowane w jednoznaczny sposób przez polecenie Distutils :command:`install_header`. Na przykład pliki nagłówkowe numerycznego języka pytonowskiego (w standardowej instalacji Unixa) są instalowane do pliku :file:`/usr/local/include/python1.5/Numerical`. (Dokładne miejsce będzie się różnić w zależności od maszyny/środowiska i instalacji języka pytonowskiego.) Odkąd katalog załączeń języka pytonowskiego---\ :file:`/usr/local/include/python1.5` w tym przypadku---jest zawsze załączany w ścieżce przeszukiwania podczas budowy rozszerzeń języka pytonowskiego, najlepszym podejściem jest napisanie kodu C w następujący sposób ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Numerical/arrayobject.h&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Numerical/arrayobject.h&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you must put the :file:`Numerical` include directory right into your header search path, though, you can find that directory using the Distutils :mod:`distutils.sysconfig` module::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli jednak musisz wstawić katalog załączeń  :file:`Numerical` w całości do twojej ścieżki poszukiwań nagłówków, jednakże, możesz znaleźć ten katalog używając modułu :mod:`distutils.sysconfig` Distutils::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.sysconfig import get_python_inc incdir = os.path.join(get_python_inc(plat_specific=1), 'Numerical') setup(...,       Extension(..., include_dirs=[incdir]),       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.sysconfig import get_python_inc incdir = os.path.join(get_python_inc(plat_specific=1), 'Numerical') setup(...,       Extension(..., include_dirs=[incdir]),       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Even though this is quite portable---it will work on any Python installation, regardless of platform---it's probably easier to just write your C code in the sensible way.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Chociaż nawet to jest całkiem przenośne---będzie działać na każdej instalacji języka pytonowskiego, niezależnie od maszyny/środowiska---jest prawdopodobnie dużo łatwiej po prostu napisać twój kod C w rozsądny sposób.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define and undefine pre-processor macros with the ``define_macros`` and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, value)`` tuples, where ``name`` is the name of the macro to define (a string) and ``value`` is its value: either a string or ``None``.  (Defining a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in your C source: with most compilers, this sets ``FOO`` to the string ``1``.)  ``undef_macros`` is just a list of macros to undefine.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz definiować i odwoływać definicje makropoleceń pre-procesora za pomocą opcji ``define_macros`` i ``undef_macros``. ``define_macros`` bierze listę ``(nazwy, wartości)`` par-krotek, gdzie ``nazwa`` jest nazwą makropolecenia do zdefiniowania (ciągiem znaków) i ``wartość`` jest jej wartością: albo ciągiem znaków albo ``None``. Definiowanie makropolecenia ``FOO`` na ``None`` jest równoznaczne czystej definicji ``#define FOO`` w twoim kodzie C: w większości kompilatorów, to ustawia ``FOO`` na ciąg znaków ``1``. ``undef_macros`` jest po prostu listą makropoleceń do odwołania definicji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension(...,           define_macros=[('NDEBUG', '1'),                          ('HAVE_STRFTIME', None)],           undef_macros=['HAVE_FOO', 'HAVE_BAR'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension(...,           define_macros=[('NDEBUG', '1'),                          ('HAVE_STRFTIME', None)],           undef_macros=['HAVE_FOO', 'HAVE_BAR'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is the equivalent of having this at the top of every C source file::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>jest jednoznaczne z ustawieniem tego ponad każdym plikiem źródłowym C::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#define NDEBUG 1 #define HAVE_STRFTIME #undef HAVE_FOO #undef HAVE_BAR</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#define NDEBUG 1 #define HAVE_STRFTIME #undef HAVE_FOO #undef HAVE_BAR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Library options</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcje bibliotek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also specify the libraries to link against when building your extension, and the directories to search for those libraries.  The ``libraries`` option is a list of libraries to link against, ``library_dirs`` is a list of directories to search for libraries at  link-time, and ``runtime_library_dirs`` is a list of directories to  search for shared (dynamically loaded) libraries at run-time.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz także określić biblioteki do dołączenia gdy budujesz swoje rozszerzenie, i katalogi aby poszukiwać tych bibliotek. Opcja ``biblioteki`` jest listą bibliotek do łączenia, opcja ``library_dirs`` jest listą katalogów do poszukiwania bibliotek w czasie łączenia wynikowego kodu, i ``runtime_library_dirs`` jest listą katalogów do poszukiwania współdzielonych (ładowanych dynamicznie) bibliotek w czasie wykonania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to link against libraries known to be in the standard library search path on target systems ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, jeśli potrzebujesz łączyć z bibliotekami znanymi z tego, że są w standardowej ścieżce poszukiwań w docelowym systemie ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension(...,           libraries=['gdbm', 'readline'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension(...,           libraries=['gdbm', 'readline'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to link with libraries in a non-standard location, you'll have to include the location in ``library_dirs``::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli musisz podłączyć z bibliotekami w nie-standardowym położeniu, musisz załączyć to położenie w opcji ``library_dirs``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension(...,           library_dirs=['/usr/X11R6/lib'],           libraries=['X11', 'Xt'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Extension(...,           library_dirs=['/usr/X11R6/lib'],           libraries=['X11', 'Xt'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Again, this sort of non-portable construct should be avoided if you intend to distribute your code.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Znów, tego rodzaju nie-przenośnych konstrukcji powinno się unikać jeśli zamierzasz rozprowadzać twój kod.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**\*\*** Should mention clib libraries here or somewhere else! **\*\***</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**\*\*** Powinno się wspomnieć biblioteki clib tutaj lub gdzieś indziej! **\*\***</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other options</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inne opcje</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are still some other options which can be used to handle special cases.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją wciąż poza tym inne opcje, które mogą być użyte do radzenia sobie ze szczególnymi przypadkami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`optional` option is a boolean; if it is true, a build failure in the extension will not abort the build process, but instead simply not install the failing extension.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`optional` jest typu boolean; Jeśli jest prawdziwa, błąd budowy rozszerzenia nie przerwie procesu budowania, ale zamiast tego po prostu nie zainstaluje zawodzącego rozszerzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`extra_objects` option is a list of object files to be passed to the linker. These files must not have extensions, as the default extension for the compiler is used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`extra_objects` jest listą plików przedmiotowych do przekazania do programu łączącego pliki wynikowe. Te pliki nie mogą mieć rozszerzenia, gdyż domyślnym rozszerzenie kompilatora jest używane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`extra_compile_args` and :option:`extra_link_args` can be used to specify additional command line options for the respective compiler and linker command lines.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`extra_compile_args` i opcja :option:`extra_link_args` może być używana do określenia dodatkowych opcji wiersza polecenia dla wierszy poleceń odpowiadających kompilatora i programu łączącego pliki wynikowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`export_symbols` is only useful on Windows.  It can contain a list of symbols (functions or variables) to be exported. This option is not needed when building compiled extensions: Distutils  will automatically add ``initmodule`` to the list of exported symbols.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`export_symbols` jest użyteczna tylko w Windows. Może pomieścić listę symboli (zadań lub zmiennych) do eksportu. Ta opcja nie jest wymagana gdy budujemy skompilowane rozszerzenia: Distutils automatycznie dodaje ``initmodule`` do listy symboli wystawianych na zewnątrz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`depends` option is a list of files that the extension depends on (for example header files). The build command will call the compiler on the sources to rebuild extension if any on this files has been modified since the previous build.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`depends` jest listą plików od których rozszerzenie zależy (na przykład plików nagłówkowych). Polecenie budowania uruchamia kompilator na źródłach do ponownego zbudowania rozszerzenia jeśli któreś z jego plików zostało zmodyfikowane od czasu poprzedniej budowy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Relationships between Distributions and Packages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Relacje pomiędzy dystrybucją a pakietami</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A distribution may relate to packages in three specific ways:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dystrybucja może odnosić się do pakietów na trzy szczególne sposoby:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can require packages or modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Może wymagać pakietów lub modułów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can provide packages or modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Może dostarczać pakiety lub moduły.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can obsolete packages or modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Może powodować że pakiety lub moduły staną się niepotrzebne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These relationships can be specified using keyword arguments to the :func:`distutils.core.setup` function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te relacje mogą być określane przy użyciu kluczowych parametrów zadania :func:`distutils.core.setup`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependencies on other Python modules and packages can be specified by supplying the *requires* keyword argument to :func:`setup`. The value must be a list of strings.  Each string specifies a package that is required, and optionally what versions are sufficient.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zależności od innych modułów pytonowskich i pakietów mogą być określane przez dostarczenie słowa kluczowego *requires* jako parametru do zadania :func:`setup`. Wartość musi być listą ciągów znaków. Każdy ciąg znaków określa pakiet, który jest wymagany, i opcjonalnie które wersje są wystarczające.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify that any version of a module or package is required, the string should consist entirely of the module or package name. Examples include ``'mymodule'`` and ``'xml.parsers.expat'``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby określić, że któraś wersja modułu lub pakietu jest wymagana, ciąg znaków powinien składać się w całości z nazwy modułu lub pakietu. Przykłady obejmują ``'mojmodul'`` i ``'xml.parsers.expat'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If specific versions are required, a sequence of qualifiers can be supplied in parentheses.  Each qualifier may consist of a comparison operator and a version number.  The accepted comparison operators are::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli szczególne wersje są wymagane, sekwencja kwalifikatorów może być dostarczona w nawiasach. Każdy kwalifikator może składać się z operatora porównania i numeru wersji. Akceptowane operatory porównania to::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;    &gt;    == &lt;=   &gt;=   !=</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;    &gt;    == &lt;=   &gt;=   !=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be combined by using multiple qualifiers separated by commas (and optional whitespace).  In this case, all of the qualifiers must be matched; a logical AND is used to combine the evaluations.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te mogą być łączone przez użycie wielu kwalifikatorów rozdzielonych przecinkami (i nadobowiązkowymi znakami białymi). W tym przypadku, wszystkie kwalifikatory muszą się zgadzać; logiczna koniunkcja jest używana do wiązania wyników.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's look at a bunch of examples:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Spójrzmy na wiecheć przykładów:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires Expression</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyrażenie wymagania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explanation</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wytłumaczenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``==1.0``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``==1.0``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only version ``1.0`` is compatible</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tylko wersja ``1.0`` jest zgodna</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``&gt;1.0, !=1.5.1, &lt;2.0``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``&gt;1.0, !=1.5.1, &lt;2.0``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie wersje po ``1.0`` i przed ``2.0`` są zgodne z wyjątkiem ``1.5.1``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we can specify dependencies, we also need to be able to specify what we provide that other distributions can require.  This is done using the *provides* keyword argument to :func:`setup`. The value for this keyword is a list of strings, each of which names a Python module or package, and optionally identifies the version.  If the version is not specified, it is assumed to match that of the distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz gdy możemy określić zależności, potrzebujemy także móc określić co dostarczamy a czego inne dystrybucje mogłyby wymagać. To jest dokonywane przy użyciu parametru kluczowego *provides* dla zadania :func:`setup`. Wartość tego słowa kluczowego jest listą ciągów znaków, z których każdy nazywa pytonowski moduł lub pakiet, i dodatkowo (nadobowiązkowo) określa wersję. Jeśli wersja nie jest określona, zakładana jest zgodność wersji z wersją dystrybucji. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some examples:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Trochę przykładów:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provides Expression</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyrażenie dostarczania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``mypkg``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``mojpakiet``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide ``mypkg``, using the distribution version</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcza ``mojpakiet``, używając wersji dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``mypkg (1.1)``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``mojpakiet (1.1)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide ``mypkg`` version 1.1, regardless of the distribution version</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcz ``mojpakiet`` w wersji 1.1, niezależnie od wersji dystrybucji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package can declare that it obsoletes other packages using the *obsoletes* keyword argument.  The value for this is similar to that of the *requires* keyword: a list of strings giving module or package specifiers.  Each specifier consists of a module or package name optionally followed by one or more version qualifiers.  Version qualifiers are given in parentheses after the module or package name.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pakiet może deklarować że powoduje że inny pakiet staje się niepotrzebny używając parametru kluczowego *obsoletes*. Wartość tego jest podobna do tej słowa kluczowego *requires*: lista ciągów znaków dających wyszczególnienie modułu lub pakietu. Każdy ciąg wyszczególniający składa się z nazwy modułu lub pakietu po której dodatkowo (nadobowiązkowo) występuje jeden lub więcej kwalifikator wersji. Kwalifikatory wersji dane są w nawiasie po nazwie modułu lub pakietu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The versions identified by the qualifiers are those that are obsoleted by the distribution being described.  If no qualifiers are given, all versions of the named module or package are understood to be obsoleted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wersje określone przez kwalifikatory to te które stają się zbędne z powodu dystrybucji której dotyczy opis. Jeśli nie są dane żadne kwalifikatory wszystkie wersje nazwanego modułu lub pakietu rozumie się jako zbędne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing Scripts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalowanie skryptów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have been dealing with pure and non-pure Python modules, which are usually not run by themselves but imported by scripts.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Do tej pory zajmowaliśmy się czystymi i nie-czystymi modułami pytonowskimi, które nie są zwykle uruchamiane same przez siebie ale importowane przez skrypty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scripts are files containing Python source code, intended to be started from the command line.  Scripts don't require Distutils to do anything very complicated. The only clever feature is that if the first line of the script starts with ``#!`` and contains the word "python", the Distutils will adjust the first line to refer to the current interpreter location. By default, it is replaced with the current interpreter location.  The :option:`--executable` (or :option:`-e`) option will allow the interpreter path to be explicitly overridden.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypty są plikami zawierającymi kod źródłowy języka pytonowskiego, przeznaczonymi do uruchamiania z wiersza poleceń. Skrypty nie wymagają aby Distutils robiło nic skomplikowanego. Jedyną sprytną sprawą jest to że jeśli pierwsza linia skryptu zaczyna się od ``#!`` i zawiera słowo "python", wtedy Distutils dostosuje pierwszą linię aby odnosiła sę do aktualnego miejsca z którego uruchomiony został program interpretujący polecenia języka pytonowskiego. Domyślnie jest to zamieniane na miejsce aktualnego programu interpretującego polecenia języka pytonowskiego. Opcja :option:`--executable` (lub opcja :option:`-e`) pozwala na jawną zamianę ścieżki dostępu do wykonywalnego programu interpretującego polecenia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`scripts` option simply is a list of files to be handled in this way.  From the PyXML setup script::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`scripts` po prostu jest listą plików do przetworzenia w ten sposób. Ze skryptu instalacyjnego PyXML::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup(...,       scripts=['scripts/xmlproc_parse', 'scripts/xmlproc_val']       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup(...,       scripts=['scripts/xmlproc_parse', 'scripts/xmlproc_val']       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing Package Data</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalowanie danych pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often, additional files need to be installed into a package.  These files are often data that's closely related to the package's implementation, or text files containing documentation that might be of interest to programmers using the package.  These files are called :dfn:`package data`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Często dodatkowe pliki konieczne są do zainstalowania dla pakietu. Te pliki są często plikami danych które są blisko związane z wypełnieniem zadań pakietu, lub plikami tekstowymi zawierającymi dokumentację która może być interesująca dla programisty używającego pakietu. Te pliki zwane są :dfn:`danymi pakietu`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package data can be added to packages using the ``package_data`` keyword argument to the :func:`setup` function.  The value must be a mapping from package name to a list of relative path names that should be copied into the package.  The paths are interpreted as relative to the directory containing the package (information from the ``package_dir`` mapping is used if appropriate); that is, the files are expected to be part of the package in the source directories. They may contain glob patterns as well.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dane pakietu mogą być dodawane do pakietów używając słowa kluczowego ``package_data`` - z ang. - ``danych pakietu`` parametru dla zadania :func:`setup`. Wartość musi być mapowaniem z nazwy pakietu na listę odnoszących się nazw ścieżek które powinny zostać skopiowane do pakietu. Ścieżki są interpretowane jako względne do katalogu zawierającego pakiet (informacja z mapowania ``package_dir`` jest używana jeśli jest to właściwe); to jest, pliki oczekiwane są aby były częścią pakietu w katalogach źródłowych. Mogą zawierać znaczniki "globalne" także.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The path names may contain directory portions; any necessary directories will be created in the installation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwy ścieżek mogą zawierać porcje katalogów; wszystkie konieczne katalogi zostaną utworzone w instalacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if a package should contain a subdirectory with several data files, the files can be arranged like this in the source tree::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na przykład, jeśli pakiet zawiera podkatalog z wieloma plikami danych, pliki mogą być ułożone w taki sposób w drzewie źródłowym::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup.py src/     mypkg/         __init__.py         module.py         data/             tables.dat             spoons.dat             forks.dat</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup.py src/     mypkg/         __init__.py         module.py         data/             tables.dat             spoons.dat             forks.dat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding call to :func:`setup` might be::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpowiadające wezwanie zadania :func:`setup` mogłoby być::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup(...,       packages=['mypkg'],       package_dir={'mypkg': 'src/mypkg'},       package_data={'mypkg': ['data/*.dat']},       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup(...,       packages=['mypkg'],       package_dir={'mypkg': 'src/mypkg'},       package_data={'mypkg': ['data/*.dat']},       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing Additional Files</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalowanie dodatkowych plików</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`data_files` option can be used to specify additional files needed by the module distribution: configuration files, message catalogs, data files, anything which doesn't fit in the previous categories.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`data_files` może być użyta aby określić dodatkowe pliki potrzebne przez dystrybucję modułu: pliki konfiguracji, katalogi z wiadomościami, pliki danych, wszystko co nie pasuje do poprzednich kategorii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`data_files` specifies a sequence of (*directory*, *files*) pairs in the following way::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`data_files` określa sekwencję par (*katalogu*,*plików*) - z ang. - (*directory*,*files*) w następujący sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup(...,       data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),                   ('config', ['cfg/data.cfg']),                   ('/etc/init.d', ['init-script'])]      )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup(...,       data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),                   ('config', ['cfg/data.cfg']),                   ('/etc/init.d', ['init-script'])]      )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that you can specify the directory names where the data files will be installed, but you cannot rename the data files themselves.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że możesz podać nazwy katalogu gdzie pliki danych będą instalowane, ale nie możesz zmienić nazwy plików danych samych w sobie. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each (*directory*, *files*) pair in the sequence specifies the installation directory and the files to install there.  If *directory* is a relative path, it is interpreted relative to the installation prefix (Python's ``sys.prefix`` for pure-Python packages, ``sys.exec_prefix`` for packages that contain extension modules).  Each file name in *files* is interpreted relative to the :file:`setup.py` script at the top of the package source distribution.  No directory information from *files* is used to determine the final location of the installed file; only the name of the file is used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każda para (*katalog*, *pliki*) w sekwencji określa katalog instalacji i pliki do zainstalowania w nim. Jeśli *katalog* jest ścieżką względną, wtedy jest interpretowany względem przedrostka instalacji (pytonowski ``sys.prefix`` jest dla czysto-pytonowskich pakietów, ``sys.exec_prefix`` dla pakietów zawierających moduły rozszerzające). Każda nazwa pliku w *plikach* jest interpretowana względnie do skryptu :file:`setup.py` na wierzchnim poziomie dystrybucji źródłowej pakietu. Żadna informacja z *plików* nie jest używana aby określić ostateczne przeznaczenie instalowanego pliku; tylko nazwa pliku jest używana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify the :option:`data_files` options as a simple sequence of files without specifying a target directory, but this is not recommended, and the :command:`install` command will print a warning in this case. To install data files directly in the target directory, an empty string should be given as the directory.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz określić opcje :option:`data_files` jako prosty ciąg plików bez określania docelowego katalogu, ale nie jest to zalecane, zaś polecenie :command:`install` wypisze ostrzeżenie w takim przypadku. Aby zainstalować pliki danych bezpośrednio w docelowym katalogu, pusty ciąg znaków powinien zostać podany jako katalog.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional meta-data</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowe dane o danych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setup script may include additional meta-data beyond the name and version. This information includes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt instalacyjny może zawierać dodatkowe dane pośrednie poza nazwą i wersją. Te informacje zawierają:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Meta-Data</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dane-o-danych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``name``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``nazwa``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>name of the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nazwa pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>short string</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>krótki ciąg znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(1)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``version``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``wersja``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>version of this release</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wersja tego wydania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(1)(2)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(1)(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``author``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``autor``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package author's name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nazwisko i imie autora pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``author_email``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``adres_email_autora``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>email address of the package author</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>adres email autora pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>email address</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>adres email</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``maintainer``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``zarządca``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package maintainer's name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>imie (i nazwisko) zarządcy pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``maintainer_email``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``adres_email_zarządcy``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>email address of the package maintainer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>adres email zarządcy pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``url``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``url``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>home page for the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>adres strony domowej pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>URL</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>URL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``description``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``opis``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>short, summary description of the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>krótki opis podsumowujący pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``long_description``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``dlugi_opis``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>longer description of the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dłuższy opis pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>long string</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>długi ciąg znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``download_url``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``adres_sciagniecia``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>location where the package may be downloaded</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>miejsce skąd pakiet może być pobrany</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``classifiers``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``klasyfikatory``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a list of classifiers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista klasyfikatorów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>list of strings</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista ciągów znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``platforms``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``maszyny_srodowiska``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a list of platforms</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lista maszyn/środowisk</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``license``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``licencja``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>license for the package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>licencja pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(6)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(6)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These fields are required.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te pola są wymagane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that versions take the form *major.minor[.patch[.sub]]*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest zalecane aby wersja miała postać *major.minor[.patch[.sub]]*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either the author or the maintainer must be identified.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Autor albo zarządca muszą być zidentyfikowani</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These fields should not be used if your package is to be compatible with Python versions prior to 2.2.3 or 2.3.  The list is available from the `PyPI website &lt;http://pypi.python.org/pypi&gt;`_.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te pola nie powinny być używane jeśli pakiet ma być zgodny z wersjami języka pytonowskiego przed 2.2.3 lub 2.3. Lista jest dostępna ze `strony PyPI &lt;http://pypi.python.org/pypi&gt;`_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``long_description`` field is used by PyPI when you are registering a package, to build its home page.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pole ``long_description`` jest używane przez PyPI gdy rejestrujesz pakiet, aby utworzyć jego stronę domową.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``license`` field is a text indicating the license covering the package where the license is not a selection from the "License" Trove classifiers. See the ``Classifier`` field. Notice that there's a ``licence`` distribution option which is deprecated but still acts as an alias for ``license``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pole ``licencja`` - z ang. - ``license`` jest tekstem oznaczającym licencję ochraniającą pakiet gdzie licencja nie jest wybrana z klasyfikacji "Licencji" Znaleźnych. Zobacz pole ``Classifier`` - ``klasyfikator``.  Zauważ, że istnieje opcja dystrybucji ``licencji`` która choć jest przestarzała ale wciąż służy jako synonim ``licencji``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A single line of text, not more than 200 characters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pojedyncza linia tekstu, nie więcej niż 200 znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple lines of plain text in reStructuredText format (see http://docutils.sf.net/).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wielokrotne linie czystego tekstu w formacie reStructuredText (zob. http://docutils.sf.net/).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See below.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zob poniżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encoding the version information is an art in itself. Python packages generally adhere to the version format *major.minor[.patch][sub]*. The major number is 0 for initial, experimental releases of software. It is incremented for releases that represent major milestones in a package. The minor number is incremented when important new features are added to the package. The patch number increments when bug-fix releases are made. Additional trailing version information is sometimes used to indicate sub-releases.  These are "a1,a2,...,aN" (for alpha releases, where functionality and API may change), "b1,b2,...,bN" (for beta releases, which only fix bugs) and "pr1,pr2,...,prN" (for final pre-release release testing). Some examples:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodowanie informacji o wersji jest sztuką samą w sobie. Pakiety języka pytonowskiego zwykle stosują się do formatu wersji *główna.poboczna[.łatka][pod]*. Główny numer jest 0 w początkowych eksperymentalnych wydaniach oprogramowania. Jest zwiększane dla wydań, które reprezentują główne kroki milowe w pakiecie. Liczba poboczna jest zwiększana gdy istotne nowe własności są dodawane do pakietu. Numer łatki zwiększa się gdy naprawy błędów są robione. Dodatkowe informacje o wersji kończące są czasem używane do zaznaczenia pod-wydań. To są "a1,a2,...,aN" (dla wydań alfa gdzie działanie i sprzęgi programowania mogą ulec zmianie), "b1,b2,...,bN" (dla wydań beta, które tylko naprawiają błędy) i "pr1,pr2,...,prN" (dla końcowych testów wydań przed-wydaniem). Niektóre przykłady:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the first, experimental release of a package</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pierwsze, eksperymentalne wydanie pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the second alpha release of the first patch version of 1.0</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>drugie wydanie alpha pierwszej łatki w wersji 1.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`classifiers` are specified in a Python list::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcja :option:`classifiers` jest określona w liście pytonowskiej::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setup(...,       classifiers=[           'Development Status :: 4 - Beta',           'Environment :: Console',           'Environment :: Web Environment',           'Intended Audience :: End Users/Desktop',           'Intended Audience :: Developers',           'Intended Audience :: System Administrators',           'License :: OSI Approved :: Python Software Foundation License',           'Operating System :: MacOS :: MacOS X',           'Operating System :: Microsoft :: Windows',           'Operating System :: POSIX',           'Programming Language :: Python',           'Topic :: Communications :: Email',           'Topic :: Office/Business',           'Topic :: Software Development :: Bug Tracking',           ],       )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>setup(...,       classifiers=[           'Development Status :: 4 - Beta',           'Environment :: Console',           'Environment :: Web Environment',           'Intended Audience :: End Users/Desktop',           'Intended Audience :: Developers',           'Intended Audience :: System Administrators',           'License :: OSI Approved :: Python Software Foundation License',           'Operating System :: MacOS :: MacOS X',           'Operating System :: Microsoft :: Windows',           'Operating System :: POSIX',           'Programming Language :: Python',           'Topic :: Communications :: Email',           'Topic :: Office/Business',           'Topic :: Software Development :: Bug Tracking',           ],       )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to include classifiers in your :file:`setup.py` file and also wish to remain backwards-compatible with Python releases prior to 2.2.3, then you can include the following code fragment in your :file:`setup.py` before the :func:`setup` call. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli chcesz załączyć klasyfikatory w pliku :file:`setup.py` ale także chcesz zachować wsteczną zgodność z wydaniami języka pytonowskiego sprzed wersji 2.2.3, wtedy możesz załączyć następujący fragment kodu w twoim pliku :file:`setup.py` przed wywołaniem :func:`setup` ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># patch distutils if it can't cope with the "classifiers" or # "download_url" keywords from sys import version if version &lt; '2.2.3':     from distutils.dist import DistributionMetadata     DistributionMetadata.classifiers = None     DistributionMetadata.download_url = None</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#łatka distutils jeśli nie da się poradzić sobie z "klasyfikatorami" lub # słowa kluczowe "download_url" from sys import version if version &lt; '2.2.3':from distutils.dist import DistributionMetadata DistributionMetadata.classifiers = None DistributionMetadata.download_url = None</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging the setup script</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpluskwianie skryptu instalacyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes things go wrong, and the setup script doesn't do what the developer wants.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami sprawy źle idą, i skrypt instalacyjny nie robi tego czego chce twórca oprogramowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distutils catches any exceptions when running the setup script, and print a simple error message before the script is terminated.  The motivation for this behaviour is to not confuse administrators who don't know much about Python and are trying to install a package.  If they get a big long traceback from deep inside the guts of Distutils, they may think the package or the Python installation is broken because they don't read all the way down to the bottom and see that it's a permission problem.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Distutils przechwytuje wszelkie wyjątki gdy uruchamiasz skrypt instalacyjny, i wypisuje prosty komunikat o błędzie zanim skrypt zostanie zakończony. Motywacją dla tego zachowania jest to aby nie wprowadzać zamieszania administratora który nie wie za wiele o języku pytonowskim i próbuje zainstalować pakiet. Jeśli dostanie długi duży wypis z głębi gardzieli Distutils, mogą pomyśleć że pakiet lub instalacja języka pytonowskiego jest popsuta gdyż nie przeczytali wszystkiego do dna i będą sądzić że jest to błąd dostępu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other hand, this doesn't help the developer to find the cause of the failure. For this purpose, the DISTUTILS_DEBUG environment variable can be set to anything except an empty string, and distutils will now print detailed information what it is doing, and prints the full traceback in case an exception occurs.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Z drugiej strony, nie pomaga to twórcom znaleźć przyczyny błędu. Z tego powodu, zmienna środowiskowa DISTUTILS_DEBUG może zostać ustawiona na cokolwiek prócz pustego ciągu znaków, a distutils będzie teraz   drukował rozbudowane informacje co się dzieje, i drukował pełen wypis w przypadku gdy nastąpi wyjątek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a Source Distribution</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie dystrybucji źródłowej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As shown in section :ref:`distutils-simple-example`, you use the :command:`sdist` command to create a source distribution.  In the simplest case, ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak pokazano w rozdziale :ref:`distutils-simple-example`, używasz polecenia :command:`sdist` aby utworzyć dystrybucję źródłową. W najprostszym przypadku, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(assuming you haven't specified any :command:`sdist` options in the setup script or config file), :command:`sdist` creates the archive of the default format for the current platform.  The default format is a gzip'ed tar file (:file:`.tar.gz`) on Unix, and ZIP file on Windows.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(zakładając że nie ustaliłeś żadnych opcji polecenia :command:`sdist`w skrypcie instalacyjnym lub pliku konfiguracyjnym), polecenie :command:`sdist` tworzy archiwum domyślnego formatu dla danej maszyny/środowiska. Domyślnym formatem jest zgzipowany plik tar (:file:`.tar.gz`) na Unixie i plik ZIP na Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify as many formats as you like using the :option:`--formats` option, for example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz określić tak wiele formatów jak uważasz za stosowne używając opcji :option:`--formats`, na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist --formats=gztar,zip</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist --formats=gztar,zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to create a gzipped tarball and a zip file.  The available formats are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>aby utworzyć zgzipowany tarball i plik zip. Dostępne formaty to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gzip'ed tar file (:file:`.tar.gz`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zgzipowany plik tar (:file:`.tar.gz`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(2)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``bztar``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``bztar``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>bzip2'ed tar file (:file:`.tar.bz2`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zbzip2owany plik tar (:file:`.tar.bz2`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>requires the :program:`compress` program. Notice that this format is now pending for deprecation and will be removed in the future versions of Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wymaga programu kompresji :program:`compress`. Zauważ że ten format oczekuje teraz na przedawnienie i zostanie zdjęty w przyszłych wersjach języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using any ``tar`` format (``gztar``, ``bztar``, ``ztar`` or ``tar``) under Unix, you can specify the ``owner`` and ``group`` names that will be set for each member of the archive.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy używa się jakiegokolwiek formatu ``tar`` (``gztar``, ``bztar``, ``ztar`` lub ``tar``) pod Unix-em, można określić nazwy ``właściciela`` i ``grupy`` które zostaną ustawione dla każdego członka archiwum.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you want all files of the archive to be owned by root::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, gdy chcesz aby wszystkie pliki archiwum były posiadane przez roota::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist --owner=root --group=root</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist --owner=root --group=root</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specifying the files to distribute</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określanie plików do rozprowadzenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't supply an explicit list of files (or instructions on how to generate one), the :command:`sdist` command puts a minimal default set into the source distribution:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli nie dostarczasz jawnej listy plików (lub instrukcji jak ją wygenerować), polecenie :command:`sdist` wkłada minimalny zbiór domyślny w dystrybucję źródeł:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all Python source files implied by the :option:`py_modules` and :option:`packages` options</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie pliki źródłowe języka pytonowskiego wynikłe niejawnie z opcji :option:`py_modules` i opcji :option:`packages`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all C source files mentioned in the :option:`ext_modules` or :option:`libraries` options (</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie pliki źródłowe C wspomniane w opcjach :option:`ext_modules` lub :option:`libraries`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**\*\*** getting C library sources currently broken---no :meth:`get_source_files` method in :file:`build_clib.py`! **\*\***)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**\*\*** uzyskanie źródeł biblioteki C obecnie zepsute---brak sposobu postępowania :meth:`get_source_files` w pliku :file:`build_clib.py`! **\*\***)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>scripts identified by the :option:`scripts` option See :ref:`distutils-installing-scripts`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>skrypty zidentyfikowane przez opcję :option:`scripts` Zobacz :ref:`distutils-installing-scripts`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>anything that looks like a test script: :file:`test/test\*.py` (currently, the Distutils don't do anything with test scripts except include them in source distributions, but in the future there will be a standard for testing Python module distributions)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cokolwiek co wygląda jak skrypt testujący: plik :file:`test/test\*.py` (obecnie Distutils nie robi nic ze skryptami testowymi z wyjątkiem załączania ich w dystrybucji źródeł, ale w przyszłości będzie standard dla testowania dystrybucji modułów języka pytonowskiego)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:file:`README.txt` (or :file:`README`), :file:`setup.py` (or whatever  you called your setup script), and :file:`setup.cfg`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>plik :file:`README.txt (lub plik :file:`README`), plik :file:`setup.py` (lub jakkolwiek nazwałeś swój skrypt), i plik :file:`setup.cfg`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files that matches the ``package_data`` metadata. See :ref:`distutils-installing-package-data`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie pliki które odpowiadają danym-o-danych ``package_data``. Zobacz :ref:`distutils-installing-package-data` - z ang. -:ref:`instalowanie-danych-pakietu-z-distutils`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files that matches the ``data_files`` metadata. See :ref:`distutils-additional-files`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie pliki które odpowiadają danym-o-danych ``data_files``. Zobacz :ref:`distutils-additional-files` - z ang. - :ref:`dodatkowe-pliki-distutils`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes this is enough, but usually you will want to specify additional files to distribute.  The typical way to do this is to write a *manifest template*, called :file:`MANIFEST.in` by default.  The manifest template is just a list of instructions for how to generate your manifest file, :file:`MANIFEST`, which is the exact list of files to include in your source distribution.  The :command:`sdist` command processes this template and generates a manifest based on its instructions and what it finds in the filesystem.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasem to jest wystarczające, ale zwykle potrzebujesz określić dodatkowe pliki do rozprowadzenia. Typowym sposobem robienia tego jest napisanie *wzoru manifestu* - z ang. - *manifest template* zwanego :file:`MANIFEST.in` domyślnie. Wzór manifestu jest po prostu listą instrukcji na to jak wygenerować plik manifestu, :file:`MANIFEST`, który jest dokładnie listą plików do włączenia w twoją dystrybucję źródłową. Polecenie :command:`sdist` przetwarza ten wzorzec i wytwarza manifest w oparciu o jego instrukcje i to, co znajdzie w systemie plików.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to roll your own manifest file, the format is simple: one filename per line, regular files (or symlinks to them) only.  If you do supply your own :file:`MANIFEST`, you must specify everything: the default set of files described above does not apply in this case.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli wolisz napisać swój własny plik manifestu, format jest prosty: jedna nazwa pliku na linię, jedynie pliki zwyczajne (lub symboliczne odwołania do nich). Jeżeli dostarczysz swój własny plik :file:`MANIFEST`, musisz określić wszystko: domyślny zbiór plików opisujących powyższe nie odnosi się do tego przypadku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See :ref:`manifest_template` section for a syntax reference.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sięgnij do rozdziału :ref:`wzór_manifestu` po opis podręczny składni.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manifest-related options</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Związane-z-Manifestem opcje</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The normal course of operations for the :command:`sdist` command is as follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Normalny kurs operacji polecenia :command:`sdist` jest następujący:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if the manifest file, :file:`MANIFEST` doesn't exist, read :file:`MANIFEST.in` and create the manifest</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli plik manifestu, :file:`MANIFEST` nie istnieje, przeczytaj plik :file:`MANIFEST.in` i utwórz manifest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if neither :file:`MANIFEST` nor :file:`MANIFEST.in` exist, create a manifest with just the default file set</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli żaden z plików :file:`MANIFEST` ani :file:`MANIFEST.in` nie istnieją, stwórz manifest tylko z domyślnym zestawem plików</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if either :file:`MANIFEST.in` or the setup script (:file:`setup.py`) are more recent than :file:`MANIFEST`, recreate :file:`MANIFEST` by reading :file:`MANIFEST.in`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli obojętnie który plik z :file:`MANIFEST.in` lub skryptu instalacyjnego (:file:`setup.py`) są bardziej niedawno utworzone niż plik :file:`MANIFEST`, odtwórz plik :file:`MANIFEST` przez przeczytanie pliku :file:`MANIFEST.in`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>use the list of files now in :file:`MANIFEST` (either just generated or read in) to create the source distribution archive(s)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>użyj listy plików teraz znajdujących się w pliku :file:`MANIFEST` (albo dopiero co wygenerowanych albo wczytanych) do utworzenia archiwum(/ów) dystrybucji źródłowej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a couple of options that modify this behaviour.  First, use the :option:`--no-defaults` and :option:`--no-prune` to disable the standard "include" and "exclude" sets.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje parę opcji które modyfikują to zachowanie. Po pierwsze, użyj opcji :option:`--no-defaults` i opcji :option:`--no-prune` aby wyłączyć standardowe zbiory załączane i wyłączane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, you might just want to (re)generate the manifest, but not create a source distribution::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Po drugie możesz po prostu chcieć wygenerować (powtórnie) manifest, ale nie tworzyć dystrybucji źródłowej::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist --manifest-only</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist --manifest-only</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:option:`-o` is a sortcut for :option:`--manifest-only`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcja :option:`-o` jest skrótem opcji :option:`--manifest-only` z ang. - --tylko-manifest.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MANIFEST.in template</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wzór MANIFEST.in</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :file:`MANIFEST.in` file can be added in a project to define the list of files to include in the distribution built by the :command:`sdist` command.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Plik :file:`MANIFEST.in` może być dodany w projekcie do definiowania listy plików do załączenia w dystrybucji zbudowanej przez polecenie :command:`sdist`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :command:`sdist` is run, it will look for the :file:`MANIFEST.in` file and interpret it to generate the :file:`MANIFEST` file that contains the list of files that will be included in the package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy polecenie :command:`sdist` jest uruchamiane, będzie szukało pliku :file:`MANIFEST.in` i interpretowało go aby wygenerować plik :file:`MANIFEST`, który zawiera listę plików, które będą załączone w pakiecie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mechanism can be used when the default list of files is not enough. (See :ref:`manifest`).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten mechanizm może być używany gdy domyślna lista plików nie wystarcza. (Zobacz :ref:`manifest`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Principle</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zasada</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The manifest template has one command per line, where each command specifies a set of files to include or exclude from the source distribution.  For an example, let's look at the Distutils' own manifest template::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wzór manifestu ma jedną komendę na linię, gdzie każda komenda określa zbiór plików do załączenia lub wyłączenia ze źródłowej dystrybucji. Na przykład, popatrzmy na własny wzór manifestu Distutils::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include *.txt recursive-include examples *.txt *.py prune examples/sample?/build</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>include *.txt recursive-include examples *.txt *.py prune examples/sample?/build - z ang -załącz pliki *.txt rekursywnie-załączaj przykłady *.txt i *.py wydmuchaj przykłady/wzory?/budowy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The meanings should be fairly clear: include all files in the distribution root matching :file:`\*.txt`, all files anywhere under the :file:`examples` directory matching :file:`\*.txt` or :file:`\*.py`, and exclude all directories matching :file:`examples/sample?/build`.  All of this is done *after* the standard include set, so you can exclude files from the standard set with explicit instructions in the manifest template.  (Or, you can use the :option:`--no-defaults` option to disable the standard set entirely.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Znaczenia powinny być raczej jasne: zawrzyj wszystkie pliki w nadrzędnym katalogu dystrybucji odpowiadające plikom :file:`\*.txt`, wszystkie pliki gdziekolwiek w katalogu :file:`examples` odpowiadające plikom :file:`\*.txt` lub :file`\*.py`, i wyłączać wszystkie katalogi pasujące do :file:`examples/sample?/build` Wszystko to dzieje się *po* standardowym zbiorze załączanym, tak że możesz wyłączyć pliki ze standardowego zbioru za pomocą jawnych instrukcji we wzorcu manifestu. Lub możesz też użyć opcji :option:`--no-defaults` aby wyłączyć standardowy zbiór całkowicie.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The order of commands in the manifest template matters: initially, we have the list of default files as described above, and each command in the template adds to or removes from that list of files.  Once we have fully processed the manifest template, we remove files that should not be included in the source distribution:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kolejność poleceń we wzorze manifestu ma znaczenie: początkowo, mamy listę domyślnych plików, jak opisano powyżej, i każde polecenie we wzorze dodaje lub zdejmuje z tej listy plików. Gdy mamy całkowicie przetworzony wzór manifestu, usuwamy pliki, które nie powinny znajdować się w dystrybucji źródłowej:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files in the Distutils "build" tree (default :file:`build/`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie pliki w drzewie budowania Distutils (domyślne :file:`build/`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all files in directories named :file:`RCS`, :file:`CVS`, :file:`.svn`, :file:`.hg`, :file:`.git`, :file:`.bzr` or :file:`_darcs`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie pliki w katalogach nazwanych :file:`RCS`, :file:`CVS`, :file:`.svn`, :file:`.hg`, :file:`.git`, :file:`.bzr` or :file:`_darcs`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have our complete list of files, which is written to the manifest for future reference, and then used to build the source distribution archive(s).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz mamy naszą pełną listę plików, które są zapisane w manifeście dla przyszłego odniesienia, i potem używane do budowania archiwum(ów) źródłowych dystrybucji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the default set of included files with the :option:`--no-defaults` option, and you can disable the standard exclude set with :option:`--no-prune`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz wyłączyć domyślny zbiór załączanych plików opcją :option:`--no-defaults` i możesz wyłączyć standardowy zbiór wyłączanych plików za pomocą opcji :option:`--no-prune`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the Distutils' own manifest template, let's trace how the :command:`sdist` command builds the list of files to include in the Distutils source distribution:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podążając za wzorem manifestu własnego Distutils, prześledźmy jak polecenie :command:`sdist` buduje listę plików do załączenia w źródłowej dystrybucji Distutils:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include all Python source files in the :file:`distutils` and :file:`distutils/command` subdirectories (because packages corresponding to those two directories were mentioned in the :option:`packages` option in the setup script---see section :ref:`setup-script`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zawrzyj wszystkie pliki źródłowe języka pytonowskiego w podkatalogach :file:`distutils` i :file:`distutils/command` (ponieważ pakiety odpowiadające tym dwóm katalogom były wymienione w opcji :option:`packages` w skrypcie instalacyjnym --- zobacz paragraf :ref:`skrypt-instalacyjny` - z ang. - :ref:`setup-script`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include :file:`README.txt`, :file:`setup.py`, and :file:`setup.cfg` (standard files)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>include :file:`README.txt`, :file:`setup.py`, and :file:`setup.cfg` (standardowe pliki)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include :file:`test/test\*.py` (standard files)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>include :file:`test/test\*.py` (standardowe pliki)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include :file:`\*.txt` in the distribution root (this will find :file:`README.txt` a second time, but such redundancies are weeded out later)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załącz pliki :file:`\*.txt` w nadrzędnym katalogu dystrybucji (to odnajdzie plik :file:`README.txt` po raz drugi, ale takie nadmiarowości są odchwaszczane później)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include anything matching :file:`\*.txt` or :file:`\*.py` in the sub-tree under :file:`examples`,</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załącz cokolwiek pasującego do wzoru :file:`\*.txt` lub :file:`*.py` w poddrzewie pod :file:`examples`,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exclude all files in the sub-trees starting at directories matching :file:`examples/sample?/build`\ ---this may exclude files included by the previous two steps, so it's important that the ``prune`` command in the manifest template comes after the ``recursive-include`` command</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyłącz wszystkie pliki w poddrzewach pasujące do  :file:`examples/sample?/build`\ --- to może wyłączyć pliki załączone w poprzednich dwóch krokach, więc istotne jest aby polecenie ``prune`` we wzorcu manifestu następowało po poleceniu ``recursive-include``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exclude the entire :file:`build` tree, and any :file:`RCS`, :file:`CVS`, :file:`.svn`, :file:`.hg`, :file:`.git`, :file:`.bzr` and :file:`_darcs` directories</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyłącz całe drzewo :file:`build`, i wszystkie katalogi :file:`RCS` :file:`CVS`, :file:`.svn`, :file:`.hg`, :file:`.git`, :file:`.bzr` i :file:`_darcs`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like in the setup script, file and directory names in the manifest template should always be slash-separated; the Distutils will take care of converting them to the standard representation on your platform. That way, the manifest template is portable across operating systems.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak jak w skrypcie instalacyjnym, nazwy plików i katalogów we wzorcu manifestu powinny zawsze być separowane-ukośnikiem; Distutils zajmie się zamianą ich na standardową postać na twojej maszynie/środowisku. W ten sposób, wzór manifestu jest przenośny pomiędzy systemami operacyjnymi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commands</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The manifest template commands are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenia wzorca manifestu to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`include pat1 pat2 ...`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`include pat1 pat2 ...`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include all files matching any of the listed patterns</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załącz wszystkie pliki pasujące do któregokolwiek wzorca</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`exclude pat1 pat2 ...`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`exclude pat1 pat2 ...`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exclude all files matching any of the listed patterns</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyłącz wszystkie pliki pasujące nazwą do któregokolwiek z wzorców</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`recursive-include dir pat1 pat2 ...`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`recursive-include kat pat1 pat2 ...`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include all files under *dir* matching any of the listed patterns</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załącz wszystkie pliki pod *kat* pasujące do któregokolwiek z wzorców</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`recursive-exclude dir pat1 pat2 ...`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`recursive-exclude kat pat1 pat2 ...`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exclude all files under *dir* matching any of the listed patterns</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyłącz wszystkie pliki pod *kat* pasujące do któregokolwiek z wzorców na liście</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`global-include pat1 pat2 ...`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`global-include pat1 pat2 ...`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include all files anywhere in the source tree matching --- &amp; any of the listed patterns</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załącz wszystkie pliki gdziekolwiek w drzewie źródłowym pasujące  --- do któregokolwiek z wymienionych wzorców</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`global-exclude pat1 pat2 ...`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`global-exclude pat1 pat2 ...`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exclude all files anywhere in the source tree matching --- &amp; any of the listed patterns</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyłącz wszystkie pliki gdziekolwiek w źródłowym drzewie pasujące nazwą --- do któregokolwiek z wymienionych wzorców</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`prune dir`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`prune dir`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exclude all files under *dir*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyłącz wszsytkie pliki w katalogu *dir*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command:`graft dir`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:command:`graft dir`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include all files under *dir*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>załącz wszystkie pliki w katalogu *dir*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patterns here are Unix-style "glob" patterns: ``*`` matches any sequence of regular filename characters, ``?`` matches any single regular filename character, and ``[range]`` matches any of the characters in *range* (e.g., ``a-z``, ``a-zA-Z``, ``a-f0-9_.``).  The definition of "regular filename character" is platform-specific: on Unix it is anything except slash; on Windows anything except backslash or colon.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wzorce tutaj są w stylu Unix-owym "glob"-wzorcami: ``*`` dopasowuje do dowolnego ciągu zwykłych znaków nazwy pliku, ``?`` dopasowuje jeden zwykły znak nazwy pliku, a ``[zakres]`` dopasowuje którekolwiek znaki z zakresu (np. ``a-z``, ``a-zA-Z``, ``a-f0-9_.``). Definicja "zwykłego znaku nazwy pliku" jest zależna od maszyny/środowiska: na Unix-ie to wszystko oprócz ukośnika; w Windows wszystko oprócz skośnika lub dwukropka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uploading Packages to the Package Index</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wysyłanie pakietów do indeksu pakietów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python Package Index (PyPI) not only stores the package info, but also  the package data if the author of the package wishes to. The distutils command :command:`upload` pushes the distribution files to PyPI.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Indeks pakietów języka pytonowskiego (PyPI) nie tylko przechowuje informacje o pakietach, ale także dane pakietów jeśli autor pakietu życzy sobie tego. Polecenie distutils :command:`upload` popycha pliki dystrybucji do PyPI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command is invoked immediately after building one or more distribution files.  For example, the command ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenie jest wywoływane natychmiast po zbudowaniu jednego lub więcej pliku dystrybucji. Na przykład polecenie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist bdist_wininst upload</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist bdist_wininst upload</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will cause the source distribution and the Windows installer to be uploaded to PyPI.  Note that these will be uploaded even if they are built using an earlier invocation of :file:`setup.py`, but that only distributions named on the command line for the invocation including the :command:`upload` command are uploaded.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>spowoduje że dystrybucja źródła i instalator Windows będą przesłane do PyPI. Zauważ że te będą przesłane nawet jeśli zostały zbudowane używając wcześniejszego odwołania do :file:`setup.py`, ale, że tylko dystrybucje nazwane w wierszu polecenia dla wywołania zawierającego polecenie :command:`upload` są wysyłane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :command:`upload` command uses the username, password, and repository URL from the :file:`$HOME/.pypirc` file (see section :ref:`pypirc` for more on this file). If a :command:`register` command was previously called in the same command, and if the password was entered in the prompt, :command:`upload` will reuse the entered password. This is useful if you do not want to store a clear text password in the :file:`$HOME/.pypirc` file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Polecenie :command:`upload` używa nazwy użytkownika, hasła, adresu repozytorium z pliku :file:`$HOME/.pypirc` (sięgni do rozdziału :ref:`pypirc` po więcej o tym pliku). Jeśli polecenie :command:`register` zostało poprzednio wezwane w tym samym poleceniem i jeśli hasło zostało wprowadzone na zapytanie, polecenie :command:`upload` użyje ponownie wprowadzonego hasła. To jest użyteczne jeśli nie chcesz przechowywać haseł otwartym tekstem w pliku :file:`$HOME/.pypirc`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify another PyPI server with the :option:`--repository=*url*` option::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz określić inny serwer PyPI opcją :option:`--repository=*url*`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist bdist_wininst upload -r http://example.com/pypi</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist bdist_wininst upload -r http://example.com/pypi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See section :ref:`pypirc` for more on defining several servers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sięgnij do rozdziału :ref:`pypirc` po więcej o definiowaniu kilku serwerów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the :option:`--sign` option to tell :command:`upload` to sign each uploaded file using GPG (GNU Privacy Guard).  The  :program:`gpg` program must be available for execution on the system :envvar:`PATH`.  You can also specify which key to use for signing using the :option:`--identity=*name*` option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz użyć opcji :option:`--sign` aby przekazać poleceniu :command:`upload`, aby podpisywała każdy przesyłany plik używając GPG (GNU Strażnika Prywatności - z ang. Privacy Guard). Program :program:`gpg` musi być dostępny do uruchomienia w systemowej ścieżce przeszukiwania :envvar:`PATH`. Możesz też określić które klucze użyć dla podpisania używając opcji :option:`--identity=*name*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other :command:`upload` options include :option:`--repository=&lt;url&gt;` or :option:`--repository=&lt;section&gt;` where *url* is the url of the server and *section* the name of the section in :file:`$HOME/.pypirc`, and :option:`--show-response` (which displays the full response text from the PyPI server for help in debugging upload problems).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inne opcje polecenia :command:`upload` zawierają :option:`--repository=&lt;url&gt;` lub :option:`--repository=&lt;section&gt;` gdzie *url* jest adresem serwera i *sekcja* nazwą sekcji w :file:`$HOME/.pypirc`, i opcja :option:`--show-response` (która pokazuje pełen tekst odpowiedzi z serwera PyPI za pomoc w odpluskwianiu przy problemach z wysyłaniem na serwer).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyPI package display</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pokaz pakietów PyPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``long_description`` field plays a special role at PyPI. It is used by the server to display a home page for the registered package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pole ``long_description`` odgrywa specjalną rolę w PyPI. Jest używane przez serwer aby pokazać stronę domową zarejestrowanego pakietu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the `reStructuredText &lt;http://docutils.sourceforge.net/rst.html&gt;`_ syntax for this field, PyPI will parse it and display an HTML output for the package home page.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli używasz składni reStructuredText-u &lt;http://docutils.sourceforge.net/rst.html&gt;`_ dla tego pola, PyPI przeczyta je i wyświetli wyjście HTML dla strony domowej pakietu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``long_description`` field can be attached to a text file located in the package::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pole ``long_description`` może być doczepione do pliku tekstowego umieszczonego w pakiecie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup  setup(name='Distutils',       long_description=open('README.txt'))</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup  setup(name='Distutils',       long_description=open('README.txt'))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In that case, :file:`README.txt` is a regular reStructuredText text file located in the root of the package besides :file:`setup.py`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym przypadku plik :file:`README.txt` jest zwykłym plikiem tekstowym reStructuredText umieszczonym w nadrzędnej lokalizacji pakietu poza :file:`setup.py`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To prevent registering broken reStructuredText content, you can use the :program:`rst2html` program that is provided by the :mod:`docutils` package and check the ``long_description`` from the command line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zapobiec rejestrowaniu popsutej treści reStructuredText, możesz użyć programu :program:`rst2html` który jest dostarczony przez pakiet :mod:`docutils` i sprawdzić ``long_description`` z wiersza poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ python setup.py --long-description | rst2html.py &gt; output.html</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ python setup.py --long-description | rst2html.py &gt; output.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`docutils` will display a warning if there's something wrong with your syntax.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pakiet :mod:`docutils` wyświetli ostrzeżenie jeśli coś będzie nie tak ze składnią.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
