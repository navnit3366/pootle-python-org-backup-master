<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.1.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Abstract Objects Layer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Płaszczyzna przedmiotów ogólnych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The functions in this chapter interact with Python objects regardless of their type, or with wide classes of object types (e.g. all numerical types, or all sequence types).  When used on object types for which they do not apply, they will raise a Python exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania opisane w tym rozdziale oddziałują na przedmioty napisane w pytonowskim języku bez względu na ich typ, lub też na różnorodne rodzaje typów przedmiotów (np. wszystkie typy liczbowe, lub wszystkie typy kolejkowe). Gdy użyte z przedmiotami niezgodnego typu zadania zgłaszają wyjątki pytonowskiego języka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to use these functions on objects that are not properly initialized, such as a list object that has been created by :cfunc:`PyList_New`, but whose items have not been set to some non-\ ``NULL`` value yet.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie jest możliwe wykonanie tych zadań na przedmiotach, które nie zostały poprawnie zapoczątkowane, takimi, jak np. lista - utworzona przy użyciu :cfunc:`PyList_New`, której pozycje nie były jeszcze uzupełnione jakimiś wartościami znacząco odróżniającymi się od ``NULL``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Allocating Objects on the Heap</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przydział miejsca dla przedmiotów w stercie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz też:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To allocate and create extension modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby umieścić i utworzyć moduły rozszerzające.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parsing arguments and building values</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pobieranie kolejnych rzeczy podanych na wejściu i konstruowanie wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These functions are useful when creating your own extensions functions and methods.  Additional information and examples are available in :ref:`extending-index`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te działania są użyteczne przy tworzeniu swoich własnych zadań rozszerzających i rozszerzających sposobów działania. Dodatkowe informacje i przykłady dostępne są w :ref:`extending-index`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first three of these functions described, :cfunc:`PyArg_ParseTuple`, :cfunc:`PyArg_ParseTupleAndKeywords`, and :cfunc:`PyArg_Parse`, all use *format strings* which are used to tell the function about the expected arguments.  The format strings use the same syntax for each of these functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te pierwsze trzy z opisanych działań, :cfunc:`PyArg_ParseTuple`,:cfunc:`PyArg_ParseTupleAndKeywords`, i:cfunc:`PyArg_Parse`, wszystkie posługują się instrukcjami kształtującymi sposób pobierania rzeczy na wejściu zawartymi w "napisach kształtujących", które są używane, aby przekazać dla zadania wskazówki wyjaśniające oczekiwany charakter wprowadzanych rzeczy. Zapisy kształtujące używają tej samej składni dla każdego z tych zadań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parsing arguments</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przetwarzanie rzeczy wchodzących</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A format string consists of zero or more "format units."  A format unit describes one Python object; it is usually a single character or a parenthesized sequence of format units.  With a few exceptions, a format unit that is not a parenthesized sequence normally corresponds to a single address argument to these functions.  In the following description, the quoted form is the format unit; the entry in (round) parentheses is the Python object type that matches the format unit; and the entry in [square] brackets is the type of the C variable(s) whose address should be passed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>napis kształtujący może być pusty lub składać się z "jednostek kształtujących". Jednostka ukształtowania opisuje jeden pytonowski przedmiot; jest to zazwyczaj jedna litera, lub kolejką jednostek ukształtowania w ujętych w nawias. Z kilkoma wyjątkami, jednostka ukształtowania, która nie jest  kolejką jednostek ujętą w nawias zwykle odpowiada pojedynczo umiejscowionej rzeczy przekazywanej dla tych zadań. W poniższych zapisach cytat jest jednostką kształtującą; polecenie ujęte w nawias okrągły ( ) oznacza typ przedmiotu w języku pytonowskim, który odpowiada jednostce kształtującej, a zapis ujęty w nawiasie kwadratowym [ ] określa typ przedmiotu / przedmiotów w języku C, którego miejsce powinno zostać wskazane i przekazane dla zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings and buffers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Napisy i skrzynki wymiany</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These formats do not expect you to provide raw storage for the returned string or bytes.  Also, you won't have to release any memory yourself, except with the ``es``, ``es#``, ``et`` and ``et#`` formats.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla tych formatów nie musisz zapewniać miejsca dla zwracanych ciągów znaków lub bajtów. Nie musisz też zwalniać żadnej pamięci własnoręcznie, z wyjątkiem tych w formatach ``es``, ``es#``, ``et`` i ``et#``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when a :ctype:`Py_buffer` structure gets filled, the underlying buffer is locked so that the caller can subsequently use the buffer even inside a :ctype:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable data being resized or destroyed.  As a result, **you have to call** :cfunc:`PyBuffer_Release` after you have finished processing the data (or in any early abort case).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednak, gdy struktura :ctype:`Py_buffer` zostanie zapełniona, leżący u podłoża bufor zostaje zablokowany, tak że wywołujący może ponownie użyć bufora nawet wewnątrz bloku :ctype:`Py_BEGIN_ALLOW_THREADS` bez ryzyka zmiany rozmiaru lub skasowania zmienialnych danych. W wyniku tego **trzeba wywołać** :cfunc: `PyBuffer_Release` po zakończeniu przetwarzania danych (lub w przypadku przedwczesnego przerwania).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unless otherwise stated, buffers are not NUL-terminated.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bufory nie są zakończone znakiem NULL, chyba że zaznaczono inaczej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For all ``#`` variants of formats (``s#``, ``y#``, etc.), the type of the length argument (int or :ctype:`Py_ssize_t`) is controlled by defining the macro :cmacro:`PY_SSIZE_T_CLEAN` before including :file:`Python.h`.  If the macro was defined, length is a :ctype:`Py_ssize_t` rather than an :ctype:`int`. This behavior will change in a future Python version to only support :ctype:`Py_ssize_t` and drop :ctype:`int` support. It is best to always define :cmacro:`PY_SSIZE_T_CLEAN`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla wszystkich wariantów ``#`` formatów (``s#``,``y#``, itp.) typ argumentu długości (int lub :ctype: `Py_ssize_t`) jest kontrolowany przez zdefiniowanie makra :cmacro:`PY_SSIZE_T_CLEAN` przed załączeniem pliku :file:`Python.h`. Jeśli makro zostało zdefiniowane, długość jest typu :ctype:`Py_ssize_t` zamiast :ctype:`int`. Ta sytuacja zostanie zmieniona w przyszłych wersjach Pythona, które wspierać będą już tylko :ctype: `Py_ssize_t`, pomijać zaś wsparcie dla :ctype:`int`. Najlepiej zawsze definiować :cmacro:`PY_SSIZE_T_CLEAN`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Unicode object to a C pointer to a character string. A pointer to an existing string is stored in the character pointer variable whose address you pass.  The C string is NUL-terminated. The Python string must not contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is raised. Unicode objects are converted to C strings using ``'utf-8'`` encoding. If this conversion fails, a :exc:`UnicodeError` is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień obiekt Unicode na wskaźnik C do ciągu znaków.Wskaźnik na istniejący ciąg znaków jest przechowywany w zmiennej wskaźnikowej której adres przekazujesz. Ciąg znaków C jest zakończony zerem. Ciąg znaków Pythona nie może zawierać wewnętrznych bajtów równych zero; Jeśli zawiera, zgłaszany jest wyjątek :exc:`TypeError`. Obiekt Unicode jest zamieniany na ciąg znaków C używając kodowania ``'uft-8'``. Jeśli ta konwersja zawiedzie, wyjątek :exc:`UnicodeError` jest zgłaszany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This format does not accept bytes-like objects.  If you want to accept filesystem paths and convert them to C character strings, it is preferrable to use the ``O&amp;`` format with :cfunc:`PyUnicode_FSConverter` as *converter*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten format nie akceptuje bajtowych obiektów. jeśli chcesz akceptować ścieżki systemowe i konwertować je do ciągów znakowych z języka C, zalecane jest używanie formatu ``O&amp;`` z funkcją :cfunc:`PyUnicode_FSConverter` jako *konwerterem* formatu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This format accepts Unicode objects as well as objects supporting the buffer protocol. It fills a :ctype:`Py_buffer` structure provided by the caller. In this case the resulting C string may contain embedded NUL bytes. Unicode objects are converted to C strings using ``'utf-8'`` encoding.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten format akceptuje obiekty Unicode w równym stopniu jak obiekty wspierające protokół buforowy. Wypełnia on strukturę :ctype:`Py_buffer` dostarczaną przez wywołującego. W tym przypadku wynikowy ciąg znaków języka C może zawierać osadzone znaki NUL. Obiekty Unicode są konwertowane do ciągów znaków języka C używając kodowania ``'utf-8'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like ``s*``, except that it doesn't accept mutable buffer-like objects such as :class:`bytearray`.  The result is stored into two C variables, the first one a pointer to a C string, the second one its length. The string may contain embedded null bytes. Unicode objects are converted to C strings using ``'utf-8'`` encoding.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobnie do ``s*`` z tą różnicą, że nie są akceptowane obiekty zmienne, z natury podobne do buforów, takie jak :class:`bytearray`. Wynik jest przechowywany w dwóch zmiennych języka C, pierwszej będącej wskaźnikiem na ciąg znaków języka C i drugiej będącej jego długością. Ciąg znaków może zawierać osadzone znaki null. Obiekty Unicode są konwertowane do ciągów znaków języka C przy użyciu kodowania ``'utf-8'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like ``s``, but the Python object may also be ``None``, in which case the C pointer is set to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak ``s``, ale obiekt Pythona może też być żaden - ``None``, a w takim przypadku wskaźnik C jest ustawiony na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like ``s*``, but the Python object may also be ``None``, in which case the ``buf`` member of the :ctype:`Py_buffer` structure is set to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak ``s*``, ale obiekt Pythona może też być ``None``, a w takim przypadku członek ``buf`` struktury :ctype:`Py_buffer` jest ustawiony na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like ``s#``, but the Python object may also be ``None``, in which case the C pointer is set to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak ``s#``, ale obiekt z języka Python może też być ``None``, a w takim przypadku wskaźnik z języka C jest ustawiany na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This format converts a bytes-like object to a C pointer to a character string; it does not accept Unicode objects.  The bytes buffer must not contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten format konwertuje obiekt bajtowy na wskaźnik z języka C wskazujący na ciąg znaków; Nie akceptuje obiektów Unicode. Bufor bajtowy nie może zawierać znaków NUL; jeśli zawiera, zgłaszany jest wyjątek :exc:`TypeError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This variant on ``s*`` doesn't accept Unicode objects, only objects supporting the buffer protocol.  **This is the recommended way to accept binary data.**</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wariant ``s*`` nie akceptuje obiektów Unicode, tylko obiekty wspierające protokół bufora. **Jest to zalecany sposób, akceptowania danych binarnych.**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This variant on ``s#`` doesn't accept Unicode objects, only bytes-like objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wariant ``s#`` nie akceptuje obiektów Unicode, a jedynie bajto-podobne obiekty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires that the Python object is a :class:`bytes` object, without attempting any conversion.  Raises :exc:`TypeError` if the object is not a bytes object.  The C variable may also be declared as :ctype:`PyObject\*`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wymaga, aby obiekt Pythona był obiektem klasy :class:`bytes` bez podejmowania próby żadnej konwersji. Zgłasza :exc:`TypeError`, jeśli obiekt nie jest obiektem bajtowym. Zmienna C może również zostać zadeklarowana jako :ctype:`PyObject\*`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires that the Python object is a :class:`bytearray` object, without attempting any conversion.  Raises :exc:`TypeError` if the object is not a :class:`bytearray` object. The C variable may also be declared as :ctype:`PyObject\*`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wymaga, aby obiekt Pythona był obiektem klasy :class:`bytearray` bez podejmowania prób konwersji. Zgłasza :exc:`TypeError`, jeśli obiekt nie jest obiektem klasy :class:`bytearray`. Zmienna C może również zostać zadeklarowana jako :CType:`PyObject\*`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of Unicode characters.  You must pass the address of a :ctype:`Py_UNICODE` pointer variable, which will be filled with the pointer to an existing Unicode buffer.  Please note that the width of a :ctype:`Py_UNICODE` character depends on compilation options (it is either 16 or 32 bits). The Python string must not contain embedded NUL characters; if it does, a :exc:`TypeError` exception is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konwertuje obiekt w formacie Unicode Pythona do wskaźnika C na zakończony znakiem NUL bufor znaków Unicode. Trzeba przekazać adres zmiennej wskaźnikowej :ctype:`Py_UNICODE`, która zostanie zapełniona wskaźnikiem do istniejącego buforu Unicode. Zwróć uwagę, że szerokość znaku :ctype:`Py_UNICODE` zależy od opcji kompilacji (jest to albo 16 albo 32 bity). Łańcuch znaków Pythona nie może zawierać osadzonych znaków NUL, jeśli zawiera, to zgłaszany jest wyjątek :exc:`TypeError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since ``u`` doesn't give you back the length of the string, and it may contain embedded NUL characters, it is recommended to use ``u#`` or ``U`` instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ponieważ ``u`` nie zwraca długości łańcucha znaków, i może zawierać osadzone znaki NUL, zaleca się zamiast tego stosowanie ``u#`` lub ``U``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This variant on ``u`` stores into two C variables, the first one a pointer to a Unicode data buffer, the second one its length.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wariant ``u`` zapisuje w dwóch zmiennych C, w pierwszej - wskaźnik do bufora danych Unicode, w drugiej - jego długość.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like ``u``, but the Python object may also be ``None``, in which case the :ctype:`Py_UNICODE` pointer is set to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak ``u``, ale obiekt Pythona może również być ``None``, a w takim przypadku wskaźnik :ctype:`Py_UNICODE` jest ustawiony na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like ``u#``, but the Python object may also be ``None``, in which case the :ctype:`Py_UNICODE` pointer is set to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobnie, jak ``u#``, ale obiekt Pythona może być również ``None``, a w takim przypadku wskaźnik :ctype:`Py_UNICODE`. jest ustawiony na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requires that the Python object is a Unicode object, without attempting any conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  The C variable may also be declared as :ctype:`PyObject\*`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wymaga, aby obiekt Pythona był obiektem Unicode, bez podejmowania prób konwersji. Zgłasza wyjątek :exc:`TypeError`, jeśli obiekt nie jest obiektem Unicode. Zmienna C może również być zadeklarowana jako :ctype:`PyObject\*`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This format accepts any object which implements the read-write buffer interface. It fills a :ctype:`Py_buffer` structure provided by the caller. The buffer may contain embedded null bytes. The caller have to call :cfunc:`PyBuffer_Release` when it is done with the buffer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Format ten akceptuje dowolne obiekty implementujące interfejs odczytu i zapisu do bufora. Wypełnia strukturę: ctype:`Py_buffer`, dostarczoną przez wołającego. Bufor może zawierać osadzone znaki null. Wywołujący musi odwołać się do funkcji :cfunc:`PyBuffer_Release`, gdy zakończy pracę z buforem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This variant on ``s`` is used for encoding Unicode into a character buffer. It only works for encoded data without embedded NUL bytes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wariant ``s`` jest używany do zakodowania Unicode w buforze znaków. To działa tylko dla zakodowanych danych bez osadzonych znaków NUL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This format requires two arguments.  The first is only used as input, and must be a :ctype:`const char\*` which points to the name of an encoding as a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An exception is raised if the named encoding is not known to Python.  The second argument must be a :ctype:`char\*\*`; the value of the pointer it references will be set to a buffer with the contents of the argument text. The text will be encoded in the encoding specified by the first argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten format wymaga dwóch argumentów. Pierwszy z nich jest używany tylko jako wejście, i musi być typu :ctype:`const char\*` i wskazywać na nazwę kodowania jako ciąg zakończony znakiem NUL, lub *NULL*, w przypadku którego używane jest kodowanie ``'utf-8'``.  Jeśli nazwa kodowania nie jest znana w języku Python Zgłaszany jest wyjątek. Drugim argumentem musi być wskaźnik :ctype:`char\*\*`; wartość wskaźnika do którego się odnosi będzie ustawiona na bufor z treścią tekstu argumentu. Tekst zostanie zakodowany w kodowaniu określonym przez pierwszy argument.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy the encoded data into this buffer and adjust *\*buffer* to reference the newly allocated storage.  The caller is responsible for calling :cfunc:`PyMem_Free` to free the allocated buffer after use.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Funkcja :cfunc:`PyArg_ParseTuple` alokuje bufor o wymaganym rozmiarze, kopiuje zakodowane dane do tego bufora i ustawia *\*bufor*, aby odwoływał się do nowo przydzielonej pamięci. Wywołujący jest odpowiedzialny za odwołanie się do funkcji :cfunc: `PyMem_Free`, w celu uwolnienia przydzielonej pamięciu bufora po jego użyciu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as ``es`` except that byte string objects are passed through without recoding them.  Instead, the implementation assumes that the byte string object uses the encoding passed in as parameter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobnie jak ``es`` z wyjątkiem tego, że obiekty ciągów znaków są przekazywane dalej bez ich zapisywania. Zamiast tego implementacja zakłada, że obiekt łańcucha znaków wykorzystuje kodowanie przekazane jako parametr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This variant on ``s#`` is used for encoding Unicode into a character buffer. Unlike the ``es`` format, this variant allows input data which contains NUL characters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wariant ``s#`` używany jest do kodowania Unicode w buforze znaków. W przeciwieństwie do formatu ``es``, ten wariant pozwala wprowadzać dane zawierające znaki NUL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It requires three arguments.  The first is only used as input, and must be a :ctype:`const char\*` which points to the name of an encoding as a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An exception is raised if the named encoding is not known to Python.  The second argument must be a :ctype:`char\*\*`; the value of the pointer it references will be set to a buffer with the contents of the argument text. The text will be encoded in the encoding specified by the first argument. The third argument must be a pointer to an integer; the referenced integer will be set to the number of bytes in the output buffer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wymagane są trzy argumenty. Pierwszy z nich jest używany tylko jako wejście, i musi być typu :ctype:`const char\*`, i wskazywać na nazwę kodowania jako ciąg zakończony znakiem NUL, lub *NULL*, w przypadku którego używane jest kodowanie ``'utf-8'``. Jeśli nazwa kodowania nie jest znana w języku Python, zgłaszany jest wyjątek. Drugim argumentem musi być wskaźnik :ctype:`char\*\*`; Wartością wskaźnika do którego odnosi się ten będzie bufor z zawartością tekstu argumentu. Tekst zostanie zakodowany w kodowaniu określonym przez pierwszy argument. Trzecim argumentem musi być wskaźnik do liczby całkowitej; liczba całkowita, do której się on odwołuje zostanie ustawiona na liczbę znaków w buforze wyjściowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two modes of operation:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją dwa tryby pracy:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *\*buffer* points a *NULL* pointer, the function will allocate a buffer of the needed size, copy the encoded data into this buffer and set *\*buffer* to reference the newly allocated storage.  The caller is responsible for calling :cfunc:`PyMem_Free` to free the allocated buffer after usage.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *\*bufor* wskazuje na wskaźnik *NULL*, funkcja zaalokuje bufor o wymaganym rozmiarze, skopiuje zakodowane dane do tego bufora i ustawi *\*bufor* aby odwoływał się do nowo przydzielonej pamięci. Wywołujący jest odpowiedzialny za wywołanie funkcji: cfunc:`PyMem_Free` w celu uwolnienia przydzielonej pamięciu bufora po zakończeniu użycia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *\*buffer* points to a non-*NULL* pointer (an already allocated buffer), :cfunc:`PyArg_ParseTuple` will use this location as the buffer and interpret the initial value of *\*buffer_length* as the buffer size.  It will then copy the encoded data into the buffer and NUL-terminate it.  If the buffer is not large enough, a :exc:`ValueError` will be set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *\*bufor* wskazuje na niezerowy wskaźnik (bufor umieszczony już w pamięci), funkcja :cfunc:`PyArg_ParseTuple` użyje tego miejsca jako bufora i zinterpretuje początkową wartość *\*buffer_length* jako rozmiar bufora. Skopiuje potem zakodowane dane do bufora i zakończy znakiem zera. Jeśli bufor nie jest wystarczająco duży, wyjątek :exc:`ValueError` zostanie zgłoszony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both cases, *\*buffer_length* is set to the length of the encoded data without the trailing NUL byte.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W obu przypadkach, *\*buffer_length* jest ustawiany na długość zakodowanych danych z pominięciem zakańczającego znaku NUL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as ``es#`` except that byte string objects are passed through without recoding them. Instead, the implementation assumes that the byte string object uses the encoding passed in as parameter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak samo, jak w ``es#`` oprócz tego, że obiekty ciągu bajtów są przekazywane do funkcji bez ich zapisywania. Zamiast tego, implementacja zakłada że obiekt ciągu bajtów używa kodowania przekazywanego w parametrze.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a nonnegative Python integer to an unsigned tiny int, stored in a C :ctype:`unsigned char`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza nieujemną liczbę całkowitą języka Python na liczbę całkowitą krótką bez znaku, przechowywaną jako liczbę języka C typu :ctype:`unsigned char`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a tiny int without overflow checking, stored in a C :ctype:`unsigned char`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę całkowitą krótką bez sprawdzania czy nie przekroczono zakresu wartości, zachowaną jako liczbę języka C typu :ctype:`unsigned char`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`short int`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę języka C typu :ctype:`short int`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`unsigned short int`, without overflow checking.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę języka C typu :ctype:`unsigned short int`, bez sprawdzania czy nie przekroczono zakresu wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a plain C :ctype:`int`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na zwykłą liczbę całkowitą języka C typu :ctype:`int`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`unsigned int`, without overflow checking.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu :ctype:`unsigned int`, bez sprawdzania czy nie przekroczono zakresu wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`long int`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu :ctype:`long int`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`unsigned long` without overflow checking.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu :ctype:`long int` bez sprawdzania czy nie przekroczono zakresu wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`long long`.  This format is only available on platforms that support :ctype:`long long` (or :ctype:`_int64` on Windows).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu :ctype:`long long` (lub typu :ctype:`_int64` w systemie Windows).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`unsigned long long` without overflow checking.  This format is only available on platforms that support :ctype:`unsigned long long` (or :ctype:`unsigned _int64` on Windows).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python na liczbę całkowitą języka C typu :ctype:`unsigned long long` bez sprawdzania czy nie przekroczono zakresu wartości. Ten format jest dostępny tylko w systemach, które wspierają liczby typu :ctype:`unsigned long long` (lub typu :ctype:`unsigned _int64` w systemie Windows).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python integer to a C :ctype:`Py_ssize_t`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza liczbę całkowitą języka Python do wielkości rozmiaru :ctype:`Py_ssize_t` z języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python byte, represented as a :class:`bytes` object of length 1, to a C :ctype:`char`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia zawartość danej bajtowej z języka Python o typie byte, reprezentującej obiekt ciągu bajtów klasy :class:`bytes` o długości 1, na znak typu :ctype:`char` z języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python character, represented as a :class:`str` object of length 1, to a C :ctype:`int`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przelicza wartość reprezentującą znak języka Python - obiekt klasy :class:`str` o długości 1, na liczbę całkowitą języka C typu :ctype:`int`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python floating point number to a C :ctype:`float`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia liczbę zmiennoprzecinkową języka Python na liczbę zmiennoprzecinkową typu :ctype:`float` języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python floating point number to a C :ctype:`double`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia liczbę zmiennoprzecinkową z języka Python na liczbę zmiennoprzecinkową podwójnej precyzji typu :ctype:`double` w języku C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python complex number to a C :ctype:`Py_complex` structure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przekłada liczbę zespoloną języka Python do struktury liczby zespolonej języka C typu :ctype:`Py_complex`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inne obiekty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Store a Python object (without any conversion) in a C object pointer.  The C program thus receives the actual object that was passed.  The object's reference count is not increased.  The pointer stored is not *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zachowuje wskazanie na obiekt języka Python (bez wprowadzania żadnych zmian) do wskaźnika obiektowego języka C. Program w języku C otrzymuje w ten sposób konkretnie ten obiekt który został przekazany do funkcji. Liczba odniesień do obiektu nie zwiększa się. Zapamiętany wskaźnik jest niepusty (not *NULL*).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Store a Python object in a C object pointer.  This is similar to ``O``, but takes two C arguments: the first is the address of a Python type object, the second is the address of the C variable (of type :ctype:`PyObject\*`) into which the object pointer is stored.  If the Python object does not have the required type, :exc:`TypeError` is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zachowuje obiekt języka Python we wskaźniku na obiekt z języka C. Jest podobna do ``O``, ale oczekuje dwóch argumentów: pierwszym jest adres obiektu typu języka Python, a drugim jest adres zmiennej języka C (o typie :ctype:`PyObject\*`) do którego zachowywany jest wskaźnik na obiekt. Jeśli obiekt języka Python nie posiada wymaganego typu, wyjątek :exc:`TypeError` jest zgłaszany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a Python object to a C variable through a *converter* function.  This takes two arguments: the first is a function, the second is the address of a C variable (of arbitrary type), converted to :ctype:`void \*`.  The *converter* function in turn is called as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia obiekt języka Python na zmienną języka C przy użyciu funkcji *konwertującej*. Oczekuje dwóch argumentów: pierwszym jest funkcja, a drugim jest adres zmiennej z języka C (o dowolnym typie), zamieniany do wskaźnika typu :ctype:`void\*`. Funkcja *konwertująca* z kolei jest wywoływana w sposób następujący::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>status = converter(object, address);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>stan = konwerter(obiekt, adres);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where *object* is the Python object to be converted and *address* is the :ctype:`void\*` argument that was passed to the :cfunc:`PyArg_Parse\*` function. The returned *status* should be ``1`` for a successful conversion and ``0`` if the conversion has failed.  When the conversion fails, the *converter* function should raise an exception and leave the content of *address* unmodified.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdzie *obiekt* jest obiektem przeznaczonym do zamiany, a *adres* jest argumentem typu :ctype:`void\*`, który został przekazany do funkcji :cfunc:`PyArg_Parse\*`. Zwrócony *status* powinien być równy ``1`` dla udanej zamiany i ``0`` jeśli zamiana nie powiodła się. Gdy zamiana zawodzi, funkcja *konwertera* powinna zgłosić wyjątek i pozostawić zawartość pamięci spod *adresu* bez zmian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the *converter* returns Py_CLEANUP_SUPPORTED, it may get called a second time if the argument parsing eventually fails, giving the converter a chance to release any memory that it had already allocated. In this second call, the *object* parameter will be NULL; *address* will have the same value as in the original call.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *konwerter* zwraca status Py_CLEANUP_SUPPORTED, może zostać wywołany po raz drugi, jeśli wczytywanie argumentów ostatecznie zawiedzie, dając konwerterowi szansę na zwolnienie jakiejkolwiek pamięci, którą uprzednio przydzielił. W tym drugim wywołaniu, parametr *obiekt* będzie pusty (NULL); zaś *adres* będzie miał tą samą wartość, co przy pierwszym wywołaniu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The object must be a Python sequence whose length is the number of format units in *items*.  The C arguments must correspond to the individual format units in *items*.  Format units for sequences may be nested.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obiekt musi być sekwencją języka Python, której długość jest liczbą elementów formatu mierzoną w *elementach*. Argumenty języka C muszą odpowiadać poszczególnym jednostkom formatu w *elementach*. Jednostki formatu dla sekwencji mogą być zagnieżdżane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to pass "long" integers (integers whose value exceeds the platform's :const:`LONG_MAX`) however no proper range checking is done --- the most significant bits are silently truncated when the receiving field is too small to receive the value (actually, the semantics are inherited from downcasts in C --- your mileage may vary).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możliwe jest przekazywanie liczb całkowitych "długich" (liczb całkowitych, których wartość przekracza wartość stałej :const:`LONG_MAX` określoną dla danej architektury) chociaż żadne właściwe sprawdzenie zakresu nie jest wykonywane - najbardziej znaczące cyfry dwójkowe są w milczeniu obcinane, gdy docelowy obszar pamięci jest zbyt mały, aby przyjąć wartość (w rzeczywistości składnia jest odziedziczona po rzutowaniu z języka C --- twoje doświadczenia mogą się różnić).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few other characters have a meaning in a format string.  These may not occur inside nested parentheses.  They are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kilka innych znaków ma jeszcze znaczenie w ciągu formatu. Nie mogą one wystąpić wewnątrz zagnieżdżonych nawiasach okrągłych. Są to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the remaining arguments in the Python argument list are optional. The C variables corresponding to optional arguments should be initialized to their default value --- when an optional argument is not specified, :cfunc:`PyArg_ParseTuple` does not touch the contents of the corresponding C variable(s).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oznacza, że pozostałe argumenty z listy argumentów języka Python są dowolne. Zmiennym języka C odpowiadającym parametrom nadobowiązkowym powinny zostać przypisane wartości początkowe równe ich wartościom automatycznym --- gdy nadobowiązkowy parametr nie jest określony, funkcja :cfunc:`PyArg_ParseTuple` nie zmienia zawartości odpowiadającej zmiennej(ych) języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of format units ends here; the string after the colon is used as the function name in error messages (the "associated value" of the exception that :cfunc:`PyArg_ParseTuple` raises).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Lista jednostek formatu kończy się tutaj; Ciąg po dwukropku jest używany jako nazwa funkcji w wiadomościach o błędach ("załączona wartość" dla wyjątku, który zgłasza funkcja :cfunc:`PyArg_ParseTuple`). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of format units ends here; the string after the semicolon is used as the error message *instead* of the default error message.  ``:`` and ``;`` mutually exclude each other.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na tym kończy się lista jednostek formatu; ciąg po średniku jest traktowany jako informacja o błędzie do użycia *zamiast* automatycznej wiadomości o błędzie. Znaki dwukropka ``:`` i średnika ``;`` wzajemnie się wykluczają.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that any Python object references which are provided to the caller are *borrowed* references; do not decrement their reference count!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć uwagę, że każde odniesienie do obiektu Pythona które jest dostarczone do wywołującego funkcję jest odniesieniem *pożyczonym*; nie zmniejsza ich liczby odniesień!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional arguments passed to these functions must be addresses of variables whose type is determined by the format string; these are used to store values from the input tuple.  There are a few cases, as described in the list of format units above, where these parameters are used as input values; they should match what is specified for the corresponding format unit in that case.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowe parametry przekazywane do tych funkcji muszą być adresami zmiennych których typ jest określany przez ciąg formatu; są one używane do przechowywania wartości z krotki wejściowej. Jest parę przypadków, jak opisuje to lista jednostek formatu powyżej, gdzie te parametry są używane jako wprowadzane wartości; w takich przypadku powinny one odpowiadać temu, co jest określone we właściwych im jednostach formatu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the conversion to succeed, the *arg* object must match the format and the format must be exhausted.  On success, the :cfunc:`PyArg_Parse\*` functions return true, otherwise they return false and raise an appropriate exception. When the :cfunc:`PyArg_Parse\*` functions fail due to conversion failure in one of the format units, the variables at the addresses corresponding to that and the following format units are left untouched.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zamiana się powiodła, obiekt argumentu *arg* musi odpowiadać formatowi i format musi zostać wyczerpany. W przypadku powodzenia operacji funkcje :cfunc:`PyArg_Parse\*` zwracają wartość prawdy, w przeciwnym przypadku zwracają fałsz i zgłaszają właściwy wyjątek. Gdy funkcje :cfunc:`PyArg_Parse\*` zawiodą z powodu niepowodzenia konwersji w jednej z jednostek formatu, zmienne pod adresami odpowiadającymi temu i następnym jednostkom formatu są pozostawiane nietknięte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Funkcje interfejsu programowania aplikacji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building values</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Budowanie wartości</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Boolean Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obiekty logiki Boole'a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Booleans in Python are implemented as a subclass of integers.  There are only two booleans, :const:`Py_False` and :const:`Py_True`.  As such, the normal creation and deletion functions don't apply to booleans.  The following macros are available, however.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zmienne logiczne w języku Python są wykonane jako podklasa liczb całkowitych. Są tylko dwie wartości Boolowskie, stała oznaczająca wartość fałszu - :const:`Py_False` i stała oznaczająca wartość prawdy - :const:`Py_True`. Jako takie, normalne funkcje tworzące i usuwające nie dotyczą zmiennych logicznych. Dostępne są jednak następujące makropolecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffer Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obiekty buforów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python objects implemented in C can export a "buffer interface."  These functions can be used by an object to expose its data in a raw, byte-oriented format. Clients of the object can use the buffer interface to access the object data directly, without needing to copy it first.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty języka pyton urzeczywistnione w języku C mogą uzewnętrzniać "postać skrzynki wymiany". Te zadania mogą być wykonane przez przedmiot do odsłaniania swoich zapisów w nieprzetworzonej postaci zobrazowanej w równej wielkości kęsach. Używający przedmiotu mogą skorzystać z postaci skrzynki wymiany aby uzyskać dostęp do zapisów przedmiotu bezpośrednio, bez konieczności uprzedniego sporządzania odwzorowania przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two examples of objects that support the buffer interface are bytes and arrays. The bytes object exposes the character contents in the buffer interface's byte-oriented form. An array can also expose its contents, but it should be noted that array elements may be multi-byte values.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dwoma przykładami przedmiotów, które wspierają sprzęg wczytywania z wyprzedzeniem są zestawy kęsowe i tabele. Przedmiot zestawu kęsowego uzewnętrznia zawartość znakową w postaci zorientowanego kęsowo zawartej w sprzęgu wczytywania z wyprzedzeniem. Tabela może także uzewnętrzniać swoją zawartość, ale warto zauważyć, że elementami tabeli mogą być wartości wielokęsowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example user of the buffer interface is the file object's :meth:`write` method. Any object that can export a series of bytes through the buffer interface can be written to a file. There are a number of format codes to :cfunc:`PyArg_ParseTuple` that operate against an object's buffer interface, returning data from the target object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykładem przypadku użycia sprzęgu wczytywania z wyprzedzeniem jest sposób postępowania zapisywania :meth:`write` przedmiotu plikowego. Każdy przedmiot, który może wydawać seryjnie kęsy przez sprzęg wczytywania z wyprzedzeniem może być zapisany do pliku. Jest kilka postaci kodujących dla zadania :cfunc:`PyArg_ParseTuple` które operują na sprzęgu wczytywania z wyprzedzeniem przedmiotu, zwracając dane z przedmiotu docelowego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on the buffer interface is provided in the section :ref:`buffer-structs`, under the description for :ctype:`PyBufferProcs`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Więcej informacji o sprzęgu wczytywania z wyprzedzeniem w sekcji :ref:`struktury-bufora`, pod opisem dla :ctype:`PyBufferProcs`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffer objects are useful as a way to expose the data from another object's buffer interface to the Python programmer.  They can also be used as a zero-copy slicing mechanism.  Using their ability to reference a block of memory, it is possible to expose any data to the Python programmer quite easily.  The memory could be a large, constant array in a C extension, it could be a raw block of memory for manipulation before passing to an operating system library, or it could be used to pass around structured data in its native, in-memory format.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmioty wczytywania z wyprzedzeniem są użyteczne jako sposób uzewnętrzniania danych ze sprzęgu wczytywania z wyprzedzeniem innego przedmiotu dla programującego w języku pytonowskim. Mogą także być użyte do mechanizmu operacji na ciągach cząstkowych bez kopiowania. Używając ich zdolności do odwołania się do obszaru pamięci, jest możliwe uzewnętrznienie dowolnych danych dla programującego w języku pytonowskim w całkiem łatwy sposób. Pamięć może mieć postać całkiem sporej stałej tabeli w rozszerzeniu języka C, może także być surowym obszarem pamięci dla operowania przed przekazaniem dla biblioteki systemu operacyjnego, lub może być używana dla wzajemnego przekazywania usystematyzowanych informacji w swojej naturalnej postaci wewnętrznej dla pamięci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffer related functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania związane z przedmiotem wczytywania z wyprzedzeniem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MemoryView objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Widoku Pamięci</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A memoryview object exposes the C level buffer interface to Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmiot widoku pamięci uzewnętrznia sprzęg wczytywania z wyprzedzeniem z poziomu języka C dla języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Byte Array Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Tabel Kęsowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type check macros</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makra sprawdzające typ danych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Direct API functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania Bezpośredniego API (sprzęgu programującego aplikację)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Macros</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These macros trade safety for speed and they don't check pointers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te makropolecenia pomijają zabezpieczenia na korzyść zwiększenia szybkości działania i nie sprawdzają wskaźników.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bytes Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Kęsowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These functions raise :exc:`TypeError` when expecting a bytes parameter and are called with a non-bytes parameter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te zadania zgłaszają wyjątek :exc:`TypeError` gdy w oczekiwaniu na parametr kęsowy otrzymają nie-kęsowy parametr wejściowy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Capsules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kapsuły</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refer to :ref:`using-capsules` for more information on using these objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zerknij do :ref:`używanie-kapsuł` po więcej informacji o używaniu tych przedmiotów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cell Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Komórkowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Cell" objects are used to implement variables referenced by multiple scopes. For each such variable, a cell object is created to store the value; the local variables of each stack frame that references the value contains a reference to the cells from outer scopes which also use that variable.  When the value is accessed, the value contained in the cell is used instead of the cell object itself.  This de-referencing of the cell object requires support from the generated byte-code; these are not automatically de-referenced when accessed. Cell objects are not likely to be useful elsewhere.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Komórkowe" przedmioty są używane do uszczegóławiania zmiennych, do których odwołania znajdują się w wielu zakresach. Dla każdej takiej zmiennej, przedmiot komórkowy jest tworzony aby przechowywać wartość; Zmienne lokalne dla każdej ramki stosu,  która odwołuje się do wartości, zawiera odniesienie do komórek z zewnętrznych zakresów które także używają tych zmiennych. Gdy wartość jest odczytywana, wartość zawarta w komórce jest używana zamiast przedmiotu komórki samego w sobie. To wtórne odwołanie przedmiotu komórkowego wymaga wsparcia od wygenerowanego kodu-kęsowego; takie kody nie są automatycznie wtórnie odwoływane podczas dostępu. Przedmioty komórkowe nie są raczej użyteczne gdzie indziej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty kodowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code objects are a low-level detail of the CPython implementation. Each one represents a chunk of executable code that hasn't yet been bound into a function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty kodowe są niskopoziomowym detalem realizacji języka pytonowskiego - CPython. Każdy jeden reprezentuje fragment wykonywalnego kodu który nie został jeszcze związany z żadną funkcją.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Complex Number Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Liczb Zespolonych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python's complex number objects are implemented as two distinct types when viewed from the C API:  one is the Python object exposed to Python programs, and the other is a C structure which represents the actual complex number value. The API provides functions for working with both.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty liczb zespolonych języka pytonowskiego są urzeczywistnione jako dwa różne typy patrząc z punktu widzenia sprzęgu programowania API języka C: jednym jest przedmiot wyprowadzony dla programów języka pytonowskiego, zaś drugi jest strukturą języka C która oddaje właściwą wartość liczby zespolonej. Sprzęg oprogramowania (API) dostarcza zadania do pracy z obydwoma typami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Complex Numbers as C Structures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczby zespolone jako struktury języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the functions which accept these structures as parameters and return them as results do so *by value* rather than dereferencing them through pointers.  This is consistent throughout the API.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ proszę że zadania które przyjmują te struktury w miejsce parametrów i zwracają je jako wyniki czynią to *przez wartość* zamiast odwoływać się do nich przez wskazania. Ta własność jest spójna w całym sprzęgu programowania (API).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Complex Numbers as Python Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczby zespolone jako przedmioty języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Concrete Objects Layer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Warstwa przedmiotów konkretnych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The functions in this chapter are specific to certain Python object types. Passing them an object of the wrong type is not a good idea; if you receive an object from a Python program and you are not sure that it has the right type, you must perform a type check first; for example, to check that an object is a dictionary, use :cfunc:`PyDict_Check`.  The chapter is structured like the "family tree" of Python object types.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania w tym rozdziale są szczególne dla konkretnych typów przedmiotów języka pytonowskiego. Przekazywanie im przedmiotów niewłaściwego typu to nie dobry pomysł; jeśli otrzymujesz przedmiot z programy w języku pytonowskim i nie jesteś pewien czy jest on właściwego typu, musisz najpierw wykonać sprawdzenie typu; na przykład, aby sprawdzić czy przedmiot jest słownikiem, użyj zadania :cfunc:`PyDict_Check`. Rozdział jest podzielony jako "drzewo rodzinne" typów przedmiotów języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the functions described in this chapter carefully check the type of the objects which are passed in, many of them do not check for *NULL* being passed instead of a valid object.  Allowing *NULL* to be passed in can cause memory access violations and immediate termination of the interpreter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podczas gdy zadania opisane w tym rozdziale dokładnie sprawdzają rodzaj przedmiotów które zostaną im przekazane, wiele z nich nie jest odporna na przekazanie im wartości *NULL* zamiast właściwego przedmiotu. Pozwalając aby wartość *NULL* była przekazywana dla zadania może powodować naruszenia dostępu do pamięci i natychmiastowe zakończenie programu wykonującego program.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fundamental Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty podstawowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section describes Python type objects and the singleton object ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział opisuje przedmioty typów języka pytonowskiego i przedmiot prostacki ``Żaden`` (``None``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numeric Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty numeryczne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequence Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty sekwencji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generic operations on sequence objects were discussed in the previous chapter; this section deals with the specific kinds of sequence objects that are intrinsic to the Python language.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawowe operacje na przedmiotach ciągłych zostały opisane w poprzednim rozdziale; ten rozdział zajmuje się szczególnymi rodzajami przedmiotów ciągłych które są wewnętrzne dla języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty mapujące</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inne przedmioty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String conversion and formatting</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawienia i formatowanie ciągów znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functions for number conversion and formatted string output.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie dla zamiany liczb i wyjścia znakowego sformatowanego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`PyOS_snprintf` and :cfunc:`PyOS_vsnprintf` wrap the Standard C library functions :cfunc:`snprintf` and :cfunc:`vsnprintf`. Their purpose is to guarantee consistent behavior in corner cases, which the Standard C functions do not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zadania :cfunc:`PyOS_snpritf` i :cfunc:`PyOS_vsnprintf` opakowują sztandarowe biblioteczne zadania języka C :cfunc:`snprintf` i :cfunc:`vsnprintf`. Ich celem jest zagwarantowanie spójnego zachowania w przypadkach brzegowych, których sztandarowe zadania języka C nie gwarantują.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The wrappers ensure that *str*[*size*-1] is always ``'\0'`` upon return. They never write more than *size* bytes (including the trailing ``'\0'``) into str. Both functions require that ``str != NULL``, ``size &gt; 0`` and ``format != NULL``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opakowania zapewniają że ostatni znak ciągu *str*[*size*-1] gdzie size - rozmiar ciągu zawsze zwraca ``'\0'``. Nigdy nie wypisują więcej niż *rozmiar ciągu* (*size*) kęsów (włącznie z kończącym znakiem zera ``'\0'``) do str. Obydwa zadania wymagają aby ``str != NULL``, ``size &gt; 0 `` i ``format != NULL``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the platform doesn't have :cfunc:`vsnprintf` and the buffer size needed to avoid truncation exceeds *size* by more than 512 bytes, Python aborts with a *Py_FatalError*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli system nie posiada zadania :cfunc:`vsnprintf` i rozmiar wymiennika potrzebny aby uniknąć obcinania przekracza *rozmiar* (*size*) o więcej niż 512 kęsów, program wykonujący przerywany jest z komunikatem *Py_FatalError*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The return value (*rv*) for these functions should be interpreted as follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość zwracana (z ang. - return value) *wr* ( z ang. - *rv*) dla tych zadań powinna być rozumiana następująco:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When ``0 &lt;= rv &lt; size``, the output conversion was successful and *rv* characters were written to *str* (excluding the trailing ``'\0'`` byte at *str*[*rv*]).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy ``0 &lt;= rv &lt; size``, konwersja wyjściowa została zakończona powodzeniem i znaki *rv* zostały zapisane do ciągu znaków *str* (pomijając kończący znak ``'\0'`` w *str*[*rv*]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When ``rv &gt;= size``, the output conversion was truncated and a buffer with ``rv + 1`` bytes would have been needed to succeed. *str*[*size*-1] is ``'\0'`` in this case.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy ``rv &gt;= size``, wynikowa podmiana została ucięta i wymiennik z ``rv + 1`` kęsami byłby potrzebny do zakończenia powodzeniem. znak *str*[*rozmiar*-1] jest znakiem ``'\0'`` w tym przypadku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When ``rv &lt; 0``, "something bad happened." *str*[*size*-1] is ``'\0'`` in this case too, but the rest of *str* is undefined. The exact cause of the error depends on the underlying platform.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy ``rv &lt; 0``, "stało się coś złego." *str*[*size*-1] jest znakiem ``'\0'`` także w tym przypadku, ale reszta ciągu *str* jest nieokreślona. Dokładna przyczyna błędu zależy od leżącego u podstaw systemu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions provide locale-independent string to number conversions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania dostarczają niezależne od ustawień regionalnych ciągi do zamian liczb.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DateTime Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Daty-Czasu (z ang. - DateTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various date and time objects are supplied by the :mod:`datetime` module. Before using any of these functions, the header file :file:`datetime.h` must be included in your source (note that this is not included by :file:`Python.h`), and the macro :cmacro:`PyDateTime_IMPORT` must be invoked, usually as part of the module initialisation function.  The macro puts a pointer to a C structure into a static variable, :cdata:`PyDateTimeAPI`, that is used by the following macros.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Różne przedmioty daty i czasu są dostarczane przez moduł :mod:`datetime`. Przed użyciem którychkolwiek z tych zadań, plik nagłówkowy :file:`datetime.h` musi zostać załączony do źródeł (zauważ że nie jest to załączone w pliku :file:`Python.h`), i makropolecznie :cmacro:`PyDateTime_IMPORT` powinno zostać wywołane, zwykle jako część zadania inicjującego moduł. Makropolecenie wstawia wskaźnik do struktury języka C do zmiennej statycznej, :cdata:`PyDateTimeAPI`, które jest używane przez następujące makropolecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-check macros:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia sprawdzenia typu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Macros to create objects:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia do tworzenia przedmiotów:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Macros to extract fields from date objects.  The argument must be an instance of :cdata:`PyDateTime_Date`, including subclasses (such as :cdata:`PyDateTime_DateTime`).  The argument must not be *NULL*, and the type is not checked:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia do wydobywania elementów daty. Parametr musi być przedstawicielem :cdata:`PyDateTime_Date`, zawierając podklasy (takie jak: :cdata:`PyDateTime_DateTime`). Parametr nie może być *NULL*, i typ nie jest sprawdzany:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Macros to extract fields from datetime objects.  The argument must be an instance of :cdata:`PyDateTime_DateTime`, including subclasses. The argument must not be *NULL*, and the type is not checked:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia do wydobywania elementów z przedmiotu daty. Parametr musi być przedstawicielem :cdata:`PyDateTime_DateTime`, włączając podklasy. Parametr nie może być *NULL*, i typ nie jest sprawdzany:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Macros to extract fields from time objects.  The argument must be an instance of :cdata:`PyDateTime_Time`, including subclasses. The argument must not be *NULL*, and the type is not checked:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia do wydobywania elementów z przedmiotu czasu. Parametr musi być przedstawicielem :cdata:`PyDateTime_Time`, włączając podklasy. Parametr nie może być pusty *NULL*, a jego typ nie jest sprawdzany:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Macros for the convenience of modules implementing the DB API:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia dla wygody modułów realizujących sprzęg programowania baz danych DB API:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Descriptor Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Deskryptorów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Descriptors" are objects that describe some attribute of an object. They are found in the dictionary of type objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Deskryptory" są przedmiotami które opisują niektóre własności przedmiotu. Można je znaleźć w słowniku przedmiotów typów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dictionary Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Słownikowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception Handling</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługa sytuacji wyjątkowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The functions described in this chapter will let you handle and raise Python exceptions.  It is important to understand some of the basics of Python exception handling.  It works somewhat like the Unix :cdata:`errno` variable: there is a global indicator (per thread) of the last error that occurred.  Most functions don't clear this on success, but will set it to indicate the cause of the error on failure.  Most functions also return an error indicator, usually *NULL* if they are supposed to return a pointer, or ``-1`` if they return an integer (exception: the :cfunc:`PyArg_\*` functions return ``1`` for success and ``0`` for failure).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania opisane w tym rozdziale pozwalają obsługiwać i zgłaszać sytuacje wyjątkowe języka pytonowskiego. Istotne jest pojęcie pewnych podstaw obsługi sytuacji wyjątkowych języka Pytonowskiego. Działa ono trochę, jak zmienna znana z systemu Unix :cdata:`errno`: istnieje ogólnego poziomu wskaźnik (po jednym na wątek) ostatniego błędu który wystąpił. Większość zadań nie wyczyszcza tego przy bezbłędnym wykonaniu, ale ustawia go aby wskazywał na powód błędu przy jego wystąpieniu. Większość zadań zwraca także wskazanie błędu, zwykle *NULL* jeśli miały zwrócić wskaźnik, lub ``-1`` jeśli zwracają liczbę całkowitą (z wyjątkiem: zadań :cfunc:`PyArg_\*` które zwracają ``1`` przy pozytywnym wykonaniu i ``0`` przy błędnym zakończeniu).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a function must fail because some function it called failed, it generally doesn't set the error indicator; the function it called already set it.  It is responsible for either handling the error and clearing the exception or returning after cleaning up any resources it holds (such as object references or memory allocations); it should *not* continue normally if it is not prepared to handle the error.  If returning due to an error, it is important to indicate to the caller that an error has been set.  If the error is not handled or carefully propagated, additional calls into the Python/C API may not behave as intended and may fail in mysterious ways.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy zadanie musi zawieźć z powodu błędu zadania które wywołało, ogólnie nie ustawia ona wskaźnika błędu; podzadanie które zostało wywołane już go ustawiła. Jest on odpowiedzialny albo za obsługę błędu i wyczyszczenie wskaźnika sytuacji wyjątkowej lub powrót po sprzątnięciu jakichkolwiek zasobów które utrzymuje (takich jak odwołania do przedmiotów lub zajęte pamięci); *nie* powinien kontynuować zwyczajnie jeśli nie jest przygotowany do obsługi błędu. Jeśli kończy z powodu błędu, istotne jest zwrócenie uwagi wołającego że został zgłoszony błąd. Jeśli błąd nie jest obsługiwany lub propagowany właściwie, dodatkowe odwołania do sprzęgu języka pytonowskiego/C mogą nie zachowywać się tak, jak planowano i mogą zawieźć w nieoczekiwane sposoby.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The error indicator consists of three Python objects corresponding to the result of ``sys.exc_info()``.  API functions exist to interact with the error indicator in various ways.  There is a separate error indicator for each thread.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wskaźnik błędu składa się z trzech przedmiotów języka pytonowskiego odpowiadających wynikowi wykonania zadania ``sys.exc_info()``. Istnieją zadania sprzęgu programowania do współpracy ze wskaźnikiem błędu na różne sposoby. Dla każdego wątku istnieje osobny wskaźnik błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Sytuacji Wyjątkowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Recursion Control</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kontrola Rekursji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two functions provide a way to perform safe recursive calls at the C level, both in the core and in extension modules.  They are needed if the recursive code does not necessarily invoke Python code (which tracks its recursion depth automatically).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te dwa zadania dostarczają sposób postępowania dla wykonania bezpiecznego odwołania rekursywnego na poziomie języka C, zarówno w głównych jak i zewnętrznych modułach. Są one potrzebne jeśli kod odwołujący się sam do siebie nie koniecznie wywołuje kod w języku pytonowskim (który śledzi poziom zagnieżdżenia odwołań rekursywnych automatycznie).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standard Exceptions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sztandarowe Sytuacje Wyjątkowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All standard Python exceptions are available as global variables whose names are ``PyExc_`` followed by the Python exception name.  These have the type :ctype:`PyObject\*`; they are all class objects.  For completeness, here are all the variables:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie sztandarowe sytuacje wyjątkowe języka pytonowskiego są dostępne jako nadrzędne zmienne których nazwy zaczynają się od ``PyExc_`` po którym następuje nazwa sytuacji wyjątkowej języka pytonowskiego. Te są typu :ctype:`PyObject\*`; wszystkie są przedmiotami definiującymi rodzaj przedmiotu. Dla uzupełnienia, tu są wszystkie nazwy zmiennych:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C Name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python Name</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa w języku pytonowskim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwagi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_BaseException`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_BaseException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`BaseException`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`BaseException`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(1)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_Exception`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_Exception`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`Exception`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`Exception`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_ArithmeticError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_ArithmeticError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`ArithmeticError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`ArithmeticError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_LookupError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_LookupError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`LookupError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`LookupError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_AssertionError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_AssertionError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`AssertionError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`AssertionError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_AttributeError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_AttributeError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`AttributeError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`AttributeError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_EOFError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_EOFError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`EOFError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`EOFError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_EnvironmentError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_EnvironmentError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`EnvironmentError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`EnvironmentError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_FloatingPointError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_FloatingPointError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`FloatingPointError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`FloatingPointError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_IOError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_IOError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`IOError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`IOError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_ImportError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_ImportError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`ImportError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`ImportError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_IndexError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_IndexError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`IndexError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`IndexError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_KeyError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_KeyError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`KeyError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`KeyError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_KeyboardInterrupt`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_KeyboardInterrupt`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`KeyboardInterrupt`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`KeyboardInterrupt`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_MemoryError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_MemoryError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`MemoryError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`MemoryError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_NameError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_NameError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`NameError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`NameError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_NotImplementedError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_NotImplementedError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`NotImplementedError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`NotImplementedError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_OSError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_OSError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`OSError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`OSError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_OverflowError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_OverflowError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`OverflowError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`OverflowError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_ReferenceError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_ReferenceError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`ReferenceError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`ReferenceError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(2)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_RuntimeError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_RuntimeError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`RuntimeError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`RuntimeError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_SyntaxError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_SyntaxError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`SyntaxError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`SyntaxError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_SystemError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_SystemError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`SystemError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`SystemError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_SystemExit`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_SystemExit`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`SystemExit`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`SystemExit`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_TypeError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_TypeError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`TypeError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`TypeError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_ValueError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_ValueError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`ValueError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`ValueError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_WindowsError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_WindowsError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`WindowsError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`WindowsError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\(3)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>\(3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`PyExc_ZeroDivisionError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`PyExc_ZeroDivisionError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:exc:`ZeroDivisionError`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:exc:`ZeroDivisionError`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwagi:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a base class for other standard exceptions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest podstawowy rodzaj przedmiotu dla innych sztandarowych sytuacji wyjątkowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the same as :exc:`weakref.ReferenceError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest to samo, co sytuacja wyjątkowa :exc:`weakref.ReferenceError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only defined on Windows; protect code that uses this by testing that the preprocessor macro ``MS_WINDOWS`` is defined.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdefiniowane tylko w systemie Windows; Kod chroniony który używa tego przez sprawdzenie czy makrodefinicja preprocesora ``MS_WINDOWS`` jest określona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Plikowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These APIs are a minimal emulation of the Python 2 C API for built-in file objects, which used to rely on the buffered I/O (:ctype:`FILE\*`) support from the C standard library.  In Python 3, files and streams use the new :mod:`io` module, which defines several layers over the low-level unbuffered I/O of the operating system.  The functions described below are convenience C wrappers over these new APIs, and meant mostly for internal error reporting in the interpreter; third-party code is advised to access the :mod:`io` APIs instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te sprzęgi programowania (API) są najmniejszą emulacją sprzęgów zamieniających z języka pytonowskiego do języka C dla wbudowanych przedmiotów plikowych, które polegały na wsparciu wczytywania i zapisu z wyprzedzeniem (:ctype:`FILE\*`) z biblioteki sztandarowej języka C. W trzeciej wersji języka pytonowskiego pliki i strumienie używają nowego modułu :mod:`io`, który określa kilka warstw ponad niskopoziomowym niewyprzedzającym odczycie/zapisie systemu operacyjnego. Zadania opisane poniżej są konwencjonalnymi opakowaniami języka C ponad tymi nowymi sprzęgami programowania ( - z ang. - API), i służą głównie wewnętrznemu raportowaniu błędów wewnątrz programu interpretującego polecenia języka pytonowskiego; dla programów pochodzących od zewnętrznych dostawców zalecany jest dostęp przez sprzęgi programowania :mod:`io`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Floating Point Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Liczb Zmiennopozycyjnych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Function Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Zadań</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few functions specific to Python functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje kilka zadań szczególnych dla zadań języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting Cyclic Garbage Collection</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla Cyklicznego Zbierania Śmieci</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python's support for detecting and collecting garbage which involves circular references requires support from object types which are "containers" for other objects which may also be containers.  Types which do not store references to other objects, or which only store references to atomic types (such as numbers or strings), do not need to provide any explicit support for garbage collection.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie języka pytonowskiego dla wykrywania i zbierania śmieci które zahacza o cykliczne odwołania wymaga wsparcia od rodzajów przedmiotów, które są pojemnikami dla innych przedmiotów które mogą także być pojemnikami. Rodzaje, które nie przechowują odwołań do innych przedmiotów, lub które tylko przechowują odwołania do przedmiotów o rodzajach podstawowych (takich jak liczby lub ciągi znaków), nie potrzebują dostarczać żadnego wsparcia dla zbierania śmieci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a container type, the :attr:`tp_flags` field of the type object must include the :const:`Py_TPFLAGS_HAVE_GC` and provide an implementation of the :attr:`tp_traverse` handler.  If instances of the type are mutable, a :attr:`tp_clear` implementation must also be provided.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby utworzyć rodzaj pojemnika, pole :attr:`tp_flags` rodzaju przedmiotu pojemnika musi zawierać :const:`Py_TPFLAGS_HAVE_GC` i dostarczać urzeczywistnienie uchwytu zadania  :attr:`tp_traverse`. Jeśli egzemplarze tego rodzaju pojemników są zmienialne (mutowalne), urzeczywistnienie zadania :attr:`tp_clear` musi także być dostarczone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects with a type with this flag set must conform with the rules documented here.  For convenience these objects will be referred to as container objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty o rodzaju z tą flagą ustawioną muszą stosować się do zasad opisanych tutaj. Dla wygody te przedmioty te będą określane mianem przedmiotów pojemnikowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constructors for container types must conform to two rules:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktory przedmiotów typu pojemnikowego muszą stosować się do dwóch zasad:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The memory for the object must be allocated using :cfunc:`PyObject_GC_New` or :cfunc:`PyObject_GC_NewVar`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pamięć dla przedmiotu musi być przydzielona używając zadania :cfunc:`PyObject_GC_New` lub :cfunc:`PyObject_GC_NewVar`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once all the fields which may contain references to other containers are initialized, it must call :cfunc:`PyObject_GC_Track`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy wszystkie pola które mogą zawierać odwołania do innych pojemników zostaną zainicjowane, wtedy musi wywoływać zadanie :cfunc:`PyObject_GC_Track`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, the deallocator for the object must conform to a similar pair of rules:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobnie odbieracz przydziału dla przedmiotu musi stosować się do podobnej pary zasad:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before fields which refer to other containers are invalidated, :cfunc:`PyObject_GC_UnTrack` must be called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zanim pola które odnoszą się do innych pojemników zostaną unieważnione, zadanie :cfunc:`PyObject_GC_UnTrack` musi zostać wywołane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The object's memory must be deallocated using :cfunc:`PyObject_GC_Del`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pamięć przydzielona przedmiotowi musi zostać zabrana używając zadania :cfunc:`PyObject_GC_Del`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_traverse` handler accepts a function parameter of this type:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uchwyt :attr:`tp_traverse` przyjmuje jako parametr zadania ten typ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_traverse` handler must have the following type:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uchwyt :attr:`tp_traverse` musi być tego typu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To simplify writing :attr:`tp_traverse` handlers, a :cfunc:`Py_VISIT` macro is provided.  In order to use this macro, the :attr:`tp_traverse` implementation must name its arguments exactly *visit* and *arg*:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby uprościć pisanie uchwytu :attr:`tp_traverse`, dostarcza się makropolecenie :cfunc:`Py_VISIT`. Aby użyć tego makropolecenia, realizacja zadania :attr:`tp_traverse` musi nazywać jego parametry dokładnie *visit* i *arg*:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_clear` handler must be of the :ctype:`inquiry` type, or *NULL* if the object is immutable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uchwyt :attr:`tp_clear` musi być typu :ctype:`inquiry` (z ang. - zapytanie) lub *NULL* jeśli przedmiot jest niezmienny (niemutowalny).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generator Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przemioty Generatorów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generator objects are what Python uses to implement generator iterators. They are normally created by iterating over a function that yields values, rather than explicitly calling :cfunc:`PyGen_New`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmiotów Generatorów język pytonowski używa aby realizować iteratory generatorów. Zwykle są one tworzone przez iterację po wynikach wyrzuconych z zadania, zamiast jawnie wywoływać zadanie :cfunc:`PyGen_New`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Importing Modules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Importowanie Modułów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python/C API Reference Manual</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podręcznik programowania sprzęgów między językami pyton i C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Release</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|version|</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>|wersja|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|today|</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>|dzisiaj|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This manual documents the API used by C and C++ programmers who want to write extension modules or embed Python.  It is a companion to :ref:`extending-index`, which describes the general principles of extension writing but does not document the API functions in detail.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten podręcznik opisuje sprzęg programowania (z ang. - API) używany przez programujących w językach C i C++, którzy chcieliby pisać moduły rozszerzające lub wstawki w języku pytonowskim. Jest on uzupełnieniem sekcji :ref:`extending-index`, który opisuje ogólne zasady pisania rozszerzeń ale nie opisuje zadań sprzęgu programowania (API) w szczegółach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initialization, Finalization, and Threads</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inicjalizacja, Zakańczanie i Wątki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread State and the Global Interpreter Lock</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stan Wątku i Nadrzędny Zamek programu Interpretującego </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python interpreter is not fully thread safe.  In order to support multi-threaded Python programs, there's a global lock, called the :dfn:`global interpreter lock` or :dfn:`GIL`, that must be held by the current thread before it can safely access Python objects. Without the lock, even the simplest operations could cause problems in a multi-threaded program: for example, when two threads simultaneously increment the reference count of the same object, the reference count could end up being incremented only once instead of twice.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Program interpretujący język pytonowski nie jest w pełni bezpieczny ze względu na wątki. W celu udzielenia wsparcia dla wielowątkowych programów języka pytonowskiego, istnieje nadrzędna blokada, zwana :dfn:`nadrzędną blokadą programu interpretującego` w skrócie :dfn:`GIL` (z ang. - global interpreter lock) która musi zostać wstrzymana przez aktywny wątek zanim będzie mógł korzystać bezpiecznie z przedmiotów języka pytonowskiego. Bez blokady, nawet najprostsze operacje mogłyby powodować kłopoty w wielowątkowym programie: np. gdy dwa wątki jednocześnie zwiększają liczbę odwołań do tego samego przedmiotu, liczba odwołań mogłaby ostatecznie zostać zwiększona tylko jednokrotnie zamiast dwukrotnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, the rule exists that only the thread that has acquired the global interpreter lock may operate on Python objects or call Python/C API functions. In order to support multi-threaded Python programs, the interpreter regularly releases and reacquires the lock --- by default, every 100 bytecode instructions (this can be changed with  :func:`sys.setcheckinterval`).  The lock is also released and reacquired around potentially blocking I/O operations like reading or writing a file, so that other threads can run while the thread that requests the I/O is waiting for the I/O operation to complete.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dlatego też, istnieje zasada mówiąca, że tylko wątek który przejął nadrzędną blokadę programu interpretującego może operować na przedmiotach języka pytonowskiego lub wzywać wykonania zadań sprzęgu programowania między językami pytonowskim i C. W celu udzielenia wsparcia dla wielowątkowych programów języka pytonowskiego, program interpretujący w równych odstępach czasu zwalnia i na powrót przejmuje blokadę --- domyślnie co 100 instrukcji w kęsokodzie (to może zostać zmienione za pomocą zadania :func:`sys.setcheckinterval`). Blokada jest także zwalniana i na powrót przejmowana wokół, potencjalnie blokowania operacji dostępu I/O, jak odczyt i zapis do pliku, tak że inne wątki mogą się toczyć podczas gdy wątek stawiający żądanie dostępu I/O (odczytu/zapisu) czeka aż operacja odczytu/zapisu zostanie zakończona. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python interpreter needs to keep some bookkeeping information separate per thread --- for this it uses a data structure called :ctype:`PyThreadState`. There's one global variable, however: the pointer to the current :ctype:`PyThreadState` structure.  Before the addition of :dfn:`thread-local storage` (:dfn:`TLS`) the current thread state had to be manipulated explicitly.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Program Interpretujący potrzebuje utrzymywać niektóre wiadomości porządkowe oddzielnie dla każdego wątku --- dla nich używa struktury danych zwanej :ctype:`PyThreadState`. Istnieje jednak jedna nadrzędna zmienna: wskaźnik na strukturę stanu obecnego wątku :ctype:`PyThreadState`. Przed dodaniem miejscowego magazynu wątku ( z ang. - :dfn:`thread-local storage` w skrócie :dfn:`TLS`) stan aktualnego wątku musiał być jawnie określany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is easy enough in most cases.  Most code manipulating the global interpreter lock has the following simple structure::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest to proste w większości przypadków. Większość kodu operującego na nadrzędnej blokadzie programu interpretującego ma następującą prostą budowę::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save the thread state in a local variable. Release the global interpreter lock. ...Do some blocking I/O operation... Reacquire the global interpreter lock. Restore the thread state from the local variable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapamiętaj stan wątku w zmiennej miejscowej. Zwolnij nadrzędną blokadę programu interpretującego. ...Wykonaj pewną operację blokującą odczytu/zapisu... Na nowo przejmij i załóż nadrzędną blokadę programu interpretującego. Przywróć stan wątku ze zmiennej miejscowej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is so common that a pair of macros exists to simplify it::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest to tak często spotykane postępowanie że istnieje para makropoleceń służąca do jego uproszczenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_BEGIN_ALLOW_THREADS ...Do some blocking I/O operation... Py_END_ALLOW_THREADS</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_BEGIN_ALLOW_THREADS ...Wykonaj pewną blokującą odzyt/zapis operację... Py_END_ALLOW_THREADS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :cmacro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a hidden local variable; the :cmacro:`Py_END_ALLOW_THREADS` macro closes the block.  Another advantage of using these two macros is that when Python is compiled without thread support, they are defined empty, thus saving the thread state and GIL manipulations.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenie :cmacro:`Py_BEGIN_ALLOW_THREADS` otwiera nowy blok i deklaruje ukrytą zmienną lokalną; Makropolecenie :cmacro:`Py_END_ALLOW_THREADS` zamyka blok. Dodatkową zaletą używania tych dwóch makropoleceń jest to, że gdy język pytonowski jest kompilowany bez wsparcia dla wątków, są zdefiniowane jako puste, w ten sposób zachowując stan wątków i zmiany typu GIL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When thread support is enabled, the block above expands to the following code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy wsparcie dla wątków jest włączone, powyższy blok rozwijany jest do poniższego kodu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyThreadState *_save;  _save = PyEval_SaveThread(); ...Do some blocking I/O operation... PyEval_RestoreThread(_save);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyThreadState *_save; _save = PyEval_SaveThread(); ...Wykonaj pewne operacje blokujące wejście/wyjście... PyEval_RestoreThread(_save);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using even lower level primitives, we can get roughly the same effect as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używanie nawet niższego poziomu zadań podstawowych, możemy uzyskać z grubsza ten sam efekt w następujący sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyThreadState *_save;  _save = PyThreadState_Swap(NULL); PyEval_ReleaseLock(); ...Do some blocking I/O operation... PyEval_AcquireLock(); PyThreadState_Swap(_save);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyThreadState *_save;  _save = PyThreadState_Swap(NULL); PyEval_ReleaseLock(); ...Wykonaj pewną operację blokującą wejście/wyjście... PyEval_AcquireLock(); PyThreadState_Swap(_save);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some subtle differences; in particular, :cfunc:`PyEval_RestoreThread` saves and restores the value of the  global variable :cdata:`errno`, since the lock manipulation does not guarantee that :cdata:`errno` is left alone.  Also, when thread support is disabled, :cfunc:`PyEval_SaveThread` and :cfunc:`PyEval_RestoreThread` don't manipulate the GIL; in this case, :cfunc:`PyEval_ReleaseLock` and :cfunc:`PyEval_AcquireLock` are not available. This is done so that dynamically loaded extensions compiled with thread support enabled can be loaded by an interpreter that was compiled with disabled thread support.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją pewne drobne różnice; w szczególności, :cfunc:`PyEval_RestoreThread` zachowuje i przywraca wartość zmiennej globalnej :cdata:`errno`, biorąc pod uwagę to, że zmiany dokonywane na blokadzie nie gwarantują, że zmienna :cdata:`errno` zostanie zostawiona w spokoju. Także gdy wsparcie dla wątków jest wyłączone, zadabue :cfunc:`PyEval_SaveThread` i :cfunc:`PyEval_RestoreThread` nie zmieniają GILa; w tym przypadku zadania :cfunc:`PyEvalReleaseLock` i :cfunc:`PyEval_AcquireLock` nie są dostępne. Jest to zrobione tak, aby dynamicznie ładowane rozszerzenia kompilowane ze wsparciem dla wątków włączonym mogły być ładowane przez program interpretujący polecenia języka pytonowskiego który został utworzony z wyłączonym wsparciem dla wątków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The global interpreter lock is used to protect the pointer to the current thread state.  When releasing the lock and saving the thread state, the current thread state pointer must be retrieved before the lock is released (since another thread could immediately acquire the lock and store its own thread state in the global variable). Conversely, when acquiring the lock and restoring the thread state, the lock must be acquired before storing the thread state pointer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>GIL - 'global interpreter lock' nadrzędna blokada programu interpretującego polecenia języka pytonowskiego jest używany do ochrony wskaźnika na obecny stan wątku. W czasie zwalniania blokady, wskaźnik na stan aktualnego wątku musi zostać odebrany zanim blokada zostanie zwolniona (gdyż inny wątek mógłby natychmiast przejąć blokadę i zapamiętać stan swojego własnego wątku w zmiennej nadrzędnej). Wtórnie, po przejęciu blokady i przywróceniu stanu wątku, blokada musi być przejęta przed zachowaniem wskaźnika stanu wątku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to note that when threads are created from C, they don't have the global interpreter lock, nor is there a thread state data structure for them.  Such threads must bootstrap themselves into existence, by first creating a thread state data structure, then acquiring the lock, and finally storing their thread state pointer, before they can start using the Python/C API.  When they are done, they should reset the thread state pointer, release the lock, and finally free their thread state data structure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Warto zauważyć, że gdy wątki są tworzone z C, nie mają nadrzędnej blokady, ani nie ma dla nich struktury danych stanu wątku. Takie wątki muszą wciągnąć się za przysłowiowe szelki do istnienia, najpierw tworząc strukturę danych stanu wątku, potem przejmując zatrzask, i w końcu zapamiętując wskaźnik na ich stan wątku, zanim będzie mógł być rozpoczęty przy użyciu sprzęgu programowania zrębem między językami pytonowskim i C (API). Gdy zostaną zakończone powinny zresetować wskaźnik stanu wątku, zwolnić zatrzask, i w końcu zwolnić ich pamięć przydzieloną strukturze danych stanu wątku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Threads can take advantage of the :cfunc:`PyGILState_\*` functions to do all of the above automatically.  The typical idiom for calling into Python from a C thread is now::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wątki mogą korzystać z zadań :cfunc:`PyGILState_\*` aby wykonywać powyższe zadania automatycznie. Typowym idiomem wzywającym zadania języka pytonowskiego z wątku w języku C jest teraz::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyGILState_STATE gstate; gstate = PyGILState_Ensure();  /* Perform Python actions here.  */ result = CallSomeFunction(); /* evaluate result */  /* Release the thread. No Python API allowed beyond this point. */ PyGILState_Release(gstate);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyGILState_STATE gstan; gstan = PyGILState_Ensure();  /* Wykonaj działania w języku pytonowskim tutaj.  */ wynik = WykonajPewneZadania(); /* oblicz wynik */  /* Zwolnij wątek. Żadne sprzęgi programowania języka pytonowskiego nie dozwolone po tym miejscu. */ PyGILState_Release(gstan);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the :cfunc:`PyGILState_\*` functions assume there is only one global interpreter (created automatically by :cfunc:`Py_Initialize`).  Python still supports the creation of additional interpreters (using :cfunc:`Py_NewInterpreter`), but mixing multiple interpreters and the :cfunc:`PyGILState_\*` API is unsupported.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Warto zauważyć, że :cfunc:`PyGILState_\*` zadania przyjmują że istnieje tylko jeden nadrzędny program interpretujący polecenia języka pytonowskiego (tworzony automatycznie przez :cfunc:`Py_Initialize`).  Język pytonowski wspiera uruchamianie dodatkowych programów interpretujących polecenia języka pytonowskiego (używając zadania :cfunc:`Py_NewInterpreter`), ale mieszanie kilku programów interpretujących polecenia języka pytonowskiego i sprzęgu programowania :cfunc:`PyGILState_\*` (API) nie jest wspierane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another important thing to note about threads is their behaviour in the face of the C :cfunc:`fork` call. On most systems with :cfunc:`fork`, after a process forks only the thread that issued the fork will exist. That also means any locks held by other threads will never be released. Python solves this for :func:`os.fork` by acquiring the locks it uses internally before the fork, and releasing them afterwards. In addition, it resets any :ref:`lock-objects` in the child. When extending or embedding Python, there is no way to inform Python of additional (non-Python) locks that need to be acquired before or reset after a fork. OS facilities such as :cfunc:`posix_atfork` would need to be used to accomplish the same thing. Additionally, when extending or embedding Python, calling :cfunc:`fork` directly rather than through :func:`os.fork` (and returning to or calling into Python) may result in a deadlock by one of Python's internal locks being held by a thread that is defunct after the fork. :cfunc:`PyOS_AfterFork` tries to reset the necessary locks, but is not always able to.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następną wartą zauważenia sprawą o wątkach jest ich zachowanie wobec napotkania wywołania zadania z języka C :cfunc:`fork`. W większości systemów z zadaniem :cfunc:`fork`, po tym jak proces dokonuje podziału tylko wątek, który wywoływał zadanie podziału wątku będzie istniał. To także oznacza, że dowolne inne blokady utrzymywane przez inne wątki nie zostaną nigdy zwolnione. Język pytonowski wprowadza rozwiązanie dla zadania :func:`os.fork` przez przejęcie blokad używanych wewnętrznie, przed rozwidleniem i zwolnienie ich po wszystkim. W dodatku resetuje wszystkie przedmioty-blokady - z ang. :ref:`lock-objects` w wątku potomnym. Przy rozszerzaniu lub zawieraniu programu interpretującego polecenia języka pytonowskiego w programie, nie istnieje żaden sposób, aby poinformować program interpretujący polecenia języka pytonowskiego o (niepochodzących z programu zapisanym w języku pytonowskim) blokadach które należy przejąć przed lub wyzerować po zakończeniu rozwidlenia wątków. Urządzenia systemu operacyjnego (OS) tkaie jak zadanie :cfunc:`posix_atfork` powinny służyć tym samym celom. Dodatkowo, przy rozszerzaniu lub załączaniu programu interpretującego polecenia języka pytonowskiego, wywoływanie zadania :cfunc:`fork` bezpośrednio zamiast przez :func:`os.fork` (i powracając do lub wywołując zadania z poziomu języka pytonowskiego) może skutkować zakleszczeniem jednej z wewnętrznych blokad programu interpretującego języka pytonowskiego utrzymywanych przez wątek, który został wyłączony po rozwidleniu. Zadanie :cfunc:`PyOS_AfterFork` próbuje rozwiązać odpowiednie blokady, choć nie zawsze jest w stanie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following macros are normally used without a trailing semicolon; look for example usage in the Python source distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące makropolecenia są za zwyczaj używane bez uwieńczania średnikiem; zobacz też przykładowe użycie w pakiecie źródłowym języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All of the following functions are only available when thread support is enabled at compile time, and must be called only when the global interpreter lock has been created.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie następujące zadania są dostępne tylko, gdy wspieranie wątków jest włączone w czasie kompilowania programu interpretującego język pytonowski, i mogą być użyte tylko po utworzeniu nadrzędnej blokady programu interpretującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous Notifications</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Powiadomienia Asynchroniczne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A mechanism is provided to make asynchronous notifications to the main interpreter thread.  These notifications take the form of a function pointer and a void argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Mechanizm dostarczany w celu wytwarzania niejednoczesnych powiadomień dla głównego wątku programu interpretującego polecenia języka pytonowskiego. Te powiadomienia mają postać wskaźnika na zadanie i pustego parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every check interval, when the global interpreter lock is released and reacquired, Python will also call any such provided functions.  This can be used for example by asynchronous IO handlers.  The notification can be scheduled from a worker thread and the actual call than made at the earliest convenience by the main thread where it has possession of the global interpreter lock and can perform any Python API calls.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W równych odstępach pomiędzy sprawdzeniami, gdy nadrzędna blokada programu interpretującego jest zwalniana i na powrót przechwytywana, program interpretujący język pytonowski wywołuje każde takie napotkane dostarczone mu zadanie. Może być to użyte na przykład przez niejednoczesne uchwyty wejścia/wyjścia. Powiadomienia mogą być planowane z wyprzedzeniem przez wątek roboczy i właściwe wywołanie potem wykonywane przy najbliższej okazji przez główny wątek który ma w posiadaniu główną blokadę programu interpretującego i może wykonywać dowolne wywołania sprzęgu programowania poleceń języka pytonowskiego (Python API).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Profiling and Tracing</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Profilowanie (badanie prędkości) i trasowanie (badanie przebiegów) programów języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python interpreter provides some low-level support for attaching profiling and execution tracing facilities.  These are used for profiling, debugging, and coverage analysis tools.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Program interpretujący dostarcza pewnych nisko-poziomowego wsparcia dla doczepiania urządzeń profilowania i badania przebiegów wykonania. Następujące używane są jak narzędzia badania prędkości, odpluskwiania i badania pokrycia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This C interface allows the profiling or tracing code to avoid the overhead of calling through Python-level callable objects, making a direct C function call instead.  The essential attributes of the facility have not changed; the interface allows trace functions to be installed per-thread, and the basic events reported to the trace function are the same as had been reported to the Python-level trace functions in previous versions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sprzęg języka C pozwala aby kod badający prędkość lub badający przebiegi unikał nadmiaru wywoływań przez rzeczy wywoływalne z poziomu języka Pytonowskiego, wykonując zamiast tego bezpośrednie wywołania zadań z języka C. Najważniejsze własności urządzenia nie zmieniły się; sprzęg pozwala zadaniom badającym przebiegi wykonania programu na doczepianie do poszczególnych wątków, a podstawowe zdarzenia raportowane do zadania badania przebiegów programu są takie same jakie były raportowane do zadań badających przebiegi wykonania programu w poprzednich wersjach. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced Debugger Support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla Rozwiniętego Odpluskwiacza</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These functions are only intended to be used by advanced debugging tools.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te zadania są przeznaczone tylko dla użycia przez narzędzia rozwiniętego odpluskwiacza.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wprowadzenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Application Programmer's Interface to Python gives C and C++ programmers access to the Python interpreter at a variety of levels.  The API is equally usable from C++, but for brevity it is generally referred to as the Python/C API.  There are two fundamentally different reasons for using the Python/C API. The first reason is to write *extension modules* for specific purposes; these are C modules that extend the Python interpreter.  This is probably the most common use.  The second reason is to use Python as a component in a larger application; this technique is generally referred to as :dfn:`embedding` Python in an application.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg programowania aplikacji w języku pytonowskim daje programistom języków C i C++ dostęp do programu interpretującego polecenia języka pytonowskiego na wielu poziomach. Sprzęg (API) jest równo użyteczny z poziomu C++ ale dla porządku jest zwykle określany mianem sprzęgu pomiędzy językami pytonowskim a C (z ang. - Python/C API). Istnieją dwie zasadniczo różne przyczyny dla użycia sprzęgu między językami pytonowskim i C. Pierwszą przyczyną jest pisanie *modułów rozszerzających* dla szczególnych powodów; są to moduły języka C, które rozszerzają program interpretujący języka pytonowskiego. To jest zwykle najczęstsze użycie. Drugą przyczyną jest użycie języka pytonowskiego jako komponentu większego programu; ta technika jest zwykle określana mianem załączania - z ang. - :dfn:`embedding` w aplikacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing an extension module is a relatively well-understood process,  where a "cookbook" approach works well.  There are several tools  that automate the process to some extent.  While people have embedded  Python in other applications since its early existence, the process of  embedding Python is less straightforward than writing an extension.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pisanie rozszerzającego modułu jest względnie dobrze zrozumiałym procesem, gdzie podejście "książki kucharskiej" działa dobrze. Istnieje kilka narzędzi które automatyzują proces do pewnego stopnia. Chociaż załączano program interpretujący język pytonowski od wczesnych lat jego istnienia, jednak proces załączania programu interpretującego język pytonowski jest mniej prosty niż pisanie rozszerzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many API functions are useful independent of whether you're embedding  or extending Python; moreover, most applications that embed Python  will need to provide a custom extension as well, so it's probably a  good idea to become familiar with writing an extension before  attempting to embed Python in a real application.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wiele zadań sprzęgu (API) jest użytecznych niezależnie od tego czy załączasz, czy też rozszerzasz program interpretujący język pytonowski; co więcej, większość aplikacji które załącza program interpretujący polecenia jezyka pytonowskiego potrzebuje także szczególnych rozszerzeń, więc prawdopodobnie jest dobrym pomysłem zaznajomienie się z pisaniem rozszerzenia przed próbą załączenia języka pytonowskiego w prawdziwej aplikacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Include Files</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pliki Włączania - z ang. Include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All function, type and macro definitions needed to use the Python/C API are included in your code by the following line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie zadania, definicje typu i makropoleceń konieczne do użycia sprzęgu między językami pytonowskim i C są włączane do źródeł w kodzie użytkownika przez następującą linijkę::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "Python.h"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include "Python.h"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This implies inclusion of the following standard headers: ``&lt;stdio.h&gt;``, ``&lt;string.h&gt;``, ``&lt;errno.h&gt;``, ``&lt;limits.h&gt;``, and ``&lt;stdlib.h&gt;`` (if available).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To oznacza włączenie następujących typowych plików nagłówkowych: ``&lt;stdio.h&gt;``, ``&lt;string.h&gt;``, ``&lt;errno.h&gt;``, ``&lt;limits.h&gt;``, i ``&lt;stdlib.h&gt;`` (jeśli są dostępne).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since Python may define some pre-processor definitions which affect the standard headers on some systems, you *must* include :file:`Python.h` before any standard headers are included.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odkąd język pytonowski może definiować pewne definicje preprocesora, które wpływają na pliki nagłówkowe na niektórych systemach, *musisz* załączyć plik :file:`Python.h` zanim jakiekolwiek standardowe nagłówki zostaną załączone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All user visible names defined by Python.h (except those defined by the included standard headers) have one of the prefixes ``Py`` or ``_Py``.  Names beginning with ``_Py`` are for internal use by the Python implementation and should not be used by extension writers. Structure member names do not have a reserved prefix.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie widoczne dla użytkownika nazwy określone w Python.h ( z wyjątkiem tych określonych przez załączone standardowe pliki nagłówkowe ) mają jeden z przedrostków ``Py`` lub ``_Py``. Nazwy rozpoczynające się od ``_Py`` służą do wewnętrznego użytku przez urzeczywistnienie programu interpretującego języka pytonowskiego i nie powinno być używane przez piszących rozszerzenia. Nazwy członków struktury nie mają zarezerwowanych przedrostków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** user code should never define names that begin with ``Py`` or ``_Py``.  This confuses the reader, and jeopardizes the portability of the user code to future Python versions, which may define additional names beginning with one of these prefixes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Istotne:** Kod użytkownika nie powinien nigdy określać nazw które zaczynają się od ``Py`` lub ``_Py``. Wprowadza to zamieszanie dla czytających kod, i utrudnia przenośność kodu użytkownika do przyszłych wersji języka pytonowskiego, które mogą definiować dodatkowe nazwy rozpoczynające się jednym z tych przedrostków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The header files are typically installed with Python.  On Unix, these  are located in the directories :file:`{prefix}/include/pythonversion/` and :file:`{exec_prefix}/include/pythonversion/`, where :envvar:`prefix` and :envvar:`exec_prefix` are defined by the corresponding parameters to Python's :program:`configure` script and *version* is ``sys.version[:3]``.  On Windows, the headers are installed in :file:`{prefix}/include`, where :envvar:`prefix` is the installation directory specified to the installer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pliki nagłówkowe są zazwyczaj instalowane z językiem pytonowskim. Na Uniksie, są one umieszczone w katalogach :plik:`{przedrostek}/include/pythonawersja/` i :plik:`{exec_prefix}/include/pythonwersja` gdzie :envvar:`prefix` są zdefiniowane przez korespondujące parametry dla skryptu :program:`configure` konfigurującego program interpretujący języka pytonowskiego i *wersja* jest ``sys.version[:3]``. W Windows, nagłówki są instalowane w katalogu :file:`{przedrostek}/include`, gdzie :envvar:`przedrostek` jest katalog instalacyjny określony w procesie instalacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include the headers, place both directories (if different) on your compiler's search path for includes.  Do *not* place the parent directories on the search path and then use ``#include &lt;pythonX.Y/Python.h&gt;``; this will break on multi-platform builds since the platform independent headers under :envvar:`prefix` include the platform specific headers from :envvar:`exec_prefix`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby załączyć pliki nagłówkowe, umieść oba katalogi (jeśli są różne) na liście przeszukiwanych ścieżek poszukiwania plików nagłówkowych. *Nie* umieszczaj katalogów nadrzędnych na ścieżkach poszukiwania plików nagłówkowych po czym wpisując ``#include &lt;pythonX.Y/Python.h&gt;``; To spowoduje przerwanie na realizacjach wieloplatformowych gdyż niezależne od platformy nagłówki dostępne w katalogu :envvar:`przedrostek` zawiera pliki nagłówkowe szczególne dla pewnych platform z katalogu :envvar:`exec_prefix`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C++ users should note that though the API is defined entirely using C, the header files do properly declare the entry points to be ``extern "C"``, so there is no need to do anything special to use the API from C++.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użytkownicy C++ powinni wziąć pod uwagę, że chociaż sprzęg programowania jest dostępny w całości przy użyciu C, pliki nagłówkowe prawidłowo deklarują punkty wejściowe aby następowały ``extern "C"``, tak że nie ma potrzeby robić nic więcej szczególnego aby używać sprzęgu z poziomu języka C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects, Types and Reference Counts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty, ich Rodzaje i Liczby Odwołań</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most Python/C API functions have one or more arguments as well as a return value of type :ctype:`PyObject\*`.  This type is a pointer to an opaque data type representing an arbitrary Python object.  Since all Python object types are treated the same way by the Python language in most situations (e.g., assignments, scope rules, and argument passing), it is only fitting that they should be represented by a single C type.  Almost all Python objects live on the heap: you never declare an automatic or static variable of type :ctype:`PyObject`, only pointer variables of type :ctype:`PyObject\*` can  be declared.  The sole exception are the type objects; since these must never be deallocated, they are typically static :ctype:`PyTypeObject` objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość zadań sprzęgu między językami pytonowskim i C ( z ang. Python/C API) ma jeden lub więcej parametrów zarówno jak wartość zwracaną typu :ctype:`PyObject\*`. Ten rodzaj jest wskaźnikiem na przezroczysty rodzaj danych reprezentujący konkretne przedmioty języka pytonowskiego. Od kiedy wszystkie rodzaje przedmiotów w języku pytonowskim są traktowane tak samo przez język pytonowski w większości sytuacji (np. przypisania, prawa pierwszeństwa nawiasów i przekazywania parametrów), jest zatem zrozumiałe, że powinny być reprezentowane przez jeden rodzaj przedmiotu w języku C. Prawie wszystkie przedmioty języka pytonowskiego wiodą swój żywot na stercie: nigdy nie deklaruje się automatycznych ani statycznych zmiennych rodzaju :ctype:`PyObject`, tylko zmienne wskaźnikowe o rodzaju :ctype:`PyObject\*` mogą być deklarowane. Jedynym wyjątkiem od tej reguły są przedmioty określające rodzaj przedmiotu; ponieważ nigdy nie mogą być one zdjęte, są one zwykle przedmiotami statycznymi :ctype:`PyTypeObject`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Python objects (even Python integers) have a :dfn:`type` and a :dfn:`reference count`.  An object's type determines what kind of object it is (e.g., an integer, a list, or a user-defined function; there are many more as explained in :ref:`types`).  For each of the well-known types there is a macro to check whether an object is of that type; for instance, ``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is a Python list.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie przedmioty języka pytonowskiego (nawet liczby całkowite języka pytonowskiego) mają :dfn:`rodzaj` i :dfn:`liczbę odniesień`. Typ przedmiotu określa jakiego rodzaju przedmiot to jest (np. liczba całkowita, lista, lub zadanie zdefiniowane przez użytkownika; jest wiele więcej jak wyjaśniono w :ref:`types`). Dla każdego z dobrze-znanych rodzajów istnieje makropolecenie sprawdzające czy przedmiot jest tego rodzaju; na przykład, ``PyList_Check(a)`` jest prawdziwe wtedy (i tylko wtedy) gdy przedmiot na który wskazuje *a* jest lista z języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference Counts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczby odniesień</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reference count is important because today's computers have a  finite (and often severely limited) memory size; it counts how many  different places there are that have a reference to an object.  Such a  place could be another object, or a global (or static) C variable, or  a local variable in some C function. When an object's reference count  becomes zero, the object is deallocated.  If it contains references to  other objects, their reference count is decremented. Those other  objects may be deallocated in turn, if this decrement makes their reference count become zero, and so on.  (There's an obvious problem  with objects that reference each other here; for now, the solution is  "don't do that.")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczba odniesień jest istotna, gdyż dzisiejsze komputery mają skończony (i zwykle poważnie ograniczony) rozmiar pamięci; liczy ona jak wiele różnych miejsc istnieje, które przechowują odniesienie do przedmiotu. Takie miejsce może być innym przedmiotem, zmienną C nadrzędnego poziomu (lub statyczną), lub lokalną zmienną w jakimś zadaniu języka C. Gdy liczba odniesień do przedmiotu staje się równa zero, przedmiot jest zdejmowany z pamięci. Jeśli zawiera odniesienia do innych przedmiotów liczba odniesień do nich jest obniżana po jednym dla każdego. Te inne przedmioty mogą być zdejmowane z pamięci w konsekwencji, jeśli obniżenie liczby odniesień do nich spowoduje że liczba odniesień stanie się równa zero, itd. (Istnieje dość oczywisty problem z przedmiotami które wzajemnie się odnoszą do siebie; na razie rozwiązaniem jest "proszę tak nie robić.")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference counts are always manipulated explicitly.  The normal way is  to use the macro :cfunc:`Py_INCREF` to increment an object's reference count by one, and :cfunc:`Py_DECREF` to decrement it by   one.  The :cfunc:`Py_DECREF` macro is considerably more complex than the incref one, since it must check whether the reference count becomes zero and then cause the object's deallocator to be called. The deallocator is a function pointer contained in the object's type structure.  The type-specific deallocator takes care of decrementing the reference counts for other objects contained in the object if this is a compound object type, such as a list, as well as performing any additional finalization that's needed.  There's no chance that the reference count can overflow; at least as many bits are used to hold the reference count as there are distinct memory locations in virtual memory (assuming ``sizeof(Py_ssize_t) &gt;= sizeof(void*)``). Thus, the reference count increment is a simple operation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczby odniesień są zawsze zmieniane jawnie. Zwykłym sposobem jest użycie makropolecenia :cfunc:`Py_INCREF` aby zwiększyć liczbę odniesień dla przedmiotu o jeden, i makropolecenie :cfunc:`Py_DECREF` aby zmniejszyć ją o jeden. Makropolecenie :cfunc:`Py_DECREF` jest z konieczności bardziej złożone niż to zwiększające o nazwie incref, gdyż musi sprawdzać czy liczba odniesień staje się równa zero i dopiero wtedy powodować wezwanie zdjęcia przedmiotu z pamięci. Zadanie zdejmujące jest wskaźnikiem na zadanie zawarte w strukturze typu przedmiotu. Szczególne dla każdego rodzaju zadanie zajmuje się zmniejszeniem liczby odniesień dla innych przedmiotów zawartych w przedmiocie, jeśli jest to przedmiot o złożonym rodzaju, takim jak lista, zarówno jak wykonując dowolne dodatkowe zakańczanie jeśli jest to konieczne. Nie ma możliwości aby liczba odniesień uległa przepełnieniu; przynajmniej tak wiele bitów użyto do przechowywania liczby odniesień, jak wiele jest różnych miejsc w pamięci w pamięci wirtualnej (zakładając ``sizeof(Py_ssize_t) &gt;= sizeof(void*)``). Zatem zwiększenie liczby odniesień jest prostą operacją.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not necessary to increment an object's reference count for every  local variable that contains a pointer to an object.  In theory, the  object's reference count goes up by one when the variable is made to  point to it and it goes down by one when the variable goes out of  scope.  However, these two cancel each other out, so at the end the  reference count hasn't changed.  The only real reason to use the  reference count is to prevent the object from being deallocated as  long as our variable is pointing to it.  If we know that there is at  least one other reference to the object that lives at least as long as our variable, there is no need to increment the reference count  temporarily. An important situation where this arises is in objects  that are passed as arguments to C functions in an extension module  that are called from Python; the call mechanism guarantees to hold a  reference to every argument for the duration of the call.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie jest konieczne zwiększanie zwiększanie liczby odniesień do przedmiotu dla każdej lokalnej zmiennej która zawiera wskaźnik na przedmiot. Teoretycznie, liczba odniesień do przedmiotu zwiększa się o jeden gdy zmienna jest zmuszana do wskazywania nań i jest zmniejszana o jeden gdy zmienna wychodzi z widoku. Jednakże te dwa działania wykluczają się nawzajem, więc ostatecznie liczba odniesień nie ulega zmianie. Jedynym prawdziwym powodem użycia liczby odniesień jest aby uniemożliwić zdjęcie z pamięci przedmiotu tak długo jak nasza zmienna nań wskazuje. Jeśli wiemy, że istnieje przynajmniej jedno inne odniesienie do przedmiotu, które żyje tak długo jak nasza zmienna, nie ma potrzeby zwiększania liczby odniesień tymczasowo. Istotną sytuacją gdzie to się pojawia jest w obiektach które są przekazywane jako parametry do zadań C w modułach rozszerzających które są wywoływane przez polecenia języka pytonowskiego; mechanizm wywołania gwarantuje przytrzymanie odniesienia do każdego parametru na czas wywołania zadania z tym parametrem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, a common pitfall is to extract an object from a list and hold on to it for a while without incrementing its reference count. Some other operation might conceivably remove the object from the list, decrementing its reference count and possible deallocating it. The real danger is that innocent-looking operations may invoke arbitrary Python code which could do this; there is a code path which allows control to flow back to the user from a :cfunc:`Py_DECREF`, so almost any operation is potentially dangerous.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednakże typową pułapką jest wyjęcie przedmiotu z listy i przetrzymanie go przez pewien czas bez zwiększenia liczby odniesień. Jakaś inna operacja może wyobrażalnie usunąć ten przedmiot z listy, zmniejszając liczbę odniesień do niego. Prawdziwym niebezpieczeństwem jest to, że niewinnie-wyglądające operacje mogą wywoływać dowolny kod w języku pytonowskim który może tego dokonać; istnieje ścieżka kodowa która pozwala aby przebieg wykonania został zwrócony do użytkownika z makropolecenia :cfunc:`Py_DECREF`, tak że prawie każda operacja jest potencjalnie niebezpieczna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A safe approach is to always use the generic operations (functions  whose name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or ``PyMapping_``). These operations always increment the reference count of the object they return. This leaves the caller with the responsibility to call :cfunc:`Py_DECREF` when they are done with the result; this soon becomes second nature.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bezpiecznym podejściem jest zawsze używać operacji podstawowych (zadań których nazwy zaczynają się ``PyObject_``, ``PyNumber_``, ``PySequence_`` lub ``PyMapping_``). Te operacje zawsze zwiększają o jeden liczbę odniesień przedmiotu który zwracają. To pozostawia wołającego obarczonego odpowiedzialnością za wywołanie :cfunc:`Py_DECREF` gdy już skończy działać na wyniku; można się do tego przyzwyczaić.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference Count Details</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Szczegóły Liczby Odniesień</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reference count behavior of functions in the Python/C API is best  explained in terms of *ownership of references*.  Ownership pertains to references, never to objects (objects are not owned: they are always shared).  "Owning a reference" means being responsible for calling Py_DECREF on it when the reference is no longer needed.  Ownership can also be transferred, meaning that the code that receives ownership of the reference then becomes responsible for eventually decref'ing it by calling :cfunc:`Py_DECREF` or :cfunc:`Py_XDECREF` when it's no longer needed---or passing on this responsibility (usually to its caller). When a function passes ownership of a reference on to its caller, the caller is said to receive a *new* reference.  When no ownership is transferred, the caller is said to *borrow* the reference. Nothing needs to be done for a borrowed reference.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zachowanie liczby odniesień w zadaniach sprzęgu między językami pytonowskim i języku C najlepiej wyjaśniać w kategoriach *właściciela odniesień*. Własność dotyczy odniesień, nigdy przedmiotów (przedmioty nie mają posiadacza: zamiast tego są współdzielone). "Posiadanie odniesienia" oznacza bycie odpowiedzialnym za wezwanie Py_DECREF na nim gdy odniesienie nie jest już więcej potrzebne. Akt własności może być przekazywany, co oznacza że kod który otrzymuje odniesienie na własność staje się odpowiedzialny za ostateczne jego "zdecrefowanie" przez wywołanie :cfunc:`Py_DECREF` lub :cfunc:`Py_XDECREF`gdy nie jest już więcej potrzebne --- lub przekazanie tej odpowiedzialności (zwykle swojemu wywołującemu). Gdy zadanie przekaże własność odniesienia do swojego wywołującego to zadanie, o wołającym mówi się, że otrzymał *nowe* odniesienie. Gdy żadna własność nie jest przenoszona, o wywołującym mówi się że *pożycza* odniesienie. Nic nie jest wymagane do zrobienia dla pożyczonego odniesienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversely, when a calling function passes in a reference to an  object, there are two possibilities: the function *steals* a  reference to the object, or it does not.  *Stealing a reference* means that when you pass a reference to a function, that function assumes that it now owns that reference, and you are not responsible for it any longer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Idąc dalej, gdy wywołujące zadanie przekazuje odniesienie do przedmiotu, istnieją dwie możliwości: zadanie *kradnie* odniesienie do przedmiotu, lub nie kradnie go. *Kradnięcie odniesienia* oznacza, że gdy przekazujesz odniesienie do zadania, to zadanie przyjmuje, że teraz ono posiada odniesienie i nie jesteś za nie odpowiedzialny ani chwili dłużej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Few functions steal references; the two notable exceptions are :cfunc:`PyList_SetItem` and :cfunc:`PyTuple_SetItem`, which  steal a reference to the item (but not to the tuple or list into which the item is put!).  These functions were designed to steal a reference because of a common idiom for populating a tuple or list with newly created objects; for example, the code to create the tuple ``(1, 2, "three")`` could look like this (forgetting about error handling for the moment; a better way to code this is shown below)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niewiele zadań kradnie referencje; dwoma szczególnymi wyjątkami są :cfunc:`PyList_SetItem` i :cfunc:`PyTuple_SetItem`, które kradną odniesienie do przedmiotu (ale nie do krotki czy listy do których przedmiot jest wkładany!). Te zadania zostały zaprojektowane tak, aby kraść odniesienie z powodu wspólnego idiomu dla zapełnienia krotki czy listy nowo utworzonymi przedmiotami; na przykład, kod do tworzenia krotki ``(1,2, "trzy")`` mógłby wyglądać następująco (pomijając błąd obsługę błędów tymczasowo; lepszy sposób na zakodowanie tego pokazany jest poniżej)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *t;  t = PyTuple_New(3); PyTuple_SetItem(t, 0, PyLong_FromLong(1L)); PyTuple_SetItem(t, 1, PyLong_FromLong(2L)); PyTuple_SetItem(t, 2, PyString_FromString("three"));</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *t;  t = PyTuple_New(3); PyTuple_SetItem(t, 0, PyLong_FromLong(1L)); PyTuple_SetItem(t, 1, PyLong_FromLong(2L)); PyTuple_SetItem(t, 2, PyString_FromString("three"));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here, :cfunc:`PyLong_FromLong` returns a new reference which is immediately stolen by :cfunc:`PyTuple_SetItem`.  When you want to keep using an object although the reference to it will be stolen, use :cfunc:`Py_INCREF` to grab another reference before calling the reference-stealing function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tutaj, :cfunc:`PyLong_FromLong` zwraca nowe odniesienie, które jest natychmiast kradzione przez zadanie :cfunc:`PyTuple_SetItem`. Gdy chcesz nadal używać przedmiotu pomimo tego, że odniesienie do niego zostanie skradzione, używaj makropolecenia :cfunc:`Py_INCREF` aby schwycić jeszcze jedno odniesienie przed wywołaniem kradnącego-odniesienia zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incidentally, :cfunc:`PyTuple_SetItem` is the *only* way to set tuple items; :cfunc:`PySequence_SetItem` and :cfunc:`PyObject_SetItem` refuse to do this since tuples are an immutable data type.  You should only use :cfunc:`PyTuple_SetItem` for tuples that you are creating yourself.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przypadkowo zadanie :cfunc:`PyTuple_SetItem` jest *jedynym* sposobem aby ustawiać elementy krotek; Zadania :cfunc:`PySequence_SetItem` i :cfunc:`PyObject_SetItem` odmawiają wykonania tego samego działania gdyż krotki są niezmiennym rodzajem danych. Powinieneś używać tylko :cfunc:`PyTuple_SetItem` dla krotek, które tworzysz własnoręcznie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Equivalent code for populating a list can be written using :cfunc:`PyList_New` and :cfunc:`PyList_SetItem`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Równoważny kod dla zapełnienia listy można napisać używając: zadań :cfunc:`PyList_New` i :cfunc:`PyList_SetItem`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, in practice, you will rarely use these ways of creating and populating a tuple or list.  There's a generic function, :cfunc:`Py_BuildValue`, that can create most common objects from C values, directed by a :dfn:`format string`. For example, the above two blocks of code could be replaced by the following (which also takes care of the error checking)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednakże, w praktyce, rzadko używa się tych sposobów tworzenia i zapełniania krotek czy list. Istnieje funkcja prosta :cfunc:`Py_BuildValue`, która może tworzyć większość typowych przedmiotów z wartości zapisanych w języku C, określona przez :dfn:`ciąg formatu`. Na przykład, powyższe dwa fragmenty kodu mogłyby być zastąpione przez następujący (który także zajmuje się sprawdzaniem błędów)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *tuple, *list;  tuple = Py_BuildValue("(iis)", 1, 2, "three"); list = Py_BuildValue("[iis]", 1, 2, "three");</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *krotka, *lista;  krotka = Py_BuildValue("(iis)", 1, 2, "trzy"); lista = Py_BuildValue("[iis]", 1, 2, "trzy");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is much more common to use :cfunc:`PyObject_SetItem` and friends with items whose references you are only borrowing, like arguments that were passed in to the function you are writing.  In that case, their behaviour regarding reference counts is much saner, since you don't have to increment a reference count so you can give a reference away ("have it be stolen").  For example, this function sets all items of a list (actually, any mutable sequence) to a given item::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dużo częściej spotyka się użycie zadania :cfunc:`PyObject_SetItem` i zaprzyjaźnionych z elementami których odniesienia tylko się pożycza, jak parametrów, które zostały przekazane do funkcji którą piszesz. W takim przypadku, ich zachowanie w stosunku do liczb odniesień jest dużo zdrowsze, gdyż nie musisz zwiększać liczby odniesień, kiedy chcesz oddać odniesienie ("pozwolić aby zostało ukradzione"). Na przykład, to zadanie ustawia wszystkie elementy listy (właściwie dowolnej zmiennej sekwencji) na dany element::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int set_all(PyObject *target, PyObject *item) {     int i, n;      n = PyObject_Length(target);     if (n &lt; 0)         return -1;     for (i = 0; i &lt; n; i++) {         PyObject *index = PyLong_FromLong(i);         if (!index)             return -1;         if (PyObject_SetItem(target, index, item) &lt; 0)             return -1;         Py_DECREF(index);     }     return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int ustaw_wszystkie(PyObject *cel, PyObject *element) {     int i, n;      n = PyObject_Length(cel);     if (n &lt; 0)         return -1;     for (i = 0; i &lt; n; i++) {         PyObject *nr = PyLong_FromLong(i);         if (!nr)             return -1;         if (PyObject_SetItem(cel, nr, element) &lt; 0)             return -1;         Py_DECREF(nr);     }     return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The situation is slightly different for function return values.   While passing a reference to most functions does not change your  ownership responsibilities for that reference, many functions that  return a reference to an object give you ownership of the reference. The reason is simple: in many cases, the returned object is created  on the fly, and the reference you get is the only reference to the  object.  Therefore, the generic functions that return object references, like :cfunc:`PyObject_GetItem` and  :cfunc:`PySequence_GetItem`, always return a new reference (the caller becomes the owner of the reference).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sytuacja jest trochę inna dla wartości zwracanych z zadania. Podczas gdy przekazywanie odniesienia do większości zadań nie zmienia twojego odpowiedzialności właścicielskiej za to odniesienie, wiele zadań, które zwracają odniesienie do przedmiotu daje też odniesienie do tego przedmiotu na własność. Powód jest prosty: w wielu przypadkach przedmiot zwracany tworzony jest w locie i odniesienie które dostajesz jest jedynym odniesieniem do tego obiektu. Zatem proste zadania które zwracają odniesienia do przedmiotów, jak :cfunc:`PyObject_GetItem` i :cfunc:`PySequence_GetItem`, zawsze zwracają nowe odniesienia (wywoływujący zadanie staje się właścicielem odniesienia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to realize that whether you own a reference returned  by a function depends on which function you call only --- *the plumage* (the type of the object passed as an argument to the function) *doesn't enter into it!* Thus, if you  extract an item from a list using :cfunc:`PyList_GetItem`, you don't own the reference --- but if you obtain the same item from the same list using :cfunc:`PySequence_GetItem` (which happens to take exactly the same arguments), you do own a reference to the returned object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest istotne zdać sobie sprawę, że to, czy posiadasz odniesienie zwrócone przez zadanie, zależy tylko od tego, które zadanie wywołasz --- *pakuły* (przedmioty przekazywane jako parametry zadania) *nie odnoszą się do tego!* Zatem, jeśli wyjmiesz element z listy używając :cfunc:`PyList_GetItem`, nie posiądziesz odniesienia --- ale jeśli otrzymasz ten sam element z tej samej listy korzystając z :cfunc:`PySequence_GetItem` (które przyjmuje dokładnie te same parametry), posiadasz odniesienie do zwróconego przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of how you could write a function that computes the sum of the items in a list of integers; once using  :cfunc:`PyList_GetItem`, and once using :cfunc:`PySequence_GetItem`. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tutaj jest przykład tego, jak można zapisać zadanie, które oblicza sumę wszystkich elementów na liście liczb całkowitych; raz przy użyciu :cfunc:`PyList_GetItem`, a raz przy użyciu :cfunc:`PySequence_GetItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>long sum_list(PyObject *list) {     int i, n;     long total = 0;     PyObject *item;      n = PyList_Size(list);     if (n &lt; 0)         return -1; /* Not a list */     for (i = 0; i &lt; n; i++) {         item = PyList_GetItem(list, i); /* Can't fail */         if (!PyLong_Check(item)) continue; /* Skip non-integers */         total += PyLong_AsLong(item);     }     return total; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>long sumuj_liste(PyObject *lista) {     int i, n;     long suma = 0;     PyObject *element;      n = PyList_Size(lista);     if (n &lt; 0)         return -1; /* To nie lista */     for (i = 0; i &lt; n; i++) {         element = PyList_GetItem(lista, i); /* Nie może zawieźć */         if (!PyLong_Check(element)) continue; /* Pomiń nie będące całkowitymi liczbami */         suma += PyLong_AsLong(element);     }     return suma; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>long sum_sequence(PyObject *sequence) {     int i, n;     long total = 0;     PyObject *item;     n = PySequence_Length(sequence);     if (n &lt; 0)         return -1; /* Has no length */     for (i = 0; i &lt; n; i++) {         item = PySequence_GetItem(sequence, i);         if (item == NULL)             return -1; /* Not a sequence, or other failure */         if (PyLong_Check(item))             total += PyLong_AsLong(item);         Py_DECREF(item); /* Discard reference ownership */     }     return total; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>long sumuj_sekwencje(PyObject *sekwencja) {     int i, n;     long suma = 0;     PyObject *element;     n = PySequence_Length(sekwencja);     if (n &lt; 0)         return -1; /* Nie ma długości */     for (i = 0; i &lt; n; i++) {         element = PySequence_GetItem(sekwencja, i);         if (element == NULL)             return -1; /* To nie sekwencja, lub inny błąd */         if (PyLong_Check(element))             suma += PyLong_AsLong(element);         Py_DECREF(element); /* Odrzuć własność odniesień */     }     return suma; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Types</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Typy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are few other data types that play a significant role in  the Python/C API; most are simple C types such as :ctype:`int`,  :ctype:`long`, :ctype:`double` and :ctype:`char\*`.  A few structure types  are used to describe static tables used to list the functions exported  by a module or the data attributes of a new object type, and another is used to describe the value of a complex number.  These will  be discussed together with the functions that use them.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje kilka innych typów danych które pełnią ważną rolę w sprzęgu pomiędzy językami pytonowskim i C (API); większość jest prostymi typami języka C takimi jak :ctype:`int`, :ctype:`long`, :ctype:`double`, :ctype`char\*`. Kilka typów struktur jest używanych do opisania statycznych tabel używanych do wypisywania zadań wystawianych na zewnątrz modułu lub własności danych nowych rodzajów przedmiotów, a inne używane są do opisania wartości liczby zespolonej. Te będą opisane razem z zadaniami, które ich używają.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exceptions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sytuacje Wyjątkowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python programmer only needs to deal with exceptions if specific  error handling is required; unhandled exceptions are automatically  propagated to the caller, then to the caller's caller, and so on, until they reach the top-level interpreter, where they are reported to the  user accompanied by a stack traceback.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Programujący komputer w języku pytonowskim musi sobie zaprzątać głowę tylko sytuacjami wyjątkowymi tylko jeśli szczególna obsługa błędów jest konieczna; Nieobsłużone wyjątki są automatycznie przesyłane do zadania wywołującego, potem do zadania które wywołało tamto zadanie, i tak dalej, dopóki nie natrafi na program interpretujący najwyższego poziomu, gdzie są przekazywane użytkownikowi wraz z wypisem kolejnych wywołań odłożonych na stercie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For C programmers, however, error checking always has to be explicit.   All functions in the Python/C API can raise exceptions, unless an  explicit claim is made otherwise in a function's documentation.  In  general, when a function encounters an error, it sets an exception,  discards any object references that it owns, and returns an  error indicator --- usually *NULL* or ``-1``.  A few functions  return a Boolean true/false result, with false indicating an error. Very few functions return no explicit error indicator or have an  ambiguous return value, and require explicit testing for errors with :cfunc:`PyErr_Occurred`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla programujących w języku C, jednakże, sprawdzanie błędów, zawsze musi być jawne. Wszystkie zadania w sprzęgu między językami pytonowskim a C mogą zgłaszać sytuacje wyjątkowe, chyba że jawne założenie zostało poczynione o innym brzmieniu w dokumentacji zadania. Zasadniczo jeśli zadanie napotka błąd, ustawia sytuację wyjątkową, odrzuca wszystkie odniesienia do przedmiotów które posiada i zwraca wskaźnik błędu --- zwykle *NULL* lub ``-1``. Kilka zadań zwraca prawdę/fałsz jako wynik, z fałszem wskazującym błąd. Bardzo mało zadań nie zwraca żadnych jawnych wskazań błędu, czy ma dwuznaczną wartość zwracaną i wymaga jawnego sprawdzenia błędów przy użyciu :cfunc:`PyErr_Occurred`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception state is maintained in per-thread storage (this is  equivalent to using global storage in an unthreaded application).  A  thread can be in one of two states: an exception has occurred, or not. The function :cfunc:`PyErr_Occurred` can be used to check for this: it returns a borrowed reference to the exception type object when an exception has occurred, and *NULL* otherwise.  There are a number of functions to set the exception state: :cfunc:`PyErr_SetString` is the most common (though not the most general) function to set the exception state, and :cfunc:`PyErr_Clear` clears the exception state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stan wyjątku jest utrzymywany w przestrzeni przydzielonej wątkowi (jest to równoważne użyciu nadrzędnego miejsca przechowania w programie pozbawionym wątków). Wątek może być w jednym z dwu stanów: gdy wyjątek nastąpił, lub nie. Zadanie :cfunc:`PyErr_Occurred` może być użyty aby to sprawdzić: zwraca on pożyczone odniesienie do przedmiotu rodzaju błędu gdy sytuacja wyjątkowa nastąpiła, i *NULL* w przeciwnym razie. Istnieje parę zadań ustawiających stan wyjątku: :cfunc:`PyErr_SetString` jest najczęstszym (chociaż nie najogólniejszym) zadaniem ustalającym stan wyjątku, a zadanie :cfunc:`PyErr_Clear` czyści stan wyjątku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full exception state consists of three objects (all of which can  be *NULL*): the exception type, the corresponding exception  value, and the traceback.  These have the same meanings as the Python result of ``sys.exc_info()``; however, they are not the same: the Python objects represent the last exception being handled by a Python  :keyword:`try` ... :keyword:`except` statement, while the C level exception state only exists while an exception is being passed on between C functions until it reaches the Python bytecode interpreter's  main loop, which takes care of transferring it to ``sys.exc_info()`` and friends.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pełen stan wyjątku obejmuje trzy przedmioty (z których wszystkie mogą być *NULL*): rodzaj wyjątku, odpowiadająca mu wartość wyjątku, i przebieg wykonania. Te mają te same znaczenia, jak wynik wywołania ``sys.exc_info()``; jednakże nie są one tożsame: przedmioty języka pytonowskiego reprezentują ostatni wyjątek obsłużone przez wyrażenie języka pytonowskiego :keyword:`try` ... :keyword:`except`, podczas gdy stan wyjątku poziomu języka C istnieje tylko podczas przekazywania wyjątku pomiędzy zadaniami języka C dopóki nie natrafi na kod kęsowy głównej pętli programu interpretującego polecenia języka pytonowskiego, który zajmuje się przenoszeniem wyjątku do ``sys.exc_info()`` i zaprzyjaźnionych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that starting with Python 1.5, the preferred, thread-safe way to access the exception state from Python code is to call the function :func:`sys.exc_info`, which returns the per-thread exception state for Python code.  Also, the semantics of both ways to access the exception state have changed so that a function which catches an exception will save and restore its thread's exception state so as to preserve the exception state of its caller.  This prevents common bugs in exception handling code caused by an innocent-looking function overwriting the exception being handled; it also reduces the often unwanted lifetime extension for objects that are referenced by the stack frames in the traceback.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że poczynając od języka pytonowskiego w wersji 1.5 preferowaną, bezpiecznym dla wątków sposobem na dostęp do stanu wyjątku z poziomu kodu napisanego w języku pytonowskim jest wezwanie zadania :func:`sys.exc_info`, które zwraca określony-dla-wątku stan wyjątku dla kodu napisanego w języku pytonowskim. Poza tym składnia obu sposobów na dostęp do stanu sytuacji wyjątkowej zmieniła się tak, że zadanie które złapie wyjątek zachowa i przywróci swój stan wyjątku tak, aby zachować stan wyjątku wywołujacego zadanie. To działanie zapobiega typowym błędom w obsłudze sytuacji wyjątkowych powodowanych przez niewinnie-wyglądające zadania nadpisujące sytuacje wyjątkowe które aktualnie są obsługiwane; to także redukuje często niechciane wydłużanie czasu życia przedmiotów do których odnosi się ramka stosu w wypisie śladu wywołań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a general principle, a function that calls another function to  perform some task should check whether the called function raised an  exception, and if so, pass the exception state on to its caller.  It  should discard any object references that it owns, and return an  error indicator, but it should *not* set another exception --- that would overwrite the exception that was just raised, and lose important information about the exact cause of the error.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jako nadrzędną zasadę, przyjmuje się że zadanie które wywołuje inne zadanie do wykonania pewnych operacji powinno sprawdzić czy wywołane zadanie zgłosiło wyjątek, a jeśli tak, to przekazać stan wyjątku do wywołującego. Powinno też odrzucić jakiekolwiek odniesienia do przedmiotów, które posiada, i zwrócić sygnalizator błędu, ale nie powinno ustawiać innego wyjątku --- który nadpisywałby wyjątek, który właśnie został zgłoszony i tracić istotne informacje o dokładnym powodzie błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simple example of detecting exceptions and passing them on is shown in the :cfunc:`sum_sequence` example above.  It so happens that that example doesn't need to clean up any owned references when it detects an error.  The following example function shows some error cleanup.  First, to remind you why you like Python, we show the equivalent Python code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Prosty przykład wykrywania wyjątków i przykazywania ich jest pokazany w powyższym przykładzie :cfunc:`suma_sekwencji`. Tak się składa że w tym przykładzie nie ma potrzeby czyszczenia żadnych posiadanych odniesień gdy wykryje błąd. Następujące przykładowe zadanie pokazuje pewne sprzątanie po błędach. Wpierw, aby przypomnieć dlaczego lubić można język pytonowski, pokazujemy odpowiadający kod w języku pytonowskim::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def incr_item(dict, key):     try:         item = dict[key]     except KeyError:         item = 0     dict[key] = item + 1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def zwieksz_element(slownik, klucz):     try:         element = slownik[klucz]     except KeyError:         element = 0     slownik[klucz] = element + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is the corresponding C code, in all its glory::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu następuje odpowiadający kod w języku C, w całej pełni okazałości::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int incr_item(PyObject *dict, PyObject *key) {     /* Objects all initialized to NULL for Py_XDECREF */     PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;     int rv = -1; /* Return value initialized to -1 (failure) */      item = PyObject_GetItem(dict, key);     if (item == NULL) {         /* Handle KeyError only: */         if (!PyErr_ExceptionMatches(PyExc_KeyError))             goto error;          /* Clear the error and use zero: */         PyErr_Clear();         item = PyLong_FromLong(0L);         if (item == NULL)             goto error;     }     const_one = PyLong_FromLong(1L);     if (const_one == NULL)         goto error;      incremented_item = PyNumber_Add(item, const_one);     if (incremented_item == NULL)         goto error;      if (PyObject_SetItem(dict, key, incremented_item) &lt; 0)         goto error;     rv = 0; /* Success */     /* Continue with cleanup code */   error:     /* Cleanup code, shared by success and failure path */      /* Use Py_XDECREF() to ignore NULL references */     Py_XDECREF(item);     Py_XDECREF(const_one);     Py_XDECREF(incremented_item);      return rv; /* -1 for error, 0 for success */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int zwieksz_element(PyObject *slownik, PyObject *klucz) {     /* Wszystkie przedmioty ustawione pierwotnie na NULL dla Py_XDECREF */     PyObject *element = NULL, *staly_jeden = NULL, *zwiekszany_element = NULL;     int wzw = -1; /* Wartość zwracana ustawiona początkowo na -1 (błąd) */      element = PyObject_GetItem(slownik, klucz);     if (element == NULL) {         /* Obsłuż tylko wyjątek KeyError: */         if (!PyErr_ExceptionMatches(PyExc_KeyError))             goto blad;          /* Wytrzyj błąd i użyj zera: */         PyErr_Clear();         element = PyLong_FromLong(0L);         if (element == NULL)             goto blad;     }     staly_jeden = PyLong_FromLong(1L);     if (staly_jeden == NULL)         goto blad;      zwiekszany_element = PyNumber_Add(element, staly_jeden);     if (zwiekszany_element == NULL)         goto blad;      if (PyObject_SetItem(slownik, klucz, zwiekszany_element) &lt; 0)         goto blad;     wzw = 0; /* Sukces */     /* Kontynuuj ze sprzątaniem po kodzie */   blad:     /* Sprzątanie, współdzielone przez ścieżki błędu i sukcesu */      /* Używaj Py_XDECREF() aby zignorować NULL odniesienia */     Py_XDECREF(element);     Py_XDECREF(staly_jeden);     Py_XDECREF(zwiekszany_element);      return wzw; /* -1 dla błędu, 0 for sukcesu */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example represents an endorsed use of the ``goto`` statement  in C! It illustrates the use of :cfunc:`PyErr_ExceptionMatches` and :cfunc:`PyErr_Clear` to handle specific exceptions, and the use of :cfunc:`Py_XDECREF` to dispose of owned references that may be *NULL* (note the ``'X'`` in the name; :cfunc:`Py_DECREF` would crash when confronted with a *NULL* reference).  It is important that the variables used to hold owned references are initialized to *NULL* for this to work; likewise, the proposed return value is initialized to ``-1`` (failure) and only set to success after the final call made is successful.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten przykład pokazuje przyjęte użycie wyrażenia idzdo - z ang. - ``goto`` w C! Pokazuje ono użycie :cfunc:`PyErr_ExceptionMatches` i :cfunc:`PyErr_Clear` do obsługi szczególnych wyjątków, i użycie :cfunc:`Py_XDECREF` do posprzątania po posiadanych odniesieniach, które mogą być *NULL* (zwróć uwagę na ``'X'`` w nazwie; :cfunc:`Py_DECREF wyłożyłby się w konfrontacji z *pustym* - *NULL* odniesieniem). Jest istotne, że zmienne użyte do trzymania własnych odniesień są zainicjowane *NULL* aby mogło to zadziałać; podobnie, proponowana wartość zwracana jest inicjowana na ``-1`` (błąd) i ustawiana na sukces tylko gdy ostatnie wywołanie zakończy się sukcesem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedding Python</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Załączanie programu interpretującego język pytonowski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one important task that only embedders (as opposed to extension writers) of the Python interpreter have to worry about is the initialization, and possibly the finalization, of the Python interpreter.  Most functionality of the interpreter can only be used after the interpreter has been initialized.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedno istotne zadanie, o które załączający (w przeciwieństwie do piszących rozszerzenia) program interpretujący język pytonowski muszą się martwić jest zainicjowanie i prawdopodobne zakończenie programu interpretującego polecenia języka pytonowskiego. Większość użyteczności programu interpretującego polecenia języka pytonowskiego może tylko być użyta po jego zainicjowaniu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic initialization function is :cfunc:`Py_Initialize`. This initializes the table of loaded modules, and creates the fundamental modules :mod:`builtins`, :mod:`__main__`, :mod:`sys`, and :mod:`exceptions`.  It also initializes the module search path (``sys.path``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podstawowym poleceniem inicjującym jest :cfunc:`Py_Initialize`. To inicjuje tabelę załadowanych modułów, i tworzy podstawowe moduły wbudowane - :mod:`builtins`, nadrzędny - :mod:`__main__`, i systemowy - :mod:`sys`, i moduł wyjątków - :mod:`exceptions`. Inicjuje także ścieżkę poszukiwania modułów - (``sys.path``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`Py_Initialize` does not set the "script argument list"  (``sys.argv``). If this variable is needed by Python code that will be executed later, it must be set explicitly with a call to  ``PySys_SetArgvEx(argc, argv, updatepath)`` after the call to :cfunc:`Py_Initialize`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cfunc:`Py_Initialize` nie ustawia "listy parametrów skryptu" (``sys.argv``). Jeśli ta zmienna jest wymagana przez kod języka pytonowskiego który ma być wykonany później, musi być ustalony jawnie przez wywołanie ``PySys_SetArgvEx(argc, argv, updatepath)`` po odwołaniu do :cfunc:`Py_Initialize`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On most systems (in particular, on Unix and Windows, although the details are slightly different), :cfunc:`Py_Initialize` calculates the module search path based upon its best guess for the location of the standard Python interpreter executable, assuming that the Python library is found in a fixed location relative to the Python interpreter executable.  In particular, it looks for a directory named :file:`lib/python{X.Y}` relative to the parent directory where the executable named :file:`python` is found on the shell command search path (the environment variable :envvar:`PATH`).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na większości systemów (w szczególności w Unixie i Windowsie, chociaż szczegóły są w niewielkim stopniu różne), zadanie :cfunc:`Py_Initialize` oblicza ścieżkę poszukiwania modułów w oparciu o najlepsze zgadywanie dla położenia najlepszego pliku wykonywalnego programu interpretującego język pytonowski, zakładając że biblioteka języka pytonowskiego znajduje się w ustalonym położeniu względem pliku wykonywalnego programu interpretującego polecenia języka pytonowskiego. W szczególności, poszukuje katalogu nazwanego :file:`lib/python{X.Y}` w odniesieniu do katalogu nadrzędnego gdzie plik wykonywalny nazwany :file:`python` znajduje się na ścieżce poszukiwań poleceń powłoki (w zmiennej środowiskowej :envvar:`PATH`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, if the Python executable is found in :file:`/usr/local/bin/python`, it will assume that the libraries are in :file:`/usr/local/lib/python{X.Y}`.  (In fact, this particular path is also the "fallback" location, used when no executable file named :file:`python` is found along :envvar:`PATH`.)  The user can override this behavior by setting the environment variable :envvar:`PYTHONHOME`, or insert additional directories in front of the standard path by setting :envvar:`PYTHONPATH`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na przykład, jeśli plik wykonywalny programu interpretującego polecenia języka pytonowskiego znajduje się w katalogu :file:`/usr/local/bin/python`, będzie zakładał, że biblioteki są w katalogu :file:`/usr/local/lib/python{X.Y}` (Faktycznie, ta szczególna ścieżka jest także "ratunkowym" położeniem, używanym gdy żaden plik wykonywalny nazwany :file:`python` nie znajdzie się w katalogach znajdujących się w zmiennej środowiskowej :envvar:`PATH`.) Użytkownik może podmienić to zachowanie przez ustawienie zmiennej środowiskowej :envvar:`PYTHONHOME`, lub wstawić dodatkowe katalogi przed sztandarową ścieżką przez ustawienie zmiennej środowiskowej :envvar:`PYTHONPATH`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The embedding application can steer the search by calling ``Py_SetProgramName(file)`` *before* calling  :cfunc:`Py_Initialize`.  Note that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` is still inserted in front of the standard path.  An application that requires total control has to provide its own implementation of :cfunc:`Py_GetPath`, :cfunc:`Py_GetPrefix`, :cfunc:`Py_GetExecPrefix`, and :cfunc:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Załącczająca  aplikacja może wysterować ścieżkę poszukiwania przez wywołanie ``Py_SetProgramName(file)`` *przed* wywołaniem :cfunc:`Py_Initialize`. Zauważ że ścieżka :envvar:`PYTHONHOME` wciąż wyprzedza to ustalenie zaś :envvar:`PYTHONPATH` wciąż jest wstawiane przed standardową ścieżką dostępu. Aplikacja która wymaga całkowitej kontroli potrzebowałaby swojej własnej interpretacji zadań :cfunc:`Py_GetPath`, :cfunc:`Py_GetPrefix`, :cfunc:`Py_GetExecPrefix`, i :cfunc:`Py_GetProgramFullPath` (wszystkie zdefiniowane w pliku :file:`Modules/getpath.c`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, it is desirable to "uninitialize" Python.  For instance,  the application may want to start over (make another call to :cfunc:`Py_Initialize`) or the application is simply done with its  use of Python and wants to free memory allocated by Python.  This can be accomplished by calling :cfunc:`Py_Finalize`.  The function :cfunc:`Py_IsInitialized` returns true if Python is currently in the initialized state.  More information about these functions is given in a later chapter. Notice that :cfunc:`Py_Finalize` does *not* free all memory allocated by the Python interpreter, e.g. memory allocated by extension modules currently cannot be released.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami jest wymagane aby "odinicjować" środowisko języka pytonowskiego. Dla przykładu gdy aplikacja ma potrzebę zrestartować (wykonać jeszcze jedno wywołanie zadania :cfunc:`Py_Initialize`) lub aplikacja jest po prostu zrobiona z użyciem języka pytonowskiego i chciałaby zwolnić pamięć przydzieloną programowi interpretującemu polecenia języka pytonowskiego. Można tego dokonać przez wezwanie :cfunc:`Py_Finalize`. Zadanie :cfunc:`Py_IsInitialized` zwraca prawdę jeśli program wykonujący polecenia języka pytonowskiego jest aktualnie w zainicjowanym stanie. Więcej informacji o tych zadaniach jest dostępna w późniejszym rozdziale. Zauważ, że zadanie :cfunc:`Py_Finalize` *nie* uwalnia całej pamięci przydzielonej przez program interpretujący polecenia języka pytonowskiego, np. pamięci przydzielonej przez moduły rozszerzające aktualnie nie mogą być uwalniane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging Builds</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpluskwiające Budowy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python can be built with several macros to enable extra checks of the interpreter and extension modules.  These checks tend to add a large amount of overhead to the runtime so they are not enabled by default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Program interpretujący język pytonowski może być zbudowany z kilkoma makropoleceniami do załączenia dodatkowych sprawdzeń programu interpretującego polecenia języka pytonowskiego i modułów rozszerzających. Te sprawdzenia mają zwyczaj dodawać duży narzut czasu wykonania poleceń programu więc nie są załączane domyślnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A full list of the various types of debugging builds is in the file :file:`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are available that support tracing of reference counts, debugging the memory allocator, or low-level profiling of the main interpreter loop.  Only the most frequently-used builds will be described in the remainder of this section.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pełną listę różnego rodzaju budów odpluskwiania znajduje się w pliku :file:`Misc/SpecialBuilds.txt` w źródłowych zasobach pakietu języka pytonowskiego. Są dostępne budowy ze wsparciem wypisywania przebiegów liczb odniesień, lub profilowania nisko-poziomowego głównej pętli programu interpretującego polecenia języka pytonowskiego. Tylko najczęściej używane budowy będą opisane w dalszej części tej sekcji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the interpreter with the :cmacro:`Py_DEBUG` macro defined produces what is generally meant by "a debug build" of Python. :cmacro:`Py_DEBUG` is enabled in the Unix build by adding :option:`--with-pydebug` to the :file:`configure` command.  It is also implied by the presence of the not-Python-specific :cmacro:`_DEBUG` macro.  When :cmacro:`Py_DEBUG` is enabled in the Unix build, compiler optimization is disabled.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompilowanie programu interpretującego polecenia języka pytonowskiego z makrodefinicją :cmacro:`Py_DEBUG` określoną daje to co potocznie zwane jest "budową odpluskwiającą" języka pytonowskiego. Makrodefinicja :cmacro:`Py_DEBUG` włączana jest w budowie Unixowej przez dodanie opcji :option:`--with-pydebug` do pliku skryptu :file:`configure` - komendy konfiguracji. Jest to także niejawnie sugerowane przez obecność nie-typowej-dla-języka-pytonowskiego makrodefinicji :cmacro:`_DEBUG`. Gdy makrodefinicja :cmacro:`Py_DEBUG` jest załączona w budowie Unixowej, optymalizacja kompilacji jest wyłączana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the reference count debugging described below, the following extra checks are performed:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W uzupełnieniu odpluskwiania opartego o zliczanie odniesień opisanego poniżej, następujące dodatkowe sprawdzenia są wykonywane:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra checks are added to the object allocator.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowe sprawdzenia są dodawane do przedmiotu lokującego inne przedmioty w pamięci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra checks are added to the parser and compiler.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowe sprawdzenia są dodawane do przedmiotu wczytującego i kompilującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Downcasts from wide types to narrow types are checked for loss of information.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rzutowania w dół z szerokich do wąskich typów są sprawdzane pod kątem utraty informacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A number of assertions are added to the dictionary and set implementations. In addition, the set object acquires a :meth:`test_c_api` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pewna ilość ustaleń twierdzących jest dodawana do realizacji słownika i zbioru. W dodatku przedmiot zbioru otrzymuje sposób postępowania zwany pod nazwą :meth:`test_c_api`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sanity checks of the input arguments are added to frame creation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdzenia przytomności parametrów wejściowych dodawane są do kreacji ramki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The storage for ints is initialized with a known invalid pattern to catch reference to uninitialized digits.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przechowalnia przedmiotów liczb całkowitych z ang. - ints jest inicjowana ze znanym błędnym wzorem do wyłapania odniesień do niezainicjowanych cyfr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Low-level tracing and extra exception checking are added to the runtime virtual machine.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niskopoziomowe śledzenie i dodatkowe sprawdzanie błędów dodawane jest do kodu wykonywalnego wirtualnej maszyny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra checks are added to the memory arena implementation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowe sprawdzenia dodawane są do implementacji areny pamięci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra debugging is added to the thread module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowe odpluskwianie dodawane jest do modułu wątków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There may be additional checks not mentioned here.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Mogą istnieć dodatkowe sprawdzenia nie wymienione tutaj.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining :cmacro:`Py_TRACE_REFS` enables reference tracing.  When defined, a circular doubly linked list of active objects is maintained by adding two extra fields to every :ctype:`PyObject`.  Total allocations are tracked as well.  Upon exit, all existing references are printed.  (In interactive mode this happens after every statement run by the interpreter.)  Implied by :cmacro:`Py_DEBUG`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Definiowanie makrodefinicji :cmacro:`Py_TRACE_REFS` włącza śledzenie odniesień. Gdy definicja jest włączona, cykliczna podwójnie powiązana lista aktywnych przedmiotów jest utrzymywana przez dodanie dwóch dodatkowych pól do każdego przedmiotu :ctype:`PyObject`. Suma przydzielonego miejsca jest również śledzona. W momencie wyjścia, wszystkie istniejące odniesienia są wypisywane. (W trybie współpracy człowieka z komputerem to następuje po każdym poleceniu wykonanym przez program interpretujący polecenia języka pytonowskiego.) Dorozumiane po napotkaniu makrodefinicji :cmacro:`Py_DEBUG`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source distribution for more detailed information.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odwołaj się do :file:`Misc/SpecialBuilds.txt` w źródłowym pakiecie języka pytonowskiego po więcej szczegółów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Iterator Protocol</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Protokół przedmiotów iterujących.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are only a couple of functions specifically for working with iterators.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje tylko kilka zadań szczególnie przeznaczonych do pracy z przedmiotami iterującymi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write a loop which iterates over an iterator, the C code should look something like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby napisać pętlę iterującą ponad przedmiotem iterującym, kod C powinien wyglądać mniej więcej tak::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *iterator = PyObject_GetIter(obj); PyObject *item;  if (iterator == NULL) {     /* propagate error */ }  while (item = PyIter_Next(iterator)) {     /* do something with item */     ...     /* release reference when done */     Py_DECREF(item); }  Py_DECREF(iterator);  if (PyErr_Occurred()) {     /* propagate error */ } else {     /* continue doing useful work */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *iterator = PyObject_GetIter(przedm); PyObject *element;  if (iterator == NULL) {     /* propaguj błąd */ }  while (element = PyIter_Next(iterator)) {     /* zrób coś z elementem */     ...     /* zwolnij odniesienie gdy skończysz */     Py_DECREF(element); }  Py_DECREF(iterator);  if (PyErr_Occurred()) {     /* propaguj błąd */ } else {     /* dalej rób coś porzytecznego */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Iterator Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Iterujące</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python provides two general-purpose iterator objects.  The first, a sequence iterator, works with an arbitrary sequence supporting the :meth:`__getitem__` method.  The second works with a callable object and a sentinel value, calling the callable for each item in the sequence, and ending the iteration when the sentinel value is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski dostarcza dwa ogólnego użytku przedmioty iterujące. Pierwszy przedmiot iterujący po sekwencji, współpracuje z dowolną sekwencją wspierającą sposób działania :meth:`__getitem__`. Drugi współpracuje z przedmiotami reagującymi na wywołanie i flagą-bezpiecznikiem, wywołując przedmiot reagujący na wywołanie dla każdego elementu sekwencji, i kończąc iteracje po otrzymaniu powrotnej flagi-bezpiecznika.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty list</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integer Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty liczb całkowitych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All integers are implemented as "long" integer objects of arbitrary size.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie liczby całkowite są realizowane jako przedmioty liczb całkowitych "długich" o określonym rozmiarze. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Protocol</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Protokół mapowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data marshalling support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla marszruty danych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These routines allow C code to work with serialized objects using the same data format as the :mod:`marshal` module.  There are functions to write data into the serialization format, and additional functions that can be used to read the data back.  Files used to store marshalled data must be opened in binary mode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te utarte sposoby postępowania pozwalają kodowi C działać z przedmiotami serializowanymi przy użyciu tych samych formatów danych jak moduł :mod:`marshal`a. Istnieją zadania do wpisywania danych do formatów serializowalnych, i dodatkowe zadania, które mogą być używane do odczytania danych otrzymanych tą drogą. Pliki używane do przechowywania marszrutowanych danych muszą być otwarte w trybie binarnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numeric values are stored with the least significant byte first.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartości numeryczne zapisywane są z najmniej znaczącym bajtem jako pierwszym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module supports two versions of the data format: version 0 is the historical version, version 1 shares interned strings in the file, and upon unmarshalling.  Version 2 uses a binary format for floating point numbers. *Py_MARSHAL_VERSION* indicates the current file format (currently 2).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł wspiera dwie wersje formatu danych: wersja 0 jest wersją historyczną, wersja 1 zachowuje w pliku pobrane ciągi znaków z momentu odmarszrutowania. Wersja 2 używa formatu binarnego dla liczb zmiennoprzecinkowych: *Py_MARSHAL_VERSION* wskazuje aktualny format pliku (obecnie 2).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions allow marshalled values to be read back in.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania pozwalają marszrutowanym wartościom na wczytywanie ich na powrót.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XXX What about error detection?  It appears that reading past the end of the file will always result in a negative numeric value (where that's relevant), but it's not clear that negative values won't be handled properly when there's no error.  What's the right way to tell? Should only non-negative values be written using these routines?</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>XXX Co ze sprawdzaniem błędów? Wygląda na to, że wczytywanie po końcu pliku zawsze spowoduje wczytanie ujemnej wartości liczbowej (tam gdzie jest to istotne), ale nie jest jasne czy ujemne wartości nie będą potraktowane właściwie gdy nie będą one skutkiem błędu. Jak właściwe rozeznać? Czy tylko nieujemne wartości powinny być zapisywane używając tych sposobów postępowania?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Memory Management</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zarządzanie Pamięcią</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overview</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skorowidz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the *Python memory manager*.  The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zarządzanie pamięcią w języku pytonowskim zakłada prywatną stertę zawierającą wszystkie przedmioty języka pytonowskiego i struktury danych. Zarządzanie tą prywatną stertą jest zapewniane wewnętrznie przez *zarządcę pamięci języka pytonowskiego*. Zarządca pamięci języka pytonowskiego ma różne komponenty które radzą sobie z różnymi aspektami dynamicznego przechowywania, jak współdzielenie, segmentacja, alokacja wstępna i kieszeniowanie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data by interacting with the memory manager of the operating system. On top of the raw memory allocator, several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type. For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, but ensures that the latter operate within the bounds of the private heap.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na najniższym poziomie, przedmiot przydzielający pamięć "na-surowo" zapewnia że będzie dość pamięci na prywatnej stercie dla przechowania wszystkich związanych-z-językiem-pytonowskim danych przez współdziałanie z zarządcą pamięci systemu operacyjnego. Ponad zarządcą surowej pamięci, kilka szczególnych dla danych typów przedmiotów zarządców operuje na tej samej stercie i wypełnia szczególne zasady zarządzania pamięcią dostosowane do szczególnych własności każdego rodzaju przedmiotu. Dla przykładu przedmioty liczb całkowitych są zarządzane inaczej wewnątrz sterty niż ciągi znaków, krotki czy słowniki gdyż liczby całkowite zakładają inne wymagania przechowywania i wady i zalety prędkości/zajętej przestrzeni. Zarządca pamięcią języka pytonowskiego zatem odprawia pewną ilość nakładów pracy dla szczególnych dla przedmiotów różnych typów zarządców, ale zapewnia że te drugie będą operować wewnątrz ograniczeń prywatnej sterty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to understand that the management of the Python heap is performed by the interpreter itself and that the user has no control over it, even if she regularly manipulates object pointers to memory blocks inside that heap.  The allocation of heap space for Python objects and other internal buffers is performed on demand by the Python memory manager through the Python/C API functions listed in this document.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istotnym jest pojąć że zarządzanie stertą języka pytonowskiego jest dokonywane przez program interpretujący polecenia języka pytonowskiego sam w sobie i że użytkownik nie ma nad nim żadnej kontroli, nawet jeśli regularnie zmienia wskaźniki przedmiotowe do obszarów pamięci wewnątrz sterty. Przydział przestrzeni pamięci dla przedmiotów języka pytonowskiego i innych wewnętrznych obszarów wymiany jest dokonywany na żądanie przez zarządcę pamięci języka pytonowskiego za pośrednictwem zadań sprzęgu między językami pytonowskim i C opisanych w tym dokumencie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid memory corruption, extension writers should never try to operate on Python objects with the functions exported by the C library: :cfunc:`malloc`, :cfunc:`calloc`, :cfunc:`realloc` and :cfunc:`free`.  This will result in  mixed calls between the C allocator and the Python memory manager with fatal consequences, because they implement different algorithms and operate on different heaps.  However, one may safely allocate and release memory blocks with the C library allocator for individual purposes, as shown in the following example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby uniknąć zburzenia porządku pamięci, piszący rozszerzenia nie powinni nigdy próbować operować na przedmiotach języka pytonowskiego za pomocą zadań udostępnionych z biblioteki C: :cfunc:`malloc`, :cfunc:`calloc`, :cfunc:`realloc` i :cfunc:`free`. To doprowadzi do pomieszania wywołań pomiędzy zarządcą z języka C i zarządcą z języka pytonowskiego z fatalnymi konsekwencjami, ponieważ realizują one różne algorytmy i operują na różnych stertach. Jednakże można bezpiecznie przydzielać i zwalniać obszary pamięci dla indywidualnych potrzeb, jak pokazano w następującym przykładzie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *res; char *buf = (char *) malloc(BUFSIZ); /* for I/O */  if (buf == NULL)     return PyErr_NoMemory(); ...Do some I/O operation involving buf... res = PyString_FromString(buf); free(buf); /* malloc'ed */ return res;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *zasob; char *buf = (char *) malloc(BUFSIZ); /* dla we/wy */  if (buf == NULL)     return PyErr_NoMemory(); ...Wykonaj pewne operacje we/wy korzystające z buf... zasob = PyString_FromString(buf); free(buf); /* malloc-nięte */ return res;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, the memory request for the I/O buffer is handled by the C library allocator. The Python memory manager is involved only in the allocation of the string object returned as a result.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym przykładzie, żądanie do pamięci obszaru wymiany jest obsługiwane przez zarządcę bibliotecznego języka C. Zarządca pamięci języka pytonowskiego zajmuje się tylko przydziałem miejsca dla przedmiotu ciągu znaków zwracanego jako wynik.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most situations, however, it is recommended to allocate memory from the Python heap specifically because the latter is under control of the Python memory manager. For example, this is required when the interpreter is extended with new object types written in C. Another reason for using the Python heap is the desire to *inform* the Python memory manager about the memory needs of the extension module. Even when the requested memory is used exclusively for internal, highly-specific purposes, delegating all memory requests to the Python memory manager causes the interpreter to have a more accurate image of its memory footprint as a whole. Consequently, under certain circumstances, the Python memory manager may or may not trigger appropriate actions, like garbage collection, memory compaction or other preventive procedures. Note that by using the C library allocator as shown in the previous example, the allocated memory for the I/O buffer escapes completely the Python memory manager.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W większości przypadków, jednakże, zalecane jest umieszczanie w pamięci ze sterty języka pytonowskiego szczególnie ponieważ ta ostatnia jest pod kontrolą zarządcy pamięci języka Pytonowskiego. Na przykład, jest to wymagane gdy program interpretujący polecenia języka pytonowskiego jest rozszerzany nowymi typami przedmiotów napisanych w języku C. Inną przyczyną użycia sterty języka pytonowskiego jest chęć *poinformowania* zarządcy pamięci języka pytonowskiego o potrzebach pamięciowych modułu rozszerzającego. Nawet gdy żądana pamięć jest używana wyłącznie dla wewnętrznych wysoko-wyspecjalizowanych potrzeb, oddelegowanie wszystkich zapytań o pamięć do zarządcy pamięci języka pytonowskiego spowoduje że program interpretujący polecenia języka pytonowskiego będzie  miał  bardziej trafny obraz podstawowego rozmiaru potrzeb pamięciowych jako całości. Konsekwentnie, w pewnych warunkach zarządca pamięci języka pytonowskiego może lub może nie uruchomić właściwych działań, jak zbiórki śmieci, porządkowania pamięci lub innych zapobiegawczych działań. Zauważ, że używając programu bibliotecznego lokującego pamięć z języka C jak pokazano w poprzednim przykładzie zarezerwowana pamięć dla obszaru wymiany wejścia/wyjścia całkowicie umyka uwadze zarządcy pamięci języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Memory Interface</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg Pamięci</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following function sets, modeled after the ANSI C standard, but specifying behavior when requesting zero bytes, are available for allocating and releasing memory from the Python heap:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zbiory zadań, ukształtowane na wzór standardu znanego z ANSI C, ale określając zachowanie po zażądaniu zera kęsów, są dostępne do lokowania i zwalniania pamięci na stercie języka pytonowskiego:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following type-oriented macros are provided for convenience.  Note  that *TYPE* refers to any C type.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące makropolecenia zorientowane-według-typu dostarczone są dla wygody. Zauważ że *TYP* odnosi się do dowolnego typu C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the following macro sets are provided for calling the Python memory allocator directly, without involving the C API functions listed above. However, note that their use does not preserve binary compatibility across Python versions and is therefore deprecated in extension modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodać należy, że następujący zbiór makropoleceń dostarczony jest aby odwoływać się do programu przydzielającego pamięć w języku pytonowskim bezpośrednio, bez udziału zadań sprzęgu C wymienionych powyżej. Jednakże, zauważ, że ich użycie nie zachowuje wzajemnej zgodności binarnej pomiędzy wersjami języka pytonowskiego i z tego też powodu ich użycie jest niewskazane w modułach rozszerzających.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`PyMem_MALLOC`, :cfunc:`PyMem_REALLOC`, :cfunc:`PyMem_FREE`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cfunc:`PyMem_MALLOC`, :cfunc:`PyMem_REALLOC`, :cfunc:`PyMem_FREE`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`PyMem_NEW`, :cfunc:`PyMem_RESIZE`, :cfunc:`PyMem_DEL`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cfunc:`PyMem_NEW`, :cfunc:`PyMem_RESIZE`, :cfunc:`PyMem_DEL`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is the example from section :ref:`memoryoverview`, rewritten so that the I/O buffer is allocated from the Python heap by using the first function set::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tutaj jest przykład z sekcji "przeglądu pamięci" - z ang. - :ref:`memoryoverview`, przepisane, tak aby przestrzeń wejścia/wyjścia była przydzielona ze sterty języka pytonowskiego używając pierwszego zestawu zadań::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *res; char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */  if (buf == NULL)     return PyErr_NoMemory(); /* ...Do some I/O operation involving buf... */ res = PyString_FromString(buf); PyMem_Free(buf); /* allocated with PyMem_Malloc */ return res;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *zasob; char *buf = (char *) PyMem_Malloc(BUFSIZ); /* dla we/wy */  if (buf == NULL)     return PyErr_NoMemory(); /* ...Wykonaj pewne operacje we/wy dotyczące buf... */ zasob = PyString_FromString(buf); PyMem_Free(buf); /* umieszczone przez PyMem_Malloc */ return zasob;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same code using the type-oriented function set::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ten sam kod przy użyciu zorientowanych na typ zbiorów zadań::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *res; char *buf = PyMem_New(char, BUFSIZ); /* for I/O */  if (buf == NULL)     return PyErr_NoMemory(); /* ...Do some I/O operation involving buf... */ res = PyString_FromString(buf); PyMem_Del(buf); /* allocated with PyMem_New */ return res;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *zasob; char *buf = PyMem_New(char, BUFSIZ); /* dla we/wy */  if (buf == NULL)     return PyErr_NoMemory(); /* ...Wykonaj pewne operacje we/wy dotyczące buf... */ zasob = PyString_FromString(buf); PyMem_Del(buf); /* utworzone przez PyMem_New */ return zasob;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in the two examples above, the buffer is always manipulated via functions belonging to the same set. Indeed, it is required to use the same memory API family for a given memory block, so that the risk of mixing different allocators is reduced to a minimum. The following code sequence contains two errors, one of which is labeled as *fatal* because it mixes two different allocators operating on different heaps. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że w dwóch powyższych przykładach, przestrzeń wymiany jest zawsze zmieniana przez zadania należące do tego samego zbioru. Właściwie, jest wymagane użycie tej samej rodziny sprzęgów zarządzania pamięcią (z ang. - memory API) dla danego obszaru pamięci, tak, że ryzyko pomieszania różnych programów lokujących zmniejszone jest do minimum. Następująca sekwencja zawiera dwa błędy, jeden z których określony jest jako *krytyczny* ponieważ miesza dwa różne programy lokujące pamięć działające na różnych stertach. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>char *buf1 = PyMem_New(char, BUFSIZ); char *buf2 = (char *) malloc(BUFSIZ); char *buf3 = (char *) PyMem_Malloc(BUFSIZ); ... PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */ free(buf2);       /* Right -- allocated via malloc() */ free(buf1);       /* Fatal -- should be PyMem_Del()  */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>char *buf1 = PyMem_New(char, BUFSIZ); char *buf2 = (char *) malloc(BUFSIZ); char *buf3 = (char *) PyMem_Malloc(BUFSIZ); ... PyMem_Del(buf3);  /* Źle -- powinno być PyMem_Free() */ free(buf2);       /* Prawidłowo -- przydzielone przez malloc() */ free(buf1);       /* Krytyczny błąd -- powinno być PyMem_Del()  */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the functions aimed at handling raw memory blocks from the Python heap, objects in Python are allocated and released with :cfunc:`PyObject_New`, :cfunc:`PyObject_NewVar` and :cfunc:`PyObject_Del`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na dodatek do zadań określonych dla obsługi surowych obszarów pamięci ze sterty języka pytonowskiego, przedmioty w języku pytonowskim są umieszczane i pamięć po nich jest zwalniana przy użyciu :cfunc:`PyObject_New`, :cfunc:`PyObject_NewVar` i :cfunc:`PyObject_Del`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These will be explained in the next chapter on defining and implementing new object types in C.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te zostaną wyjaśnione w następnym rozdziale o określaniu i realizowaniu nowych typów przedmiotów w języku C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instance Method Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Sposobów postępowania dla egzemplarzy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An instance method is a wrapper for a :cdata:`PyCFunction` and the new way to bind a :cdata:`PyCFunction` to a class object. It replaces the former call ``PyMethod_New(func, NULL, class)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania dla egzemplarza jest opakowaniem dla :cdata:`PyCFunction` i nowym sposobem na związanie :cdata:`PyCFunction` do przedmiotu klasy. Zastępuje poprzednie wezwanie ``PyMethod_New(func, NULL, class)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Sposobów Postępowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods are bound function objects. Methods are always bound to an instance of an user-defined class. Unbound methods (methods bound to a class object) are no longer available.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby Postępowania są związanymi przedmiotami zadań. Sposoby postępowania są zawsze związane z przykładowymi przedmiotami należącymi do zdefiniowanych przez użytkownika kategorii. Niezwiązane sposoby postępowania (sposoby postępowania związane z przedmiotem kategorii) nie są już dostępne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Module Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty modułów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are only a few functions special to module objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje tylko kilka zadań szczególnych dla przedmiotów modułów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initializing C modules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inicjowanie modułów języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These functions are usually used in the module initialization function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te zadania są zwykle używane w zadaniu rozpoczynającym modułu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The None Object</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmiot "Żaden" - z ang. - None</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the :ctype:`PyTypeObject` for ``None`` is not directly exposed in the Python/C API.  Since ``None`` is a singleton, testing for object identity (using ``==`` in C) is sufficient. There is no :cfunc:`PyNone_Check` function for the same reason.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że :ctype:`PyTypeObject` dla ``Żadnego`` - z ang. - ``None`` nie jest bezpośrednio wystawiany w sprzęgu między językami pytonowskim a C. Ponieważ ``Żaden`` - z ang. - ``None`` jest kategorią samą w sobie, sprawdzanie tożsamości przedmiotu (używając ``==`` w języku C) jest wystarczające. Nie istnieje zadanie :cfunc:`PyNone_Check` z tego samego powodu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Number Protocol</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Protokół Liczbowy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffer Protocol</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Protokół Wymiany Danych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object Protocol</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Protokół Przedmiotów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subclass determination is done in a fairly straightforward way, but includes a wrinkle that implementors of extensions to the class system may want to be aware of.  If :class:`A` and :class:`B` are class objects, :class:`B` is a subclass of :class:`A` if it inherits from :class:`A` either directly or indirectly.  If either is not a class object, a more general mechanism is used to determine the class relationship of the two objects.  When testing if *B* is a subclass of *A*, if *A* is *B*, :cfunc:`PyObject_IsSubclass` returns true.  If *A* and *B* are different objects, *B*'s :attr:`__bases__` attribute is searched in a depth-first fashion for *A* --- the presence of the :attr:`__bases__` attribute is considered sufficient for this determination.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sprawdzanie podkategorii jest dokonywane w raczej prosto zrozumiały sposób, ale zawiera załomek o którym realizatorzy rozszerzeń systemu kategorii mogliby chcieć wiedzieć. Jeśli kategoria przedmiotów :class:`A` i kategoria przedmiotów :class:`B` są przedmiotami kategorii przedmiotów, wtedy kategoria przedmiotów :class:`B` jest podkategorią przedmiotów kategorii przedmiotów :class:`A`, jeśli dziedziczy po kategorii przedmiotów :class:`A` bezpośrednio lub pośrednio. Jeśli któraś z nich nie jest przedmiotem kategorii przedmiotów, wtedy bardziej ogólny mechanizm jest używany do sprawdzenia relację bycia podkategorią zachodzącą pomiędzy dwoma przedmiotami. Sprawdzając czy *B* jest podkategorią *A*, jeśli *A* jest *B*, wtedy zadanie :cfunc:`PyObject_IsSubclass` zwraca prawdę. Jeśli *A* i *B* są różnymi przedmiotami, wtedy atrybut *B* - :attr:`__bases__` jest przeszukiwany w sposób "wpierw-wgłąb" na obecność *A* --- obecność atrybutu :attr:`__bases__` jest uważana za wystarczającą dla tego sprawdzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object Implementation Support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla realizacji przedmiotów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter describes the functions, types, and macros used when defining new object types.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział opisuje zadania, rodzaje przedmiotów, i makrodefinicje i makropolecenia używane przy definiowaniu nowych rodzajów przedmiotów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference Counting</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zliczanie Odniesień</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The macros in this section are used for managing reference counts of Python objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia w tym rozdziale są używane do zarządzania liczbami odniesień dla przedmiotów w języku pytonowskim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions are for runtime dynamic embedding of Python: ``Py_IncRef(PyObject *o)``, ``Py_DecRef(PyObject *o)``. They are simply exported function versions of :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF`, respectively.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania służą dynamicznemu załączaniu kodów języka pytonowskiego: ``Py_IncRef(PyObject *o)``, ``Py_DecRef(PyObject *o)``. Są one po prostu uzewnętrznionymi wersjami zadań :cfunc:`Py_XINCREF` i :cfunc:`Py_XDECREF`, odpowiednio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions or macros are only for use within the interpreter core: :cfunc:`_Py_Dealloc`, :cfunc:`_Py_ForgetReference`, :cfunc:`_Py_NewReference`, as well as the global variable :cdata:`_Py_RefTotal`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania lub makropolecenia są tylko do użytku wewnątrz rdzenia programu iterpretującego polecenia języka pytonowskiego: :cfunc:`_Py_Dealloc`, :cfunc:`_Py_Forget_Reference` :cfunc:`_Py_NewReference`, zarówno, jak też nadrzędną zmienną :cdata:`_Py_RefTotal`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reflection</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Refleksja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequence Protocol</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Protokół Sekwencji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Zbiorów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section details the public API for :class:`set` and :class:`frozenset` objects.  Any functionality not listed below is best accessed using the either the abstract object protocol (including :cfunc:`PyObject_CallMethod`, :cfunc:`PyObject_RichCompareBool`, :cfunc:`PyObject_Hash`, :cfunc:`PyObject_Repr`, :cfunc:`PyObject_IsTrue`, :cfunc:`PyObject_Print`, and :cfunc:`PyObject_GetIter`) or the abstract number protocol (including :cfunc:`PyNumber_And`, :cfunc:`PyNumber_Subtract`, :cfunc:`PyNumber_Or`, :cfunc:`PyNumber_Xor`, :cfunc:`PyNumber_InPlaceAnd`, :cfunc:`PyNumber_InPlaceSubtract`, :cfunc:`PyNumber_InPlaceOr`, and :cfunc:`PyNumber_InPlaceXor`).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział wyszczególnia publiczny sprzęg programowania z ang. - API dla kategorii przedmiotu zbioru z ang. - :class:`set` i kategorii przedmiotu zamrożonego zbioru - z ang. - :class:`frozenset`. Do dowolnych możliwości nie wyszczególnionych poniżej najlepiej odnieść się przy użyciu abstrakcyjnego protokołu przedmiotów (włączając w to :cfunc:`PyObject_CallMethod`, :cfunc:`PyObject_RichCompareBool`, :cfunc:`PyObject_Hash`, :cfunc:`PyObject_Repr`, :cfunc:`PyObject_IsTrue`, :cfunc:`PyObject_Print`, i :cfunc:`PyObject_GetIter`) lub przy użyciu abstrakcyjnego protokołu liczbowego (włączając w to :cfunc:`PyNumber_And`, :cfunc:`PyNumber_Subtract`, :cfunc:`PyNumber_Or`, :cfunc:`PyNumber_Xor`, :cfunc:`PyNumber_InPlaceAnd`, :cfunc:`PyNumber_InPlaceSubtract`, :cfunc:`PyNumber_InPlaceOr`, i :cfunc:`PyNumber_InPlaceXor`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following type check macros work on pointers to any Python object. Likewise, the constructor functions work with any iterable Python object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące makropolecenia sprawdzające rodzaj przedmiotu pracują na wskaźnikach do dowolnych przedmiotów języka pytonowskiego. Podobnie, zadania konstruktorów pracjują z dowolnymi przedmiotami przechodnimi języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions and macros are available for instances of :class:`set` or :class:`frozenset` or instances of their subtypes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania i makropolecenia dostępne są dla przykładów kategorii zbioru - z ang. - :class:`set` lub zbioru zamrożonego - z ang. - :class:`frozenset` lub przykładowych realizacjach ich podtypów i podkategorii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions are available for instances of :class:`set` or its subtypes but not for instances of :class:`frozenset` or its subtypes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania dostępne są  dla przykładów kategorii zbioru -  z ang. - :class:`set` lub jej podkategorii, ale nie dla przykładów kategorii zamrożonego zbioru - z ang. - :class:`frozenset` lub jego podkategorii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Slice Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty wycinków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common Object Structures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wspólne struktury przedmiotów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a large number of structures which are used in the definition of object types for Python.  This section describes these structures and how they are used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje duża liczba struktur, które są używane przy definiowaniu rodzajów przedmiotów w języku pytonowskim. Ten rozdział opisuje te struktury i jak są one używane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Python objects ultimately share a small number of fields at the beginning of the object's representation in memory.  These are represented by the :ctype:`PyObject` and :ctype:`PyVarObject` types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie przedmioty języka pytonowskiego ostatecznie współdzielą niewielką liczbę pól na początku ich reprezentacji w pamięci. Są one reprezentowane przez pola o rodzaju :ctype:`PyObject` i :ctype:`PyVarObject` które są zdefiniowane z kolei przez rozwinięcia pewnych makrodefinicji używanych także bezpośrednio lub pośrednio, w definicji wszystkich innych przedmiotów języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These macros are used in the definition of :ctype:`PyObject` and :ctype:`PyVarObject`:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te makrodefinicje używane są przy definicjach :ctype:`PyObject` i :ctype:`PyVarObject`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`ml_meth` is a C function pointer.  The functions may be of different types, but they always return :ctype:`PyObject\*`.  If the function is not of the :ctype:`PyCFunction`, the compiler will require a cast in the method table. Even though :ctype:`PyCFunction` defines the first parameter as :ctype:`PyObject\*`, it is common that the method implementation uses a the specific C type of the *self* object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Atrybut :attr:`ml_meth` jest wskaźnikiem zadania z jęyzka C. Zadania mogą być różnych rodzajów, ale zawsze zwracają :ctype:`PyObject\*`. Jeśli zadanie nie jest :ctype:`PyCFunction`, kompilator będzie wymagał rzutowania w tabeli sposobów postępowania. Chociaż :ctype:`PyCFunction` definiuje pierwszy parametr jako :ctype:`PyObject\*`, często zdarza się, że wypełnienie sposobu postępowania używa szczególnego rodzaju z języka C wynikającego z *swojego* - z ang. - *self* przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`ml_flags` field is a bitfield which can include the following flags. The individual flags indicate either a calling convention or a binding convention.  Of the calling convention flags, only :const:`METH_VARARGS` and :const:`METH_KEYWORDS` can be combined (but note that :const:`METH_KEYWORDS` alone is equivalent to ``METH_VARARGS | METH_KEYWORDS``). Any of the calling convention flags can be combined with a binding flag.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pole :attr:`ml_flags` jest polem bitowym, które może zawierać następujące flagi.Indywidualne flagi wskazują albo konwencję wywoływania albo konwencję wiązania. Z konwencji wywoływania, tylko :const:`METH_VARARGS` i :const:`METH_KEYWORDS` mogą być mieszane (ale zauważ, że samo :const:`METH_KEYWORDS jest równoważne ``METH_VARARGS | METH_KEYWORDS``). Każda z flag konwencji wywołania może być mieszana z flagą wiążącą.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the typical calling convention, where the methods have the type :ctype:`PyCFunction`. The function expects two :ctype:`PyObject\*` values. The first one is the *self* object for methods; for module functions, it is the module object.  The second parameter (often called *args*) is a tuple object representing all arguments. This parameter is typically processed using :cfunc:`PyArg_ParseTuple` or :cfunc:`PyArg_UnpackTuple`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest typowa konwencja wywoływania, gdzie sposoby postępowania są rodzaju :ctype:`PyCFunction`. Zadanie oczekuje dwóch wartości typu :ctype:`PyObject\*`, Pierwszą z nich jest *samo* - z ang. - *self* dla sposobów postępowania; dla zadań modułowych, jest to przedmiot modułu. Drugim parametrem (często zwanym *args*) jest przedmiot krotki reprezentujący wszystkie parametry. Ten parametr jest zwykle przetwarzany przy użyciu :cfunc:`PyArg_ParseTuple` lub :cfunc:`PyArg_UnpackTuple`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods with these flags must be of type :ctype:`PyCFunctionWithKeywords`. The function expects three parameters: *self*, *args*, and a dictionary of all the keyword arguments.  The flag is typically combined with :const:`METH_VARARGS`, and the parameters are typically processed using :cfunc:`PyArg_ParseTupleAndKeywords`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania z tymi flagami muszą być typu :ctype:`PyCFunctionWithKeywords`. Zadanie oczekuje trzech parametrów: *samego*, *argumentów*, i słownika wszystkich parametrów kluczowych. Flaga jest zwykle łączona z :const:`METH_VARARGS`, a parametry są zwykle przetwarzane używając :cfunc:`PyArg_ParseTupleAndKeywords`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods without parameters don't need to check whether arguments are given if they are listed with the :const:`METH_NOARGS` flag.  They need to be of type :ctype:`PyCFunction`.  The first parameter is typically named *self* and will hold a reference to the module or object instance.  In all cases the second parameter will be *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania bez parametrów nie potrzebują sprawdzać czy parametry zostały im dostarczone jeśli są one na liście z załączoną flagą :const:`METH_NOARGS`. Muszą być typu :ctype:`PyCFunction`. Pierwszy parametr jest zwyczajowo nazwany *sam* - z ang. - *self* i przechowuje odwołanie do modułu lub przykładu przedmiotu. We wszystkich przypadkach drugi parametr jest *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods with a single object argument can be listed with the :const:`METH_O` flag, instead of invoking :cfunc:`PyArg_ParseTuple` with a ``"O"`` argument. They have the type :ctype:`PyCFunction`, with the *self* parameter, and a :ctype:`PyObject\*` parameter representing the single argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania z pojedynczym przedmiotem jako parametrem mogą być umieszczone z flagą :const:`METH_O`, zamiast wywoływania :cfunc:`PyArg_ParseTuple` z parametrem ``"O"``. Są typu :ctype:`PyCFunction`, z parametrem *self*, i parametrem :ctype:`PyObject\*` reprezentującym pojedynczy parametr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two constants are not used to indicate the calling convention but the binding when use with methods of classes.  These may not be used for functions defined for modules.  At most one of these flags may be set for any given method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te dwie stałe nie są używane do zaznaczania konwencji wywoływania, ale wiążą gdy są używane ze sposobami postępowania w rodzajach przedmiotów. Nie mogą być one używane dla zadań określonych dla modułów. Co najwyżej jedna z tych flag może być ustawiona dla dowolnego danego sposobu postępowania. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method will be passed the type object as the first parameter rather than an instance of the type.  This is used to create *class methods*, similar to what is created when using the :func:`classmethod` built-in function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposobowi postępowania zostanie przekazany  przedmiot typu przedmiotu jako pierwszy parametr zamiast przykładu przedmiotu tego typu. Jest to używane aby tworzyć *sposoby postępowania rodzajów przedmiotów*, podobnie do tego, co jest tworzone przy użyciu zadania wbudowanego :func:`classmethod`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method will be passed *NULL* as the first parameter rather than an instance of the type.  This is used to create *static methods*, similar to what is created when using the :func:`staticmethod` built-in function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposobowi postępowania zostanie przekazany parametr *NULL* jako pierwszy zamiast przykładu przedmiotu tego typu. Jest to używane aby tworzyć *statyczny sposób postępowania*, podobne do tego co tworzy się przy użyciu wbudowanego zadania  :func:`staticmethod`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One other constant controls whether a method is loaded in place of another definition with the same method name.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedna pozostała stała kontroluje czy sposób postępowania jest ładowany w miejscu innej definicji o tej samej nazwie sposobu postępowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method will be loaded in place of existing definitions.  Without *METH_COEXIST*, the default is to skip repeated definitions.  Since slot wrappers are loaded before the method table, the existence of a *sq_contains* slot, for example, would generate a wrapped method named :meth:`__contains__` and preclude the loading of a corresponding PyCFunction with the same name.  With the flag defined, the PyCFunction will be loaded in place of the wrapper object and will co-exist with the slot.  This is helpful because calls to PyCFunctions are optimized more than wrapper object calls.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania zostanie załadowany w miejsce istniejących definicji. Bez *METH_COEXIST*, domyślnie pomija się powtórzone definicje. Od kiedy opakowania gniazd są ładowane przed tabelą sposobów postępowania, istnienie na przykład gniazda *sq_contains* generuje opakowany sposób postępowania nazywany :meth:`__contains__` i zapobiega ładowaniu odpowiadającego zadania PyCFunction o tej samej nazwie. Ze zdefiniowaną flagą, PyCFunction zostanie załadowane w miejsce przedmiotu opakowania i będzie współistniał z gniazdem. To jest pomocne ponieważ wywołania PyCFunction są zoptymalizowane bardziej niż odwołania do przedmiotów opakowań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Operating System Utilities</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użytki Systemu Operacyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>System Functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania systemowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are utility functions that make functionality from the :mod:`sys` module accessible to C code.  They all work with the current interpreter thread's :mod:`sys` module's dict, which is contained in the internal thread state structure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są zadania użytkowe, które czynią zadania z modułu :mod:`sys` dostępnymi dla kodu z języka C. Wszystkie pracują z obecnym słownikiem modułu :mod:`sys` wątku programu interpretującego polecenia języka pytonowskiego, który to słownik jest zawarty w wewnętrznej strukturze stanu wątku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Process Control</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kontrola procesów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tuple Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty krotek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty rodzaju</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perhaps one of the most important structures of the Python object system is the structure that defines a new type: the :ctype:`PyTypeObject` structure.  Type objects can be handled using any of the :cfunc:`PyObject_\*` or :cfunc:`PyType_\*` functions, but do not offer much that's interesting to most Python applications. These objects are fundamental to how objects behave, so they are very important to the interpreter itself and to any extension module that implements new types.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapewne jedną z najważniejszych struktur systemu przedmiotów języka pytonowskiego jest struktura która definiuje nowy typ: strukturę :ctype:`PyTypeObject`. Przedmioty typu mogą być obsłużone używając dowolnego zadania spośród :cfunc:`PyObject_\*` lub :cfunc:`PyType_\*`, ale nie oferują wiele w sensie tego, co mogłoby być interesujące dla większości aplikacji języka pytonowskiego. Te przedmioty są podstawowe dla tego jak zachowują się przedmioty, więc są one bardzo istotne dla samego programu interpretującego polecenia języka pytonowskiego i do dowolnego modułu rozszerzającego który określa nowe typy przedmiotów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type objects are fairly large compared to most of the standard types. The reason for the size is that each type object stores a large number of values, mostly C function pointers, each of which implements a small part of the type's functionality.  The fields of the type object are examined in detail in this section.  The fields will be described in the order in which they occur in the structure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty typu przedmiotów są znacznie większe w porównaniu do większości standardowych typów.  Powodem tego rozmiaru jest to, że każdy przedmiot typu przechowuje dużą liczbę wartości, w większości wskaźników zadań C, z których każda wypełnia małą część użyteczności danego typu. Pola przedmiotu typu zostaną opisane w kolejności w której pojawiają się w strukturze.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, intargfunc, intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, reprfunc, hashfunc</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Definicje typu: unaryfunc, binaryfunc, ternaryfunc, inquiry, intargfunc, intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, reprfunc, hashfunc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structure definition for :ctype:`PyTypeObject` can be found in :file:`Include/object.h`.  For convenience of reference, this repeats the definition found there:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Definicja struktury dla :ctype:`PyTypeObject` można znaleźć w :file:`Include/object.h`. Dla wygody poręczności, powtórzona definicja znajduje się tutaj:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */     int tp_basicsize, tp_itemsize; /* For allocation */      /* Methods to implement standard operations */      destructor tp_dealloc;     printfunc tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void *tp_reserved;     reprfunc tp_repr;      /* Method suites for standard classes */      PyNumberMethods *tp_as_number;     PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping;      /* More standard operations (here for binary compatibility) */      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Functions to access object as input/output buffer */     PyBufferProcs *tp_as_buffer;      /* Flags to define presence of optional/expanded features */     long tp_flags;      char *tp_doc; /* Documentation string */      /* call function for all accessible objects */     traverseproc tp_traverse;      /* delete references to contained objects */     inquiry tp_clear;      /* rich comparisons */     richcmpfunc tp_richcompare;      /* weak reference enabler */     long tp_weaklistoffset;      /* Iterators */     getiterfunc tp_iter;     iternextfunc tp_iternext;      /* Attribute descriptor and subclassing stuff */     struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc tp_free; /* Low-level free-memory routine */     inquiry tp_is_gc; /* For PyObject_IS_GC */     PyObject *tp_bases;     PyObject *tp_mro; /* method resolution order */     PyObject *tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* Dla drukowania, w formacie "&lt;moduł&gt;.&lt;nazwa&gt;" */     int tp_basicsize, tp_itemsize; /* Dla alokacji */      /* Sposoby postępowania wypełniające standardowe operacje */      destructor tp_dealloc;     printfunc tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void *tp_reserved;     reprfunc tp_repr;      /* Suity sposobów postępowania dla typów standardowych */      PyNumberMethods *tp_as_number;     PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping;      /* Wiele  standardowych operacji (tutaj dla  binarnej kompatybilności) */      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Zadania  do dostępu do przedmiotów jako wejścia/wyjścia przestrzeni wymiany */     PyBufferProcs *tp_as_buffer;      /* Flagi do definiowania obecności dodatkowych/rozszerzonych właściwości */     long tp_flags;      char *tp_doc; /* ciągi znaków dokumentacji */      /* wywołanie zadania dla wszystkich dostępnych przedmiotów */     traverseproc tp_traverse;      /* skasuje odniesienia do zawartych przedmiotów */     inquiry tp_clear;      /* bogate porównania */     richcmpfunc tp_richcompare;      /* załączanie słabych odniesień */     long tp_weaklistoffset;      /* Przedmioty przechodzące */     getiterfunc tp_iter;     iternextfunc tp_iternext;      /* Przedmioty opisujące atrybuty i sprawy tworzenia podrodzajów */     struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc tp_free; /* Sposób postępowania zwalniający pamięć na niskim poziomie */     inquiry tp_is_gc; /* Dla PyObject_IS_GC */     PyObject *tp_bases;     PyObject *tp_mro; /* kolejność rozwiązywania nazw sposobów postępowania */     PyObject *tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The type object structure extends the :ctype:`PyVarObject` structure. The :attr:`ob_size` field is used for dynamic types (created by  :func:`type_new`, usually called from a class statement). Note that :cdata:`PyType_Type` (the metatype) initializes :attr:`tp_itemsize`, which means that its instances (i.e. type objects) *must* have the :attr:`ob_size` field.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Struktura przedmiotu rodzaju rozszerza strukturę :ctype:`PyVarObject`. Pole :attr:`ob_size` używane jest dla typów dynamicznych (tworzonych przy użyciu :func:`type_new`, zwykle wywoływanych z deklaracji rodzaju przedmiotu). Zauważ, że :cdata:`PyType_Type` (typ przedmiotu typu - inaczej metatyp) inicjuje :attr:`tp_itemsize`, które oznacza, że jego przykłady (przedmioty typu) *muszą* mieć pole :attr:`ob_size`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The remaining fields are only defined if the feature test macro :const:`COUNT_ALLOCS` is defined, and are for internal use only. They are documented here for completeness.  None of these fields are inherited by subtypes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pozostałe pola są tylko zdefiniowane jeśli makrodefinicja sprawdzenia występowania własności :const:`COUNT_ALLOCS` jest zdefiniowane, i jest tylko do wewnętrznego użytku. Są tutaj opisane dla zupełności. Żadne z tych pól nie jest dziedziczone przez podtypy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, note that, in a garbage collected Python, tp_dealloc may be called from any Python thread, not just the thread which created the object (if the object becomes part of a refcount cycle, that cycle might be collected by a garbage collection on any thread).  This is not a problem for Python API calls, since the thread on which tp_dealloc is called will own the Global Interpreter Lock (GIL). However, if the object being destroyed in turn destroys objects from some other C or C++ library, care should be taken to ensure that destroying those objects on the thread which called tp_dealloc will not violate any assumptions of the library.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ też, że w programie interpretującym polecenia języka pytonowskiego z regularnym odśmiecaniem, tp_dealloc może być wywoływane z dowolnego wątku programu interpretującego polecenia języka pytonowskiego, nie tylko z wątku który stworzył przedmiot (jeśli przedmiot stanie się częścią cyklu refcount, ten cykl może być potraktowany odśmiecaniem przez zbiórkę śmieci w dowolnym wątku). Nie jest to problem dla wywołań sprzęgu języka pytonowskiego (z ang. - API), od kiedy wątek, na którym tp_dealloc jest wywoływany będzie posiadał Nadrzędną Blokadę Programu Interpretującego język pytonowski (z ang. - GIL). Jednakże, jeśli przedmiot ulegający destrukcji z kolei zniszczy przedmioty z jakiejś innej biblioteki C lub C++, powinno się zwrócić szczególną uwagę, aby niszcząc te przedmioty w wątku, który wywołał tp_dealloc nie zakłócić żadnych założeń bibliotecznych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Number Object Structures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Struktury przedmiotów liczbowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping Object Structures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Struktury przedmiotów mapowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequence Object Structures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Struktury przedmiotów sekwencyjnych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffer Object Structures</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Struktury przedmiotów przestrzeni wymiany (z ang. - buffer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The buffer interface exports a model where an object can expose its internal data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg przestrzeni wymiany wystawia model gdzie przedmiot może wystawiać swoje wewnętrzne dane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an object does not export the buffer interface, then its :attr:`tp_as_buffer` member in the :ctype:`PyTypeObject` structure should be *NULL*.  Otherwise, the :attr:`tp_as_buffer` will point to a :ctype:`PyBufferProcs` structure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli przedmiot nie wystawia na zewnątrz sprzęgu przestrzeni wymiany, wtedy jego pole :attr:`tp_as_buffer` w strukturze :ctype:`PyTypeObject` powinno być puste - z ang. - *NULL*. W przeciwnym przypadku :attr:`tp_as_buffer` będzie wskazywał na strukturę :ctype:`PyBufferProcs`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode Objects and Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Unikodu i Kodery/Dekodery</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Unikodu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode Type</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rodzaj Unikodu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the basic Unicode object types used for the Unicode implementation in Python:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są podstawowe przedmioty Unikodu używane dla wypełnienia Unikodu w języku pytonowskim:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that UCS2 and UCS4 Python builds are not binary compatible. Please keep this in mind when writing extensions or interfaces.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że kompilacje UCS2 i UCS4 języka pytonowskiego nie są wzajemnie odpowiednie binarnie. Proszę miej to na uwadze pisząc rozszerzenia lub sprzęgi biblioteczne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following APIs are really C macros and can be used to do fast checks and to access internal read-only data of Unicode objects:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sprzęgi są w rzeczywistości makropoleceniami języka C i mogą być używane do szybkich sprawdzeń i do uzyskiwania dostępu do  wewnętrznych danych tylko do odczytu przedmiotów Unikodu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode Character Properties</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Własności znaków Unikodu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode provides many different character properties. The most often needed ones are available through these macros which are mapped to C functions depending on the Python configuration.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Unikod dostarcza wiele różnych właściwości znaków. Najczęściej potrzebne są dostępne przez te makropolecenia które są zmapowane na zadania w języku C zależnie od konfiguracji języka pytonowskiego. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These APIs can be used for fast direct character conversions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te sprzęgi mogą być używane do szybkich zamian znaków: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Plain Py_UNICODE</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czysty Py_UNICODE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create Unicode objects and access their basic sequence properties, use these APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby tworzyć przedmioty unikodowe i korzystać z ich podstawowych właściwości sekwencyjnych, używaj tych sprzęgów - z ang. - API:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the platform supports :ctype:`wchar_t` and provides a header file wchar.h, Python can interface directly to this type using the following functions. Support is optimized if Python's own :ctype:`Py_UNICODE` type is identical to the system's :ctype:`wchar_t`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli urządzenie fizyczne wspiera :ctype:`wchar_t` i dostarcza plik nagłówkowy wchar.h, język pytonowski może odnosić się do tego typu bezpośrednio przy użyciu następujących zadań. Wsparcie jest zoptymalizowane jeśli typ własny języku pytonowskiego :ctype:`Py_UNICODE` jest identyczny z systemowym :ctype:`wchar_t`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File System Encoding</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodowanie systemu plików </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To encode and decode file names and other environment strings, :cdata:`Py_FileSystemEncoding` should be used as the encoding, and ``"surrogateescape"`` should be used as the error handler (:pep:`383`). To encode file names during argument parsing, the ``"O&amp;"`` converter should be used, passsing :func:PyUnicode_FSConverter as the conversion function:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zakodować i odkodować nazwy plików inne napisy środowiskowe, :cdata:`Py_FileSystemEncoding` powinien być używany jako kodowanie i ``"surrogateescape"`` powinien być używany do obsługi błędów (zob. :pep:`383`). Aby zakodować nazwy plików w czasie przetwarzania parametrów, powinno się użyć konwertera ``"O&amp;"`` przekazując :func:`PyUnicode_FSConverter` jako zadanie konwersji:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>wchar_t Support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla wchar_t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>wchar_t support for platforms which support it:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla wchar_t dla maszyn które je wspierają:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wbudowane kodery/dekodery</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python provides a set of built-in codecs which are written in C for speed. All of these codecs are directly usable via the following functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski zapewnia zestaw wbudowanych koderów/dekoderów, które są napisane w języku C dla szybkości. Wszystkie te kodery/dekodery są bezpośrednio użyteczne przez następujące zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many of the following APIs take two arguments encoding and errors. These parameters encoding and errors have the same semantics as the ones of the built-in :func:`unicode` Unicode object constructor.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wiele z następujących sprzęgów pobiera dwa parametry kodowania i błędów. Te parametry kodowania i błędów mają tę samą składnię, co te dla wbudowanego konstruktora przedmiotu Unikodu - :func:`unicode`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting encoding to *NULL* causes the default encoding to be used which is ASCII.  The file system calls should use :cfunc:`PyUnicode_FSConverter` for encoding file names. This uses the variable :cdata:`Py_FileSystemDefaultEncoding` internally. This variable should be treated as read-only: On some systems, it will be a pointer to a static string, on others, it will change at run-time (such as when the application invokes setlocale).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustawienie kodowania na puste - z ang. - *NULL* powoduje użycie domyślnego kodowania którym jest ASCII. Odwołania systemu plików powinny używać :cfunc:`PyUnicode_FSConverter` dla kodowania nazw plików. To używa zmiennej :cdata:`Py_FileSystemDefaultEncoding wewnętrznie. Ta zmienna powinna być traktowana jak tylko-do-odczytu: Na niektórych maszynach, będzie ona wskaźnikiem do statycznego ciągu znaków, na innych będzie ulegać zmianie w czasie-wykonania-programu (ta, jak wtedy, gdy program wywołuje setlocale).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error handling is set by errors which may also be set to *NULL* meaning to use the default handling defined for the codec.  Default error handling for all built-in codecs is "strict" (:exc:`ValueError` is raised).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługa błędów jest ustawiana przez błędy które mogą także być ustawione na *NULL* co oznacza użycie domyślnego sposobu obsługi określonego dla kodera/dekodera. Domyślna obsługa błędów dla wszystkich wbudowanych koderów/dekoderów jest "ścisła" (podnoszony jest :exc:`ValueError`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The codecs all use a similar interface.  Only deviation from the following generic ones are documented for simplicity.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery wszystkie używają podobnego sprzęgu. Jedyne odstępstwa od następujących podstawowych są opisane dla uproszczenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generic Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery podstawowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the generic codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są podstawowe sprzęgi koderów/dekoderów (z ang. - API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-8 Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery UTF-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the UTF-8 codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera UTF-8 (z ang. - API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-32 Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery UTF-32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the UTF-32 codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera UTF-32 (z ang. - API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-16 Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery UTF-16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the UTF-16 codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera UTF-16 (z ang. - API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode-Escape Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/Dekodery ucieczkowych-sekwencji-Unikodu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the "Unicode Escape" codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera ucieczkowych-sekwencji-Unikodu (z ang. - API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raw-Unicode-Escape Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery surowych-sekwencji-ucieczkowych-Unikodu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the "Raw Unicode Escape" codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera "surowych sekwencji ucieczkowych Unikodu" (z ang. - API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Latin-1 Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery Latin-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 Unicode ordinals and only these are accepted by the codecs during encoding.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera Latin-1 (z ang. API): Latin-1 odpowiada pierwszym 256 znakom porządkowym Unikodu i tylko te są akceptowane przez kodery/dekodery podczas kodowania. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ASCII Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All other codes generate errors.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzegi koderów/dekoderów ASCII (z ang. API). Tylko 7-bitowe dane ASCII są akceptowane. Wszystkie inne kody generują błędy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Character Map Codecs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/Dekodery Mapy Znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the mapping codec APIs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera mapowania (z ang. API):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This codec is special in that it can be used to implement many different codecs (and this is in fact what was done to obtain most of the standard codecs included in the :mod:`encodings` package). The codec uses mapping to encode and decode characters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten koder/dekoder jest szczególny w tym że może być użyty do wypełnienia wielu różnych kederów/dekoderów (i to jest faktycznie to co uczyniono aby otrzymać większość ze standardowych koderów/dekoderów załączonych w pakiecie :mod:`encodings`). Koder/dekoder używa mapowania do zakodowania i zdekodowania znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decoding mappings must map single string characters to single Unicode characters, integers (which are then interpreted as Unicode ordinals) or None (meaning "undefined mapping" and causing an error).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Mapowania dekodujące muszą mapować pojedynczy ciąg znaków na pojedyncze znaki Unikodu, liczby całkowite (które są potem interpretowane jako liczby porządkowe Unikodu) lub Nic (z ang. - None) (oznaczające "niezdefiniowane mapowanie" i powodujące błąd).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encoding mappings must map single Unicode characters to single string characters, integers (which are then interpreted as Latin-1 ordinals) or None (meaning "undefined mapping" and causing an error).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Mapowania kodujące muszą mapować pojedyncze znaki Unikodu na pojedyncze ciągi znaków, liczby całkowite (które są potem interpretowane jako liczby porządkowe Latin-1) lub Nic ( z ang. None) (oznaczające "niezdefiniowane mapowanie" i powodujące błąd).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mapping objects provided must only support the __getitem__ mapping interface.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty mapujące dostarczane muszą tylko wspierać mapujący sprzęg __getitem__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a character lookup fails with a LookupError, the character is copied as-is meaning that its ordinal value will be interpreted as Unicode or Latin-1 ordinal resp. Because of this, mappings only need to contain those mappings which map characters to different code points.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli podgląd znaku zawiedzie z błędem podglądu z ang. - LookupError, znak jest kopiowany taki jaki jest to znaczy że jego wartość porządkowa zostanie zinterpretowana jako Unikod lub liczba porządkowa Latin-1 odpowiednio. Z tego powodu zbiór mapowań wymaga zawarcia w nim tylko tych mapowań, które mapują znaki do różnych punktów kodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following codec API is special in that maps Unicode to Unicode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący sprzęg kodera/dekodera (z ang. - API) jest szczególny gdyż mapuje Unikod na Unikod. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the MBCS codec APIs. They are currently only available on Windows and use the Win32 MBCS converters to implement the conversions.  Note that MBCS (or DBCS) is a class of encodings, not just one.  The target encoding is defined by the user settings on the machine running the codec.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To są sprzęgi kodera/dekodera MBCS Obecnie dostępne są one tylko na Windows i używają konwerterów MBCS Win32 aby wypełnić konwersje. Zauważ, że MBCS (lub DBCS) jest kategorią kodowań, nie tylko jednym z nich.  Docelowe kodowanie jest zdefiniowane przez ustawienia użytkownik na maszynie uruchamiającej koder/dekoder.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MBCS codecs for Windows</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery/dekodery MBCS w Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods &amp; Slots</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania i Gniazda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods and Slot Functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania i Zadania Gniazd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following APIs are capable of handling Unicode objects and strings on input (we refer to them as strings in the descriptions) and return Unicode objects or integers as appropriate.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sprzęgi (z ang. - API) są przydatne w posługiwaniu się przedmiotami Unikodu i ciągów znaków na wejściu (odwołujemy się do nich jako do ciągów w opisach) i zwracają przedmioty Unikodu lub liczby całkowite jako właściwe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They all return *NULL* or ``-1`` if an exception occurs.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie one zwracają *PUSTY* ( - z ang. - *NULL* ) lub ``-1`` jeśli nastąpi sytuacja wyjątkowa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Utilities</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użytki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The functions in this chapter perform various utility tasks, ranging from helping C code be more portable across platforms, using Python modules from C, and parsing function arguments and constructing Python values from C values.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania w tym rozdziale wykonują różne działania użytkowe, poczynając od pomagania kodowi C aby był bardziej przenośny pomiędzy maszynami, poprzez używanie modułów języka pytonowskiego z poziomu C, i przetwarzając parametry zadań i konstruując wartości języka pytonowskiego z wartości C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Very High Level Layer</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Warstwa Bardzo Wysokiego Poziomu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The functions in this chapter will let you execute Python source code given in a file or a buffer, but they will not let you interact in a more detailed way with the interpreter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania w tym rozdziale będą pozwalały Ci wykonywać kod w języku pytonowskim podany w pliku lub przestrzeni wymiany, ale nie pozwolą Ci współpracować w szczególny sposób z programem interpretującym polecenia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Several of these functions accept a start symbol from the grammar as a parameter.  The available start symbols are :const:`Py_eval_input`, :const:`Py_file_input`, and :const:`Py_single_input`.  These are described following the functions which accept them as parameters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kilka z tych zadań akceptuje symbol startowy z gramatyki jako parametr. Dostępnymi symbolami startowymi są :const:`Py_eval_input`, :const:`Py_file_input` i :const:`Py_single_input`. Są one opisane po zadaniach akceptujących je jako parametry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note also that several of these functions take :ctype:`FILE\*` parameters.  One particular issue which needs to be handled carefully is that the :ctype:`FILE` structure for different C libraries can be different and incompatible.  Under Windows (at least), it is possible for dynamically linked extensions to actually use different libraries, so care should be taken that :ctype:`FILE\*` parameters are only passed to these functions if it is certain that they were created by the same library that the Python runtime is using.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć także uwagę że kilka z tych zadań przyjmuje pliki - :ctype:`FILE\*` jako paramtery. Jedną szczególną sprawą którą trzeba traktować uważnie jest to, że struktura :ctype:`FILE` dla różnych bibliotek C może być różna i niezgodna. Pod Windows (przynajmniej) możliwe jest dla dynamicznie łączonych rozszerzeń użycie różnych bibliotek, więc powinno się zwrócić uwagę, aby parametry :ctype:`FILE\*` były przekazywane do tych zadań tylko gdy jest pewne że zostały utworzone przez tą samą bibliotekę której używa aktualnie wykonywany program interpretujący polecenia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Weak Reference Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Słabych Odniesień </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python supports *weak references* as first-class objects.  There are two specific object types which directly implement weak references.  The first is a simple reference object, and the second acts as a proxy for the original object as much as it can.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowskie wspiera *słabe odniesienia* jako przedmioty pierwszej-klasy. Istnieją dwa szczególne rodzaje przedmiotów które bezpośrednio wypełniają słabe odniesienia. Pierwszym jest prosty przedmiot odniesienia, a drugi działa jako przedmiot zastępczy dla pierwotnego przedmiotu na tyle na ile się da.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
