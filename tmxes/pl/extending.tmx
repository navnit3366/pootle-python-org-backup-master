<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.1.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Building C and C++ Extensions with distutils</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Budowanie Rozszerzeń C i C++ za pomocą distutils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting in Python 1.4, Python provides, on Unix, a special make file for building make files for building dynamically-linked extensions and custom interpreters.  Starting with Python 2.0, this mechanism (known as related to Makefile.pre.in, and Setup files) is no longer supported. Building custom interpreters was rarely used, and extension modules can be built using distutils.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poczynając od języka pytonowskiego w wersji 1.4 język pytonowski dostarcza w Unixie, szczególny plik make-file dla budowania plików make-file dla budowania dynamicznie-łączonych rozszerzeń i szczególnych programów interpretujących. Poczynając od wersji języka pytonowskiego 2.0, ten mechanizm (znany jako związany z Makefile.pre.in, i plikami instalacyjnymi) nie jest już wspierany. Budowanie szczególnych programów interpretujących było rzadko używane, i moduły rozszerzające mogą być budowane przy użyciu distutils.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building an extension module using distutils requires that distutils is installed on the build machine, which is included in Python 2.x and available separately for Python 1.5. Since distutils also supports creation of binary packages, users don't necessarily need a compiler and distutils to install the extension.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Budowanie modułu rozszerzającego przy użyciu distutils wymaga aby distutils było zainstalowane na maszynie budującej, co jest załączone w wersjach języka pytonowskiego 2.x i dostępne oddzielnie dla języka pytonowskiego w wersji 1.5 Od kiedy distutils także wspiera tworzenie pakietów binarnych, użytkownicy nie muszą koniecznie potrzebować kompilatora i distutils aby zainstalować rozszerzenie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A distutils package contains a driver script, :file:`setup.py`. This is a plain Python file, which, in the most simple case, could look like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pakiet distutils zawiera skrypt sterownika, :file:`setup.py`. To jest czysto pytonowski plik, który w najprostszym przypadku, może wyglądać następująco::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup, Extension  module1 = Extension('demo',                     sources = ['demo.c'])  setup (name = 'PackageName',        version = '1.0',        description = 'This is a demo package',        ext_modules = [module1])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup, Extension  module1 = Extension('demo',                     sources = ['demo.c'])  setup (name = 'NazwaPakietu',        version = '1.0',        description = 'To jest pakiet demo',        ext_modules = [module1])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this :file:`setup.py`, and a file :file:`demo.c`, running ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Z tym plikiem :file:`setup.py`, i plikiem :file:`demo.c`, uruchomienie ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py build</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py build</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will compile :file:`demo.c`, and produce an extension module named ``demo`` in the :file:`build` directory. Depending on the system, the module file will end up in a subdirectory :file:`build/lib.system`, and may have a name like :file:`demo.so` or :file:`demo.pyd`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>skompiluje plik :file:`demo.c`, i wytworzy moduł rozszerzający nazwany ``demo`` w katalogu :file:`build`. W zależności od systemu plik modułu wyląduje w podkatalogu :file:`build/lib.system` i może mieć nazwę taką, jak :file:`demo.so` lub :file:`demo.pyd`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the :file:`setup.py`, all execution is performed by calling the ``setup`` function. This takes a variable number of keyword arguments, of which the example above uses only a subset. Specifically, the example specifies meta-information to build packages, and it specifies the contents of the package.  Normally, a package will contain of addition modules, like Python source modules, documentation, subpackages, etc. Please refer to the distutils documentation in :ref:`distutils-index` to learn more about the features of distutils; this section explains building extension modules only.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W pliku :file:`setup.py`, wszystkie operacje są wykonywane przez wywołanie zadania ``setup``. To pobiera zmienną liczbę kluczowych parametrów, z których przykład powyższy używa tylko podzbioru. Szczególnie, przykład określa informacje pośrednie aby zbudować pakiety, i określa zawartość pakietu. Zwykle pakiet będzie zawierał dodatek modułów takich jak moduły źródłowe języka pytonowskiego, dokumentację, podpakiety, itp. Uprasza się o zajrzenie do dokumentacji distutils do :ref:`distutils-index` aby dowiedzieć się więcej o właściwościach distutils; ten rozdział wyjaśnia tylko budowanie modułów rozszerzeń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is common to pre-compute arguments to :func:`setup`, to better structure the driver script. In the example above, the\ ``ext_modules`` argument to :func:`setup` is a list of extension modules, each of which is an instance of the :class:`Extension`. In the example, the instance defines an extension named ``demo`` which is build by compiling a single source file, :file:`demo.c`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest często spotykane aby uprzednio obliczać parametry dla zadania :func:`setup`, aby lepiej rozłożyć skrypt sterownika. W przykładzie powyższym parametr \ ``ext_modules`` dla zadania :func:`setup` jest listą rozszerzających modułów, z których każdy jest przykładem uogólnienia :class:`Extension`. W tym przypadku, przykład definiuje rozszerzenie nazwane ``demo`` które jest budowane przez skompilowanie pojedynczego pliku źródłowego, :file:`demo.c`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In many cases, building an extension is more complex, since additional preprocessor defines and libraries may be needed. This is demonstrated in the example below. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W wielu przypadkach, budowanie rozszerzenia jest bardziej skomplikowane, gdyż dodatkowe definicje preprocesora i biblioteki mogą być potrzebne. To jest demonstrowane w przykładzie poniżej. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup, Extension  module1 = Extension('demo',                     define_macros = [('MAJOR_VERSION', '1'),                                      ('MINOR_VERSION', '0')],                     include_dirs = ['/usr/local/include'],                     libraries = ['tcl83'],                     library_dirs = ['/usr/local/lib'],                     sources = ['demo.c'])  setup (name = 'PackageName',        version = '1.0',        description = 'This is a demo package',        author = 'Martin v. Loewis',        author_email = 'martin@v.loewis.de',        url = 'http://docs.python.org/extending/building',        long_description = ''' This is really just a demo package. ''',        ext_modules = [module1])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup, Extension  module1 = Extension('demo',                     define_macros = [('MAJOR_VERSION', '1'),                                      ('MINOR_VERSION', '0')],                     include_dirs = ['/usr/local/include'],                     libraries = ['tcl83'],                     library_dirs = ['/usr/local/lib'],                     sources = ['demo.c'])  setup (name = 'NazwaPakietu',        version = '1.0',        description = 'To jest pakiet demo',        author = 'Martin v. Loewis',        author_email = 'martin@v.loewis.de',        url = 'http://docs.python.org/extending/building',        long_description = ''' To jest na prawdę tylko pakiet demo. ''',        ext_modules = [module1])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, :func:`setup` is called with additional meta-information, which is recommended when distribution packages have to be built. For the extension itself, it specifies preprocessor defines, include directories, library directories, and libraries. Depending on the compiler, distutils passes this information in different ways to the compiler. For example, on Unix, this may result in the compilation commands ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym przykładzie, zadanie :func:`setup` jest wywoływane z dodatkowymi informacjami pośrednimi, co jest zalecane gdy pakiety dystrybucji maja być zbudowane. Dla tego rozszerzenia samego w sobie, określa ona definicje preprocesora, katalogi załączane, katalogi bibliotek, i biblioteki. W zależności od kompilatora, distutils przekazuje tą informację w różny sposób kompilatorowi. Na przykład w Unix-ie, to może dawać rezultat poleceń kompilacji ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gcc -DNDEBUG -g -O3 -Wall -Wstrict-prototypes -fPIC -DMAJOR_VERSION=1 -DMINOR_VERSION=0 -I/usr/local/include -I/usr/local/include/python2.2 -c demo.c -o build/temp.linux-i686-2.2/demo.o  gcc -shared build/temp.linux-i686-2.2/demo.o -L/usr/local/lib -ltcl83 -o build/lib.linux-i686-2.2/demo.so</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gcc -DNDEBUG -g -O3 -Wall -Wstrict-prototypes -fPIC -DMAJOR_VERSION=1 -DMINOR_VERSION=0 -I/usr/local/include -I/usr/local/include/python2.2 -c demo.c -o build/temp.linux-i686-2.2/demo.o  gcc -shared build/temp.linux-i686-2.2/demo.o -L/usr/local/lib -ltcl83 -o build/lib.linux-i686-2.2/demo.so</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These lines are for demonstration purposes only; distutils users should trust that distutils gets the invocations right.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te linie są dla celów demonstracyjnych tylko i wyłącznie; użytkownicy distutils powinni ufać że distutils wystosuje właściwe odwołania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distributing your extension modules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozprowadzanie swoich modułów rozszerzających</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an extension has been successfully build, there are three ways to use it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kiedy rozszerzenie zostało z powodzeniem zbudowane, są trzy sposoby aby go użyć.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>End-users will typically want to install the module, they do so by running ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użytkownicy końcowi będą najczęściej chcieć zainstalować moduł, będą mogli to zrobić uruchamiając ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py install</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Module maintainers should produce source packages; to do so, they run ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zarządcy modułów powinni wyprodukować źródłowe pakiety; aby tego dokonać, uruchomią oni ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py sdist</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py sdist</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, additional files need to be included in a source distribution; this is done through a :file:`MANIFEST.in` file; see the distutils documentation for details.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W niektórych przypadkach, dodatkowe pliki są potrzebne w dystrybucji źródłowej; tego dokonuje się przez plik :file:`MANIFEST.in`; sięgnij do dokumentacji distutils po więcej szczegółów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the source distribution has been build successfully, maintainers can also create binary distributions. Depending on the platform, one of the following commands can be used to do so. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli dystrybucja źródłowa została zbudowana szczęśliwie, zarządcy mogą także tworzyć dystrybucje binarne. W zależności od środowiska/maszyny, jedna z następujących komend może być użyta aby tego dokonać. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>python setup.py bdist_wininst python setup.py bdist_rpm python setup.py bdist_dumb</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>python setup.py bdist_wininst python setup.py bdist_rpm python setup.py bdist_dumb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedding Python in Another Application</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Załączanie języka pytonowskiego w innej aplikacji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous chapters discussed how to extend Python, that is, how to extend the functionality of Python by attaching a library of C functions to it.  It is also possible to do it the other way around: enrich your C/C++ application by embedding Python in it.  Embedding provides your application with the ability to implement some of the functionality of your application in Python rather than C or C++. This can be used for many purposes; one example would be to allow users to tailor the application to their needs by writing some scripts in Python.  You can also use it yourself if some of the functionality can be written in Python more easily.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poprzednie rozdziały opisywały jak rozszerzać język pytonowski, to jest, jak rozszerzać zdolności działania języka pytonowskiego przez dołączanie biblioteki zadań C do niego. Jest także możliwe robienie tego w drugą stronę: wzbogacić twoją aplikcję C/C++ przez załączenie pytona w niej. Załączanie dostarcza twojej aplikacji zdolność wypełnienia niektórych zadań twojej aplikacji w języku pytonowskim zamiast w C lub C++. To może zostać wykorzystane w wielu celach; jednym z przykładów byłoby pozwolenie innym użytkownikom dostosowanie aplikacji do swoich potrzeb przez napisanie pewnych skryptów w języku pytonowskim. Możesz też użyć tego samodzielnie jeśli niektóre z zadań mogą być napisane w języku pytonowskim nieco łatwiej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedding Python is similar to extending it, but not quite.  The difference is that when you extend Python, the main program of the application is still the Python interpreter, while if you embed Python, the main program may have nothing to do with Python --- instead, some parts of the application occasionally call the Python interpreter to run some Python code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Załączanie języka pytonowskiego jest podobne do rozszerzania go, ale nie całkiem. Różnica polega na tym, że gdy rozszerzasz język pytonowski, głównym programem aplikacji jest wciąż program interpretujący polecenia języka pytonowskiego, podczas gdy jeśli załączasz język pytonowski, główny program może nie mieć nic wspólnego z językiem pytonowskim --- zamiast tego, niektóre części aplikacji czasami wzywają program interpretujący polecenia języka pytonowskiego aby uruchomić pewien kod języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you are embedding Python, you are providing your own main program.  One of the things this main program has to do is initialize the Python interpreter.  At the very least, you have to call the function :cfunc:`Py_Initialize`.  There are optional calls to pass command line arguments to Python.  Then later you can call the interpreter from any part of the application.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Więc jeśli załączasz język pytonowski, dostarczasz wtedy swój własny program główny. Jedną z rzeczy którą ten program główny musi zrobić jest zainicjować program interpretujący polecenia języka pytonowskiego. Na sam koniec, trzeba wywołać zadanie :cfunc:`Py_Initialize`. Istnieją opcjonalne wywołania aby przekazać parametry wiersza polecenia dla języka pytonowskiego. Potem później możesz odwołać się do programu interpretującego polecenia języka pytonowskiego z każdej części aplikacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several different ways to call the interpreter: you can pass a string containing Python statements to :cfunc:`PyRun_SimpleString`, or you can pass a stdio file pointer and a file name (for identification in error messages only) to :cfunc:`PyRun_SimpleFile`.  You can also call the lower-level operations described in the previous chapters to construct and use Python objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje kilka różnych sposobów aby wywołać program interpretujący polecenia języka pytonowskiego: możesz przekazać ciąg znaków zawierający wyrażenia języka pytonowskiego do zadania :cfunc:`PyRun_SimpleString`, lub możesz przekazać wskaźnik pliku stdio i nazwę pliku (tylko dla rozróżnienia w wiadomościach o błędach) dla zadania :cfunc:`PyRun_SimpleFile`. Możesz także wywołać nisko-poziomowe operacje opisane w poprzednich rozdziałach aby tworzyć i używać przedmiotów języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simple demo of embedding Python can be found in the directory :file:`Demo/embed/` of the source distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Proste demo załączania języka pytonowskiego może być znalezione w katalogu :file:`Demo/embed/` źródłowej dystrybucji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz także</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The details of Python's C interface are given in this manual. A great deal of necessary information can be found here.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Szczegóły sprzęgu C języka pytonowskiego są dane w tym podręczniku. Większość koniecznych informacji może być znaleziona tutaj.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very High Level Embedding</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bardzo wysokiego poziomu załączanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest form of embedding Python is the use of the very high level interface. This interface is intended to execute a Python script without needing to interact with the application directly. This can for example be used to perform some operation on a file. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Najprostszy sposób załączania języka pytonowskiego polega na tym, aby użyć sprzęgu bardzo wysokiego poziomu. Ten sprzęg jest przeznaczony aby wykonać skrypt języka pytonowskiego bez potrzeby współdziałania z aplikacją bezpośrednio. To może dla przykładu być użyte aby wykonać pewne operacje na pliku. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt;  int main(int argc, char *argv[]) {   Py_Initialize();   PyRun_SimpleString("from time import time,ctime\n"                      "print('Today is', ctime(time()))\n");   Py_Finalize();   return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt;  int main(int argc, char *argv[]) {   Py_Initialize();   PyRun_SimpleString("from time import time,ctime\n"                      "print('Dziś jest', ctime(time()))\n");   Py_Finalize();   return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above code first initializes the Python interpreter with :cfunc:`Py_Initialize`, followed by the execution of a hard-coded Python script that print the date and time.  Afterwards, the :cfunc:`Py_Finalize` call shuts the interpreter down, followed by the end of the program.  In a real program, you may want to get the Python script from another source, perhaps a text-editor routine, a file, or a database.  Getting the Python code from a file can better be done by using the :cfunc:`PyRun_SimpleFile` function, which saves you the trouble of allocating memory space and loading the file contents.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Powyższy kod najpierw inicjuje program interpretujący polecenia języka pytonowskiego za pomocą zadania :cfunc:`Py_Initialize` po którym następuje wykonanie skryptu zakodowanego na sztywno który wypisuje datę i czas. Po wszystkim, odwołanie :cfunc:`Py_Finalize` zamyka program interpretujący polecenia języka pytonowskiego, po którym następuje koniec programu. W rzeczywistym programie, możesz chcieć pobrać skrypt języka pytonowskiego z innego źródła, być może ze sposobu postępowania edytora-tekstu, pliku, lub bazy danych. Pobranie kodu języka pytonowskiego z pliku może być lepiej zrobione przez użycie zadania :cfunc:`PyRun_SimpleFile`, które ratuje cię przed trudami lokowania przestrzeni w pamięci i ładowania zawartości pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond Very High Level Embedding: An overview</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poza bardzo wysokiego poziomu załączaniem: Przegląd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The high level interface gives you the ability to execute arbitrary pieces of Python code from your application, but exchanging data values is quite cumbersome to say the least. If you want that, you should use lower level calls. At the cost of having to write more C code, you can achieve almost anything.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg wysokiego poziomu daje ci możliwość wykonania zadanych kawałków kodu języka pytonowskiego ze swojej aplikacji, ale wymiana wartości danych jest całkiem kłopotliwa, prawdę powiedziawszy. Jeśli tego oczekujesz powinieneś użyć niższego poziomu wywołań. Kosztem konieczności pisania większej ilości kodu C, możesz osiągnąć prawie wszystko.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should be noted that extending Python and embedding Python is quite the same activity, despite the different intent. Most topics discussed in the previous chapters are still valid. To show this, consider what the extension code from Python to C really does:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Powinno się zauważyć, że rozszerzanie języka pytonowskiego i wstawianie języka pytonowskiego jest prawie całkiem taką samą działalnością, z wyjątkiem odmienności celów. Większość tematów rozważanych w poprzednich rozdziałach jest wciąż poprawna. Aby to pokazać, rozważ co kod rozszerzający z języka pytonowskiego do C robi naprawdę:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert data values from Python to C,</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konwertuj wartości danych z języka pytonowskiego do C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform a function call to a C routine using the converted values, and</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj odwołanie do zadania C używając zamienionych wartości, i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the data values from the call from C to Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień wartości danych z wywołania z C do języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When embedding Python, the interface code does:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy załączasz język pytonowski, kod sprzęgający wykonuje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert data values from C to Python,</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia wartości danych z C do języka pytonowskiego,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform a function call to a Python interface routine using the converted values, and</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj wywołanie zadania do sprzęgu języka pytonowskiego używając zamienionych wartości, i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the data values from the call from Python to C.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień wartości danych z odwołania z języka pytonowskiego do C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, the data conversion steps are simply swapped to accommodate the different direction of the cross-language transfer. The only difference is the routine that you call between both data conversions. When extending, you call a C routine, when embedding, you call a Python routine.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak możesz się zorientować, kroki zamiany danych są po prostu zamienione aby umożliwić odwrócenie kierunku między-językowego transferu. Jedyną różnicą jest zadanie które wywoływane jest pomiędzy obiema zamianami danych. Gdy rozszerzasz, wywołujesz zadanie C, gdy załączasz, wywołujesz zadanie języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter will not discuss how to convert data from Python to C and vice versa.  Also, proper use of references and dealing with errors is assumed to be understood.  Since these aspects do not differ from extending the interpreter, you can refer to earlier chapters for the required information.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział nie będzie rozważał jak zamienić dane z języka pytonowskiego do C i w przeciwnym kierunku. Także właściwe użycie odniesień i obsługa błędów zakłada się że jest znajoma. Jako że te sprawy nie różnią się od rozszerzania programu interpretującego polecenia języka pytonowskiego, możesz odnieść się do wcześniejszych rozdziałów po wymagane informacje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pure Embedding</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czyste załączanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first program aims to execute a function in a Python script. Like in the section about the very high level interface, the Python interpreter does not directly interact with the application (but that will change in the next section).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwszy program ma na celu wykonanie zadania w skrypcie języka pytonowskiego. Jak w rozdziale o sprzęgu bardzo wysokiego poziomu, program interpretujący polecenia języka pytonowskiego bezpośrednio nie oddziałuje z aplikacją (ale to się zmieni w następnym rozdziale).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code to run a function defined in a Python script is:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kod służący uruchomieniu zadania określonego w skrypcie języka pytonowskiego to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt;  int main(int argc, char *argv[]) {     PyObject *pName, *pModule, *pDict, *pFunc;     PyObject *pArgs, *pValue;     int i;      if (argc &lt; 3) {         fprintf(stderr,"Usage: call pythonfile funcname [args]\n");         return 1;     }      Py_Initialize();     pName = PyUnicode_FromString(argv[1]);     /* Error checking of pName left out */      pModule = PyImport_Import(pName);     Py_DECREF(pName);      if (pModule != NULL) {         pFunc = PyObject_GetAttrString(pModule, argv[2]);         /* pFunc is a new reference */          if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {             pArgs = PyTuple_New(argc - 3);             for (i = 0; i &lt; argc - 3; ++i) {                 pValue = PyLong_FromLong(atoi(argv[i + 3]));                 if (!pValue) {                     Py_DECREF(pArgs);                     Py_DECREF(pModule);                     fprintf(stderr, "Cannot convert argument\n");                     return 1;                 }                 /* pValue reference stolen here: */                 PyTuple_SetItem(pArgs, i, pValue);             }             pValue = PyObject_CallObject(pFunc, pArgs);             Py_DECREF(pArgs);             if (pValue != NULL) {                 printf("Result of call: %ld\n", PyLong_AsLong(pValue));                 Py_DECREF(pValue);             }             else {                 Py_DECREF(pFunc);                 Py_DECREF(pModule);                 PyErr_Print();                 fprintf(stderr,"Call failed\n");                 return 1;             }         }         else {             if (PyErr_Occurred())                 PyErr_Print();             fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);         }         Py_XDECREF(pFunc);         Py_DECREF(pModule);     }     else {         PyErr_Print();         fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);         return 1;     }     Py_Finalize();     return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt;  int main(int argc, char *argv[]) {     PyObject *pName, *pModule, *pDict, *pFunc;     PyObject *pArgs, *pValue;     int i;      if (argc &lt; 3) {         fprintf(stderr,"Użycie: wywołaj plikpytona nazwazadania [parametry]\n");         return 1;     }      Py_Initialize();     pNazwa = PyUnicode_FromString(argv[1]);     /* Sprawdzanie błędu pNazwy pomienięte */      pModule = PyImport_Import(pNazwa);     Py_DECREF(pNazwa);      if (pModule != NULL) {         pFunc = PyObject_GetAttrString(pModule, argv[2]);         /* pFunc jest nowym odniesieniem */          if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {             pArgs = PyTuple_New(argc - 3);             for (i = 0; i &lt; argc - 3; ++i) {                 pValue = PyLong_FromLong(atoi(argv[i + 3]));                 if (!pValue) {                     Py_DECREF(pArgs);                     Py_DECREF(pModule);                     fprintf(stderr, "Nie mogę zamienić parametrów\n");                     return 1;                 }                 /* odniesienie do pValue kradzione tutaj: */                 PyTuple_SetItem(pArgs, i, pValue);             }             pValue = PyObject_CallObject(pFunc, pArgs);             Py_DECREF(pArgs);             if (pValue != NULL) {                 printf("Wynik wywołania: %ld\n", PyLong_AsLong(pValue));                 Py_DECREF(pValue);             }             else {                 Py_DECREF(pFunc);                 Py_DECREF(pModule);                 PyErr_Print();                 fprintf(stderr,"Wywołanie zawiodło\n");                 return 1;             }         }         else {             if (PyErr_Occurred())                 PyErr_Print();             fprintf(stderr, "Nie mogę znaleźć zadania \"%s\"\n", argv[2]);         }         Py_XDECREF(pFunc);         Py_DECREF(pModule);     }     else {         PyErr_Print();         fprintf(stderr, "Nieudane ładowanie \"%s\"\n", argv[1]);         return 1;     }     Py_Finalize();     return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code loads a Python script using ``argv[1]``, and calls the function named in ``argv[2]``.  Its integer arguments are the other values of the ``argv`` array.  If you compile and link this program (let's call the finished executable :program:`call`), and use it to execute a Python script, such as::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten kod ładuje skrypt języka pytonowskiego używając ``argv[1]``, i wywołuje zadanie nazwane w ``argv[2]``. Jego całkowitymi parametrami są inne wartości tablicy ``argv``. Jeśli skompilujesz i podłączysz ten program (nazwijmy skończony plik wykonywalny :program:`wywołaniem` - z ang. - :program:`call`) i użyjemy go do wywołania skryptu języka pytonowskiego, takiego jak::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def multiply(a,b):     print("Will compute", a, "times", b)     c = 0     for i in range(0, a):         c = c + b     return c</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def mnozenie(a,b):     print("Policzy", a, "razy", b)     c = 0     for i in range(0, a):         c = c + b     return c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>then the result should be::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wtedy wynik powinien być::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ call multiply multiply 3 2 Will compute 3 times 2 Result of call: 6</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ wywolanie mnozenie mnozenie 3 2 Policzy 3 razy 2 Wynik wywołania: 6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the program is quite large for its functionality, most of the code is for data conversion between Python and C, and for error reporting.  The interesting part with respect to embedding Python starts with ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Chociaż program jest całkiem spory jak na jego skromne działanie, większość kodu jest dla zamiany danych pomiędzy językiem pytonowskim i C, i dla zgłaszania błędów. Interesująca część z punktu widzenia załączania języka pytonowskiego zaczyna się od::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_Initialize(); pName = PyString_FromString(argv[1]); /* Error checking of pName left out */ pModule = PyImport_Import(pName);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_Initialize(); pNazwa = PyString_FromString(argv[1]); /* Sprawdzanie błędów pNazwa pominięte */ pModule = PyImport_Import(pNazwa);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After initializing the interpreter, the script is loaded using :cfunc:`PyImport_Import`.  This routine needs a Python string as its argument, which is constructed using the :cfunc:`PyString_FromString` data conversion routine. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Po zainicjowaniu interpretera, skrypt jest ładowany używając :cfunc:`PyImport_Import`. To zadanie wymaga ciągu znaków języka  pytonowskiego jako jego parametru, które są tworzone używając :cfunc:`PyString_FromString` zadania zamiany  danych. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pFunc = PyObject_GetAttrString(pModule, argv[2]); /* pFunc is a new reference */  if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {     ... } Py_XDECREF(pFunc);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pFunc = PyObject_GetAttrString(pModule, argv[2]); /* pFunc jest nowym odniesieniem */  if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {     ... } Py_XDECREF(pFunc);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the script is loaded, the name we're looking for is retrieved using :cfunc:`PyObject_GetAttrString`.  If the name exists, and the object returned is callable, you can safely assume that it is a function.  The program then proceeds by constructing a tuple of arguments as normal.  The call to the Python function is then made with::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy skrypt jest załadowany, nazwa na którą patrzymy jest pobierana używając :cfunc:`PyObject_GetAttrString`. Jeśli nazwa istnieje, i przedmiot zwracany jest wywoływalny, można bezpiecznie założyć że jest on zadaniem. Program potem postępuje naprzód tworząc dwójkę parametrów w zwyczajny sposób. Wywołanie zadania języka pytonowskiego jest potem wykonywane za pomocą::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pValue = PyObject_CallObject(pFunc, pArgs);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pValue = PyObject_CallObject(pFunc, pArgs);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Upon return of the function, ``pValue`` is either *NULL* or it contains a reference to the return value of the function.  Be sure to release the reference after examining the value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na powrót z zadania, ``pValue`` jest albo *pusta* - z ang. - *NULL* albo zawiera odniesienia do wartości zwracanej z zadania. Upewnij się że uwalniasz odniesienie po przetestowaniu wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending Embedded Python</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerzanie załączonego języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, the embedded Python interpreter had no access to functionality from the application itself.  The Python API allows this by extending the embedded interpreter.  That is, the embedded interpreter gets extended with routines provided by the application. While it sounds complex, it is not so bad.  Simply forget for a while that the application starts the Python interpreter.  Instead, consider the application to be a set of subroutines, and write some glue code that gives Python access to those routines, just like you would write a normal Python extension.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak dotąd, załączony program interpretujący polecenia języka pytonowskiego nie miał dostępu do zadań samej aplikacji. Sprzęg języka pytonowskiego pozwala na to przez rozszerzanie załączonego programu interpretującego polecenia języka pytonowskiego. To jest, załączony program interpretujący polecenia języka pytonowskiego poszerza się przez zadania dostarczone przez aplikację. Podczas gdy brzmi to skomplikowanie, nie jest to takie straszne. Po prostu zapomnij na chwilę, że aplikacja uruchamia program interpretujący polecenia języka pytonowskiego. Zamiast tego, rozważ, że aplikacja jest zbiorem podzadań i napisz trochę kodu lepiącego który daje dostęp do tych zadań, tak jakbyś pisał zwykłe rozszerzenia. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int numargs=0;  /* Return the number of arguments of the application command line */ static PyObject* emb_numargs(PyObject *self, PyObject *args) {     if(!PyArg_ParseTuple(args, ":numargs"))         return NULL;     return Py_BuildValue("i", numargs); }  static PyMethodDef EmbMethods[] = {     {"numargs", emb_numargs, METH_VARARGS,      "Return the number of arguments received by the process."},     {NULL, NULL, 0, NULL} };  static PyModuleDef EmbModule = {     PyModuleDef_HEAD_INIT, "emb", NULL, -1, EmbMethods,     NULL, NULL, NULL, NULL };  static PyObject* PyInit_emb(void) {     return PyModule_Create(&amp;EmbModule); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int numargs=0;  /* Zwróć liczbę parametrów wiersza poleceń aplikacji */ static PyObject* emb_numargs(PyObject *self, PyObject *args) {     if(!PyArg_ParseTuple(args, ":numargs"))         return NULL;     return Py_BuildValue("i", numargs); }  static PyMethodDef EmbMethods[] = {     {"numargs", emb_numargs, METH_VARARGS,      "Zwróć liczbę parametrów otrzymaną przez proces."},     {NULL, NULL, 0, NULL} };  static PyModuleDef EmbModule = {     PyModuleDef_HEAD_INIT, "emb", NULL, -1, EmbMethods,     NULL, NULL, NULL, NULL };  static PyObject* PyInit_emb(void) {     return PyModule_Create(&amp;EmbModule); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert the above code just above the :cfunc:`main` function. Also, insert the following two statements before the call to :cfunc:`Py_Initialize`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wstaw powyższy kod tuż powyżej zadania :cfunc:`main`. Także, wstaw następujące dwa wyrażenia przed odwołaniem do :cfunc:`Py_Initialize`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>numargs = argc; PyImport_AppendInittab("emb", &amp;PyInit_emb);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>numargs = argc; PyImport_AppendInittab("emb", &amp;PyInit_emb);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two lines initialize the ``numargs`` variable, and make the :func:`emb.numargs` function accessible to the embedded Python interpreter. With these extensions, the Python script can do things like ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te dwie linie inicjują zmienną ``numargs``, i czynią zadanie :func:`emb.numargs` dostępnym dla załączonego programu interpretującego polecenia języka pytonowskiego. Z tymi rozszerzeniami, skrypt języka pytonowskiego może zrobić rzeczy takie jak::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import emb print("Number of arguments", emb.numargs())</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import emb print("Liczba parametrów", emb.numargs())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a real application, the methods will expose an API of the application to Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W realnej aplikacji, sposoby postępowania wystawią sprzęg aplikacji dla języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedding Python in C++</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Załączanie języka pytonowskiego w języku C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to embed Python in a C++ program; precisely how this is done will depend on the details of the C++ system used; in general you will need to write the main program in C++, and use the C++ compiler to compile and link your program.  There is no need to recompile Python itself using C++.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest także możliwe załączanie języka pytonowskiego w programie C++; dokładnie jak to jest robione zależy od szczegółów systemu C++ będącego w użyciu; Co do zasady, będziesz musiał napisać program główny w C++, i użyć kompilatora C++ aby skompilować i podłączyć twój program. Nie ma konieczności ponownej kompilacji języka pytonowskiego samego w sobie przy użyciu języka C++. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Linking Requirements</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wymagania dołączania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the :program:`configure` script shipped with the Python sources will correctly build Python to export the symbols needed by dynamically linked extensions, this is not automatically inherited by applications which embed the Python library statically, at least on Unix.  This is an issue when the application is linked to the static runtime library (:file:`libpython.a`) and needs to load dynamic extensions (implemented as :file:`.so` files).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podczas gdy skrypt :program:`configure` dostarczony ze źródłowym kodem języka pytonowskiego będzie poprawnie budował język pytonowski aby wystawiał na zewnątrz symbole potrzebne dla dynamicznie dołączanych rozszerzeń, to nie jest automatycznie dziedziczone przez aplikacje które załączają bibliotekę języka pytonowskiego statycznie, przynajmniej w Unix-ie. To jest problemem gdy aplikacja jest dołączana do statycznej biblioteki czasu wykonania (:file:`libpython.a`) i potrzebuje załadować dynamiczne rozszerzenia (wypełnione jako pliki :file:`.so`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The problem is that some entry points are defined by the Python runtime solely for extension modules to use.  If the embedding application does not use any of these entry points, some linkers will not include those entries in the symbol table of the finished executable.  Some additional options are needed to inform the linker not to remove these symbols.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Problem polega na tym, że niektóre punkty wejścia są definiowane przez program języka pytonowskiego w czasie jego wykonania jedynie dla rozszerzających modułów dla użycia. Jeśli załączająca aplikacja nie używa żadnych z tych punktów wejścia, niektóre programy dołączające nie dołączą tych wpisów w tabeli symboli ukończonego pliku programu. Niektóre dodatkowe opcje są wymagane aby poinformować program łączący aby nie usuwać tych symboli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Determining the right options to use for any given platform can be quite difficult, but fortunately the Python configuration already has those values. To retrieve them from an installed Python interpreter, start an interactive interpreter and have a short session like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określenie właściwych opcji do użycia dla każdej danej maszyny/środowiska może być raczej trudne, ale na szczęście konfiguracja języka pytonowskiego od razu ma te wartości. Aby otrzymać je z zainstalowanego programu interpretującego polecenia języka pytonowskiego, uruchom współdziałający z użytkownikiem program interpretujący polecenia języka pytonowskiego i weź krótką sesję taką jak ta::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import distutils.sysconfig &gt;&gt;&gt; distutils.sysconfig.get_config_var('LINKFORSHARED') '-Xlinker -export-dynamic'</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import distutils.sysconfig &gt;&gt;&gt; distutils.sysconfig.get_config_var('LINKFORSHARED') '-Xlinker -export-dynamic'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The contents of the string presented will be the options that should be used. If the string is empty, there's no need to add any additional options.  The :const:`LINKFORSHARED` definition corresponds to the variable of the same name in Python's top-level :file:`Makefile`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zawartość ciągu znaków prezentowanego będzie opcjami które powinny być użyte. Jeśli ciąg znaków jest pusty, nie ma potrzeby dodawać żadnych dodatkowych opcji. Definicja :const:`LINKFORSHARED` odpowiada zmiennej o tej samej nazwie w nadrzędnym pliku :file:`Makefile` języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending Python with C or C++</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerzanie języka pytonowskiego za pomocą C lub C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is quite easy to add new built-in modules to Python, if you know how to program in C.  Such :dfn:`extension modules` can do two things that can't be done directly in Python: they can implement new built-in object types, and they can call C library functions and system calls.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest całkiem łatwo dodać nowe wbudowane moduły do języka pytonowskiego, jeśli znasz się na programowaniu w C. Takie :dfn:`moduły rozszerzające` - z ang. - :dfn:`extension modules` mogą zrobić dwie rzeczy których nie da się zrobić bezpośrednio w języku pytonowskim: mogą wypełnić nowe wbudowane typy przedmiotów i mogą odwołać się do zadań bibliotecznych C i odwołań systemowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To support extensions, the Python API (Application Programmers Interface) defines a set of functions, macros and variables that provide access to most aspects of the Python run-time system.  The Python API is incorporated in a C source file by including the header ``"Python.h"``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby wspierać rozszerzenia, sprzęg programowania języka pytonowskiego API - z ang. (Application Programmers Interface) określa zbiór zadań, makropoleceń i zmiennych które dostarczają dostęp do większości aspektów systemu czasu-wykonania języka pytonowskiego. Sprzęg programowania języka pytonowskiego jest załączany w źródłowym pliku C przez załączenie pliku nagłówkowego ``"Python.h"``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The compilation of an extension module depends on its intended use as well as on your system setup; details are given in later chapters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompilacja rozszerzających modułów zależy od jego zamierzonego użycia zarówno jak też od ustawień twojego systemu; szczegóły są dane w późniejszych rozdziałach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do note that if your use case is calling C library functions or system calls, you should consider using the :mod:`ctypes` module rather than writing custom C code. Not only does :mod:`ctypes` let you write Python code to interface with C code, but it is more portable between implementations of Python than writing and compiling an extension module which typically ties you to CPython.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że jeśli twoim przypadkiem użycia jest wezwanie zadania z biblioteki lub wywołanie systemowe, powinieneś/powinnaś rozważyć użycie modułu :mod:`ctypes` raczej zamiast pisać dostosowawczy kod C. Moduł :mod:`ctypes` pozwala nie tylko pisać kod w języku pytonowskim do sprzęgania się z kodem C, ale także jest bardziej przenośny pomiędzy wypełnieniami języka pytonowskiego niż pisanie i kompilowanie modułów rozszerzeń które typowo łączą cię z CPythonem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Simple Example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Prosty przykład</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an extension module called ``spam`` (the favorite food of Monty Python fans...) and let's say we want to create a Python interface to the C library function :cfunc:`system`. [#]_ This function takes a null-terminated character string as argument and returns an integer.  We want this function to be callable from Python as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stwórzmy rozszerzający moduł nazwany ``spam`` (ulubione danie fanów Monty Pytona...) i powiedzmy że chcemy stworzyć sprzęg języka pytonowskiego z bibliotecznym zadaniem C :cfunc:`system`. [#]_ To zadanie pobiera zakończony zerem ciąg znaków jako parametr i zwraca liczbę całkowitą. Chcemy aby to zadanie było wywoływane z poziomu języka pytonowskiego, w następujący sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import spam &gt;&gt;&gt; status = spam.system("ls -l")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import spam &gt;&gt;&gt; status = spam.system("ls -l")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Begin by creating a file :file:`spammodule.c`.  (Historically, if a module is called ``spam``, the C file containing its implementation is called :file:`spammodule.c`; if the module name is very long, like ``spammify``, the module name can be just :file:`spammify.c`.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zaczynając od stworzenia pliku :file:`spammodule.c` (Historycznie, jeśli moduł był nazwany ``spam``, plik C zawierający jego wypełnienie jest nazywany :file:`spammodule.c`; jeśli nazwa modułu jest bardzo długa, jak np ``spammify``, nazwa modułu może być po prostu :file:`spammify.c`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first line of our file can be::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwsza linia naszego pliku mogłaby być::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which pulls in the Python API (you can add a comment describing the purpose of the module and a copyright notice if you like).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Które pociąga sprzęg programowania języka pytonowskiego (możesz dodać komentarz opisujący powód modułu i uwagi praw autorskich jeśli wolisz).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since Python may define some pre-processor definitions which affect the standard headers on some systems, you *must* include :file:`Python.h` before any standard headers are included.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odkąd język pytonowski może definiować pewne definicje preprocesora które wpływają na standardowe nagłówki na niektórych maszynach/środowiskach, *musisz* zawrzeć plik :file:`Python.h` przed załączeniem jakichkolwiek standardowych plików nagłówkowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py`` or ``PY``, except those defined in standard header files. For convenience, and since they are used extensively by the Python interpreter, ``"Python.h"`` includes a few standard header files: ``&lt;stdio.h&gt;``, ``&lt;string.h&gt;``, ``&lt;errno.h&gt;``, and ``&lt;stdlib.h&gt;``.  If the latter header file does not exist on your system, it declares the functions :cfunc:`malloc`, :cfunc:`free` and :cfunc:`realloc` directly.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie widoczne-dla-użytkownika symbole zdefiniowane przez :file:`Python.h` mają przedrostek ``Py`` lub ``PY``, z wyjątkiem tych  zdefiniowanych w standardowym pliku nagłówkowym. Dla wygody, i ponieważ są one użyte szeroko przez program interpretujący polecenia języka pytonowskiego, ``"Python.h"`` zawiera kilka standardowych plików nagłówkowych: ``&lt;stdio.h&gt;``, ``&lt;string.h&gt;``, ``&lt;errno.h&gt;``, i ``&lt;stdlib.h&gt;``. Jeśli ostatni plik nagłówkowy nie istnieje na twojej maszynie/środowisku deklaruje zadania :cfunc:`malloc`, :cfunc:`free` i :cfunc:`realloc` bezpośrednio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next thing we add to our module file is the C function that will be called when the Python expression ``spam.system(string)`` is evaluated (we'll see shortly how it ends up being called)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następną rzeczą którą dodajemy do naszego pliku modułu jest zadanie C które będzie wzywane gdy wyrażenie języka pytonowskiego ``spam.system(string)`` zostanie obliczone (zobaczymy niedługo, jak to się kończy wywołaniem)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * spam_system(PyObject *self, PyObject *args) {     const char *command;     int sts;      if (!PyArg_ParseTuple(args, "s", &amp;command))         return NULL;     sts = system(command);     return Py_BuildValue("i", sts); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * spam_system(PyObject *self, PyObject *args) {     const char *command;     int sts;      if (!PyArg_ParseTuple(args, "s", &amp;command))         return NULL;     sts = system(command);     return Py_BuildValue("i", sts); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a straightforward translation from the argument list in Python (for example, the single expression ``"ls -l"``) to the arguments passed to the C function.  The C function always has two arguments, conventionally named *self* and *args*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje prosta zamiana nazw z listy parametrów w języku pytonowskim (dla przykładu, pojedyncze wyrażenie ``"ls -l"``) do parametrów przekazanych do zadania C. Zadanie C zawsze ma dwa parametry, dla wygody nazywane *sam* - z ang. - *self* i *args*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *self* argument points to the module object for module-level functions; for a method it would point to the object instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *sam* - z ang. - *self* - wskazuje na przedmiot modułu dla zadań na poziomie-modułu; dla sposobu postępowania wskazywałby na przykład przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *args* argument will be a pointer to a Python tuple object containing the arguments.  Each item of the tuple corresponds to an argument in the call's argument list.  The arguments are Python objects --- in order to do anything with them in our C function we have to convert them to C values.  The function :cfunc:`PyArg_ParseTuple` in the Python API checks the argument types and converts them to C values.  It uses a template string to determine the required types of the arguments as well as the types of the C variables into which to store the converted values.  More about this later.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *args* będzie wskaźnikiem do przedmiotu dwójki języka Pytonowskiego zawierających parametry. Każdy element dwójki odpowiada parametrowi na liście parametrów wywołania. Parametrami są przedmioty języka pytonowskiego --- w celu aby zrobić cokolwiek z nimi w naszym zadaniu C musimy zamienić je na wartości C. Zadanie :cfunc:`PyArg_ParseTuple` w sprzęgu języka pytonowskiego sprawdza typy parametrów i zamienia je na wartości C. używa ciągu znaków wzorcowego aby określić wymagane typy parametrów zarówno jak też typy zmiennych C do których zapamiętuje zamienione wartości. Więcej o tym później.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the right type and its components have been stored in the variables whose addresses are passed.  It returns false (zero) if an invalid argument list was passed.  In the latter case it also raises an appropriate exception so the calling function can return *NULL* immediately (as we saw in the example).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cfunc:`PyArg_ParseTuple` zwraca prawdę (nie-zero) jeśli wszystkie parametry mają prawidłowy typ i ich komponenty zostały zapamiętane w zmiennych których adresy są przekazywane. Zwraca fałsz (zero) jeśli nieprawidłowy parametr był przekazany. W przypadku drugim podnosi też odpowiedni wyjątek tak, że wywołanie zadania może zwrócić *NULL* natychmiast (jak widzieliśmy w przykładzie).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Intermezzo: Errors and Exceptions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Intermezzo: Błędy i Wyjątki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An important convention throughout the Python interpreter is the following: when a function fails, it should set an exception condition and return an error value (usually a *NULL* pointer).  Exceptions are stored in a static global variable inside the interpreter; if this variable is *NULL* no exception has occurred.  A second global variable stores the "associated value" of the exception (the second argument to :keyword:`raise`).  A third variable contains the stack traceback in case the error originated in Python code.  These three variables are the C equivalents of the result in Python of :meth:`sys.exc_info` (see the section on module :mod:`sys` in the Python Library Reference).  It is important to know about them to understand how errors are passed around.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istotną konwencją w programie interpretującym polecenia języka pytonowskiego jest następująca: gdy zadanie zawiedzie, powinno ustawić warunek wyjątku i zwrócić wartość błędu (zwykle pusty wskaźnik - z ang. - *NULL* ) Wyjątki są przechowywane w statycznej nadrzędnej zmiennej wewnątrz programu interpretującego polecenia języka pytonowskiego; jeśli ta zmienna jest *NULL* żaden wyjątek nie nastąpił. Druga nadrzędna zmienna przechowuje "związaną wartość" wyjątku (drugi parametr słowa kluczowego :keyword:`raise` - z ang. zgłoś). Trzecia zmienna zawiera wypis śladu ze sterty w razie gdyby błąd wypływał z kodu w języku pytonowskim. Te trzy zmienne są równoważnikami C wyniku w języku pytonowskim sposobu postępowania :meth:`sys.exc_info` (zobacz sekcję o module :mod:`sys` w podręczniku biblioteki języka pytonowskiego). Istotne jest wiedzieć o nich aby rozumieć jak błędy są przekazywane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python API defines a number of functions to set various types of exceptions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg języka pytonowskiego określa pewien zestaw zadań do ustawiania różnych rodzajów  wyjątków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most common one is :cfunc:`PyErr_SetString`.  Its arguments are an exception object and a C string.  The exception object is usually a predefined object like :cdata:`PyExc_ZeroDivisionError`.  The C string indicates the cause of the error and is converted to a Python string object and stored as the "associated value" of the exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Najbardziej rozpowszechniony to :cfunc:`PyErr_SetString`. Jego parametry to przedmiot wyjątku i ciąg znaków z języka C. Przedmiot wyjątku jest zwykle predefiniowanym przedmiotem jak :cdata:`PyExc_ZeroDivisionError`. Ciąg znków C wskazuje na powód błędu i jest zamieniany na przedmiot ciągu znaków języka pytonowskiego i zachowywany jako "wartość związana" tego wyjątku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another useful function is :cfunc:`PyErr_SetFromErrno`, which only takes an exception argument and constructs the associated value by inspection of the global variable :cdata:`errno`.  The most general function is :cfunc:`PyErr_SetObject`, which takes two object arguments, the exception and its associated value.  You don't need to :cfunc:`Py_INCREF` the objects passed to any of these functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Innym użytecznym zadaniem jest :cfunc:`PyErr_SetFromErrno`, który pobiera tylko parametr wyjątku i konstruuje związaną wartość przez podejrzenie zmiennej nadrzędnej :cdata:`errno`. Najogólniejszym zadaniem jest :cfunc:`PyErr_SetObject` które pobiera dwa parametry przedmiotowe, wyjątek i związaną wartość. Nie potrzebują one zwiększać ilości odniesień :cfunc:`Py_INCREF` przedmiotów przekazanych do którychkolwiek z tych zadań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can test non-destructively whether an exception has been set with :cfunc:`PyErr_Occurred`.  This returns the current exception object, or *NULL* if no exception has occurred.  You normally don't need to call :cfunc:`PyErr_Occurred` to see whether an error occurred in a function call, since you should be able to tell from the return value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz sprawdzić nie-destrukcyjnie czy wyjątek został ustawiony za pomocą zadania :cfunc:`PyErr_Occured`. To zwraca przedmiot obecnego wyjątku, lub *NULL* jeśli żaden wyjątek nie nastąpił. Zwykle nie musisz wywoływać zadania :cfunc:`PyErr_Occurred` aby zobaczyć czy błąd nastąpił w wywołaniu zadania, ponieważ powinno się być w stanie określić na podstawie zwracanej wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a function *f* that calls another function *g* detects that the latter fails, *f* should itself return an error value (usually *NULL* or ``-1``).  It should *not* call one of the :cfunc:`PyErr_\*` functions --- one has already been called by *g*. *f*'s caller is then supposed to also return an error indication to *its* caller, again *without* calling :cfunc:`PyErr_\*`, and so on --- the most detailed cause of the error was already reported by the function that first detected it.  Once the error reaches the Python interpreter's main loop, this aborts the currently executing Python code and tries to find an exception handler specified by the Python programmer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy zadanie *f* które wywołuje inne zadanie *g* wykryje że to drugie zawiedzie, *f* powinno samo zwrócić wartość błędu (zwykle *NULL* lub ``-1``). *Nie* powinno wywoływać jednego z zadań :cfunc:`PyErr_\*` --- gdyż jedno już zostało wywołane przez *g*. Wywołujący zadanie *f* jest potem zobowiązany także zwrócić wskazanie błędu temu kto *je* wywołał, znów *bez* wywoływania zadania :cfunc:`PyErr_\*` itd --- najbardziej szczegółowy powód błędu został już zaraportowany przez zadanie, które pierwsze wykryło go. Gdy błąd dotrze do pętli głównej programu interpretującego polecenia języka pytonowskiego, to przerywa obecne wykonanie kodu języka pytonowskiego i próbuje znaleźć obsługę błędu określoną przez programistę języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(There are situations where a module can actually give a more detailed error message by calling another :cfunc:`PyErr_\*` function, and in such cases it is fine to do so.  As a general rule, however, this is not necessary, and can cause information about the cause of the error to be lost: most operations can fail for a variety of reasons.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Istnieją sytuacje gdy moduł może właściwie dawać bardziej szczegółową wiadomość o błędzie przez wywołanie kolejnego zadania :cfunc:`PyErr_\*` i w takich przypadkach nie sprawia to kłopotu. Jako naczelna zasada, jednakże, nie jest to konieczne, i może powodować utratę informacji o powodzie błędu: większość operacji może zawieźć z różnych powodów.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ignore an exception set by a function call that failed, the exception condition must be cleared explicitly by calling :cfunc:`PyErr_Clear`.  The only time C code should call :cfunc:`PyErr_Clear` is if it doesn't want to pass the error on to the interpreter but wants to handle it completely by itself (possibly by trying something else, or pretending nothing went wrong).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zignorować wyjątek ustanowiony przez wywołanie zadania które zawiodło, warunek wyjątku musi być wyczyszczony jawnie przez wywołanie :cfunc:`PyErr_Clear`. Jedynym momentem gdy kod C powinien wzywać :cfunc:`PyErr_Clear` jest jeśli nie chce przekazać błędu dla programu interpretującego polecenia języka pytonowskiego ale chce obsłużyć je całkowicie samodzielnie (możliwie przez próbowanie czegoś innego, lub udawanie że nic się nie stało).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every failing :cfunc:`malloc` call must be turned into an exception --- the direct caller of :cfunc:`malloc` (or :cfunc:`realloc`) must call :cfunc:`PyErr_NoMemory` and return a failure indicator itself.  All the object-creating functions (for example, :cfunc:`PyLong_FromLong`) already do this, so this note is only relevant to those who call :cfunc:`malloc` directly.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każde zawodzące odwołanie :cfunc:`malloc` musi być zamienione na sytuację wyjątkową --- bezpośrednio wołający :cfunc:`malloc` (lub :cfunc:`realloc`) musi wywołać :cfunc:`PyErr_NoMemory` i zwrócić wskazanie o błędzie samo w sobie. Wszystkie zadania tworzące-przedmioty (dla przykładu. :cfunc:`PyLong_FromLong`) już to robią więc ta notatka jest ważna tylko dla tych którzy wzywają :cfunc:`malloc` bezpośrednio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that, with the important exception of :cfunc:`PyArg_ParseTuple` and friends, functions that return an integer status usually return a positive value or zero for success and ``-1`` for failure, like Unix system calls.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ także, że z istotnym wyjątkiem zadania :cfunc:`PyArg_ParseTuple` i przyjaciół, zadania które zwracają status liczbą całkowitą zwykle zwracają dodatnią wartość lub zero dla powodzenia i ``-1`` dla niepowodzenia, tak jak odwołania systemowe Unix-a.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, be careful to clean up garbage (by making :cfunc:`Py_XDECREF` or :cfunc:`Py_DECREF` calls for objects you have already created) when you return an error indicator!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W końcu bądź ostrożny przy czyszczeniu śmieci (przez wywołania zadań :cfunc:`PyXDECREF` lub :cfunc:`Py_DECREF` dla przedmiotów które już utworzyłeś) gdy zwracasz wskaźnik błędu!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The choice of which exception to raise is entirely yours.  There are predeclared C objects corresponding to all built-in Python exceptions, such as :cdata:`PyExc_ZeroDivisionError`, which you can use directly. Of course, you should choose exceptions wisely --- don't use :cdata:`PyExc_TypeError` to mean that a file couldn't be opened (that should probably be :cdata:`PyExc_IOError`). If something's wrong with the argument list, the :cfunc:`PyArg_ParseTuple` function usually raises :cdata:`PyExc_TypeError`.  If you have an argument whose value must be in a particular range or must satisfy other conditions, :cdata:`PyExc_ValueError` is appropriate.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wybór który wyjątek zgłosić jest całkowicie twój. Istnieją uprzednio zadeklarowane przedmioty C odpowiadające wszystkim wbudowanym wyjątkom języka pytonowskiego, takie, jak :cdata:`PyExc_ZeroDivisionError` którego możesz użyć bezpośrednio. Oczywiście, powinieneś wybierać wyjątki rozsądnie --- nie używaj :cdata:`PyExc_TypeError` aby oznaczyć że plik nie mógł być otworzony (to powinno prawdopodobnie być :cdata:`PyExc_IOError`). Jeśli coś jest nie wporządku z listą parametrów, zadanie :cfunc:`PyArg_ParseTuple` zwykle zgłasza :cdata:`PyExc_TypeError`. Jeśli masz parametr którego wartość musi być w szczególnym zakresie lub musi zaspokajać inne warunki :cdata:`PyExc_ValueError` jest odpowiednia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also define a new exception that is unique to your module. For this, you usually declare a static object variable at the beginning of your file::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz też określić nowy wyjątek który jest niepowtarzalny dla twojego modułu. Dla tego, zwykle deklarujesz przedmiot statycznej zmiennej na początku pliku::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject *SpamError;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject *SpamError;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and initialize it in your module's initialization function (:cfunc:`PyInit_spam`) with an exception object (leaving out the error checking for now)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i zainicjować je w twoim zadaniu zainicjowania modułu (:cfunc:`PyInit_spam`) przedmiotem wyjątku (pozostawiając na razie sprawdzanie błędów)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;      m = PyModule_Create(&amp;spammodule);     if (m == NULL)         return NULL;      SpamError = PyErr_NewException("spam.error", NULL, NULL);     Py_INCREF(SpamError);     PyModule_AddObject(m, "error", SpamError);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;      m = PyModule_Create(&amp;spammodule);     if (m == NULL)         return NULL;      SpamError = PyErr_NewException("spam.error", NULL, NULL);     Py_INCREF(SpamError);     PyModule_AddObject(m, "error", SpamError);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the Python name for the exception object is :exc:`spam.error`.  The :cfunc:`PyErr_NewException` function may create a class with the base class being :exc:`Exception` (unless another class is passed in instead of *NULL*), described in :ref:`bltin-exceptions`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że nazwa języka pytonowskiego dla przedmiotu wyjątku to :exc:`spam.error`. Zadanie :cfunc:`PyErr_NewException` może tworzyć uogólnienie z bazowym uogólnieniem będącym :exc:`Exception` (chyba, że inne uogólnienie jest przekazane zamiast *NULL*), opisane w :ref:`bltin-exceptions`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note also that the :cdata:`SpamError` variable retains a reference to the newly created exception class; this is intentional!  Since the exception could be removed from the module by external code, an owned reference to the class is needed to ensure that it will not be discarded, causing :cdata:`SpamError` to become a dangling pointer. Should it become a dangling pointer, C code which raises the exception could cause a core dump or other unintended side effects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ także, że zmienna :cdata:`SpamError` zachowuje odniesienie do nowo utworzonego uogólnienia wyjątku; to jest specjalnie! Od kiedy wyjątek mógł być zdjęty z modułu przez zewnętrzny kod, posiadane odniesienie do uogólnienia jest konieczne aby zapewnić że nie będzie pominięte, powodując, że :cdata:`SpamError` stanie się wiszącym wskaźnikiem. Jeśli by tak się stało, kod C, który zgłasza wyjątek mógłby spowodować zrzucenie jądra lub inne niezamierzone efekty uboczne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We discuss the use of PyMODINIT_FUNC as a function return type later in this sample.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozważamy użycie PyMODINIT_FUNC jako typ zwracany później w tym przykładzie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to the Example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Z powrotem do Przykładu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going back to our example function, you should now be able to understand this statement::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wracając do naszej przykładowego zadania, powinieneś już być w stanie zrozumieć to wyrażenie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (!PyArg_ParseTuple(args, "s", &amp;command))     return NULL;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>if (!PyArg_ParseTuple(args, "s", &amp;command))     return NULL;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It returns *NULL* (the error indicator for functions returning object pointers) if an error is detected in the argument list, relying on the exception set by :cfunc:`PyArg_ParseTuple`.  Otherwise the string value of the argument has been copied to the local variable :cdata:`command`.  This is a pointer assignment and you are not supposed to modify the string to which it points (so in Standard C, the variable :cdata:`command` should properly be declared as ``const char *command``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca ona *NULL* (wskaźnik błędu dla zadań zwracających przedmiotowe wskaźniki) jeśli błąd został wykryty na liście parametrów, polegając na wyjątku ustawionym przez :cfunc:`PyArg_ParseTuple`. Poza tym wartość ciągu znaków parametru została skopiowana do zmiennej lokalnej :cdata:`command`. To jest przypisanie wskaźnika i nie powinieneś zmieniać ciągu znaków na który on wskazuje (więc w Standardowym C, zmienna :cdata:`command` powinna odpowiednio być zadeklarowana jako ``const char *command``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next statement is a call to the Unix function :cfunc:`system`, passing it the string we just got from :cfunc:`PyArg_ParseTuple`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następne wyrażenie jest wezwaniem zadania Unix-a :cfunc:`system`, przekazując mu ciąg znaków, który właśnie otrzymaliśmy z :cfunc:`PyArg_ParseTuple`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sts = system(command);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sts = system(command);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our :func:`spam.system` function must return the value of :cdata:`sts` as a Python object.  This is done using the function :cfunc:`Py_BuildValue`, which is something like the inverse of :cfunc:`PyArg_ParseTuple`: it takes a format string and an arbitrary number of C values, and returns a new Python object. More info on :cfunc:`Py_BuildValue` is given later. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nasze zadanie :func:`spam.system` musi zwracać wartość :cdata:`sts` jako przedmiot języka pytonowskiego. To jest czynione używając zadania :cfunc:`Py_BuildValue`, która jest czymś podobnym do odwrotności :cfunc:`PyArg_ParseTuple`: bierze ona ciąg formatowania i dowolną liczbę wartości C, i zwraca nowy przedmiot języka pytonowskiego. Więcej informacji o :cfunc:`Py_BuildValue` jest podana później. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>return Py_BuildValue("i", sts);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>return Py_BuildValue("i", sts);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, it will return an integer object.  (Yes, even integers are objects on the heap in Python!)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym przypadku, zwróci przedmiot liczby całkowitej (Tak, nawet liczby całkowite są przedmiotami na stercie w języku pytonowskim!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a C function that returns no useful argument (a function returning :ctype:`void`), the corresponding Python function must return ``None``.   You need this idiom to do so (which is implemented by the :cmacro:`Py_RETURN_NONE` macro)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz zadanie C które nie zwraca żadnych użytecznych parametrów (zadanie zwracające :ctype:`void`), odpowiadające zadanie języka pytonowskiego musi zwracać ``None``. Potrzebujesz tego idiomu aby to uczynić (który jest wypełniony przez makrodefinicję :cmacro:`Py_RETURN_NONE`)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_INCREF(Py_None); return Py_None;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_INCREF(Py_None); return Py_None;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cdata:`Py_None` is the C name for the special Python object ``None``.  It is a genuine Python object rather than a *NULL* pointer, which means "error" in most contexts, as we have seen.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cdata:`Py_None` jest nazwą C dla szczególnego przedmiotu języka pytonowskiego ``None``. Jest to prawdziwy przedmiot języka pytonowskiego zamiast pustego wskaźnika - z ang. - *NULL*, co oznacza "błąd" w większości przypadków, jak już widzieliśmy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Module's Method Table and Initialization Function</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie zainicjowania i tabela sposobów postępowania modułu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I promised to show how :cfunc:`spam_system` is called from Python programs. First, we need to list its name and address in a "method table"::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obiecywałem pokazać jak :cfunc:`spam_system` jest wywoływana z programu języka pytonowskiego. Najpierw musimy wypisać jej nazwę i adres w "tabeli sposobów postępowania"::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyMethodDef SpamMethods[] = {     ...     {"system",  spam_system, METH_VARARGS,      "Execute a shell command."},     ...     {NULL, NULL, 0, NULL}        /* Sentinel */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyMethodDef SpamMethods[] = {     ...     {"system",  spam_system, METH_VARARGS,      "Uruchom polecenie powłoki."},     ...     {NULL, NULL, 0, NULL}        /* pilnowacz */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the third entry (``METH_VARARGS``).  This is a flag telling the interpreter the calling convention to be used for the C function.  It should normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a value of ``0`` means that an obsolete variant of :cfunc:`PyArg_ParseTuple` is used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ trzeci wpis (``METH_VARARGS``). To jest flaga mówiąca programowi interpretującemu polecenia języka pytonowskiego o konwencji która ma zostać użyta dla zadania C. Zwykle zawsze powinna to być ``METH_VARARGS`` lub ``METH_VARARGS | METH_KEYWORDS``; wartość ``0`` oznacza że przestarzały wariant zadania :cfunc:`PyArg_ParseTuple` jest używany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using only ``METH_VARARGS``, the function should expect the Python-level parameters to be passed in as a tuple acceptable for parsing via :cfunc:`PyArg_ParseTuple`; more information on this function is provided below.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy w użyciu jest tylko ``METH_VARARGS``, zadanie powinno spodziewać się parametrów na poziomie języka pytonowskiego aby były przekazywane jako dwójka akceptowalna do wczytania przez :cfunc:`PyArg_ParseTuple`; więcej informacji o tym zadaniu jest dostarczone poniżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :const:`METH_KEYWORDS` bit may be set in the third field if keyword arguments should be passed to the function.  In this case, the C function should accept a third ``PyObject \*`` parameter which will be a dictionary of keywords. Use :cfunc:`PyArg_ParseTupleAndKeywords` to parse the arguments to such a function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bit :const:`METH_KEYWORDS` może być ustawiany w trzecim polu jeśli parametry słów kluczowych miałyby być przekazywane do zadania. W takim przypadku, zadanie C powinno akceptować trzeci parametr ``PyObject \*``, który będzie słownikiem słów kluczowych. Użyj zadania :cfunc:`PyArg_ParseTupleAndKeywords` aby wczytać parametry takiego zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method table must be referenced in the module definition structure::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tabela sposobów postępowania musi być określona w strukturze definicji modułu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static struct PyModuleDef spammodule = {    PyModuleDef_HEAD_INIT,    "spam",   /* name of module */    spam_doc, /* module documentation, may be NULL */    -1,       /* size of per-interpreter state of the module,                 or -1 if the module keeps state in global variables. */    SpamMethods };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static struct PyModuleDef spammodule = { PyModuleDef_HEAD_INIT, "spam", /*nazwa modułu */ spam_doc, /* dokumentacja modułu, może być pusta (NULL) */ -1, /* rozmiar stanu modułu dla programu interpretującego polecenia języka pytonowskiego, lub -1 jeśli moduł utrzymuje stan w nadrzędnych zmiennych. */ SpamMethods };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This structure, in turn, must be passed to the interpreter in the module's initialization function.  The initialization function must be named :cfunc:`PyInit_name`, where *name* is the name of the module, and should be the only non-\ ``static`` item defined in the module file::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta struktura, z kolei, musi być przekazana do programu interpretującego polecenia języka pytonowskiego w zadaniu inicjującym moduł. Zadanie inicjujące musi się nazywać :cfunc:`PyInit_nazwa`, gdzie *nazwa* jest nazwą modułu, i powinna być jedynym nie-\ ``statycznym`` elementem określonym w pliku modułu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyMODINIT_FUNC PyInit_spam(void) {     return PyModule_Create(&amp;spammodule); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyMODINIT_FUNC PyInit_spam(void) {     return PyModule_Create(&amp;spammodule); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that PyMODINIT_FUNC declares the function as ``PyObject *`` return type, declares any special linkage declarations required by the platform, and for C++ declares the function as ``extern "C"``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że PyMODINIT_FUNC deklaruje zadanie jako zwrotny typ ``PyObject *``, deklaruje wszelkie specjalne deklaracje połączeń wymagane przez maszynę/środowisko, i dla C++ deklaruje zadanie jako ``extern "C"``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the Python program imports module :mod:`spam` for the first time, :cfunc:`PyInit_spam` is called. (See below for comments about embedding Python.) It calls :cfunc:`PyModule_Create`, which returns a module object, and inserts built-in function objects into the newly created module based upon the table (an array of :ctype:`PyMethodDef` structures) found in the module definition. :cfunc:`PyModule_Create` returns a pointer to the module object that it creates.  It may abort with a fatal error for certain errors, or return *NULL* if the module could not be initialized satisfactorily. The init function must return the module object to its caller, so that it then gets inserted into ``sys.modules``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy program języka pytonowskiego importuje moduł :mod:`spam` po raz pierwszy, zadanie :cfunc:`PyInit_spam` jest wzywane. (Zobacz poniższe komentarze o załączaniu języka pytonowskiego.) Wzywa zadanie :cfunc:`PyModule_Create`, które zwraca przedmiot modułu, i wstawia przedmioty wbudowanych zadań do nowo utworzonego modułu w oparciu o tabelę (rząd struktur :ctype:`PyMethodDef`) znajdujących się w definicji modułu. :cfunc:`PyModule_Create` zwraca wskaźnik do przedmiotu modułu który tworzy. Może przerwać z krytycznym błędem dla pewnych błędów, lub zwrócić *NULL* jeśli moduł nie mógł być zainicjowany satysfakcjonująco. Zadanie inicjujące musi zwrócić przedmiot modułu do swojego wywołującego, tak żeby było następnie wstawione do ``sys.modules``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When embedding Python, the :cfunc:`PyInit_spam` function is not called automatically unless there's an entry in the :cdata:`PyImport_Inittab` table. To add the module to the initialization table, use :cfunc:`PyImport_AppendInittab`, optionally followed by an import of the module::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przy załączaniu języka pytonowskiego, zadanie :cfunc:`PyInit_spam` nie jest wzywane automatycznie chyba, że istnieje wpis w tabeli :cdata:`PyImport_Inittab`. Aby dodać moduł do tabeli zainicjowania użyj :cfunc:`PyImport_AppendInittab`, z dodatkową możliwością następnie importowania modułu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int main(int argc, char *argv[]) {     /* Add a built-in module, before Py_Initialize */     PyImport_AppendInittab("spam", PyInit_spam);      /* Pass argv[0] to the Python interpreter */     Py_SetProgramName(argv[0]);      /* Initialize the Python interpreter.  Required. */     Py_Initialize();      /* Optionally import the module; alternatively,        import can be deferred until the embedded script        imports it. */     PyImport_ImportModule("spam");</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int main(int argc, char *argv[]) { /* Dodaj wbudowany moduł, przed Py_Initialize */ PyImport_AppendInittab("spam", PyInit_spam); /* Przekaż argv[0] do programu interpretującego polecenia języka pytonowskiego */ Py_SetProgramName(argv[0]); /* Inicjuj program interpretujący polecenia języka pytonowskiego. Wymagane. */ Py_Initialize(); /* Opcjonalnie importuj moduł; alternatywnie, import może być opóźniony aż do momentu gdy załączony skrypt go zaimportuje. */ PyImport_ImportModule("spam");</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example may be found in the file :file:`Demo/embed/demo.c` in the Python source distribution.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład można znaleźć w pliku :file:`Demo/embed/demo.c` w dystrybucji źródłowej języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removing entries from ``sys.modules`` or importing compiled modules into multiple interpreters within a process (or following a :cfunc:`fork` without an intervening :cfunc:`exec`) can create problems for some extension modules. Extension module authors should exercise caution when initializing internal data structures.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwanie wpisów z ``sys.modules`` lub importowanie skompilowanych modułów do wielu interpreterów wewnątrz procesu (lub postępując za rozwidleniem :cfunc:`fork` bez przerwy ze strony :cfunc:`exec`) może tworzyć problemy dla niektórych modułów rozszerzających. Twórcy modułów rozszerzających powinni wzmóc czujność podczas inicjowania wewnętrznych struktur danych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more substantial example module is included in the Python source distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  template or simply read as an example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bardziej konkretny przykład modułu jest załączony w dystrybucji źródeł języka pytonowskiego jako plik :file:`Modules/xxmodule.c`. Ten plik może być użyty jako wzór lub po prostu czytany jako przykład.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compilation and Linkage</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompilacja i łączenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two more things to do before you can use your new extension: compiling and linking it with the Python system.  If you use dynamic loading, the details may depend on the style of dynamic loading your system uses; see the chapters about building extension modules (chapter :ref:`building`) and additional information that pertains only to building on Windows (chapter :ref:`building-on-windows`) for more information about this.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Są jeszcze dwie rzeczy które trzeba zrobić zanim będzie można użyć nowego rozszerzenia: skompilowanie go i podłączenie z systemem języka pytonowskiego. Jeśli używasz dynamicznego ładowania, szczegóły mogą zależeć od stylu dynamicznego ładowania którego twój system używa; zobacz rozdział o budowaniu rozszerzających modułów (rozdział :ref:`budowanie`) i dodatkowe informacje które odnoszą się tylko do budowania w Windows (rozdział :ref:`budowanie-w-windows`) po więcej informacji na ten temat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you can't use dynamic loading, or if you want to make your module a permanent part of the Python interpreter, you will have to change the configuration setup and rebuild the interpreter.  Luckily, this is very simple on Unix: just place your file (:file:`spammodule.c` for example) in the :file:`Modules/` directory of an unpacked source distribution, add a line to the file :file:`Modules/Setup.local` describing your file::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli nie możesz użyć dynamicznego ładowania, lub jeśli chcesz uczynić swój moduł trwałą częścią programu interpretującego polecenia języka pytonowskiego, będziesz musiał zmienić ustawienia konfiguracyjne i przebudować program interpretujący polecenia języka pytonowskiego. Na szczęście jest to bardzo proste w Unix-ie: po prostu wstaw swój plik (:file:`spammodule.c` dla przykładu) w katalogu :file:`Modules/` odpakowanej dystrybucji źródłowej, dodaj linię do pliku :file:`Modules/Setup.local` opisującą twój plik:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>spam spammodule.o</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>spam spammodule.o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and rebuild the interpreter by running :program:`make` in the toplevel directory.  You can also run :program:`make` in the :file:`Modules/` subdirectory, but then you must first rebuild :file:`Makefile` there by running ':program:`make` Makefile'.  (This is necessary each time you change the :file:`Setup` file.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i przebuduj program interpretujący przez uruchomienie programu :program:`make` w katalogu głównym instalacji. Możesz także uruchomić program :program:`make` w podkatalogu :file:`Modules/`, ale wtedy musisz najpierw przebudować plik :file:`Makefile` tam przez uruchomienie programu :program:`make` Makefile'. To jest konieczne za każdym razem gdy zmieniasz plik :file:`Setup`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your module requires additional libraries to link with, these can be listed on the line in the configuration file as well, for instance::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli twój moduł wymaga dodatkowych bibliotek do podłączenia, te mogą być wymienione na liście w kolejce do pliku konfiguracyjnego na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>spam spammodule.o -lX11</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>spam spammodule.o -lX11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling Python Functions from C</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływanie zadań języka pytonowskiego z C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have concentrated on making C functions callable from Python.  The reverse is also useful: calling Python functions from C. This is especially the case for libraries that support so-called "callback" functions.  If a C interface makes use of callbacks, the equivalent Python often needs to provide a callback mechanism to the Python programmer; the implementation will require calling the Python callback functions from a C callback.  Other uses are also imaginable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak do tej pory koncentrowaliśmy się na uczynieniu zadań C możliwymi do wywołania z poziomu języka pytonowskiego. Odwrotna sytuacja jest także użyteczna: wywoływanie zadań języka pytonowskiego z poziomu języka C. To w szczególności odnosi się do bibliotek które wspierają tak zwane zadania "callback" wstecznie wywołujące. Jeśli sprzęg C używa zadań wstecznie wywołujących, odpowiednik języka pytonowskiego często potrzebuje dostarczyć mechanizm wstecznego wywołania dla programisty języka pytonowskiego; wypełnienie będzie potrzebowało wzywać zadania wywołania wstecznego z poziomu wstecznego C. Inne przypadki są także możliwe do wyobrażenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately, the Python interpreter is easily called recursively, and there is a standard interface to call a Python function.  (I won't dwell on how to call the Python parser with a particular string as input --- if you're interested, have a look at the implementation of the :option:`-c` command line option in :file:`Modules/main.c` from the Python source code.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Szczęśliwie, program interpretujący polecenia języka pytonowskiego jest łatwo wywoływany rekursywnie i istnieje standardowy sprzęg aby wywołać zadanie języka pytonowskiego. (Nie będę rozpisywał się o tym jak wywołać czytnik języka pytonowskiego z konkretnym ciągiem znaków na wejściu --- jeśli jesteś zainteresowany, spójrz na wypełnienie opcji :option:`-c` wiersza polecenia w :file:`Modules/main.c` z kodu źródłowego języka pytonowskiego.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling a Python function is easy.  First, the Python program must somehow pass you the Python function object.  You should provide a function (or some other interface) to do this.  When this function is called, save a pointer to the Python function object (be careful to :cfunc:`Py_INCREF` it!) in a global variable --- or wherever you see fit. For example, the following function might be part of a module definition::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołanie zadania języka pytonowskiego jest łatwe. Po pierwsze program języka pytonowskiego musi jakoś przekazać ci przedmiot zadania języka pytonowskiego. Powinieneś dostarczyć zadanie (lub jakiś inny sprzęg) aby to uczynić. Gdy to zadanie jest wzywane, zachowaj wskaźnik do przedmiotu zadania języka pytonowskiego (uważaj aby zwiększyć ilość odniesień do niego :cfunc:`Py_INCREF`) w nadrzędnej zmiennej --- lub gdziekolwiek uznasz to za stosowne. Dla przykładu, następujące zadanie może być częścią definicji modułu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject *my_callback = NULL;  static PyObject * my_set_callback(PyObject *dummy, PyObject *args) {     PyObject *result = NULL;     PyObject *temp;      if (PyArg_ParseTuple(args, "O:set_callback", &amp;temp)) {         if (!PyCallable_Check(temp)) {             PyErr_SetString(PyExc_TypeError, "parameter must be callable");             return NULL;         }         Py_XINCREF(temp);         /* Add a reference to new callback */         Py_XDECREF(my_callback);  /* Dispose of previous callback */         my_callback = temp;       /* Remember new callback */         /* Boilerplate to return "None" */         Py_INCREF(Py_None);         result = Py_None;     }     return result; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject *my_callback = NULL;  static PyObject * my_set_callback(PyObject *dummy, PyObject *args) {     PyObject *result = NULL;     PyObject *temp;      if (PyArg_ParseTuple(args, "O:set_callback", &amp;temp)) {         if (!PyCallable_Check(temp)) {             PyErr_SetString(PyExc_TypeError, "parametr musi być możliwy do wywołania");             return NULL;         }         Py_XINCREF(temp);         /* Dodaj odniesienie do nowego wstecznie wywoływanego zadania */         Py_XDECREF(my_callback);  /* Pozbądź się poprzedniego wstecznie wywołanego zadania */         my_callback = temp;       /* Zapamiętaj nowe wstecznie wywoływane zadanie */         /* talerzowanie aby zwrócić "None" */         Py_INCREF(Py_None);         result = Py_None;     }     return result; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function must be registered with the interpreter using the :const:`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The :cfunc:`PyArg_ParseTuple` function and its arguments are documented in section :ref:`parsetuple`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie musi być zarejestrowane w programie interpretującym polecenia języka pytonowskiego używając flagi :const:`METH_VARARGS`; to jest opisane w rozdziale :ref:`methodtable` - :ref:`tabeli sposobów postępowania`. Zadanie :cfunc:`PyArg_ParseTuple` i jego parametry są dokumentowane w rozdziale :ref:`parsetuple` - ref:`wczytaj_dwójkę`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The macros :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF` increment/decrement the reference count of an object and are safe in the presence of *NULL* pointers (but note that *temp* will not be  *NULL* in this context).  More info on them in section :ref:`refcounts`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia :cfunc:`Py_XINCREF` i :cfunc:`Py_XDECREF` zwiększają/zmniejszają liczbę odniesień przedmiotu i są bezpieczne w obliczu pustych wskaźników *NULL* (ale zwróc uwagę, że *temp* nie będzie pusty - *NULL* w tym kontekście). Więcej informacji na ten temat znajdziesz w sekcji :ref:`refcounts` - :ref:`zliczaniaodniesień`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Later, when it is time to call the function, you call the C function :cfunc:`PyObject_CallObject`.  This function has two arguments, both pointers to arbitrary Python objects: the Python function, and the argument list.  The argument list must always be a tuple object, whose length is the number of arguments.  To call the Python function with no arguments, pass in NULL, or an empty tuple; to call it with one argument, pass a singleton tuple. :cfunc:`Py_BuildValue` returns a tuple when its format string consists of zero or more format codes between parentheses.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Później gdy nadchodzi czas aby wywołać zadanie, wywołujesz zadanie C :cfunc:`PyObject_CallObject`. To zadanie ma dwa parametry, oba wskaźniki do dowolnych przedmiotów języka pytonowskiego: zadania pytonowskiego i listy parametrów. Lista parametrów musi zawsze być przedmiotem krotki, której długością jest liczba parametrów. Aby wywołać zadanie języka pytonowskiego bez parametrów, przekaż NULL, lub pustą krotkę; aby wywołać je z jednym parametrem przekaż głupią krotkę. :cfunc:`Py_BuildValue` zwraca krotkę gdy jego ciąg znaków formatujących składa się z zera lub więcej kodów formatujących pomiędzy nawiasami. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int arg; PyObject *arglist; PyObject *result; ... arg = 123; ... /* Time to call the callback */ arglist = Py_BuildValue("(i)", arg); result = PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int arg; PyObject *arglist; PyObject *result; ... arg = 123; ... /* Czas wywołać zadanie wstecznie */ arglist = Py_BuildValue("(i)", arg); result = PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfunc:`PyObject_CallObject` returns a Python object pointer: this is the return value of the Python function.  :cfunc:`PyObject_CallObject` is "reference-count-neutral" with respect to its arguments.  In the example a new tuple was created to serve as the argument list, which is :cfunc:`Py_DECREF`\ -ed immediately after the call.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:cfunc:`PyObject_CallObject` zwraca wskaźnik przedmiotowy języka pytonowskiego: to jest wartość zwracana zadania języka pytonowskiego. :cfunc:`PyObject_CallObject` jest "neutralne-pod-względem-zliczania-odniesień" względem jego parametrów. W przykładzie nowa krotka została utworzona aby służyć jako lista parametrów, której liczba odniesień jest zmniejszona (:cfunc:`Py_DECREF`) od razu po wywołaniu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The return value of :cfunc:`PyObject_CallObject` is "new": either it is a brand new object, or it is an existing object whose reference count has been incremented.  So, unless you want to save it in a global variable, you should somehow :cfunc:`Py_DECREF` the result, even (especially!) if you are not interested in its value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość zwracana :cfunc:`PyObject_CallObject` jest "nowa": albo jest to zupełnie nowy przedmiot, albo jest to istniejący przedmiot którego liczba odniesień została zwiększona. Więc, z wyjątkiem sytuacji gdy chcesz zachować ją w globalnej zmiennej, powinieneś jakoś zmniejszyć liczbę odniesień :cfunc:`Py_DECREF` rezultat, nawet (szczególnie!) jeśli nie jesteś zainteresowany jego wartością.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you do this, however, it is important to check that the return value isn't *NULL*.  If it is, the Python function terminated by raising an exception. If the C code that called :cfunc:`PyObject_CallObject` is called from Python, it should now return an error indication to its Python caller, so the interpreter can print a stack trace, or the calling Python code can handle the exception. If this is not possible or desirable, the exception should be cleared by calling :cfunc:`PyErr_Clear`.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zanim to zrobisz, jednakże, jest istotne aby sprawdzić czy wartość zwracana nie jest pusta - *NULL*. Jeśli jest, zadanie języka pytonowskiego zakończyło się przez wzniesienie wyjątku. Jeśli kod w języku C który wywołał :cfunc:`PyObject_CallObject` jest wywoływany z języka pytonowskiego, powinien teraz zwrócić błąd do swojego wywołującego z poziomu języka pytonowskiego, tak by program interpretujący polecenia języka pytonowskiego mógł wypisać ostatnie wywołania ze stosu, lub wywołanie kodu języak pytonowskiego mogło obsłużyć wyjątek. Jeśli nie jest to możliwe albo nie jest pożądane, wyjątek powinien zostać wyczyszczony przez wywołanie :cfunc:`PyErr_Clear`. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (result == NULL)     return NULL; /* Pass error back */ ...use result... Py_DECREF(result);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>if (result == NULL)     return NULL; /* Przakaź błąd wstecz */ ...użyj wyniku... Py_DECREF(result);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on the desired interface to the Python callback function, you may also have to provide an argument list to :cfunc:`PyObject_CallObject`.  In some cases the argument list is also provided by the Python program, through the same interface that specified the callback function.  It can then be saved and used in the same manner as the function object.  In other cases, you may have to construct a new tuple to pass as the argument list.  The simplest way to do this is to call :cfunc:`Py_BuildValue`.  For example, if you want to pass an integral event code, you might use the following code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W zależności od oczekiwanego sprzęgu do wywoływanego wstecznie zadania, możesz także potrzebować dostarczyć listę parametrów do zadania :cfunc:`PyObject_CallObject`. W niektórych przypadkach lista parametrów jest także dostarczana przez program języka pytonowskiego, przez ten sam sprzęg który określał zadanie wywołania wstecznego. Może potem być zachowane i użyte w ten sam sposób jak przedmiot zadania. W innych przypadkach może być konieczne stworzenie nowej krotki aby przekazać ją jako listę parametrów. Najprostszym sposobem aby tego dokonać jest wywołanie :cfunc:`PyBuildValue`. Dla przykładu, jeśli chcesz przekazać wewnętrzny kod zdarzenia możesz użyć następującego kodu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *arglist; ... arglist = Py_BuildValue("(l)", eventcode); result = PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist); if (result == NULL)     return NULL; /* Pass error back */ /* Here maybe use the result */ Py_DECREF(result);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *arglist; ... arglist = Py_BuildValue("(l)", eventcode); result = PyObject_CallObject(my_callback, arglist); Py_DECREF(arglist); if (result == NULL)     return NULL; /* Przekaż błąd wstecz */ /* Tutaj być może użycie wyniku */ Py_DECREF(result);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the placement of ``Py_DECREF(arglist)`` immediately after the call, before the error check!  Also note that strictly speaking this code is not complete: :cfunc:`Py_BuildValue` may run out of memory, and this should be checked.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ położenie ``Py_DECREF(arglist)`` bezpośrednio po wywołaniu, przed sprawdzeniem błędu! Zauważ też że ściśle mówiąc ten kod jest nie pełny: dla zadania :cfunc:`Py_BuildValue` może skończyć się pamięć, i to powinno zostać sprawdzone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may also call a function with keyword arguments by using :cfunc:`PyObject_Call`, which supports arguments and keyword arguments.  As in the above example, we use :cfunc:`Py_BuildValue` to construct the dictionary. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz także wywołać zadanie z parametrami kluczowymi przez użycie :cfunc:`PyObject_Call`, które wspiera parametry i parametry słów kluczowych. Jak w powyższym przykładzie, używamy zadania :cfunc:`Py_BuildValue` aby zbudować słownik. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *dict; ... dict = Py_BuildValue("{s:i}", "name", val); result = PyObject_Call(my_callback, NULL, dict); Py_DECREF(dict); if (result == NULL)     return NULL; /* Pass error back */ /* Here maybe use the result */ Py_DECREF(result);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *dict; ... dict = Py_BuildValue("{s:i}", "name", val); result = PyObject_Call(my_callback, NULL, dict); Py_DECREF(dict); if (result == NULL)     return NULL; /* Przekaż błąd wstecz */ /* Tutaj być może użyj wyniku */ Py_DECREF(result);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extracting Parameters in Extension Functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydobywanie parametrów w zadaniach rozszerzających</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :cfunc:`PyArg_ParseTuple` function is declared as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie :cfunc:`PyArg_ParseTuple` jest zadeklarowane jak następuje::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int PyArg_ParseTuple(PyObject *arg, char *format, ...);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int PyArg_ParseTuple(PyObject *arg, char *format, ...);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *arg* argument must be a tuple object containing an argument list passed from Python to a C function.  The *format* argument must be a format string, whose syntax is explained in :ref:`arg-parsing` in the Python/C API Reference Manual.  The remaining arguments must be addresses of variables whose type is determined by the format string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *arg* musi być przedmiotem - krotką zawierającym listę parametrów z języka pytonowskiego dla zadania C. Parametr *format* musi być ciągiem formatu, którego składnia jest wyjaśniona w :ref:`wczytywanie-parametrów` - :ref:`arg-parsing` w podręczniku użytkownika sprzęgów języka pytonowskiego/C. Pozostałe parametry muszą być adresami zmiennych których rodzaj jest określony przez ciąg formatujący.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that while :cfunc:`PyArg_ParseTuple` checks that the Python arguments have the required types, it cannot check the validity of the addresses of C variables passed to the call: if you make mistakes there, your code will probably crash or at least overwrite random bits in memory.  So be careful!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że podczas gdy :cfunc:`PyArg_ParseTuple` sprawdza, że parametry języka pytonowskiego mają wymagane rodzaje, nie może sprawdzić ważności adresów zmiennych C przekazywanych do wywołania: jeśli popełnisz tu błędy, twój kod prawdopodobnie wykona niedozwoloną operację lub przynajmniej zapisze przypadkowe pola w pamięci. Więc bądź ostrożny!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that any Python object references which are provided to the caller are *borrowed* references; do not decrement their reference count!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że dowolne odniesienia do przedmiotów języka pytonowskiego, które są dostarczone wołającemu są *pożyczonymi* odniesieniami; nie zmniejszaj liczby tych odniesień.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some example calls::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pewne przykładowe wywołania::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#define PY_SSIZE_T_CLEAN  /* Make "s#" use Py_ssize_t rather than int. */ #include &lt;Python.h&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#define PY_SSIZE_T_CLEAN  /* zrób "s#" użytek z Py_ssize_t raczej zamiast int. */ #include &lt;Python.h&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int ok; int i, j; long k, l; const char *s; Py_ssize_t size;  ok = PyArg_ParseTuple(args, ""); /* No arguments */     /* Python call: f() */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int ok; int i, j; long k, l; const char *s; Py_ssize_t size;  ok = PyArg_ParseTuple(args, ""); /* Żadnych parametrów */     /* Wywołanie pytonowskie: f() */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ok = PyArg_ParseTuple(args, "s", &amp;s); /* A string */     /* Possible Python call: f('whoops!') */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ok = PyArg_ParseTuple(args, "s", &amp;s); /* Ciąg znaków */     /* Możliwe wywołanie pytonowskie: f('whoops!') */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ok = PyArg_ParseTuple(args, "lls", &amp;k, &amp;l, &amp;s); /* Two longs and a string */     /* Possible Python call: f(1, 2, 'three') */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ok = PyArg_ParseTuple(args, "lls", &amp;k, &amp;l, &amp;s); /* Dwie liczby długie i ciąg znaków */     /* Możliwe wywołanie pytonowskie: f(1, 2, 'three') */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ok = PyArg_ParseTuple(args, "(ii)s#", &amp;i, &amp;j, &amp;s, &amp;size);     /* A pair of ints and a string, whose size is also returned */     /* Possible Python call: f((1, 2), 'three') */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ok = PyArg_ParseTuple(args, "(ii)s#", &amp;i, &amp;j, &amp;s, &amp;size);     /* Para liczb całkowitych i ciąg znaków, którego rozmiar jest także zwracany */     /* Możliwe wywołanie pytonowskie: f((1, 2), 'three') */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{     const char *file;     const char *mode = "r";     int bufsize = 0;     ok = PyArg_ParseTuple(args, "s|si", &amp;file, &amp;mode, &amp;bufsize);     /* A string, and optionally another string and an integer */     /* Possible Python calls:        f('spam')        f('spam', 'w')        f('spam', 'wb', 100000) */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>{     const char *file;     const char *mode = "r";     int bufsize = 0;     ok = PyArg_ParseTuple(args, "s|si", &amp;file, &amp;mode, &amp;bufsize);     /* Ciąg znaków, i opcjonalnie następny ciąg i liczba całkowita */     /* Możliwe wywołania pytonowskie:        f('spam')        f('spam', 'w')        f('spam', 'wb', 100000) */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{     int left, top, right, bottom, h, v;     ok = PyArg_ParseTuple(args, "((ii)(ii))(ii)",              &amp;left, &amp;top, &amp;right, &amp;bottom, &amp;h, &amp;v);     /* A rectangle and a point */     /* Possible Python call:        f(((0, 0), (400, 300)), (10, 10)) */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>{     int left, top, right, bottom, h, v;     ok = PyArg_ParseTuple(args, "((ii)(ii))(ii)",              &amp;left, &amp;top, &amp;right, &amp;bottom, &amp;h, &amp;v);     /* Prostokąt i punkt */     /* Możliwe wywołania pytonowskie:        f(((0, 0), (400, 300)), (10, 10)) */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{     Py_complex c;     ok = PyArg_ParseTuple(args, "D:myfunction", &amp;c);     /* a complex, also providing a function name for errors */     /* Possible Python call: myfunction(1+2j) */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>{     Py_complex c;     ok = PyArg_ParseTuple(args, "D:myfunction", &amp;c);     /* Zespolona, także dostarczająca nazwę zadania dla błędów */     /* Możliwe wywołania pytonowskie: myfunction(1+2j) */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keyword Parameters for Extension Functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry kluczowe dla zadań rozszerzających</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :cfunc:`PyArg_ParseTupleAndKeywords` function is declared as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie :cfunc:`PyArg_ParseTupleAndKeywords` jest zadeklarowane jak następuje::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,                                 char *format, char *kwlist[], ...);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,                                 char *format, char *kwlist[], ...);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *arg* and *format* parameters are identical to those of the :cfunc:`PyArg_ParseTuple` function.  The *kwdict* parameter is the dictionary of keywords received as the third parameter from the Python runtime.  The *kwlist* parameter is a *NULL*-terminated list of strings which identify the parameters; the names are matched with the type information from *format* from left to right.  On success, :cfunc:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns false and raises an appropriate exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry *arg* i *format* są identyczne z tymi z zadania :cfunc:`PyArg_ParseTuple`. Parametr *kwdict* jest słownikiem słów kluczowych otrzymywanych jako trzeci parametr w czasie wykonania. Parametr *kwlist* jest zakończoną znakiem *NULL* listą ciągów znaków które identyfikują parametry; Nazwy są dopasowywane z typem informacji z *formatu* od lewej do prawej. Przy pomyślnym rozwiązaniu zadanie :cfunc:`PyArg_ParseTupleAndKeywords` zwraca prawdę, w innym przypadku zwraca fałsz i zgłasza odpowiedni wyjątek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nested tuples cannot be parsed when using keyword arguments!  Keyword parameters passed in which are not present in the *kwlist* will cause :exc:`TypeError` to be raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zagnieżdźone krotki nie mogą być wczytane gdy używane są parametry słów kluczowych! Parametry słów kluczowych przekazane do zadania które nie są obecne na liście *kwlist* spowodują że wyjątek :exc:`TypeError` zostanie zgłoszony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example module which uses keywords, based on an example by Geoff Philbrick (philbrick@hks.com)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest przykładowy moduł który używa słów kluczowych, oparty na przykładzie Geoffa Philbricka (philbrick@hks.com)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "Python.h"  static PyObject * keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds) {     int voltage;     char *state = "a stiff";     char *action = "voom";     char *type = "Norwegian Blue";      static char *kwlist[] = {"voltage", "state", "action", "type", NULL};      if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist,                                      &amp;voltage, &amp;state, &amp;action, &amp;type))         return NULL;      printf("-- This parrot wouldn't %s if you put %i Volts through it.\n",            action, voltage);     printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);      Py_INCREF(Py_None);      return Py_None; }  static PyMethodDef keywdarg_methods[] = {     /* The cast of the function is necessary since PyCFunction values      * only take two PyObject* parameters, and keywdarg_parrot() takes      * three.      */     {"parrot", (PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,      "Print a lovely skit to standard output."},     {NULL, NULL, 0, NULL}   /* sentinel */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include "Python.h"  static PyObject * keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds) {     int napiecie;     char *stan = "sztywna";     char *akcja = "wyje";     char *typ = "Norweska Niebieska";      static char *kwlist[] = {"napiecie", "stan", "akcja", "typ", NULL};      if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist,                                      &amp;napiecie, &amp;stan, &amp;akcja, &amp;typ))         return NULL;      printf("-- Ta papuga nie %s nawet jeśli przyłożysz %i Voltów do niej.\n",            action, voltage);     printf("-- Piękne ubarwienie, %s -- jest %s!\n", type, state);      Py_INCREF(Py_None);      return Py_None; }  static PyMethodDef keywdarg_methods[] = {     /* Rzutowanie zadania jest konieczne odkąd wartości PyCFunction      * pobierają tylko dwa parametery PyObject* , i keywdarg_parrot() pobiera      * trzy.      */     {"parrot", (PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,      "Wypisz ładny skecz na standardowe wyjście."},     {NULL, NULL, 0, NULL}   /* ochroniarz */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>void initkeywdarg(void) {   /* Create the module and add the functions */   Py_InitModule("keywdarg", keywdarg_methods); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>void initkeywdarg(void) { /* Stwórz moduł i dodaj zadania */ Py_InitModule("keywdarg", keywdarg_methods); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Arbitrary Values</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Budowanie Dowolnych Wartości</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is the counterpart to :cfunc:`PyArg_ParseTuple`.  It is declared as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest odpowiednikiem :cfunc:`PyArg_ParseTuple`. Jest deklarowane w następujący sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyObject *Py_BuildValue(char *format, ...);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyObject *Py_BuildValue(char *format, ...);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It recognizes a set of format units similar to the ones recognized by :cfunc:`PyArg_ParseTuple`, but the arguments (which are input to the function, not output) must not be pointers, just values.  It returns a new Python object, suitable for returning from a C function called from Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozpoznaje ono zestaw jednostek formatu podobnych do tych rozpoznawanych przez :cfunc:`PyArg_ParseTuple`, ale parametry (które są wprowadzane do funkcji, nie są wynikami) nie mogą być wskaźnikami, tylko wartościami. Zwracają nowy przedmiot języka pytonowskiego, dostosowany do zwracania z zadania C wzywanego przez język pytonowski.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One difference with :cfunc:`PyArg_ParseTuple`: while the latter requires its first argument to be a tuple (since Python argument lists are always represented as tuples internally), :cfunc:`Py_BuildValue` does not always build a tuple.  It builds a tuple only if its format string contains two or more format units. If the format string is empty, it returns ``None``; if it contains exactly one format unit, it returns whatever object is described by that format unit.  To force it to return a tuple of size 0 or one, parenthesize the format string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedna różnicą w zadaniu :cfunc:`PyArg_ParseTuple`: podczas gdy ta druga wymaga jej pierwszego parametru aby był krotką (od kiedy listy parametrów języka pytonowskiego są zawsze reprezentowane jeko krotki wewnętrznie), :cfunc:`Py_BuildValue` nie zawsze buduje krotkę. Buduje krotkę tylko jeśli jej ciąg formatujący zawiera dwie lub więcej jednostki formatujące. Jeśli ciąg formatujący jest pusty, zwraca ``Żaden`` - z ang. - ``None``; jeśli zawiera dokładnie jedną jednostkę formatującą, zwraca ten przedmiot który jest opisywany przez tą jednostkę formatującą. Aby zmusić ją aby zwracała krotkę o rozmiarze 0 lub jeden, zawrzyj ciąg formatujący w nawiasy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples (to the left the call, to the right the resulting Python value)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady (na lewo - wywołanie, na prawo - wynikająca wartość języka pytonowskiego)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_BuildValue("")                        None Py_BuildValue("i", 123)                  123 Py_BuildValue("iii", 123, 456, 789)      (123, 456, 789) Py_BuildValue("s", "hello")              'hello' Py_BuildValue("y", "hello")              b'hello' Py_BuildValue("ss", "hello", "world")    ('hello', 'world') Py_BuildValue("s#", "hello", 4)          'hell' Py_BuildValue("y#", "hello", 4)          b'hell' Py_BuildValue("()")                      () Py_BuildValue("(i)", 123)                (123,) Py_BuildValue("(ii)", 123, 456)          (123, 456) Py_BuildValue("(i,i)", 123, 456)         (123, 456) Py_BuildValue("[i,i]", 123, 456)         [123, 456] Py_BuildValue("{s:i,s:i}",               "abc", 123, "def", 456)    {'abc': 123, 'def': 456} Py_BuildValue("((ii)(ii)) (ii)",               1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_BuildValue("")                        None Py_BuildValue("i", 123)                  123 Py_BuildValue("iii", 123, 456, 789)      (123, 456, 789) Py_BuildValue("s", "hello")              'hello' Py_BuildValue("y", "hello")              b'hello' Py_BuildValue("ss", "hello", "world")    ('hello', 'world') Py_BuildValue("s#", "hello", 4)          'hell' Py_BuildValue("y#", "hello", 4)          b'hell' Py_BuildValue("()")                      () Py_BuildValue("(i)", 123)                (123,) Py_BuildValue("(ii)", 123, 456)          (123, 456) Py_BuildValue("(i,i)", 123, 456)         (123, 456) Py_BuildValue("[i,i]", 123, 456)         [123, 456] Py_BuildValue("{s:i,s:i}",               "abc", 123, "def", 456)    {'abc': 123, 'def': 456} Py_BuildValue("((ii)(ii)) (ii)",               1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference Counts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczby odniesień</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In languages like C or C++, the programmer is responsible for dynamic allocation and deallocation of memory on the heap.  In C, this is done using the functions :cfunc:`malloc` and :cfunc:`free`.  In C++, the operators ``new`` and ``delete`` are used with essentially the same meaning and we'll restrict the following discussion to the C case.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W językach takich jak C lub C++, programujący jest odpowiedzialny za dynamiczną alokację i dealokację pamięci na stercie. W C, to jest dokonywane przy użyciu zadań :cfunc:`malloc` i :cfunc:`free`. W C++, operatory ``new`` i ``delete`` są używane z w gruncie rzeczy jednakowym znaczeniem i ograniczymy się w następującej dyskusji do przypadku C. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every block of memory allocated with :cfunc:`malloc` should eventually be returned to the pool of available memory by exactly one call to :cfunc:`free`. It is important to call :cfunc:`free` at the right time.  If a block's address is forgotten but :cfunc:`free` is not called for it, the memory it occupies cannot be reused until the program terminates.  This is called a :dfn:`memory leak`.  On the other hand, if a program calls :cfunc:`free` for a block and then continues to use the block, it creates a conflict with re-use of the block through another :cfunc:`malloc` call.  This is called :dfn:`using freed memory`. It has the same bad consequences as referencing uninitialized data --- core dumps, wrong results, mysterious crashes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każdy blok pamięci alokowany za pomocą zadania :cfunc:`malloc` powinien w końcu być zwrócony do puli dostępnej pamięci przez dokładnie jedno odwołanie do zadania :cfunc:`free`. Jest to istotne aby wywołać zadanie :cfunc:`free` we właściwym momencie. Jeśli adres bloku został zapomniany, ale zadanie :cfunc:`free` nie zostanie wezwane dla niego, pamięć którą zajmuje nie może być ponownie użyta dopóki program nie zakończy swojego działania. To nazywane jest wyciekiem pamięci - z ang. - :dfn:`memory leak`. Z drugiej strony, jeśli program wywołuje :cfunc:`free` dla bloku i potem nadal korzysta z bloku, tworzy to konflikt z ponownym użyciem bloku przez inne wywołanie zadania :cfunc:`malloc`. To jest zwane :dfn:`użyciem uwolnionej pamięci` - z ang. - :dfn:`using freed memory`. Ma to tak samo złe konsekwencje jak odwołanie się do niezainicjowanych danych --- zrzuty jądra, złe wyniki, tajemnicze zatrzymania programu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common causes of memory leaks are unusual paths through the code.  For instance, a function may allocate a block of memory, do some calculation, and then free the block again.  Now a change in the requirements for the function may add a test to the calculation that detects an error condition and can return prematurely from the function.  It's easy to forget to free the allocated memory block when taking this premature exit, especially when it is added later to the code.  Such leaks, once introduced, often go undetected for a long time: the error exit is taken only in a small fraction of all calls, and most modern machines have plenty of virtual memory, so the leak only becomes apparent in a long-running process that uses the leaking function frequently.  Therefore, it's important to prevent leaks from happening by having a coding convention or strategy that minimizes this kind of errors.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Typowymi przyczynami wycieków pamięci są nietypowe ścieżki przejścia przez kod. Dla przykładu, zadanie może zaalokować blok pamięci, wykonać pewne obliczenia, a potem uwolnić ten blok jeszcze raz. Teraz zmiana w wymaganiach dla zadania może dodać test do obliczenia który wykrywa warunek błędu i może wrócić wcześniej z zadania. Łatwo jest zapomnieć aby uwolnić zaalokowany blok pamięci podczas wybierania tej drogi wcześniejszego zakończenia, szczególnie gdy jest dodawane później do kodu. Takie przecieki, gdy raz wprowadzone, często uchodzą niewykryte przez długi czas: błędne wyjście jest wybierane tylko w małym wycinku wszystkich wywołań, i większość nowoczesnych maszyn ma mnóstwo wirtualnej pamięci, tak że wyciek staje się widoczny tylko w długo działającym procesie który używa cieknącego zadania często. Dlatego też, jest to ważne aby zapobiegać wyciekom przed ich nastąpieniem, przez powzięcie konwencji kodowania lub strategii która minimalizuje ten rodzaj błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since Python makes heavy use of :cfunc:`malloc` and :cfunc:`free`, it needs a strategy to avoid memory leaks as well as the use of freed memory.  The chosen method is called :dfn:`reference counting`.  The principle is simple: every object contains a counter, which is incremented when a reference to the object is stored somewhere, and which is decremented when a reference to it is deleted. When the counter reaches zero, the last reference to the object has been deleted and the object is freed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skoro język pytonowski często używa :cfunc:`malloc` i :cfunc:`free`, wymagana jest strategia aby omijać wycieki pamięci zarówno jak też użycia uwolnionej pamięci. Wybrana metoda jest zwana :dfn:`zliczaniem odniesień` - z ang. :dfn:`reference counting`. Zasada jest prosta: każdy przedmiot zawiera licznik, który jest zwiększany gdy odniesienie do przedmiotu jest zachowywane gdzieś, i który jest zmniejszany gdy odniesienie do niego jest kasowane. Gdy licznik dotrze do zera, ostatnie odniesienie do przedmiotu zostało skasowane i przedmiot jest uwalniany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative strategy is called :dfn:`automatic garbage collection`. (Sometimes, reference counting is also referred to as a garbage collection strategy, hence my use of "automatic" to distinguish the two.)  The big advantage of automatic garbage collection is that the user doesn't need to call :cfunc:`free` explicitly.  (Another claimed advantage is an improvement in speed or memory usage --- this is no hard fact however.)  The disadvantage is that for C, there is no truly portable automatic garbage collector, while reference counting can be implemented portably (as long as the functions :cfunc:`malloc` and :cfunc:`free` are available --- which the C Standard guarantees). Maybe some day a sufficiently portable automatic garbage collector will be available for C. Until then, we'll have to live with reference counts.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Alternatywna strategia jest zwana :dfn:`automatyczną zbiórką śmieci`. (Czasami, do zliczania odniesień także odnosimy się jako do strategii zbierania śmieci, stąd moje użycie określenia "automatycznej" aby odróżnić je między sobą.) Dużą zaletą automatycznej zbiórki śmieci jest to, że użytkownik nie musi wzywać zadania :cfunc:`free` jawnie. (Inną utrzymywaną zaletą jest usprawnienie w prędkości użycia pamięci --- nie jest to jednak twardy fakt.) Wadą jest to że dla C nie ma prawdziwie przenośnego automatycznego zbieracza śmieci, podczas gdy zliczanie odniesień może być wypełnione przenośnie (tak długo, jak dostępne są zadania :cfunc:`malloc` i :cfunc:`free` --- co gwarantuje standard C). Może pewnego dnia wystarczająco przenośny automatyczny zbieracz śmieci będzie dostępny dla C. Jednak do tego czasu, będziemy musieli żyć ze zliczaniem odniesień.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles.  This allows applications to not worry about creating direct or indirect circular references; these are the weakness of garbage collection implemented using only reference counting.  Reference cycles consist of objects which contain (possibly indirect) references to themselves, so that each object in the cycle has a reference count which is non-zero.  Typical reference counting implementations are not able to reclaim the memory belonging to any objects in a reference cycle, or referenced from the objects in the cycle, even though there are no further references to the cycle itself.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podczas gdy język pytonowski używa tradycyjnego wypełnienia zliczania odniesień, on także oferuje wykrywanie cykli, które pracuje aby wykrywać cykliczne odniesienia. To pozwala aplikacjom nie martwić się o tworzenie bezpośrednich lub pośrednich cyklicznych odniesień; to są słabości wypełnienia zbiórki śmieci opartego jedynie na zliczaniu odniesień. Cykle odniesień składają się z przedmiotów które zawierają (możliwie pośrednio) odniesienia do samych siebie, tak że każdy przedmiot w cyklu ma liczbę odniesień która jest nie-zerowa. Typowe wypełnienia zliczające odniesienia nie są w stanie przejąć z powrotem pamięci należącej do któregokolwiek z przedmiotów w cyklu odniesień, ani do której odnosi się któryś z przedmiotów w cyklu, nawet jeśli nie ma więcej odniesień do cyklu samego w sobie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cycle detector is able to detect garbage cycles and can reclaim them so long as there are no finalizers implemented in Python (:meth:`__del__` methods). When there are such finalizers, the detector exposes the cycles through the :mod:`gc` module (specifically, the ``garbage`` variable in that module).  The :mod:`gc` module also exposes a way to run the detector (the :func:`collect` function), as well as configuration interfaces and the ability to disable the detector at runtime.  The cycle detector is considered an optional component; though it is included by default, it can be disabled at build time using the :option:`--without-cycle-gc` option to the :program:`configure` script on Unix platforms (including Mac OS X).  If the cycle detector is disabled in this way, the :mod:`gc` module will not be available.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykrywacz cyklów jest w stanie wykryć cykle śmieci i przejąć je tak długo jak nie ma sposobów postępowania zakańczających życie przedmiotów wypełnionych w języku pytonowskim (sposobów postępowania :meth:`__del__`). Gdy są takie sposoby postępowania zakańczające życie przedmiotów, wykrywacz cyklów wystawia cykle przez moduł :mod:`gc` (szczególnie, przez zmienną ``śmieci`` w tym module). Moduł :mod:`gc` także wystawia sposób aby uruchomić wykrywacz cykli (zadaniem :func:`collect`), zarówno, jak też sprzęgi i możliwość wyłączenia wykrywacza w czasie wykonania programów. Wykrywacz cykli jest uznawany za dodatkowy (ponadprogramowy) element; chociaż jest załączony domyślnie, może być wyłączony w czasie budowania przy użyciu opcji :option:`--without-cycle-gc` dla skryptu :program:`configure` na maszynie/środowisku Unix-owym (włączając w to Mac OS X). Jeśli wykrywacz cykli zostanie wyłączony w ten sposób, moduł :mod:`gc` nie będzie dostępny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference Counting in Python</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zliczanie odniesień w języku pytonowskim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle the incrementing and decrementing of the reference count. :cfunc:`Py_DECREF` also frees the object when the count reaches zero. For flexibility, it doesn't call :cfunc:`free` directly --- rather, it makes a call through a function pointer in the object's :dfn:`type object`.  For this purpose (and others), every object also contains a pointer to its type object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją dwa makropolecenia, ``Py_INCREF(x)`` i ``Py_DECREF(x)``, które obsługują zwiększanie i zmniejszanie liczby odniesień. :cfunc:`Py_DECREF` uwalnia także przedmiot gdy liczba odniesień dotrze do zera. Dla elastyczności, nie wzywa się zadania :cfunc:`free` bezpośrednio --- zamiast tego, wykonuje się wywołanie zadania przez wskaźnik zadania, w :dfn:`typie przedmiotu` - z ang. :dfn:`type object` należącym do przedmiotu. Dla tego celu (i innych), każdy przedmiot także zawiera wskaźnik do swojego rodzaju przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The big question now remains: when to use ``Py_INCREF(x)`` and ``Py_DECREF(x)``? Let's first introduce some terms.  Nobody "owns" an object; however, you can :dfn:`own a reference` to an object.  An object's reference count is now defined as the number of owned references to it.  The owner of a reference is responsible for calling :cfunc:`Py_DECREF` when the reference is no longer needed.  Ownership of a reference can be transferred.  There are three ways to dispose of an owned reference: pass it on, store it, or call :cfunc:`Py_DECREF`. Forgetting to dispose of an owned reference creates a memory leak.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wielkie pytanie teraz pozostaje: kiedy używać ``Py_INCREF(x)`` i ``Py_DECREF(x)``? Wprowadźmy najpierw kilka terminów. Nikt nie "posiada" przedmiotu; jednakże można :dfn:`posiadać odniesienie` do przedmiotu. Liczba odniesień do przedmiotu jest teraz określona jako liczba posiadanych odniesień do niego. Właściciel odniesienia jest odpowiedzialny za wezwanie zadania :cfunc:`Py_DECREF` gdy odniesienie nie jest już dłużej potrzebne. Bycie właścicielem odniesienia może być przenoszone. Istnieją trzy sposoby aby pozbyć się posiadanego odniesienia: przekazać je, zachować je lub wywołać zadanie :cfunc:`Py_DECREF`. Zapominanie o pozbyciu się posiadanego odniesienia tworzy wyciek pamięci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The borrower of a reference should not call :cfunc:`Py_DECREF`.  The borrower must not hold on to the object longer than the owner from which it was borrowed. Using a borrowed reference after the owner has disposed of it risks using freed memory and should be avoided completely. [#]_</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest także możliwe :dfn:`pożyczanie` [#]_ - z ang. - :dfn:`borrow` [#]_ odniesienia do przedmiotu. Pożyczający odniesienie nie powinien wzywać :cfunc:`Py_DECREF`. Pożyczającemu nie wolno trzymać się przedmiotu dłużej niż właścicielowi od którego przedmiot został pożyczony. Używanie pożyczonego odniesienia po tym jak właściciel się go pozbył ryzykuje używaniem uwolnionej pamięci i powinno być unikane całkowicie. [#]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The advantage of borrowing over owning a reference is that you don't need to take care of disposing of the reference on all possible paths through the code --- in other words, with a borrowed reference you don't run the risk of leaking when a premature exit is taken.  The disadvantage of borrowing over owning is that there are some subtle situations where in seemingly correct code a borrowed reference can be used after the owner from which it was borrowed has in fact disposed of it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zaletą pożyczania ponad posiadaniem odniesienia jest to że nie potrzebujesz zaprzątać swojej uwagi pozbyciem się odniesienia na wszystkich możliwych ścieżkach przejścia przez kod --- innymi słowy, z pożyczonym odniesieniem nie musisz ryzykować wycieku gdy nastąpi przedwczesne wyjście z programu. Wadą pożyczania ponad posiadaniem jest to że istnieją pewne szczególne sytuacje gdzie w wydawałoby się poprawnym kodzie pożyczone odniesienie może być użyte po tym jak właściciel od którego zostało ono pożyczone faktycznie pozbył się go.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A borrowed reference can be changed into an owned reference by calling :cfunc:`Py_INCREF`.  This does not affect the status of the owner from which the reference was borrowed --- it creates a new owned reference, and gives full owner responsibilities (the new owner must dispose of the reference properly, as well as the previous owner).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pożyczone odniesienie może być zamienione na posiadane odniesienie przez wezwanie :cfunc:`Py_INCREF`. To nie wpływa na status właściciela od którego odniesienie zostało pożyczone --- to tworzy nowe posiadane odniesienie, i daje pełne prawa i obowiązki właścicielskie (nowy właściciel musi pozbyć się odniesienia we właściwy sposób, tak jak poprzedni właściciel).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ownership Rules</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zasady właścicielskie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whenever an object reference is passed into or out of a function, it is part of the function's interface specification whether ownership is transferred with the reference or not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zawsze gdy odniesienie do przedmiotu jest przekazywane do lub z zadania, jest częścią specyfiki sprzęgu zadania to czy własność jest przekazywana z odniesieniem czy też nie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most functions that return a reference to an object pass on ownership with the reference.  In particular, all functions whose function it is to create a new object, such as :cfunc:`PyLong_FromLong` and :cfunc:`Py_BuildValue`, pass ownership to the receiver.  Even if the object is not actually new, you still receive ownership of a new reference to that object.  For instance, :cfunc:`PyLong_FromLong` maintains a cache of popular values and can return a reference to a cached item.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość zadań które zwracają odniesienie do przedmiotu przekazuje prawo własności wraz z odniesieniem. W szczególności, wszystkie zadania których celem jest tworzenie nowych przedmiotów, takich jak :cfunc:`PyLong_FromLong` i :cfunc:`Py_BuildValue`, przekazują prawo własności do odbierającego. Nawet jeśli przedmiot nie jest właściwie nowy, wciąż otrzymujesz własność nowego odniesienia do tego przedmiotu. Dla przykładu, :cfunc:`PyLong_FromLong` utrzymuje pamięć podręczną popularnych wartości i może zwrócić odniesienie do przedmiotów trzymanych w pamięci podręcznej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many functions that extract objects from other objects also transfer ownership with the reference, for instance :cfunc:`PyObject_GetAttrString`.  The picture is less clear, here, however, since a few common routines are exceptions: :cfunc:`PyTuple_GetItem`, :cfunc:`PyList_GetItem`, :cfunc:`PyDict_GetItem`, and :cfunc:`PyDict_GetItemString` all return references that you borrow from the tuple, list or dictionary.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wiele zadań które wydobywają przedmioty z innych przedmiotów także przekazuje własność z odniesieniem, na przykład :cfunc:`PyObject_GetAttrString`. Obraz jest mniej jasny, tutaj, jednakże, gdyż kilka typowych zadań jest wyjątkami: :cfunc:`PyTuple_GetItem`, :cfunc:`PyList_GetItem`, :cfunc:`PyDict_GetItem`, i :cfunc:`PyDict_GetItemString` wszystkie zwracają odniesienia które pożyczasz z krotki, listy lub słownika.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function :cfunc:`PyImport_AddModule` also returns a borrowed reference, even though it may actually create the object it returns: this is possible because an owned reference to the object is stored in ``sys.modules``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie :cfunc:`PyImport_AddModule` także zwraca pożyczone odniesienia, nawet jeśli może to właściwie tworzyć przedmiot który zwraca: jest to możliwe, ponieważ posiadane odniesienie do przedmiotu jest przechowywane w ``sys.modules``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you pass an object reference into another function, in general, the function borrows the reference from you --- if it needs to store it, it will use :cfunc:`Py_INCREF` to become an independent owner.  There are exactly two important exceptions to this rule: :cfunc:`PyTuple_SetItem` and :cfunc:`PyList_SetItem`.  These functions take over ownership of the item passed to them --- even if they fail!  (Note that :cfunc:`PyDict_SetItem` and friends don't take over ownership --- they are "normal.")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy przekazujesz odniesienie do przedmiotu dla innego zadania, z reguły, zadanie pożycza odniesienie od ciebie --- jeśli potrzebuje zachować je, użyje :cfunc:`Py_INCREF` aby zostać niezależnym właścicielem. Istnieją dokładnie dwa istotne wyjątki od tej reguły: zadania :cfunc:`PyTuple_SetItem` i :cfunc:`PyList_SetItem`. Te zadania przejmują prawo własności przedmiotów przekazywanych im --- nawet jeśli zawiodą! (Zauważ, że :cfunc:`PyDict_SetItem i jego przyjaciele nie przejmują własności --- one są "normalne.")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a C function is called from Python, it borrows references to its arguments from the caller.  The caller owns a reference to the object, so the borrowed reference's lifetime is guaranteed until the function returns.  Only when such a borrowed reference must be stored or passed on, it must be turned into an owned reference by calling :cfunc:`Py_INCREF`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy zadanie C jest wzywane z poziomu języka pytonowskiego, pożycza ono odniesienia do swoich parametrów od wzywającego. Wywołujący posiada odniesienia do przedmiotu, tak więc istnienie pożyczonych odniesień jest gwarantowane aż do powrotu z zadania. Tylko gdy tak pożyczone odniesienie musi być zachowane lub przekazane, musi ono być zamienione w posiadane odniesienie przez wywołanie makropolecenia :cfunc:`Py_INCREF`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The object reference returned from a C function that is called from Python must be an owned reference --- ownership is transferred from the function to its caller.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odniesienie do przedmiotu zwrócone z zadania C które jest wywołane z poziomu języka pytonowskiego musi być posiadanym odniesieniem --- prawo własności jest przekazywane z zadania do wywołującego to ostatnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thin Ice</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Cienki lód</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few situations where seemingly harmless use of a borrowed reference can lead to problems.  These all have to do with implicit invocations of the interpreter, which can cause the owner of a reference to dispose of it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje kilka sytuacji gdzie wydawałoby się nieszkodliwe użycie pożyczonych odniesień może prowadzić do kłopotów. Wszystkie one mają do czynienia z niejawnymi wezwaniami programu interpretującego polecenia języka pytonowskiego, które mogą powodować że właściciel odniesienia pozbędzie się go.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first and most important case to know about is using :cfunc:`Py_DECREF` on an unrelated object while borrowing a reference to a list item.  For instance::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwszym i najbardziej istotnym przypadkiem o którym warto wiedzieć jest użycie :cfunc:`Py_DECREF` na niezwiązanym przedmiocie podczas pożyczania odniesienia do elementu listy. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>void bug(PyObject *list) {     PyObject *item = PyList_GetItem(list, 0);      PyList_SetItem(list, 1, PyLong_FromLong(0L));     PyObject_Print(item, stdout, 0); /* BUG! */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>void bug(PyObject *list) {     PyObject *element = PyList_GetItem(list, 0);      PyList_SetItem(list, 1, PyLong_FromLong(0L));     PyObject_Print(element, stdout, 0); /* BŁĄD! */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function first borrows a reference to ``list[0]``, then replaces ``list[1]`` with the value ``0``, and finally prints the borrowed reference. Looks harmless, right?  But it's not!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie najpierw pożycza odniesienie do ``list[0]``, potem zamienia ``list[1] na wartość ``0``, i ostatecznie wypisuje pożyczone odniesienie. Wydaje się nieszkodliwe, czyż nie? A jednak jest!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's follow the control flow into :cfunc:`PyList_SetItem`.  The list owns references to all its items, so when item 1 is replaced, it has to dispose of the original item 1.  Now let's suppose the original item 1 was an instance of a user-defined class, and let's further suppose that the class defined a :meth:`__del__` method.  If this class instance has a reference count of 1, disposing of it will call its :meth:`__del__` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Prześledźmy przepływ wykonania wchodzący do :cfunc:`PyList_SetItem`. Lista posiada odniesienia do wszystkich swoich elementów, więc gdy element pierwszy jest zamieniany, musi pozbyć się pierwotnego elementu pierwszego. A teraz załóżmy, że pierwotny element pierwszy był przykładem zdefiniowanego-przez-użytkownika uogólnienia, i załóżmy także że uogólnienie określało sposób postępowania :meth:`__del__`. Jeśli ten przykład uogólnienia miał liczbę odniesień równą jeden, pozbywając się go wywoła on swój sposób postępowania :meth:`__del__`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since it is written in Python, the :meth:`__del__` method can execute arbitrary Python code.  Could it perhaps do something to invalidate the reference to ``item`` in :cfunc:`bug`?  You bet!  Assuming that the list passed into :cfunc:`bug` is accessible to the :meth:`__del__` method, it could execute a statement to the effect of ``del list[0]``, and assuming this was the last reference to that object, it would free the memory associated with it, thereby invalidating ``item``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ponieważ jest to napisane w języku pytonowskim, sposób postępowania :meth:`__del__` może wykonać dowolny kod języka pytonowskiego. Mógłby być może zrobić coś, co unieważniłoby odniesienie do ``elementu`` w zadaniu :cfunc:`bug`? Można się założyć że tak! Przyjmując założenie, że lista przekazana do zadania :cfunc:`bug` jest dostępna dla sposobu postępowania :meth:`__del__, mogłoby wykonać wyrażenie efektywnego ``del list[0]`` i zakładając że to było ostatnie odniesienie do tego przedmiotu, to uwolniłoby pamięć związaną z nią, tym samym unieważniając ``element``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution, once you know the source of the problem, is easy: temporarily increment the reference count.  The correct version of the function reads::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozwiązanie, gdy znasz już źródło problemu, jest łatwe: tymczasowo zwiększyć ilość odniesień. Poprawna wersja zadania równa jest::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>void no_bug(PyObject *list) {     PyObject *item = PyList_GetItem(list, 0);      Py_INCREF(item);     PyList_SetItem(list, 1, PyLong_FromLong(0L));     PyObject_Print(item, stdout, 0);     Py_DECREF(item); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>void no_bug(PyObject *list) {     PyObject *element = PyList_GetItem(list, 0);      Py_INCREF(element);     PyList_SetItem(list, 1, PyLong_FromLong(0L));     PyObject_Print(element, stdout, 0);     Py_DECREF(element); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a true story.  An older version of Python contained variants of this bug and someone spent a considerable amount of time in a C debugger to figure out why his :meth:`__del__` methods would fail...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest prawdziwa historia. Starsza wersja języka pytonowskiego zawierała warianty tego błędu i ktoś spędził zdrowy kawałek czasu w debugerze C aby dowiedzieć się czemu jegosposoby postępowania :meth:`__del__` zawodziły...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second case of problems with a borrowed reference is a variant involving threads.  Normally, multiple threads in the Python interpreter can't get in each other's way, because there is a global lock protecting Python's entire object space.  However, it is possible to temporarily release this lock using the macro :cmacro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it using :cmacro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O calls, to let other threads use the processor while waiting for the I/O to complete. Obviously, the following function has the same problem as the previous one::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Drugim przypadkiem problemów z pożyczonym odniesieniem jest wariant zajmujący się wątkami. Zwykle, wiele wątków w programie interpretującym polecenia języka pytonowskiego nie może wchodzić sobie nawzajem w drogę, ponieważ istnieje nadrzędna blokada chroniąca całą przestrzeń przedmiotów języka pytonowskiego. Jednakże, jest możliwe tymczasowo zwolnić tą blokadę używając makropolecenia :cmacro:`Py_BEGIN_ALLOW_THREADS`, i ponownie je przejąć używając :cmacro:`Py_END_ALLOW_THREADS`. To jest częste przy blokowaniu wywołań wejścia/wyjścia, aby pozwalać innym wątkom używać procesora czekając na wejście/wyjście aby zostało zakończone. Oczywiste jest, że następujące zadanie ma ten sam problem co poprzednie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>void bug(PyObject *list) {     PyObject *item = PyList_GetItem(list, 0);     Py_BEGIN_ALLOW_THREADS     ...some blocking I/O call...     Py_END_ALLOW_THREADS     PyObject_Print(item, stdout, 0); /* BUG! */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>void bug(PyObject *list) {     PyObject *element = PyList_GetItem(list, 0);     Py_BEGIN_ALLOW_THREADS     ...pewne operacje blokujące we/wy...     Py_END_ALLOW_THREADS     PyObject_Print(element, stdout, 0); /* BŁĄD! */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NULL Pointers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Puste wskaźniki (NULL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, functions that take object references as arguments do not expect you to pass them *NULL* pointers, and will dump core (or cause later core dumps) if you do so.  Functions that return object references generally return *NULL* only to indicate that an exception occurred.  The reason for not testing for *NULL* arguments is that functions often pass the objects they receive on to other function --- if each function were to test for *NULL*, there would be a lot of redundant tests and the code would run more slowly.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwykle, zadania, które pobierają odniesienia do przedmiotów jako parametry nie oczekują abyś przekazywał im puste (*NULL*) wskaźniki, i zrzucą jądro (lub spowodują późniejsze zrzucenie jądra) jeśli to wykonasz. Zadania które zwracają odniesienia do przedmiotu zwykle zwracają *NULL* tylko aby zaznaczyć że nastąpił wyjątek. Przyczyną nie sprawdzania parametrów czy są *NULL* jest to, że zadania często przekazują przedmioty które otrzymują dalej do innych zadań --- jeśli każde zadanie miałoby sprawdzać czy jego parametry są *NULL*, byłoby mnóstwo nadmiarowych testów i kod działałby dużo wolniej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is better to test for *NULL* only at the "source:" when a pointer that may be *NULL* is received, for example, from :cfunc:`malloc` or from a function that may raise an exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest lepiej sprawdzać czy jest *NULL* tylko u "źródła:" gdy wskaźnik, który mógłby być *NULL* jest otrzymywany, na przykład, z :cfunc:`malloc` lub z zadania które mogłoby zgłosić wyjątek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The macros :cfunc:`Py_INCREF` and :cfunc:`Py_DECREF` do not check for *NULL* pointers --- however, their variants :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF` do.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia :cfunc:`Py_INCREF` i :cfunc:`Py_DECREF` nie sprawdzają wskaźników *NULL* --- jednakże w ich odmianie :cfunc:Py_XINCREF` i :cfunc:`Py_XDECREF` sprawdzają.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The macros for checking for a particular object type (``Pytype_Check()``) don't check for *NULL* pointers --- again, there is much code that calls several of these in a row to test an object against various different expected types, and this would generate redundant tests.  There are no variants with *NULL* checking.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Makropolecenia dla sprawdzenia szczególnego rodzaju przedmiotu(``Pytype_Check()``) nie sprawdzają pustych (*NULL*) wskaźników --- znów, istnieje dużo kodu który wywołuje kilka z tych w rzędzie aby sprawdzić czy przedmiot jest typu jednego z kilku różnych oczekiwanych, i to powodowałoby nadmiarowe sprawdzenia. Nie ma wariantu ze sprawdzaniem *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The C function calling mechanism guarantees that the argument list passed to C functions (``args`` in the examples) is never *NULL* --- in fact it guarantees that it is always a tuple. [#]_</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Mechanizm wywołań zadań z języka C gwarantuje, że lista parametrów przekazywana do zadania C (``args`` w przykładach) nigdy nie jest *NULL* --- faktycznie gwarantuje że to zawsze jest krotka. [#]_  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a severe error to ever let a *NULL* pointer "escape" to the Python user.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest to poważnym błędem aby pozwolić aby pusty *NULL* wskaźnik "uciekł" do użytkownika języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions in C++</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pisanie rozszerzeń w C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to write extension modules in C++.  Some restrictions apply.  If the main program (the Python interpreter) is compiled and linked by the C compiler, global or static objects with constructors cannot be used.  This is not a problem if the main program is linked by the C++ compiler.  Functions that will be called by the Python interpreter (in particular, module initialization functions) have to be declared using ``extern "C"``. It is unnecessary to enclose the Python header files in ``extern "C" {...}`` --- they use this form already if the symbol ``__cplusplus`` is defined (all recent C++ compilers define this symbol).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest możliwe pisanie modułów rozszerzających w C++. Niektóre ograniczenia obowiązują. Jeśli główny program (program interpretujący polecenia języka pytonowskiego) jest kompilowany i łączony przez kompilator języka C, nadrzędne lub statyczne przedmioty z konstruktorami nie mogą być używane. To nie jest problemem jeśli główny program jest łączony przez kompilator C++. Zadania które będą wezwane przez program interpretujący polecenia języka pytonowskiego (w szczególności, zadania inicjujące moduł) muszą być deklarowane używając ``extern "C"``. Nie jest to konieczne aby zawierać plik nagłówkowy języka pytonowskiego w ``extern "C" {...}`` --- one używają już tej formy jeśli symbol ``__cplusplus`` jest zdefiniowany (wszystkie niedawne kompilatory C++ definiują ten symbol).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing a C API for an Extension Module</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarczanie sprzęgu programowania aplikacji (API) języka C dla modułu rozszerzającego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many extension modules just provide new functions and types to be used from Python, but sometimes the code in an extension module can be useful for other extension modules. For example, an extension module could implement a type "collection" which works like lists without order. Just like the standard Python list type has a C API which permits extension modules to create and manipulate lists, this new collection type should have a set of C functions for direct manipulation from other extension modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wiele modułów rozszerzających po prostu dostarcza nowych zadań i typów aby były używane z języka pytonowskiego, ale czasami kod w module rozszerzającym może być użyteczny dla innych rozszerzających modułów. Na przykład, moduł rozszerzający mógłby wypełniać typ "kolekcji" który działałby jak lista bez wprowadzonego porządku. Tak jak standardowy typ listy języka pytonowskiego posiada sprzęg programowania aplikacji języka C, który pozwala modułom rozszerzającym tworzenie i zmianę list, ten nowy typ kolekcji powinien mieć zbiór zadań C dla bezpośrednich zmian z innych modułów rozszerzających.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At first sight this seems easy: just write the functions (without declaring them ``static``, of course), provide an appropriate header file, and document the C API. And in fact this would work if all extension modules were always linked statically with the Python interpreter. When modules are used as shared libraries, however, the symbols defined in one module may not be visible to another module. The details of visibility depend on the operating system; some systems use one global namespace for the Python interpreter and all extension modules (Windows, for example), whereas others require an explicit list of imported symbols at module link time (AIX is one example), or offer a choice of different strategies (most Unices). And even if symbols are globally visible, the module whose functions one wishes to call might not have been loaded yet!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na pierwszy rzut oka to wydaje się proste: napisać zadania (bez deklarowania ich jako ``statycznych``, oczywiście), dostarczyć odpowiedni plik nagłówkowy, i udokumentować sprzęg programowania aplikacji (API) C. I faktycznie to mogłoby zadziałać jeśli wszystkie rozszerzające moduły byłyby zawsze złączone statycznie z programem interpretującym polecenia języka pytonowskiego. Gdy moduły są używane jako współdzielone biblioteki, jednakże, symbole zdefiniowane w jednym module mogą nie być widoczne dla innych modułów. Szczegóły widoczności zależą od systemu operacyjnego; niektóre systemy używają jednej nadrzędnej przestrzeni nazw dla programu interpretującego polecenia języka pytonowskiego i wszystkich modułów rozszerzających (dla Windows, na przykład), podczas gdy inne wymagają jawnej listy importowanych symboli w czasie łączenia modułów (AIX jest jednym z przykładów), lub oferują wybór różnych strategii (większość Unix-ów). I nawet jeśli symbole są widoczne nadrzędnie, moduł którego zadania ktoś chciałby uruchomić mogły nie zostać jeszcze załadowane! </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Portability therefore requires not to make any assumptions about symbol visibility. This means that all symbols in extension modules should be declared ``static``, except for the module's initialization function, in order to avoid name clashes with other extension modules (as discussed in section :ref:`methodtable`). And it means that symbols that *should* be accessible from other extension modules must be exported in a different way.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przenośność zatem wymaga aby nie czynić żadnych założeń o widoczności symboli. To oznacza, że wszystkie symbole w rozszerzających modułach powinny być deklarowane jako ``statyczne``, z wyjątkiem zadania zainicjowania modułu, w celu ominięcia wojen nazw z innymi modułami rozszerzającymi (jak określono w rozdziale :ref:`methodtable` - z ang. - :ref:`tabela sposobów postępowania`). I to oznacza, że symbole, które *powinny* być dostępne z innych rozszerzających modułów muszą być eksportowane w różny sposób.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python provides a special mechanism to pass C-level information (pointers) from one extension module to another one: Capsules. A Capsule is a Python data type which stores a pointer (:ctype:`void \*`).  Capsules can only be created and accessed via their C API, but they can be passed around like any other Python object. In particular,  they can be assigned to a name in an extension module's namespace. Other extension modules can then import this module, retrieve the value of this name, and then retrieve the pointer from the Capsule.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski dostarcza specjalny mechanizm aby przekazać informację na-poziomie-języka-C (wskaźniki) z jednego rozszerzenia do innego: Kapsuły. Kapsuły są typem danych języka pytonowskiego, które przechowują wskaźnik (:ctype:`void \*`). Kapsuły mogą tylko być tworzone i dostęp do nich może tylko być otrzymywany przez ich sprzęg programowania aplikacji (API) C, ale one nie mogą być przekazywane postronnie jak inne przedmioty języka pytonowskiego. W szczególności, mogą być przypisane do nazwy w przestrzeni nazw modułu rozszerzającego. Inne rozszerzające moduły mogą wtedy importować ten moduł, odebrać wartość tej nazwy, i wtedy odebrać wskaźnik z kapsuły.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many ways in which Capsules can be used to export the C API of an extension module. Each function could get its own Capsule, or all C API pointers could be stored in an array whose address is published in a Capsule. And the various tasks of storing and retrieving the pointers can be distributed in different ways between the module providing the code and the client modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje wiele sposobów w jakie kapsuły mogą być używane aby wystawiać na zewnątrz sprzęgi programowania aplikacji (API) języka C dla danego modułu rozszerzającego. Każde zadanie mogłoby dostać swoją własną kapsułę, lub wszystkie wskaźniki sprzęgu programowania aplikacji (API) języka C mogłyby być zachowane w tabeli której adres byłby opublikowany w kapsule. A różne zadania zachowania i odbioru wskaźników mogłyby być rozprowadzone na różne sposoby pomiędzy moduły dostarczające kod i moduły odbierające.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whichever method you choose, it's important to name your Capsules properly. The function :cfunc:`PyCapsule_New` takes a name parameter (:ctype:`const char \*`); you're permitted to pass in a *NULL* name, but we strongly encourage you to specify a name.  Properly named Capsules provide a degree of runtime type-safety; there is no feasible way to tell one unnamed Capsule from another.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Którejkolwiek metody nie wybrałbyś, jest istotne aby nazywać swoje kapsuły odpowiednio. Zadanie :cfunc:`PyCapsule_New` przyjmuje nazwę parametru (:ctype:`const char \*`); wolno Ci przekazać pustą nazwę *NULL*, ale silnie zachęcamy Cię byś określił nazwę. Poprawnie nazwana kapsuła dostarcza pewien poziom bezpieczeństwa-typów w czasie wykonania; nie ma żadnego możliwego sposobu aby odróżnić jedną nienazwaną kapsułę od drugiej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular, Capsules used to expose C APIs should be given a name following this convention::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W szczególności, kapsułom używanym do wystawiania sprzęgów programowania aplikacji języka C ( - z ang. - API) powinna być nadana nazwa stosująca się do następującej konwencji::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>modulename.attributename</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>modulename.attributename</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The convenience function :cfunc:`PyCapsule_Import` makes it easy to load a C API provided via a Capsule, but only if the Capsule's name matches this convention.  This behavior gives C API users a high degree of certainty that the Capsule they load contains the correct C API.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie sprzyjania :cfunc:`PyCapsule_Import` czyni łatwym aby ładować sprzęg programowania aplikacji w języku C dostarczony przez kapsułę, ale tylko jeśli nazwa kapsuły pasuje do tej konwencji. To zachowanie daje użytkownikom sprzęgu programowania aplikacji w języku C ( z ang. - API) wysokiego poziomu pewność że kapsuła którą ładują zawiera poprawny sprzęg programowania aplikcji w języku C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example demonstrates an approach that puts most of the burden on the writer of the exporting module, which is appropriate for commonly used library modules. It stores all C API pointers (just one in the example!) in an array of :ctype:`void` pointers which becomes the value of a Capsule. The header file corresponding to the module provides a macro that takes care of importing the module and retrieving its C API pointers; client modules only have to call this macro before accessing the C API.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący przykład demonstruje podejście które nakłada większość obciążenia na piszącym wystawiający na zewnątrz moduł, który jest właściwy dla wspólnie używanych modułów bibliotecznych. On przechowuje wszystkie wskaźniki sprzęgu programowania aplikcaji w języku C ( - z ang. - C API) (tylko jeden w tym przykładzie!) w tabeli wskaźników :ctype:`void`, które stają się wartością kapsuły. Plik nagłówkowy, odpowiadający modułowi dostarcza makropolecenie które zajmuje się  importowaniem modułu i odbieraniem jego wskaźników sprzęgu programowania aplikacji w języku C ( - z ang. - C API); Moduły korzystające muszą tylko wezwać to makropolecenie przed dostępem do sprzęgu programowania aplikacji w języku C ( - z ang. - C API)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The exporting module is a modification of the :mod:`spam` module from section :ref:`extending-simpleexample`. The function :func:`spam.system` does not call the C library function :cfunc:`system` directly, but a function :cfunc:`PySpam_System`, which would of course do something more complicated in reality (such as adding "spam" to every command). This function :cfunc:`PySpam_System` is also exported to other extension modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Eksportujący moduł jest modyfikacją modułu :mod:`spam` z sekcji :ref:`prosty-przykład-rozszerzania` - z ang - :ref:`extending-simpleexample`. Zadanie :func:`spam.system` nie wzywa zadania bibliotecznego z języka C :cfunc:`system` bezpośrednio, ale zadanie :cfunc:`PySpam_System`, który zrobiłby oczywiście coś bardziej skomplikowanego w rzeczywistości (takiego, jak dodanie "spam" do każdego polecenia). To zadanie :cfunc:`PySpam_System` jest także wystawiane na zewnątrz do innych modułów rozszerzających.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function :cfunc:`PySpam_System` is a plain C function, declared ``static`` like everything else::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie :cfunc:`PySpam_System` jest czystym zadaniem C, zadeklarowanym statycznie - z ang. - ``static`` jak wszystko inne::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int PySpam_System(const char *command) {     return system(command); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int PySpam_System(const char *command) {     return system(command); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function :cfunc:`spam_system` is modified in a trivial way::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie :cfunc:`spam_system` jest zmodyfikowane w trywialny sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * spam_system(PyObject *self, PyObject *args) {     const char *command;     int sts;      if (!PyArg_ParseTuple(args, "s", &amp;command))         return NULL;     sts = PySpam_System(command);     return Py_BuildValue("i", sts); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * spam_system(PyObject *self, PyObject *args) {     const char *command;     int sts;      if (!PyArg_ParseTuple(args, "s", &amp;command))         return NULL;     sts = PySpam_System(command);     return Py_BuildValue("i", sts); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the beginning of the module, right after the line ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na początku modułu, zaraz za linią ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "Python.h"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include "Python.h"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>two more lines must be added::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>muszą być dodane dwie linie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#define SPAM_MODULE #include "spammodule.h"</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#define SPAM_MODULE #include "spammodule.h"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``#define`` is used to tell the header file that it is being included in the exporting module, not a client module. Finally, the module's initialization function must take care of initializing the C API pointer array::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``#define`` jest używane aby przekazać plikowi nagłówkowemu że jest załączany w module wystawianym na zewnątrz, nie w module któremu wszystko służy. Ostatecznie zadanie inicjowania musi zadbać o zainicjowanie tabeli wskaźników sprzęgu programowania aplikacji języka C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;     static void *PySpam_API[PySpam_API_pointers];     PyObject *c_api_object;      m = PyModule_Create(&amp;spammodule);     if (m == NULL)         return NULL;      /* Initialize the C API pointer array */     PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;      /* Create a Capsule containing the API pointer array's address */     c_api_object = PyCapsule_New((void *)PySpam_API, "spam._C_API", NULL);      if (c_api_object != NULL)         PyModule_AddObject(m, "_C_API", c_api_object);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyMODINIT_FUNC PyInit_spam(void) {     PyObject *m;     static void *PySpam_API[PySpam_API_pointers];     PyObject *c_api_object;      m = PyModule_Create(&amp;spammodule);     if (m == NULL)         return NULL;      /* Zainicjuj  tabelę wskaźników C API */     PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;      /* Utwórz kapsułę zawierającą adres tabeli wskaźników API */     c_api_object = PyCapsule_New((void *)PySpam_API, "spam._C_API", NULL);      if (c_api_object != NULL)         PyModule_AddObject(m, "_C_API", c_api_object);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array would disappear when :func:`PyInit_spam` terminates!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że ``PySpam_API`` jest zadeklarowane ``statycznie``; w innym przypadku tabela wskaźników zniknęłaby gdy :func:`PyInit_spam` się zakończy!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bulk of the work is in the header file :file:`spammodule.h`, which looks like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większa część pracy jest wykonywana w pliku nagłówkowym :file:`spammodule.h`, który wygląda następująco::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#ifndef Py_SPAMMODULE_H #define Py_SPAMMODULE_H #ifdef __cplusplus extern "C" { #endif  /* Header file for spammodule */  /* C API functions */ #define PySpam_System_NUM 0 #define PySpam_System_RETURN int #define PySpam_System_PROTO (const char *command)  /* Total number of C API pointers */ #define PySpam_API_pointers 1   #ifdef SPAM_MODULE /* This section is used when compiling spammodule.c */  static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;  #else /* This section is used in modules that use spammodule's API */  static void **PySpam_API;  #define PySpam_System \  (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])  /* Return -1 on error, 0 on success.  * PyCapsule_Import will set an exception if there's an error.  */ static int import_spam(void) {     PySpam_API = (void **)PyCapsule_Import("spam._C_API", 0);     return (PySpam_API != NULL) ? 0 : -1; }  #endif  #ifdef __cplusplus } #endif  #endif /* !defined(Py_SPAMMODULE_H) */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#ifndef Py_SPAMMODULE_H #define Py_SPAMMODULE_H #ifdef __cplusplus extern "C" { #endif  /* Plik nagłówkowy dla spammodule */  /* Zadania sprzęgu programowania aplikacji w języku C (API) */ #define PySpam_System_NUM 0 #define PySpam_System_RETURN int #define PySpam_System_PROTO (const char *command)  /* Całkowita liczba wskaźników C API */ #define PySpam_API_pointers 1   #ifdef SPAM_MODULE /* Ten rozdział jest używany gdy spammodule.c jest kompilowany*/  static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;  #else /* Ten rozdział jest używany w modułach które używają  API spammodule*/  static void **PySpam_API;  #define PySpam_System \  (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])  /* Zwróć -1 przy błędzie, 0 jako udane działanie.  * PyCapsule_Import ustawi wyjątek jeśli zajdzie błąd.  */ static int import_spam(void) {     PySpam_API = (void **)PyCapsule_Import("spam._C_API", 0);     return (PySpam_API != NULL) ? 0 : -1; }  #endif  #ifdef __cplusplus } #endif  #endif /* !defined(Py_SPAMMODULE_H) */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All that a client module must do in order to have access to the function :cfunc:`PySpam_System` is to call the function (or rather macro) :cfunc:`import_spam` in its initialization function::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkim co moduł klienta musi zrobić aby mieć dostęp do zadania :cfunc:`PySpam_System` jest wezwanie zadania (lub raczej makropolecenia) :cfunc:`import_spam` w jej zadaniu inicjującym::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyMODINIT_FUNC PyInit_client(void) {     PyObject *m;      m = PyModule_Create(&amp;clientmodule);     if (m == NULL)         return NULL;     if (import_spam() &lt; 0)         return NULL;     /* additional initialization can happen here */     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyMODINIT_FUNC PyInit_client(void) {     PyObject *m;      m = PyModule_Create(&amp;clientmodule);     if (m == NULL)         return NULL;     if (import_spam() &lt; 0)         return NULL;     /* dodatkowe zainicjowanie może mieć miejsce tutaj */     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main disadvantage of this approach is that the file :file:`spammodule.h` is rather complicated. However, the basic structure is the same for each function that is exported, so it has to be learned only once.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Główną wadą tego podejścia jest to, że plik :file:`spammodule.h` jest raczej skomplikowany. Jednakże podstawowa struktura jest taka sama dla każdego zadania które jest wystawiane na zewnątrz więc trzeba się tego uczyć tylko raz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally it should be mentioned that Capsules offer additional functionality, which is especially useful for memory allocation and deallocation of the pointer stored in a Capsule. The details are described in the Python/C API Reference Manual in the section :ref:`capsules` and in the implementation of Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c` in the Python source code distribution).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatecznie warto wspomnieć że kapsuły dają dodatkowe możliwości działania, które są szczególnie użyteczne dla umieszczania i zabierania miejsca w pamięci wskaźników zachowywanych w kapsule. Szczegóły są opisane w podręczniku użytkownika sprzęgu języków C i pytonowskiego w rozdziale :ref:`kapsuły` - z ang. - :ref:`capsules` i w wypełnieniu programowym kapsuł (plików :file:`Include/pycapsule.h` i :file:`Objects/pycapsule.c` w dystrybucji źródłowej kodu języka pytonowskiego).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Footnotes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przypisy dolne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interface for this function already exists in the standard module :mod:`os` --- it was chosen as a simple and straightforward example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sprzęg dla tego zadania już istnieje w standardowym module :mod:`os` --- został on wybrany jako prosty i przejrzysty przykład.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The metaphor of "borrowing" a reference is not completely correct: the owner still has a copy of the reference.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Metafora "pożyczania" odniesienia nie jest do końca poprawna: właściciel wciąż ma kopię odniesienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Checking that the reference count is at least 1 **does not work** --- the reference count itself could be in freed memory and may thus be reused for another object!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdzanie że liczba odniesień jest przynajmniej 1 **nie działa** --- liczba odniesień sama w sobie może być w uwolnionej pamięci i dlatego może być ponownie użyta dla innego przedmiotu!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These guarantees don't hold when you use the "old" style calling convention --- this is still found in much existing code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te gwarancje nie są w mocy gdy używasz "starego" sposobu wywoływania --- to jest wciąż znajdowane w dużej części istniejącego kodu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extending and Embedding the Python Interpreter</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerzanie i Załączanie programu interpretującego polecenia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Release</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|version|</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>|wersja|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|today|</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>|dziś|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes how to write modules in C or C++ to extend the Python interpreter with new modules.  Those modules can define new functions but also new object types and their methods.  The document also describes how to embed the Python interpreter in another application, for use as an extension language. Finally, it shows how to compile and link extension modules so that they can be loaded dynamically (at run time) into the interpreter, if the underlying operating system supports this feature.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten dokument opisuje jak pisać moduły w C lub C++ aby rozszerzać program interpretujący polecenia języka pytonowskiego nowymi modułami. Te moduły mogą określać nowe zadania, ale także nowe rodzaje przedmiotów i ich sposoby postępowania. Dokument także opisuje jak załączać program interpretujący polecenia języka pytonowskiego w innej aplikacji, dla użycia jako rozszerzający język. Ostatecznie pokazuje jak kompilować i łączyć rozszerzające moduły tak żeby mogły być ładowane dynamicznie (w czasie wykonania) do programu interpretującego polecenia języka pytonowskiego, jeśli leżący u podstaw system operacyjny wspiera tą możliwość. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document assumes basic knowledge about Python.  For an informal introduction to the language, see :ref:`tutorial-index`.  :ref:`reference-index` gives a more formal definition of the language.  :ref:`library-index` documents the existing object types, functions and modules (both built-in and written in Python) that give the language its wide application range.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten dokument przyjmuje założenie że znane są podstawy wiedzy o języku pytonowskim. Dla nieformalnego wprowadzenia do języka, zobacz :ref:`tutorial-index`. :ref:`reference-index` daje bardziej formalną definicję języka. :ref:`library-index` dokumentuje istniejące typy przedmiotów, zadań i modułów (zarówno wbudowanych jak i napisanych w języku pytonowskim) które dają językowi jego szeroki zakres zastosowań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a detailed description of the whole Python/C API, see the separate :ref:`c-api-index`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla szczegółowego opisu całego sprzęgu pomiędzy językami C i pytonowskim, zobacz oddzielny :ref:`c-api-index`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining New Types</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Definiowanie nowych typów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the last chapter, Python allows the writer of an extension module to define new types that can be manipulated from Python code, much like strings and lists in core Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak wspomniano w poprzednim rozdziale, język pytonowski pozwala piszącemu moduły rozszerzające definiować nowe typy które mogą być zmieniane z kodu w języku pytonowskim, tak jak ciągi i listy wewnątrz języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not hard; the code for all extension types follows a pattern, but there are some details that you need to understand before you can get started.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To nie jest trudne; kod dla wszystkich rodzajów rozszerzeń podąża za wzorcem, ale są pewne szczegóły, które musisz zrozumieć zanim będziesz mógł zacząć.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Basics</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Python runtime sees all Python objects as variables of type :ctype:`PyObject\*`.  A :ctype:`PyObject` is not a very magnificent object - it just contains the refcount and a pointer to the object's "type object".  This is where the action is; the type object determines which (C) functions get called when, for instance, an attribute gets looked up on an object or it is multiplied by another object.  These C functions are called "type methods" to distinguish them from things like ``[].append`` (which we call "object methods").</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonujący się program języka pytonowskiego widzi wszystkie przedmioty języka pytonowskiego jak zmienne typu :ctype:`PyObject\*`. :ctype:`PyObject` nie jest zbyt wspaniałym przedmiotem - zawiera on po prostu liczbę odniesień i wskaźnik do "typu przedmiotu" przedmiotu. To jest miejsce gdzie coś się dzieje; rodzaj przedmiotu określa które zadania (języka C) są wywoływane kiedy, dla przykładu, atrybut będzie podejrzany na przedmiocie lub będzie pomnożony przez inny przedmiot. Te zadania języka C są nazywane "sposobami postępowania właściwymi dla typu" aby odróżnić je od rzeczy takich jak ``[].append`` (które nazywamy "sposobami postępowania przedmiotów").</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if you want to define a new object type, you need to create a new type object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Więc, jeśli chcesz określić nowy typ przedmiotu musisz stworzyć nowy przedmiot typu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This sort of thing can only be explained by example, so here's a minimal, but complete, module that defines a new type:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tego rodzaju rzeczy można tylko wyjaśnić na przykładzie, więc tutaj jest minimalny, ale kompletny, moduł który definiuje nowy typ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt;  typedef struct {     PyObject_HEAD     /* Type-specific fields go here. */ } noddy_NoddyObject;  static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */     0,                         /* tp_itemsize */     0,                         /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT,        /* tp_flags */     "Noddy objects",           /* tp_doc */ };  static PyModuleDef noddymodule = {     PyModuleDef_HEAD_INIT,     "noddy",     "Example module that creates an extension type.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy(void)  {     PyObject* m;      noddy_NoddyType.tp_new = PyType_GenericNew;     if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&amp;noddy_NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt;  typedef struct {     PyObject_HEAD     /* Szczególne-dla-typu pola idą tutaj. */ } noddy_NoddyObject;  static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */     0,                         /* tp_itemsize */     0,                         /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT,        /* tp_flags */     "Noddy objects",           /* tp_doc */ };  static PyModuleDef noddymodule = {     PyModuleDef_HEAD_INIT,     "noddy",     "Przykładowy moduł który tworzy typ rozszerzający.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy(void)  {     PyObject* m;      noddy_NoddyType.tp_new = PyType_GenericNew;     if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&amp;noddy_NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that's quite a bit to take in at once, but hopefully bits will seem familiar from the last chapter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To całkiem sporo aby strawić, jak na jeden raz, ale miejmy nadzieję że niektóre fragmenty będą wyglądały znajomo z poprzedniego rozdziału.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first bit that will be new is::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwszy fragment który będzie nowy jest::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct {     PyObject_HEAD } noddy_NoddyObject;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct {     PyObject_HEAD } noddy_NoddyObject;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is what a Noddy object will contain---in this case, nothing more than every Python object contains, namely a refcount and a pointer to a type object.  These are the fields the ``PyObject_HEAD`` macro brings in.  The reason for the macro is to standardize the layout and to enable special debugging fields in debug builds.  Note that there is no semicolon after the ``PyObject_HEAD`` macro; one is included in the macro definition.  Be wary of adding one by accident; it's easy to do from habit, and your compiler might not complain, but someone else's probably will!  (On Windows, MSVC is known to call this an error and refuse to compile the code.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest tym co przedmiot Noddy będzie zawierał --- w tym przypadku, nic więcej poza tym co każdy przedmiot języka pytonowskiego posiada, to jest liczba odniesień i wskaźnik do przedmiotu reprezentującego typ przedmiotu. To są pola które makropolecenie ``PyObject_HEAD`` wprowadza. Powodem makropolecenia jest standaryzacja rozkładu i umożliwienie szczególnych pól dla odpluskwiania w budowach odpluskwiających. Zauważ, że nie ma średnika po makropoleceniu ``PyObject_HEAD``; jeden jest zawarty w definicji makropolecenia. Uważaj też na dodanie jednego przez przypadek; łatwo się pomylić przez nawyk a kompilator nie będzie protestował ale ktoś inny prawdopodobnie będzie! (W Windows, MSVC jest znany z nazywania tego błędem i odmawiania kompilacji kodu.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For contrast, let's take a look at the corresponding definition for standard Python floats::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla skontrastowania, zobaczmy odpowiadającą definicję standardowych liczb zmiennoprzecinkowych języka pytonowskiego::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct {     PyObject_HEAD     double ob_fval; } PyFloatObject;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct {     PyObject_HEAD     double ob_fval; } PyFloatObject;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving on, we come to the crunch --- the type object. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Idąc dalej, dochodzimy do skurczu --- przedmiotu typu. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */     0,                         /* tp_itemsize */     0,                         /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT,        /* tp_flags */     "Noddy objects",           /* tp_doc */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyTypeObject noddy_NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(noddy_NoddyObject), /* tp_basicsize */     0,                         /* tp_itemsize */     0,                         /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT,        /* tp_flags */     "Przedmioty Noddy",           /* tp_doc */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now if you go and look up the definition of :ctype:`PyTypeObject` in :file:`object.h` you'll see that it has many more fields that the definition above.  The remaining fields will be filled with zeros by the C compiler, and it's common practice to not specify them explicitly unless you need them.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz jeśli pójdziesz i sprawdzisz definicję :ctype:`PyTypeObject` w pliku :file:`object.h` zobaczysz że ma ona dużo więcej pól niż powyższa definicja. Pozostałe pola będą wypełnione zerami przez kompilator języka C, i jest to częstą praktyką nie określać ich jawnie chyba że się ich potrzebuje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is so important that we're going to pick the top of it apart still further::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest tak istotne że mamy zamiar rozebrać na części górę tego jeszcze bardziej::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyVarObject_HEAD_INIT(NULL, 0)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyVarObject_HEAD_INIT(NULL, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This line is a bit of a wart; what we'd like to write is::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta linia jest nieco jak pryszcz; to co chcielibyśmy napisać to::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>as the type of a type object is "type", but this isn't strictly conforming C and some compilers complain.  Fortunately, this member will be filled in for us by :cfunc:`PyType_Ready`. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>jako że typ przedmiotu typu jest "typem" ale to nie jest ściśle stosowanie się do C i niektóre kompilatory będą narzekać. Szczęśliwie ten członek będzie wypełniony dla nas przez :cfunc:`PyType_Ready`.::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"noddy.Noddy",              /* tp_name */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"noddy.Noddy",              /* tp_name */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of our type.  This will appear in the default textual representation of our objects and in some error messages, for example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa naszego typu. To pojawi się w domyślnej tekstowej reprezentacji naszego przedmiotu i w niektórych wiadomościach o błędzie, na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; "" + noddy.new_noddy() Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in ? TypeError: cannot add type "noddy.Noddy" to string</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; "" + noddy.new_noddy() Wypis śledzenia (najbardziej niedawne wywołanie ostatnie):   File "&lt;stdin&gt;", line 1, in ? Błąd Typu: nie można dodać typu "noddy.Noddy" do ciągu znaków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the name is a dotted name that includes both the module name and the name of the type within the module. The module in this case is :mod:`noddy` and the type is :class:`Noddy`, so we set the type name to :class:`noddy.Noddy`. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że nazwa jest nazwą po kropce która zawiera zarówno nazwę modułu i nazwę typu wewnątrz modułu. Modułem w tym przypadku jest  :mod:`noddy` i typem jest :class:`Noddy`, więc ustawiamy nazwę typu uogólnienia na :class:`noddy.Noddy`. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sizeof(noddy_NoddyObject),  /* tp_basicsize */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sizeof(noddy_NoddyObject),  /* tp_basicsize */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is so that Python knows how much memory to allocate when you call :cfunc:`PyObject_New`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To tak, aby język pytonowski wiedział jak dużo pamięci przydzielić gdy wywoływane jest zadanie :cfunc:`PyObject_New`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want your type to be subclassable from Python, and your type has the same :attr:`tp_basicsize` as its base type, you may have problems with multiple inheritance.  A Python subclass of your type will have to list your type first in its :attr:`__bases__`, or else it will not be able to call your type's :meth:`__new__` method without getting an error.  You can avoid this problem by ensuring that your type has a larger value for :attr:`tp_basicsize` than its base type does.  Most of the time, this will be true anyway, because either your base type will be :class:`object`, or else you will be adding data members to your base type, and therefore increasing its size.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli chcesz aby twój typ uogólnienia był możliwy do wyciągnięcia uogólnienia pochodnego w języku pytonowskim, i twój typ ma ten sam :attr:`tp_basicsize` jako jego typ bazowy, możesz mieć problemy z wielokrotnym dziedziczeniem. Podrzędne uogólnienie twojego typu będzie musiało wypisać twój typ na początku w swojej listy :attr:`__bases__`, bo w przeciwnym razie nie będzie w stanie wywołać sposobu postępowania :meth:`__new__` należącego do twojego typu bez spowodowania błędu. Można uniknąć tego problemu przez zapewnienie, że twój typ ma większą wartość dla :attr:`tp_basicsize` niż jego typ bazowy. W większości przypadków będzie to prawdą tak czy inaczej, gdyż albo twoje uogólnienie bazowe będzie uogólnieniem :class:`object`, lub w przeciwnym wypadku będziesz dodawał członki danych do typu bazowego, i w ten sposób zwiększał jego rozmiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>0,                          /* tp_itemsize */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>0,                          /* tp_itemsize */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This has to do with variable length objects like lists and strings. Ignore this for now.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To ma do czynienia ze zmienną długością przedmiotów takich jak listy i ciągi znaków. Pomińmy to na razie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skipping a number of type methods that we don't provide, we set the class flags to :const:`Py_TPFLAGS_DEFAULT`. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pomijając pewną liczbę sposobów postępowania należących do typu których nie dostarczamy, ustawiamy flagi uogólnienia na :const:`Py_TPFLAGS_DEFAULT`. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_TPFLAGS_DEFAULT,        /* tp_flags */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_TPFLAGS_DEFAULT,        /* tp_flags */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All types should include this constant in their flags.  It enables all of the members defined by the current version of Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie typy powinny zawierać tą stałą w swoich flagach. Ona włącza wszystkie członki określone przez obecną wersję języka pytonowskiego. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We provide a doc string for the type in :attr:`tp_doc`. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarczamy ciąg znaków dokumentacji dla tego typu uogólnienia w :attr:`tp_doc`. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Noddy objects",           /* tp_doc */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Przedmioty Noddy", /* tp_doc */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we get into the type methods, the things that make your objects different from the others.  We aren't going to implement any of these in this version of the module.  We'll expand this example later to have more interesting behavior.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz zabierzemy się za sposoby postępowania rodzaju uogólnienia, rzeczy które sprawiają że twoje przedmioty są wyjątkowe na tle pozostałych. Nie wypełnimy żadnej z tych w tej wersji modułu. Rozszerzymy ten przykład później aby mieć bardziej interesujące zachowanie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, all we want to be able to do is to create new :class:`Noddy` objects. To enable object creation, we have to provide a :attr:`tp_new` implementation. In this case, we can just use the default implementation provided by the API function :cfunc:`PyType_GenericNew`.  We'd like to just assign this to the :attr:`tp_new` slot, but we can't, for portability sake, On some platforms or compilers, we can't statically initialize a structure member with a function defined in another C module, so, instead, we'll assign the :attr:`tp_new` slot in the module initialization function just before calling :cfunc:`PyType_Ready`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na razie, wszystko czego chcemy, to mieć możliwość tworzyć nowe przedmioty uogólnienia :class:`Noddy`. Aby umożliwić tworzenie przedmiotów, musimy dostarczyć wypełnienie sposobu postępowania dla :attr:`tp_new`. W tym przypadku możemy po prostu użyć domyślnego wypełnienia dostarczonego przez zadanie sprzęgu programowania aplikacji :cfunc:`PyType_GenericNew`. Wolelibyśmy po prostu przypisać to do gniazda :attr:`tp_new`, ale nie możemy, z powodu umożliwienia przenośności, Na niektórych maszynach/środowiskach lub kompilatorach, nie możemy statycznie inicjować członka struktury z zadaniem zdefiniowanym w innym module C, więc, zamiast tego, przypiszemy gniazdo :attr:`tp_new` w zadaniu inicjującym moduł tuż przed wywołaniem :cfunc:`PyType_Ready`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>noddy_NoddyType.tp_new = PyType_GenericNew; if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)     return;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>noddy_NoddyType.tp_new = PyType_GenericNew; if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)     return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the other type methods are *NULL*, so we'll go over them later --- that's for a later section!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie inne sposoby postępowania są *NULL*, więc przyjrzymy się im później --- to jest dla późniejszej sekcji!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything else in the file should be familiar, except for some code in :cfunc:`PyInit_noddy`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystko inne w pliku powinno być znajome, z wyjątkiem pewnych kodów w :cfunc:`PyInit_noddy`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)     return;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)     return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This initializes the :class:`Noddy` type, filing in a number of members, including :attr:`ob_type` that we initially set to *NULL*. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To inicjuje typ :class:`Noddy`, wypełniając pewną liczbę członków, zawierającą :attr:`ob_type` które początkowo ustawiamy na *NULL*. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This adds the type to the module dictionary.  This allows us to create :class:`Noddy` instances by calling the :class:`Noddy` class::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To dodaje typ do słownika modułu. To pozwala nam tworzyć przykłady uogólnienia :class:`Noddy` przez odwołanie się do uogólnienia :class:`Noddy` ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import noddy &gt;&gt;&gt; mynoddy = noddy.Noddy()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import noddy &gt;&gt;&gt; mynoddy = noddy.Noddy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's it!  All that remains is to build it; put the above code in a file called :file:`noddy.c` and ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To wszystko! Wszystko co pozostaje to zbudować to; umieść powyższy kod w pliku nazwanym :file:`noddy.c` i ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup, Extension setup(name="noddy", version="1.0",       ext_modules=[Extension("noddy", ["noddy.c"])])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup, Extension setup(name="noddy", version="1.0",       ext_modules=[Extension("noddy", ["noddy.c"])])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in a file called :file:`setup.py`; then typing ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w pliku nazwanym :file:`setup.py`; potem wpisując ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ python setup.py build</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ python setup.py build</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>at a shell should produce a file :file:`noddy.so` in a subdirectory; move to that directory and fire up Python --- you should be able to ``import noddy`` and play around with Noddy objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w powłoce, powinno to wyprodukować plik :file:`noddy.so` w podkatalogu; przejdź do tego katalogu i uruchom program interpretujący polecenia języka pytonowskiego --- powinieneś móc ``import noddy`` - importować noddy-ego i posługiwać się przedmiotami Noddy-ego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That wasn't so hard, was it?</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To nie było takie trudne, nieprawdaż?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, the current Noddy type is pretty uninteresting. It has no data and doesn't do anything. It can't even be subclassed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oczywiście obecny typ uogólnienia Noddy nie jest zbyt interesujący. Nie ma w ogóle danych i nic nie robi. Nie może nawet być odziedziczony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding data and methods to the Basic example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodawanie danych i sposobów postępowania do podstawowego przykładu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's expend the basic example to add some data and methods.  Let's also make the type usable as a base class. We'll create a new module, :mod:`noddy2` that adds these capabilities:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozwińmy podstawowy przykład i dodajmy trochę danych i sposobów postępowania. Uczyńmy też typ używalnym jako uogólnienie bazowe. Stworzymy nowy moduł :mod:`noddy2`, który dodaje te możliwości:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt; #include "structmember.h"  typedef struct {     PyObject_HEAD     PyObject *first; /* first name */     PyObject *last;  /* last name */     int number; } Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self-&gt;first);     Py_XDECREF(self-&gt;last);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;first = PyUnicode_FromString("");         if (self-&gt;first == NULL)           {             Py_DECREF(self);             return NULL;           }                  self-&gt;last = PyUnicode_FromString("");         if (self-&gt;last == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;number = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {"first", "last", "number", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,                                        &amp;first, &amp;last,                                        &amp;self-&gt;number))         return -1;       if (first) {         tmp = self-&gt;first;         Py_INCREF(first);         self-&gt;first = first;         Py_XDECREF(tmp);     }      if (last) {         tmp = self-&gt;last;         Py_INCREF(last);         self-&gt;last = last;         Py_XDECREF(tmp);     }      return 0; }   static PyMemberDef Noddy_members[] = {     {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,      "first name"},     {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,      "last name"},     {"number", T_INT, offsetof(Noddy, number), 0,      "noddy number"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString("%s %s");         if (format == NULL)             return NULL;     }      if (self-&gt;first == NULL) {         PyErr_SetString(PyExc_AttributeError, "first");         return NULL;     }      if (self-&gt;last == NULL) {         PyErr_SetString(PyExc_AttributeError, "last");         return NULL;     }      args = Py_BuildValue("OO", self-&gt;first, self-&gt;last);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {"name", (PyCFunction)Noddy_name, METH_NOARGS,      "Return the name, combining the first and last name"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     "Noddy objects",           /* tp_doc */     0,		               /* tp_traverse */     0,		               /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     0,                         /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy2module = {     PyModuleDef_HEAD_INIT,     "noddy2",     "Example module that creates an extension type.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy2(void)  {     PyObject* m;      if (PyType_Ready(&amp;NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddy2module);     if (m == NULL)         return NULL;      Py_INCREF(&amp;NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;NoddyType);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt; #include "structmember.h"  typedef struct {     PyObject_HEAD     PyObject *imie; /* Imię */     PyObject *nazwisko;  /* nazwisko */     int numer; } Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self-&gt;imie);     Py_XDECREF(self-&gt;nazwisko);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;imie = PyUnicode_FromString("");         if (self-&gt;imie == NULL)           {             Py_DECREF(self);             return NULL;           }                  self-&gt;nazwisko = PyUnicode_FromString("");         if (self-&gt;nazwisko == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;numer = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {"imie", "nazwisko", "numer", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,                                        &amp;imie, &amp;nazwisko,                                        &amp;self-&gt;numer))         return -1;       if (imie) {         tmp = self-&gt;imie;         Py_INCREF(imie);         self-&gt;imie = imie;         Py_XDECREF(tmp);     }      if (nazwisko) {         tmp = self-&gt;nazwisko;         Py_INCREF(nazwisko);         self-&gt;nazwisko = nazwisko;         Py_XDECREF(tmp);     }      return 0; }   static PyMemberDef Noddy_members[] = {     {"imie", T_OBJECT_EX, offsetof(Noddy, imie), 0,      "imię"},     {"nazwisko", T_OBJECT_EX, offsetof(Noddy, nazwisko), 0,      "nazwisko"},     {"numer", T_INT, offsetof(Noddy, numer), 0,      "noddy numer"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString("%s %s");         if (format == NULL)             return NULL;     }      if (self-&gt;imie == NULL) {         PyErr_SetString(PyExc_AttributeError, "imie");         return NULL;     }      if (self-&gt;nazwisko == NULL) {         PyErr_SetString(PyExc_AttributeError, "nazwisko");         return NULL;     }      args = Py_BuildValue("OO", self-&gt;imie, self-&gt;nazwisko);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {"imie", (PyCFunction)Noddy_name, METH_NOARGS,      "Return the name, combining the first and last name"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     "Noddy objects",           /* tp_doc */     0,			               /* tp_traverse */     0,		               /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     0,                         /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy2module = {     PyModuleDef_HEAD_INIT,     "noddy2",     "Przykładowy moduł który tworzy rozszerzający typ uogólnienia.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy2(void)  {     PyObject* m;      if (PyType_Ready(&amp;NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddy2module);     if (m == NULL)         return NULL;      Py_INCREF(&amp;NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;NoddyType);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This version of the module has a number of changes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta wersja modułu ma parę zmian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We've added an extra include::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaliśmy dodatkową formułę załączenia - include::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;structmember.h&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;structmember.h&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This include provides declarations that we use to handle attributes, as described a bit later.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta dyrektywa załączania (include) dostarcza deklaracje których używamy do obsługi własności jak opisano kawałek później.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the :class:`Noddy` object structure has been shortened to :class:`Noddy`.  The type object name has been shortened to :class:`NoddyType`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa struktury przedmiotu :class:`Noddy` została skrócona do :class:`Noddy`. Nazwa przedmiotu typu została skrócona do :class:`NoddyType`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The  :class:`Noddy` type now has three data attributes, *first*, *last*, and *number*.  The *first* and *last* variables are Python strings containing first and last names. The *number* attribute is an integer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Typ uogólnienia teraz ma trzy własności danych, *imie*, *nazwisko* i *numer*. Zmienne *imie* i *nazwisko* są ciągami znaków języka pytonowskiego zawierającymi imię i nazwisko. Własność *numer* jest liczbą całkowitą.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The object structure is updated accordingly::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Struktura przedmiotu jest uaktualniona podobnie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct {     PyObject_HEAD     PyObject *first;     PyObject *last;     int number; } Noddy;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct {     PyObject_HEAD     PyObject *imie;     PyObject *nazwisko;     int numer; } Noddy;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we now have data to manage, we have to be more careful about object allocation and deallocation.  At a minimum, we need a deallocation method::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ponieważ teraz mamy dane do zarządzania, musimy być bardziej ostrożni w kwestii umieszczania w pamięci i odbierania miejsca. Jako minimum, potrzebujemy sposobu zwalniania miejsca w pamięci::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self-&gt;first);     Py_XDECREF(self-&gt;last);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self-&gt;imie);     Py_XDECREF(self-&gt;nazwisko);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which is assigned to the :attr:`tp_dealloc` member::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>które jest przypisany do członka :attr:`tp_dealloc`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(destructor)Noddy_dealloc, /*tp_dealloc*/</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(destructor)Noddy_dealloc, /*tp_dealloc*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method decrements the reference counts of the two Python attributes. We use :cfunc:`Py_XDECREF` here because the :attr:`first` and :attr:`last` members could be *NULL*.  It then calls the :attr:`tp_free` member of the object's type to free the object's memory.  Note that the object's type might not be :class:`NoddyType`, because the object may be an instance of a subclass.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania zmniejsza liczbę odniesień do dwóch własności języka pytonowskiego. Używamy :cfunc:`Py_XDECREF` tutaj ponieważ :attr:`imie` i :attr:`nazwisko` mogą być *NULL*. Potem uruchamia członka :attr:`tp_free` typu przedmiotu aby zwolnić pamięć przedmiotu. Zauważ, że typ przedmiotu może nie być :class:`NoddyType`, ponieważ przedmiot może być przykładem podrzędnego uogólnienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We want to make sure that the first and last names are initialized to empty strings, so we provide a new method::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Chcemy upewnić się że imię i nazwisko są zainicjowane do pustych ciągów znaków, więc dostarczamy sposób postępowania nowości::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;first = PyString_FromString("");         if (self-&gt;first == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;last = PyString_FromString("");         if (self-&gt;last == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;number = 0;     }      return (PyObject *)self; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;imie = PyString_FromString("");         if (self-&gt;imie == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;nazwisko = PyString_FromString("");         if (self-&gt;nazwisko == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;numer = 0;     }      return (PyObject *)self; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and install it in the :attr:`tp_new` member::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i zainstaluj go w elemencie :attr:`tp_new`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Noddy_new,                 /* tp_new */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Noddy_new,                 /* tp_new */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new member is responsible for creating (as opposed to initializing) objects of the type.  It is exposed in Python as the :meth:`__new__` method.  See the paper titled "Unifying types and classes in Python" for a detailed discussion of the :meth:`__new__` method.  One reason to implement a new method is to assure the initial values of instance variables.  In this case, we use the new method to make sure that the initial values of the members :attr:`first` and :attr:`last` are not *NULL*. If we didn't care whether the initial values were *NULL*, we could have used :cfunc:`PyType_GenericNew` as our new method, as we did before.  :cfunc:`PyType_GenericNew` initializes all of the instance variable members to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>członek new jest odpowiedzialny za tworzenie (w przeciwieństwie do inicjowania) przedmiotów o określonym typie. Jest wystawiony w języku pytonowskim jako sposób postępowania :meth:`__new__`. Zobacz dokument "Unifikacja typów i uogólnień w języku pytonowskim" dla pogłębionej dyskusji o sposobie postępowania :meth:`__new__`. Jednym z powodów do wypełnienia sposobu postępowania "nowy" - z ang. - new jest zapewnienie wartości początkowych zmiennych przykładu. W tym przypadku, używamy sposobu postępowania "new" aby zapewnić, że wartości początkowe członków :attr:`first` i :attr:`last` nie są puste (*NULL*). Jeśli nie troszczylibyśmy się, czy początkowe wartości były *NULL*, moglibyśmy użyć :cfunc:`PyType_GenericNew` jako naszego sposobu postępowania "new", tak jak poprzednio. :cfunc:`PyType_GenericNew` inicjuje wszystkie członki zmienne przykładu na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new method is a static method that is passed the type being instantiated and any arguments passed when the type was called, and that returns the new object created. New methods always accept positional and keyword arguments, but they often ignore the arguments, leaving the argument handling to initializer methods. Note that if the type supports subclassing, the type passed may not be the type being defined.  The new method calls the tp_alloc slot to allocate memory. We don't fill the :attr:`tp_alloc` slot ourselves. Rather :cfunc:`PyType_Ready` fills it for us by inheriting it from our base class, which is :class:`object` by default.  Most types use the default allocation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania "new" jest sposobem postępowania statycznym, któremu przekazywany jest typ uogólnienia którego przykład dajemy i jakiekolwiek parametry przekazywane gdy typ został wywołany, i który zwraca nowo utworzony przedmiot. Metoda "Nowy" - z ang. - "new" zawsze akceptuje parametry pozycyjne i słów kluczowych, ale często pomija parametry, pozostawiając obsługę parametrów dla sposobów postępowania inicjujących. Zauważ, że jeśli typ wspiera tworzenie uogólnień  podrzędnych, przekazywany typ nie może być typem który jest definiowany. Sposób postępowania "nowy" - z ang. - "new"  wzywa gniazdo tp_alloc aby alokować pamięć. Nie wypełniamy własnoręcznie :attr:`tp_alloc`. Raczej :cfunc:`PyType_Ready` wypełnia go za nas przez odziedziczenie go z naszego bazowego uogólnienia, którym jest :class:`object` - z ang. - przedmiot domyślnie. Większość typów używa domyślnego przydzielania pamięci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are creating a co-operative :attr:`tp_new` (one that calls a base type's :attr:`tp_new` or :meth:`__new__`), you must *not* try to determine what method to call using method resolution order at runtime.  Always statically determine what type you are going to call, and call its :attr:`tp_new` directly, or via ``type-&gt;tp_base-&gt;tp_new``.  If you do not do this, Python subclasses of your type that also inherit from other Python-defined classes may not work correctly. (Specifically, you may not be able to create instances of such subclasses without getting a :exc:`TypeError`.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli tworzysz ko-operujący :attr:`tp_new` (taki, który wywołuje sposób postępowania :attr:`tp_new` lub :meth:`__new__` typu bazowego), *nie* możesz próbować określić którą metodę wywołać przy użyciu ustalania kolejności sposobów postępowania w czasie wykonania. Zawsze określaj statycznie do którego typu będziesz się odwoływał, i wzywaj jego :attr:`tp_new` bezpośrednio, lub przez ``type-&gt;tp_base-&gt;tp_new``. Jeśli tego nie zrobisz, podrzędne uogólnienia języka pytonowskiego twojego typu, który także dziedziczy po innych określonych przez język pytonowski uogólnieniach może nie działać prawidłowo. (Szczególnie, być może nie będziesz mógł tworzyć przykładów takich podrzędnych uogólnień bez otrzymania sytuacji wyjątkowej :exc:`TypeError`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We provide an initialization function::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarczamy zadanie inicjujące::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {"first", "last", "number", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,                                       &amp;first, &amp;last,                                       &amp;self-&gt;number))         return -1;      if (first) {         tmp = self-&gt;first;         Py_INCREF(first);         self-&gt;first = first;         Py_XDECREF(tmp);     }      if (last) {         tmp = self-&gt;last;         Py_INCREF(last);         self-&gt;last = last;         Py_XDECREF(tmp);     }      return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *imie=NULL, *nazwisko=NULL, *tmp;      static char *kwlist[] = {"imie", "nazwisko", "numer", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,                                       &amp;imie, &amp;nazwisko,                                       &amp;self-&gt;numer))         return -1;      if (imie) {         tmp = self-&gt;imie;         Py_INCREF(imie);         self-&gt;imie = imie;         Py_XDECREF(tmp);     }      if (nazwisko) {         tmp = self-&gt;nazwisko;         Py_INCREF(nazwisko);         self-&gt;nazwisko = nazwisko;         Py_XDECREF(tmp);     }      return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>by filling the :attr:`tp_init` slot. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przez wypełnienie gniazda :attr:`tp_init`. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(initproc)Noddy_init,         /* tp_init */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(initproc)Noddy_init, /* tp_init */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_init` slot is exposed in Python as the :meth:`__init__` method. It is used to initialize an object after it's created. Unlike the new method, we can't guarantee that the initializer is called.  The initializer isn't called when unpickling objects and it can be overridden.  Our initializer accepts arguments to provide initial values for our instance. Initializers always accept positional and keyword arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gniazdo :attr:`tp_init` jest wystawione w języku pytonowskim jako sposób postępowania :meth:`__init__`. Jest używany do inicjowania przedmiotu po jego utworzeniu. W przeciwieństwie do sposobu postępowania "nowy", nie możemy zagwarantować że sposób postępowania inicjujący będzie uruchomiony. Sposób postępowania inicjujący nie jest uruchamiany gdy przedmiot jest odpakowywany i może być zastąpiony. Sposób postępowania inicjujący akceptuje parametry aby dostarczyć wartości początkowych dla naszego przykładu. Sposoby postępowania inicjujące zawsze akceptują parametry pozycyjne i słów kluczowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initializers can be called multiple times.  Anyone can call the :meth:`__init__` method on our objects.  For this reason, we have to be extra careful when assigning the new values.  We might be tempted, for example to assign the :attr:`first` member like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania inicjujące mogą być wzywane kilkukrotnie. Ktokolwiek może wezwać :meth:`__init__` na naszych przedmiotach. Z tego powodu, musimy być szczególnie ostrożni gdy przypisujemy nowe wartości. Możemy pokusić się, dla przykładu na przypisanie członka :attr:`imie` jak następuje::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (first) {     Py_XDECREF(self-&gt;first);     Py_INCREF(first);     self-&gt;first = first; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>if (imie) {     Py_XDECREF(self-&gt;imie);     Py_INCREF(imie);     self-&gt;imie = imie; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this would be risky.  Our type doesn't restrict the type of the :attr:`first` member, so it could be any kind of object.  It could have a destructor that causes code to be executed that tries to access the :attr:`first` member.  To be paranoid and protect ourselves against this possibility, we almost always reassign members before decrementing their reference counts.  When don't we have to do this?</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ale to byłoby ryzykowne. Nasz typ nie ogranicza typu członka :attr:`imie`, więc może być jakiegokolwiek rodzaju przedmiotem. Może mieć destruktor, który powoduje że kod uruchamiany próbuje uzyskać dostęp do członka :attr:`imie`. Aby być paranoikami i bronić się przed tą możliwością, prawie zawsze przepisujemy członki przed zmniejszeniem ich liczby odniesień. Kiedy nie musimy tego robić?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we absolutely know that the reference count is greater than 1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gdy absolutnie wiemy że liczba odniesień jest większa niż 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we know that deallocation of the object [#]_ will not cause any calls back into our type's code</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gdy wiemy że zabranie miejsca w pamięci na przedmiot [#]_ nie spowoduje żadnych powrotnych wywołań do kodu naszego typu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when decrementing a reference count in a :attr:`tp_dealloc` handler when garbage-collections is not supported [#]_</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gdy zmniejszajamy liczbę odniesień w obsłudze :attr:`tp_dealloc` gdy zbiórka-śmieci nie jest dostępna [#]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We want to expose our instance variables as attributes. There are a number of ways to do that. The simplest way is to define member definitions::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Chcemy wystawić zmienne naszego przykładu jako własności. Istnieje kilka dróg do tego. Najprościej jest zdefiniować definicje członków::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyMemberDef Noddy_members[] = {     {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,      "first name"},     {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,      "last name"},     {"number", T_INT, offsetof(Noddy, number), 0,      "noddy number"},     {NULL}  /* Sentinel */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyMemberDef Noddy_members[] = {     {"imie", T_OBJECT_EX, offsetof(Noddy, imie), 0,      "imię"},     {"nazwisko", T_OBJECT_EX, offsetof(Noddy, nazwisko), 0,      "nazwisko"},     {"numer", T_INT, offsetof(Noddy, numer), 0,      "numer noddy-ego"},     {NULL}  /* Ochrona */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and put the definitions in the :attr:`tp_members` slot::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i wstawić definicje do gniazda :attr:`tp_members`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Noddy_members,             /* tp_members */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Noddy_members,             /* tp_members */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each member definition has a member name, type, offset, access flags and documentation string. See the :ref:`Generic-Attribute-Management` section below for details.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każda definicja członka ma nazwę członka, rodzaj, odstęp w pamięci, flagi dostępu i ciąg dokumentacji. Zobacz sekcję :ref:`Zarządzanie-zamiennymi-własnościami` - z ang. - :ref:`Generic-Attribute-Management` po więcej szczegółów na ten temat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A disadvantage of this approach is that it doesn't provide a way to restrict the types of objects that can be assigned to the Python attributes.  We expect the first and last names to be strings, but any Python objects can be assigned. Further, the attributes can be deleted, setting the C pointers to *NULL*.  Even though we can make sure the members are initialized to non-*NULL* values, the members can be set to *NULL* if the attributes are deleted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wadą tego podejścia jest to, że nie dostarcza ono sposobu aby ograniczyć rodzaje przedmiotów, które można przypisywać do "własności" języka pytonowskiego. Oczekujemy że imię i nazwisko będą ciągami znaków, ale wszystkie przedmioty języka pytonowskiego mogą być przypisywane. Dalej własności mogą być usunięte, ustawiając wskaźniki C na *NULL*. Nawet chociaż możemy się upewnić, że członki są inicjowane na niepuste (z ang. - non-*NULL*) wartości, członki mogą być ustawione na *NULL* jeśli własności będą kasowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We define a single method, :meth:`name`, that outputs the objects name as the concatenation of the first and last names. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określamy pojedynczy sposób postępowania, :meth:`name`, która wystawia nazwę przedmiotów jako sklejenia imienia i nazwiska. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyString_FromString("%s %s");         if (format == NULL)             return NULL;     }      if (self-&gt;first == NULL) {         PyErr_SetString(PyExc_AttributeError, "first");         return NULL;     }      if (self-&gt;last == NULL) {         PyErr_SetString(PyExc_AttributeError, "last");         return NULL;     }      args = Py_BuildValue("OO", self-&gt;first, self-&gt;last);     if (args == NULL)         return NULL;      result = PyString_Format(format, args);     Py_DECREF(args);      return result; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyString_FromString("%s %s");         if (format == NULL)             return NULL;     }      if (self-&gt;imie == NULL) {         PyErr_SetString(PyExc_AttributeError, "imie");         return NULL;     }      if (self-&gt;last == NULL) {         PyErr_SetString(PyExc_AttributeError, "nazwisko");         return NULL;     }      args = Py_BuildValue("OO", self-&gt;imie, self-&gt;nazwisko);     if (args == NULL)         return NULL;      result = PyString_Format(format, args);     Py_DECREF(args);      return result; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method is implemented as a C function that takes a :class:`Noddy` (or :class:`Noddy` subclass) instance as the first argument.  Methods always take an instance as the first argument. Methods often take positional and keyword arguments as well, but in this cased we don't take any and don't need to accept a positional argument tuple or keyword argument dictionary. This method is equivalent to the Python method::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania jest wypełniony jako zadanie C które przyjmuje przykład uogólnienia :class:`Noddy` (lub podrzędnego uogólnienia względem uogólnienia :class:`Noddy`) jako pierwszy parametr. Sposoby postępowania zawsze przyjmują przykład jako pierwszy argument. Sposoby postępowania często przyjmują pozycyjne jak i kluczowe parametry zarówno, ale w tym przypadku nie pobieramy żadnych i nie potrzebujemy akceptować pozycyjne parametry krotki pozycyjne lub parametrów słów kluczowych słownika. Ten sposób postępowania jest równoważny sposobowi postępowania języka pytonowskiego::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def name(self):    return "%s %s" % (self.first, self.last)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def name(self):    return "%s %s" % (self.imie, self.nazwisko)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we have to check for the possibility that our :attr:`first` and :attr:`last` members are *NULL*.  This is because they can be deleted, in which case they are set to *NULL*.  It would be better to prevent deletion of these attributes and to restrict the attribute values to be strings.  We'll see how to do that in the next section.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że musimy sprawdzić możliwość, że nasze własności :attr:`imie` i :attr:`nazwisko` są puste - z ang. - *NULL*. To jest dlatego że mogą być one skasowane, w którym przypadku zostaną one ustawione na *NULL*. Lepiej byłoby zapobiec skasowaniu tych własności i ograniczyć wartości właściwości aby były ciągami znaków. Zobaczymy jak to zrobić w następnym rozdziale.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we've defined the method, we need to create an array of method definitions::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz gdy określiliśmy sposób postępowania, musimy stworzyć tabelę definicji sposobów postępowania::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyMethodDef Noddy_methods[] = {     {"name", (PyCFunction)Noddy_name, METH_NOARGS,      "Return the name, combining the first and last name"     },     {NULL}  /* Sentinel */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyMethodDef Noddy_methods[] = {     {"name", (PyCFunction)Noddy_name, METH_NOARGS,      "Zwróć nazwę, łącząc imię i nazwisko"     },     {NULL}  /* Ochrona */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and assign them to the :attr:`tp_methods` slot::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i przypisz je do gniazda :attr:`tp_methods`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Noddy_methods,             /* tp_methods */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Noddy_methods,             /* tp_methods */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we used the :const:`METH_NOARGS` flag to indicate that the method is passed no arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że używaliśmy flagi :const:`METH_NOARGS` aby wskazać który sposób postępowania nie dostaje żadnych parametrów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, we'll make our type usable as a base class.  We've written our methods carefully so far so that they don't make any assumptions about the type of the object being created or used, so all we need to do is to add the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatecznie czynimy nasz typ użytecznym jako uogólnienie bazowe. Napisaliśmy nasze sposoby postępowania uważnie tak że nie czynią one żadnych założeń o rodzaju przedmiotu który jest utworzony lub użyty, więc wszystko, co musimy uczynić to dodać :const:`Py_TPFLAGS_BASETYPE` do naszej definicji flag uogólnienia::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We rename :cfunc:`PyInit_noddy` to :cfunc:`PyInit_noddy2` and update the module name in the :ctype:`PyModuleDef` struct.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zmieniamy nazwę :cfunc:`PyInit_noddy` na :cfunc:`PyInit_noddy2` i uaktualnić nazwę modułu w strukturze :ctype:`PyModuleDef`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, we update our :file:`setup.py` file to build the new module::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatecznie uaktualniamy nasz plik :file:`setup.py` do budowania nowego modułu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from distutils.core import setup, Extension setup(name="noddy", version="1.0",       ext_modules=[          Extension("noddy", ["noddy.c"]),          Extension("noddy2", ["noddy2.c"]),          ])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from distutils.core import setup, Extension setup(name="noddy", version="1.0",       ext_modules=[          Extension("noddy", ["noddy.c"]),          Extension("noddy2", ["noddy2.c"]),          ])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing finer control over data attributes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarczając dokładniejszej kontroli ponad własnościami danych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we'll provide finer control over how the :attr:`first` and :attr:`last` attributes are set in the :class:`Noddy` example. In the previous version of our module, the instance variables :attr:`first` and :attr:`last` could be set to non-string values or even deleted. We want to make sure that these attributes always contain strings.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym rozdziale, dostarczymy dokładniejszej kontroli ponad tym jak własności :attr:`imie` i :attr:`nazwisko` są ustawiane w przykładzie :class:`Noddy`. W poprzedniej wersji naszego modułu, zmienne przykładu :attr:`imie` i :attr:`nazwisko` mogły być ustawione na wartości nie-ciągu-znaków lub nawet skasowane. Chcemy się upewnić że te własności zawsze zawierają ciągi znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt; #include "structmember.h"  typedef struct {     PyObject_HEAD     PyObject *first;     PyObject *last;     int number; } Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self-&gt;first);     Py_XDECREF(self-&gt;last);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;first = PyUnicode_FromString("");         if (self-&gt;first == NULL)           {             Py_DECREF(self);             return NULL;           }                  self-&gt;last = PyUnicode_FromString("");         if (self-&gt;last == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;number = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {"first", "last", "number", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,                                        &amp;first, &amp;last,                                        &amp;self-&gt;number))         return -1;       if (first) {         tmp = self-&gt;first;         Py_INCREF(first);         self-&gt;first = first;         Py_DECREF(tmp);     }      if (last) {         tmp = self-&gt;last;         Py_INCREF(last);         self-&gt;last = last;         Py_DECREF(tmp);     }      return 0; }  static PyMemberDef Noddy_members[] = {     {"number", T_INT, offsetof(Noddy, number), 0,      "noddy number"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_getfirst(Noddy *self, void *closure) {     Py_INCREF(self-&gt;first);     return self-&gt;first; }  static int Noddy_setfirst(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");     return -1;   }      if (! PyUnicode_Check(value)) {     PyErr_SetString(PyExc_TypeError,                      "The first attribute value must be a string");     return -1;   }          Py_DECREF(self-&gt;first);   Py_INCREF(value);   self-&gt;first = value;        return 0; }  static PyObject * Noddy_getlast(Noddy *self, void *closure) {     Py_INCREF(self-&gt;last);     return self-&gt;last; }  static int Noddy_setlast(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, "Cannot delete the last attribute");     return -1;   }      if (! PyUnicode_Check(value)) {     PyErr_SetString(PyExc_TypeError,                      "The last attribute value must be a string");     return -1;   }          Py_DECREF(self-&gt;last);   Py_INCREF(value);   self-&gt;last = value;        return 0; }  static PyGetSetDef Noddy_getseters[] = {     {"first",       (getter)Noddy_getfirst, (setter)Noddy_setfirst,      "first name",      NULL},     {"last",       (getter)Noddy_getlast, (setter)Noddy_setlast,      "last name",      NULL},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString("%s %s");         if (format == NULL)             return NULL;     }      args = Py_BuildValue("OO", self-&gt;first, self-&gt;last);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {"name", (PyCFunction)Noddy_name, METH_NOARGS,      "Return the name, combining the first and last name"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     "Noddy objects",           /* tp_doc */     0,		               /* tp_traverse */     0,		               /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     Noddy_getseters,           /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy3module = {     PyModuleDef_HEAD_INIT,     "noddy3",     "Example module that creates an extension type.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy3(void)  {     PyObject* m;      if (PyType_Ready(&amp;NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddy3module);     if (m == NULL)         return NULL;      Py_INCREF(&amp;NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;NoddyType);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt; #include "structmember.h"  typedef struct {     PyObject_HEAD     PyObject *imie;     PyObject *nazwisko;     int numer; } Noddy;  static void Noddy_dealloc(Noddy* self) {     Py_XDECREF(self-&gt;imie);     Py_XDECREF(self-&gt;nazwisko);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;imie = PyUnicode_FromString("");         if (self-&gt;imie == NULL)           {             Py_DECREF(self);             return NULL;           }                  self-&gt;nazwisko = PyUnicode_FromString("");         if (self-&gt;nazwisko == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;numer = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *imie=NULL, *nazwisko=NULL, *tmp;      static char *kwlist[] = {"imie", "nazwisko", "numer", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,                                        &amp;imie, &amp;nazwisko,                                        &amp;self-&gt;numer))         return -1;       if (imie) {         tmp = self-&gt;imie;         Py_INCREF(imie);         self-&gt;imie = imie;         Py_DECREF(tmp);     }      if (nazwisko) {         tmp = self-&gt;nazwisko;         Py_INCREF(nazwisko);         self-&gt;nazwisko = nazwisko;         Py_DECREF(tmp);     }      return 0; }  static PyMemberDef Noddy_members[] = {     {"numer", T_INT, offsetof(Noddy, numer), 0,      "noddy numer"},     {NULL}  /* Ochrona */ };  static PyObject * Noddy_getfirst(Noddy *self, void *closure) {     Py_INCREF(self-&gt;imie);     return self-&gt;imie; }  static int Noddy_setimie(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, "Nie można usunąć właściwości imienia");     return -1;   }      if (! PyUnicode_Check(value)) {     PyErr_SetString(PyExc_TypeError,                      "Wartość własności imienia musi być ciągiem znaków");     return -1;   }          Py_DECREF(self-&gt;imie);   Py_INCREF(value);   self-&gt;imie = value;        return 0; }  static PyObject * Noddy_getlast(Noddy *self, void *closure) {     Py_INCREF(self-&gt;nazwisko);     return self-&gt;nazwisko; }  static int Noddy_setnazwisko(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, "Nie można usunąć własności nazwiska");     return -1;   }      if (! PyUnicode_Check(value)) {     PyErr_SetString(PyExc_TypeError,                      "Wartość własności nazwiska musi być ciągiem znaków");     return -1;   }          Py_DECREF(self-&gt;nazwisko);   Py_INCREF(value);   self-&gt;nazwisko = value;        return 0; }  static PyGetSetDef Noddy_getseters[] = {     {"imie",       (getter)Noddy_getimie, (setter)Noddy_setimie,      "imię",      NULL},     {"nazwisko",       (getter)Noddy_getnazwisko, (setter)Noddy_setnazwisko,      "nazwisko",      NULL},     {NULL}  /* Ochrona */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString("%s %s");         if (format == NULL)             return NULL;     }      args = Py_BuildValue("OO", self-&gt;imie, self-&gt;nazwisko);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {"nazwa", (PyCFunction)Noddy_nazwa, METH_NOARGS,      "Zwróć nazwisko, łącząc imię i nazwisko"     },     {NULL}  /* Ochrona */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE,   /* tp_flags */     "przedmioty Noddy",           /* tp_doc */     0,			               /* tp_traverse */     0,		               /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     Noddy_getseters,           /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy3module = {     PyModuleDef_HEAD_INIT,     "noddy3",     "Przykładowy moduł który tworzy typ rozszerzający.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy3(void)  {     PyObject* m;      if (PyType_Ready(&amp;NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddy3module);     if (m == NULL)         return NULL;      Py_INCREF(&amp;NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;NoddyType);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To provide greater control, over the :attr:`first` and :attr:`last` attributes, we'll use custom getter and setter functions.  Here are the functions for getting and setting the :attr:`first` attribute::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zapewnić większą kontrolę, nad właściwościami :attr:`imie` i :attr:`nazwisko` użyjemy własnych zadań pobrania i ustawiania. Tu są zadania dla pobierania i ustawiania (getter i setter - z ang.) właściwości :attr:`imie`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Noddy_getfirst(Noddy *self, void *closure) {     Py_INCREF(self-&gt;first);     return self-&gt;first; }  static int Noddy_setfirst(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");     return -1;   }    if (! PyString_Check(value)) {     PyErr_SetString(PyExc_TypeError,                     "The first attribute value must be a string");     return -1;   }    Py_DECREF(self-&gt;first);   Py_INCREF(value);   self-&gt;first = value;    return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Noddy_getimie(Noddy *self, void *closure) {     Py_INCREF(self-&gt;imie);     return self-&gt;imie; }  static int Noddy_setimie(Noddy *self, PyObject *value, void *closure) {   if (value == NULL) {     PyErr_SetString(PyExc_TypeError, "Nie można usunąć właściwości imienia");     return -1;   }    if (! PyString_Check(value)) {     PyErr_SetString(PyExc_TypeError,                     "Wartość pierwszej właściwości musi być ciągiem znaków");     return -1;   }    Py_DECREF(self-&gt;imie);   Py_INCREF(value);   self-&gt;imie = value;    return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The getter function is passed a :class:`Noddy` object and a "closure", which is void pointer. In this case, the closure is ignored. (The closure supports an advanced usage in which definition data is passed to the getter and setter. This could, for example, be used to allow a single set of getter and setter functions that decide the attribute to get or set based on data in the closure.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadaniu pobierającemu jest przekazywany przedmiot uogólnienia :class:`Noddy` i "domknięcie" - ang. - "closure", które jest pustym wskaźnikiem. W tym przypadku "domknięcie" jest ignorowane. (domknięcie wspiera zaawansowane użycie w którym dane definicji są przekazywane dla zadania pobierającego i ustawiającego (getter i setter). To mogłoby, dla przykładu, być użyte aby pozwolić pojedynczemu zbiorowi zadań pobierających i ustawiających decydować, że własność będzie wzięta lub ustawiona w oparciu o dane w domknięciu.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The setter function is passed the :class:`Noddy` object, the new value, and the closure. The new value may be *NULL*, in which case the attribute is being deleted.  In our setter, we raise an error if the attribute is deleted or if the attribute value is not a string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadaniu ustawiającemu jest przekazywany przedmiot uogólnienia :class:`Noddy`, nowa wartość i domknięcie. Nowa wartość może być *NULL*, w którym to przypadku własność zostanie usunięta. W naszym zadaniu ustawiającym, zgłaszamy błąd jeśli właściwość jest kasowana lub jeśli własność nie jest ciągiem znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We create an array of :ctype:`PyGetSetDef` structures::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzymy tabelę struktur :ctype:`PyGetSetDef`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyGetSetDef Noddy_getseters[] = {     {"first",      (getter)Noddy_getfirst, (setter)Noddy_setfirst,      "first name",      NULL},     {"last",      (getter)Noddy_getlast, (setter)Noddy_setlast,      "last name",      NULL},     {NULL}  /* Sentinel */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyGetSetDef Noddy_getseters[] = {     {"imie",      (getter)Noddy_getfirst, (setter)Noddy_setfirst,      "imię",      NULL},     {"nazwisko",      (getter)Noddy_getlast, (setter)Noddy_setlast,      "nazwisko",      NULL},     {NULL}  /* Ochrona */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and register it in the :attr:`tp_getset` slot::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i rejestrujemy je w gnieździe :attr:`tp_getset`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Noddy_getseters,           /* tp_getset */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Noddy_getseters,           /* tp_getset */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to register our attribute getters and setters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>aby zarejestrować nasze zadania pobierania i ustawiania właściwości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last item in a :ctype:`PyGetSetDef` structure is the closure mentioned above. In this case, we aren't using the closure, so we just pass *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatnim elementem w strukturze :ctype:`PyGetSetDef` jest domknięcie wspomniane powyżej. W tym przypadku, nie używamy domknięcia, więc przekażemy po prostu *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also remove the member definitions for these attributes::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdejmujemy także definicje członków dla tych własności::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyMemberDef Noddy_members[] = {     {"number", T_INT, offsetof(Noddy, number), 0,      "noddy number"},     {NULL}  /* Sentinel */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyMemberDef Noddy_members[] = {     {"numer", T_INT, offsetof(Noddy, numer), 0,      "noddy numer"},     {NULL}  /* Ochrona */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the :attr:`tp_init` handler to only allow strings [#]_ to be passed::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Musimy także uaktualnić obsługę :attr:`tp_init` aby tylko akceptowała ciągi znaków [#]_ aby były przekazywane::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {"first", "last", "number", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,                                       &amp;first, &amp;last,                                       &amp;self-&gt;number))         return -1;      if (first) {         tmp = self-&gt;first;         Py_INCREF(first);         self-&gt;first = first;         Py_DECREF(tmp);     }      if (last) {         tmp = self-&gt;last;         Py_INCREF(last);         self-&gt;last = last;         Py_DECREF(tmp);     }      return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *imie=NULL, *nazwisko=NULL, *tmp;      static char *kwlist[] = {"imie", "nazwisko", "numer", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,                                       &amp;imie, &amp;nazwisko,                                       &amp;self-&gt;numer))         return -1;      if (imie) {         tmp = self-&gt;imie;         Py_INCREF(imie);         self-&gt;imie = imie;         Py_DECREF(tmp);     }      if (nazwisko) {         tmp = self-&gt;nazwisko;         Py_INCREF(nazwisko);         self-&gt;nazwisko = nazwisko;         Py_DECREF(tmp);     }      return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With these changes, we can assure that the :attr:`first` and :attr:`last` members are never *NULL* so we can remove checks for *NULL* values in almost all cases. This means that most of the :cfunc:`Py_XDECREF` calls can be converted to :cfunc:`Py_DECREF` calls. The only place we can't change these calls is in the deallocator, where there is the possibility that the initialization of these members failed in the constructor.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Z tymi zmianami, możemy zapewnić, że członki :attr:`imie` i :attr:`nazwisko` nigdy nie są *NULL* więc możemy zdjąć sprawdzenia wartości *NULL* w większości przypadków. To oznacza, że większość z wywołań :cfunc:`Py_XDECREF` może być zamienionych na wywołania :cfunc:`Py_DECREF`. Jedynym miejscem w którym nie możemy zmienić tych wywołań jest dealokator, gdzie istnieje możliwość, że inicjacja tych członków zawiodła w konstruktorze.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also rename the module initialization function and module name in the initialization function, as we did before, and we add an extra definition to the :file:`setup.py` file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zmieniamy także zadanie inicjujące moduł i nazwę modułu w zadaniu inicjującym, tak jak poprzednio, i dodajemy dodatkową definicję do pliku :file:`setup.py`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supporting cyclic garbage collection</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla cyklicznej zbiórki śmieci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python has a cyclic-garbage collector that can identify unneeded objects even when their reference counts are not zero. This can happen when objects are involved in cycles.  For example, consider::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski ma cykliczną zbiórkę śmieci, która może identyfikować niepotrzebne przedmioty nawet gdy ich liczby odniesień nie są równe zero. To może się zdarzyć gdy przedmioty odnoszą się do siebie cyklicznie. Na przykład, załóżmy::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; l = [] &gt;&gt;&gt; l.append(l) &gt;&gt;&gt; del l</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; l = [] &gt;&gt;&gt; l.append(l) &gt;&gt;&gt; del l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we create a list that contains itself. When we delete it, it still has a reference from itself. Its reference count doesn't drop to zero. Fortunately, Python's cyclic-garbage collector will eventually figure out that the list is garbage and free it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym przykładzie, tworzymy listę, która zawiera samą siebie. Gdy kasujemy ją, to wciąż ma ona odniesienie do niej ze środka. Jej liczba odniesień nie spada do zera. Na szczęście cykliczna-zbiórka śmieci języka pytonowskiego ostatecznie że cała lista jest śmieciem i uwolni ją.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the second version of the :class:`Noddy` example, we allowed any kind of object to be stored in the :attr:`first` or :attr:`last` attributes. [#]_ This means that :class:`Noddy` objects can participate in cycles::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W drugiej wersji przykładu uogólnienia :class:`Noddy`, pozwoliliśmy dowolnego rodzaju przedmiotowi aby był zachowany we własnościach :attr:`imie` lub :attr:`nazwisko`. [#]_ To oznacza że przedmioty :class:`Noddy` mogą brać udział w cyklicznych odwołaniach::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import noddy2 &gt;&gt;&gt; n = noddy2.Noddy() &gt;&gt;&gt; l = [n] &gt;&gt;&gt; n.first = l</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import noddy2 &gt;&gt;&gt; n = noddy2.Noddy() &gt;&gt;&gt; l = [n] &gt;&gt;&gt; n.first = l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is pretty silly, but it gives us an excuse to add support for the cyclic-garbage collector to the :class:`Noddy` example.  To support cyclic garbage collection, types need to fill two slots and set a class flag that enables these slots:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest raczej głupie, ale daje nam wymówkę aby dodać wsparcie dla cyklicznej zbiórki śmieci do przykładu uogólnienia :class:`Noddy`. Aby wspierać cykliczną zbiórkę śmieci, typy potrzebują wypełniać dwa gniazda i ustawić flagę uogólnienia która włącza te gniazda:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt; #include "structmember.h"  typedef struct {     PyObject_HEAD     PyObject *first;     PyObject *last;     int number; } Noddy;  static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int vret;      if (self-&gt;first) {         vret = visit(self-&gt;first, arg);         if (vret != 0)             return vret;     }     if (self-&gt;last) {         vret = visit(self-&gt;last, arg);         if (vret != 0)             return vret;     }      return 0; }  static int  Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self-&gt;first;     self-&gt;first = NULL;     Py_XDECREF(tmp);      tmp = self-&gt;last;     self-&gt;last = NULL;     Py_XDECREF(tmp);      return 0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;first = PyUnicode_FromString("");         if (self-&gt;first == NULL)           {             Py_DECREF(self);             return NULL;           }                  self-&gt;last = PyUnicode_FromString("");         if (self-&gt;last == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;number = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *first=NULL, *last=NULL, *tmp;      static char *kwlist[] = {"first", "last", "number", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,                                        &amp;first, &amp;last,                                        &amp;self-&gt;number))         return -1;       if (first) {         tmp = self-&gt;first;         Py_INCREF(first);         self-&gt;first = first;         Py_XDECREF(tmp);     }      if (last) {         tmp = self-&gt;last;         Py_INCREF(last);         self-&gt;last = last;         Py_XDECREF(tmp);     }      return 0; }   static PyMemberDef Noddy_members[] = {     {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,      "first name"},     {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,      "last name"},     {"number", T_INT, offsetof(Noddy, number), 0,      "noddy number"},     {NULL}  /* Sentinel */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString("%s %s");         if (format == NULL)             return NULL;     }      if (self-&gt;first == NULL) {         PyErr_SetString(PyExc_AttributeError, "first");         return NULL;     }      if (self-&gt;last == NULL) {         PyErr_SetString(PyExc_AttributeError, "last");         return NULL;     }      args = Py_BuildValue("OO", self-&gt;first, self-&gt;last);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {"name", (PyCFunction)Noddy_name, METH_NOARGS,      "Return the name, combining the first and last name"     },     {NULL}  /* Sentinel */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE |         Py_TPFLAGS_HAVE_GC,    /* tp_flags */     "Noddy objects",           /* tp_doc */     (traverseproc)Noddy_traverse,   /* tp_traverse */     (inquiry)Noddy_clear,           /* tp_clear */     0,		               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     0,                         /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy4module = {     PyModuleDef_HEAD_INIT,     "noddy4",     "Example module that creates an extension type.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy4(void)  {     PyObject* m;      if (PyType_Ready(&amp;NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddy4module);     if (m == NULL)         return NULL;      Py_INCREF(&amp;NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;NoddyType);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt; #include "structmember.h"  typedef struct {     PyObject_HEAD     PyObject *imie;     PyObject *nazwisko;     int numer; } Noddy;  static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int vret;      if (self-&gt;imie) {         vret = visit(self-&gt;imie, arg);         if (vret != 0)             return vret;     }     if (self-&gt;nazwisko) {         vret = visit(self-&gt;nazwisko, arg);         if (vret != 0)             return vret;     }      return 0; }  static int  Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self-&gt;imie;     self-&gt;imie = NULL;     Py_XDECREF(tmp);      tmp = self-&gt;nazwisko;     self-&gt;nazwisko = NULL;     Py_XDECREF(tmp);      return 0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }  static PyObject * Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {     Noddy *self;      self = (Noddy *)type-&gt;tp_alloc(type, 0);     if (self != NULL) {         self-&gt;imie = PyUnicode_FromString("");         if (self-&gt;imie == NULL)           {             Py_DECREF(self);             return NULL;           }                  self-&gt;nazwisko = PyUnicode_FromString("");         if (self-&gt;nazwisko == NULL)           {             Py_DECREF(self);             return NULL;           }          self-&gt;numer = 0;     }      return (PyObject *)self; }  static int Noddy_init(Noddy *self, PyObject *args, PyObject *kwds) {     PyObject *imie=NULL, *nazwisko=NULL, *tmp;      static char *kwlist[] = {"imie", "nazwisko", "numer", NULL};      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,                                        &amp;imie, &amp;nazwisko,                                        &amp;self-&gt;numer))         return -1;       if (imie) {         tmp = self-&gt;imie;         Py_INCREF(imie);         self-&gt;imie = imie;         Py_XDECREF(tmp);     }      if (nazwisko) {         tmp = self-&gt;nazwisko;         Py_INCREF(nazwisko);         self-&gt;nazwisko = nazwisko;         Py_XDECREF(tmp);     }      return 0; }   static PyMemberDef Noddy_members[] = {     {"imie", T_OBJECT_EX, offsetof(Noddy, imie), 0,      "imie"},     {"nazwisko", T_OBJECT_EX, offsetof(Noddy, last), 0,      "nazwisko"},     {"numer", T_INT, offsetof(Noddy, numer), 0,      "numer noddy"},     {NULL}  /* Ochrona */ };  static PyObject * Noddy_name(Noddy* self) {     static PyObject *format = NULL;     PyObject *args, *result;      if (format == NULL) {         format = PyUnicode_FromString("%s %s");         if (format == NULL)             return NULL;     }      if (self-&gt;imie == NULL) {         PyErr_SetString(PyExc_AttributeError, "imie");         return NULL;     }      if (self-&gt;nazwisko == NULL) {         PyErr_SetString(PyExc_AttributeError, "nazwisko");         return NULL;     }      args = Py_BuildValue("OO", self-&gt;imie, self-&gt;nazwisko);     if (args == NULL)         return NULL;      result = PyUnicode_Format(format, args);     Py_DECREF(args);          return result; }  static PyMethodDef Noddy_methods[] = {     {"nazwisko", (PyCFunction)Noddy_name, METH_NOARGS,      "Zwróć nazwisko, sklejając imię i nazwisko"     },     {NULL}  /* Ochrona */ };  static PyTypeObject NoddyType = {     PyVarObject_HEAD_INIT(NULL, 0)     "noddy.Noddy",             /* tp_name */     sizeof(Noddy),             /* tp_basicsize */     0,                         /* tp_itemsize */     (destructor)Noddy_dealloc, /* tp_dealloc */     0,                         /* tp_print */     0,                         /* tp_getattr */     0,                         /* tp_setattr */     0,                         /* tp_reserved */     0,                         /* tp_repr */     0,                         /* tp_as_number */     0,                         /* tp_as_sequence */     0,                         /* tp_as_mapping */     0,                         /* tp_hash  */     0,                         /* tp_call */     0,                         /* tp_str */     0,                         /* tp_getattro */     0,                         /* tp_setattro */     0,                         /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE |         Py_TPFLAGS_HAVE_GC,    /* tp_flags */     "przedmioty Noddy",           /* tp_doc */     (traverseproc)Noddy_traverse,   /* tp_traverse */     (inquiry)Noddy_clear,           /* tp_clear */     0,			               /* tp_richcompare */     0,		               /* tp_weaklistoffset */     0,		               /* tp_iter */     0,		               /* tp_iternext */     Noddy_methods,             /* tp_methods */     Noddy_members,             /* tp_members */     0,                         /* tp_getset */     0,                         /* tp_base */     0,                         /* tp_dict */     0,                         /* tp_descr_get */     0,                         /* tp_descr_set */     0,                         /* tp_dictoffset */     (initproc)Noddy_init,      /* tp_init */     0,                         /* tp_alloc */     Noddy_new,                 /* tp_new */ };  static PyModuleDef noddy4module = {     PyModuleDef_HEAD_INIT,     "noddy4",     "Przykładowy moduł który tworzy typ rozszerzający.",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_noddy4(void)  {     PyObject* m;      if (PyType_Ready(&amp;NoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;noddy4module);     if (m == NULL)         return NULL;      Py_INCREF(&amp;NoddyType);     PyModule_AddObject(m, "Noddy", (PyObject *)&amp;NoddyType);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The traversal method provides access to subobjects that could participate in cycles::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania trawersujący dostarcza dostęp do podrzędnych przedmiotów które mogą brać udział w cyklach::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int vret;      if (self-&gt;first) {         vret = visit(self-&gt;first, arg);         if (vret != 0)             return vret;     }     if (self-&gt;last) {         vret = visit(self-&gt;last, arg);         if (vret != 0)             return vret;     }      return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     int vret;      if (self-&gt;imie) {         vret = visit(self-&gt;imie, arg);         if (vret != 0)             return vret;     }     if (self-&gt;nazwisko) {         vret = visit(self-&gt;nazwisko, arg);         if (vret != 0)             return vret;     }      return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each subobject that can participate in cycles, we need to call the :cfunc:`visit` function, which is passed to the traversal method. The :cfunc:`visit` function takes as arguments the subobject and the extra argument *arg* passed to the traversal method.  It returns an integer value that must be returned if it is non-zero.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla każdego podrzędnego przedmiotu który może brać udział w cyklach, potrzebujemy wezwać zadanie :cfunc:`visit`, które jest przekazywane do sposobu postępowania trawersującego. Zadanie :cfunc:`visit` pobiera jako parametry podrzędne przedmioty i dodatkowy parametr *arg* przekazywany do zadania trawersującego. Zwraca liczbę całkowitą która musi być zwrócona jeśli jest nie-zerowa. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python provides a :cfunc:`Py_VISIT` macro that automates calling visit functions.  With :cfunc:`Py_VISIT`, :cfunc:`Noddy_traverse` can be simplified::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski dostarcza makropolecenie :cfunc:`Py_VISIT` które automatyzuje wzywania zadania wizytowania. Za pomocą :cfunc:`Py_VISIT` zadanie :cfunc:`Noddy_traverse` może zostać uproszczona::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     Py_VISIT(self-&gt;first);     Py_VISIT(self-&gt;last);     return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Noddy_traverse(Noddy *self, visitproc visit, void *arg) {     Py_VISIT(self-&gt;imie);     Py_VISIT(self-&gt;nazwisko);     return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the :attr:`tp_traverse` implementation must name its arguments exactly *visit* and *arg* in order to use :cfunc:`Py_VISIT`.  This is to encourage uniformity across these boring implementations.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że wypełnienie własności :attr:`tp_traverse` musi nazywać swoje argumenty dokładnie *visit* i *arg* w celu użycia zadania :cfunc:`Py_VISIT`. To jest w celu zachęcenia do jednakowości pośród tych nudnych wypełnień.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to provide a method for clearing any subobjects that can participate in cycles.  We implement the method and reimplement the deallocator to use it::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>My także potrzebujemy dostarczyć sposób postępowania dla czyszczenia podrzędnych przedmiotów które mogą brać udział w cyklach. Wypełniamy sposób postępowania i ponownie wypełniamy sposób postępowania uwalniający pamięć aby go użyć::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self-&gt;first;     self-&gt;first = NULL;     Py_XDECREF(tmp);      tmp = self-&gt;last;     self-&gt;last = NULL;     Py_XDECREF(tmp);      return 0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Noddy_clear(Noddy *self) {     PyObject *tmp;      tmp = self-&gt;imie;     self-&gt;imie = NULL;     Py_XDECREF(tmp);      tmp = self-&gt;nazwisko;     self-&gt;nazwisko = NULL;     Py_XDECREF(tmp);      return 0; }  static void Noddy_dealloc(Noddy* self) {     Noddy_clear(self);     Py_TYPE(self)-&gt;tp_free((PyObject*)self); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of a temporary variable in :cfunc:`Noddy_clear`. We use the temporary variable so that we can set each member to *NULL* before decrementing its reference count.  We do this because, as was discussed earlier, if the reference count drops to zero, we might cause code to run that calls back into the object.  In addition, because we now support garbage collection, we also have to worry about code being run that triggers garbage collection.  If garbage collection is run, our :attr:`tp_traverse` handler could get called. We can't take a chance of having :cfunc:`Noddy_traverse` called when a member's reference count has dropped to zero and its value hasn't been set to *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ użycie tymczasowej zmiennej w :cfunc:`Noddy_clear`. Używamy zmiennej tymczasowej tak aby móc ustawić każdego członka na *NULL* zanim zmniejszymy jego liczbę odniesień. Robimy to dlatego, że, jak wyjaśniono wcześniej, jeśli liczba odniesień spadnie do zera, moglibyśmy spowodować, że kod uruchomiłby się, który wywołuje wstecz do wnętrza przedmiotu. W dodatku, ponieważ my teraz wspieramy zbieranie śmieci, musimy także martwić się o kod który uruchamia się i wyzwala zbieranie śmieci. Jeśli zbieranie śmieci zostanie uruchomione, nasza obsługa :attr:`tp_traverse` mogłaby być wywołana. Nie możemy ryzykować wywołania :cfunc:`Noddy_traverse` gdy liczba odniesień do członka spadła do zera i jego wartość nie została ustawiona na *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python provides a :cfunc:`Py_CLEAR` that automates the careful decrementing of reference counts.  With :cfunc:`Py_CLEAR`, the :cfunc:`Noddy_clear` function can be simplified::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Python dostarcza zadanie :cfunc:`Py_CLEAR` które automatyzuje ostrożne zmniejszanie liczby odniesień.  Z zadaniem :cfunc:`Py_CLEAR`, zadanie :cfunc:`Noddy_clear` może zostać uproszczone::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Noddy_clear(Noddy *self) {     Py_CLEAR(self-&gt;first);     Py_CLEAR(self-&gt;last);     return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Noddy_clear(Noddy *self) {     Py_CLEAR(self-&gt;imie);     Py_CLEAR(self-&gt;nazwisko);     return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatecznie dodajemy flagę :const:`Py_TPFLAGS_HAVE_GC` do flag uogólnienia::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's pretty much it.  If we had written custom :attr:`tp_alloc` or :attr:`tp_free` slots, we'd need to modify them for cyclic-garbage collection. Most extensions will use the versions automatically provided.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To z grubsza wszystko. Jeśli napisalibyśmy szczególne sposoby postępowania :attr:`tp_alloc` lub :attr:`tp_free` w gniazdach, potrzebowalibyśmy zmodyfikować je dla cyklicznego zbierania śmieci. Większość rozszerzeń będzie używać wersji dostarczonych automatycznie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subclassing other types</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie podrzędnych uogólnień innych typów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create new extension types that are derived from existing types. It is easiest to inherit from the built in types, since an extension can easily use the :class:`PyTypeObject` it needs. It can be difficult to share these :class:`PyTypeObject` structures between extension modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest możliwe tworzenie nowych typów rozszerzeń które są pochodnymi istniejących typów. Najłatwiej jest dziedziczyć z typów wbudowanych od kiedy rozszerzenie może łatwo używać uogólnienia :class:`PyTypeObject`, którego potrzebuje. Może być trudno dzielić struktury uogólnienia :class:`PyTypeObject` pomiędzy moduły rozszerzające.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example we will create a :class:`Shoddy` type that inherits from the built-in :class:`list` type. The new type will be completely compatible with regular lists, but will have an additional :meth:`increment` method that increases an internal counter. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W tym przykładzie utworzymy typ uogólnienie :class:`Shoddy` który będzie dziedziczył po wbudowanych typach uogólnienia :class:`list`. Nowy typ będzie kompletnie zgodny z regularnymi listami, ale będzie miał dodatkowy sposób postępowania :meth:`increment` który zwiększa wewnętrzny licznik. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import shoddy &gt;&gt;&gt; s = shoddy.Shoddy(range(3)) &gt;&gt;&gt; s.extend(s) &gt;&gt;&gt; print(len(s)) 6 &gt;&gt;&gt; print(s.increment()) 1 &gt;&gt;&gt; print(s.increment()) 2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import shoddy &gt;&gt;&gt; s = shoddy.Shoddy(range(3)) &gt;&gt;&gt; s.extend(s) &gt;&gt;&gt; print(len(s)) 6 &gt;&gt;&gt; print(s.increment()) 1 &gt;&gt;&gt; print(s.increment()) 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include &lt;Python.h&gt;  typedef struct {     PyListObject list;     int state; } Shoddy;   static PyObject * Shoddy_increment(Shoddy *self, PyObject *unused) {     self-&gt;state++;     return PyLong_FromLong(self-&gt;state); }   static PyMethodDef Shoddy_methods[] = {     {"increment", (PyCFunction)Shoddy_increment, METH_NOARGS,      PyDoc_STR("increment state counter")},     {NULL,	NULL}, };  static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject *)self, args, kwds) &lt; 0)         return -1;     self-&gt;state = 0;     return 0; }   static PyTypeObject ShoddyType = {     PyObject_HEAD_INIT(NULL)     "shoddy.Shoddy",         /* tp_name */     sizeof(Shoddy),          /* tp_basicsize */     0,                       /* tp_itemsize */     0,                       /* tp_dealloc */     0,                       /* tp_print */     0,                       /* tp_getattr */     0,                       /* tp_setattr */     0,                       /* tp_reserved */     0,                       /* tp_repr */     0,                       /* tp_as_number */     0,                       /* tp_as_sequence */     0,                       /* tp_as_mapping */     0,                       /* tp_hash */     0,                       /* tp_call */     0,                       /* tp_str */     0,                       /* tp_getattro */     0,                       /* tp_setattro */     0,                       /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE, /* tp_flags */     0,                       /* tp_doc */     0,                       /* tp_traverse */     0,                       /* tp_clear */     0,                       /* tp_richcompare */     0,                       /* tp_weaklistoffset */     0,                       /* tp_iter */     0,                       /* tp_iternext */     Shoddy_methods,          /* tp_methods */     0,                       /* tp_members */     0,                       /* tp_getset */     0,                       /* tp_base */     0,                       /* tp_dict */     0,                       /* tp_descr_get */     0,                       /* tp_descr_set */     0,                       /* tp_dictoffset */     (initproc)Shoddy_init,   /* tp_init */     0,                       /* tp_alloc */     0,                       /* tp_new */ };  static PyModuleDef shoddymodule = {     PyModuleDef_HEAD_INIT,     "shoddy",     "Shoddy module",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      ShoddyType.tp_base = &amp;PyList_Type;     if (PyType_Ready(&amp;ShoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;shoddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&amp;ShoddyType);     PyModule_AddObject(m, "Shoddy", (PyObject *) &amp;ShoddyType);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#include &lt;Python.h&gt;  typedef struct {     PyListObject list;     int stan; } Shoddy;   static PyObject * Shoddy_increment(Shoddy *self, PyObject *unused) {     self-&gt;stan++;     return PyLong_FromLong(self-&gt;stan); }   static PyMethodDef Shoddy_methods[] = {     {"increment", (PyCFunction)Shoddy_increment, METH_NOARGS,      PyDoc_STR("zwiększ licznik stanu")},     {NULL,		NULL}, };  static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject *)self, args, kwds) &lt; 0)         return -1;     self-&gt;stan = 0;     return 0; }   static PyTypeObject ShoddyType = {     PyObject_HEAD_INIT(NULL)     "shoddy.Shoddy",         /* tp_name */     sizeof(Shoddy),          /* tp_basicsize */     0,                       /* tp_itemsize */     0,                       /* tp_dealloc */     0,                       /* tp_print */     0,                       /* tp_getattr */     0,                       /* tp_setattr */     0,                       /* tp_reserved */     0,                       /* tp_repr */     0,                       /* tp_as_number */     0,                       /* tp_as_sequence */     0,                       /* tp_as_mapping */     0,                       /* tp_hash */     0,                       /* tp_call */     0,                       /* tp_str */     0,                       /* tp_getattro */     0,                       /* tp_setattro */     0,                       /* tp_as_buffer */     Py_TPFLAGS_DEFAULT |         Py_TPFLAGS_BASETYPE, /* tp_flags */     0,                       /* tp_doc */     0,                       /* tp_traverse */     0,                       /* tp_clear */     0,                       /* tp_richcompare */     0,                       /* tp_weaklistoffset */     0,                       /* tp_iter */     0,                       /* tp_iternext */     Shoddy_methods,          /* tp_methods */     0,                       /* tp_members */     0,                       /* tp_getset */     0,                       /* tp_base */     0,                       /* tp_dict */     0,                       /* tp_descr_get */     0,                       /* tp_descr_set */     0,                       /* tp_dictoffset */     (initproc)Shoddy_init,   /* tp_init */     0,                       /* tp_alloc */     0,                       /* tp_new */ };  static PyModuleDef shoddymodule = {     PyModuleDef_HEAD_INIT,     "shoddy",     "Moduł shoddy",     -1,     NULL, NULL, NULL, NULL, NULL };  PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      ShoddyType.tp_base = &amp;PyList_Type;     if (PyType_Ready(&amp;ShoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;shoddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&amp;ShoddyType);     PyModule_AddObject(m, "Shoddy", (PyObject *) &amp;ShoddyType);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, the source code closely resembles the :class:`Noddy` examples in previous sections. We will break down the main differences between them. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak widać, kod źródłowy blisko przypomina przykład uogólnienia :class:`Noddy` z poprzednich rozdziałów. Podzielimy główne różnice pomiędzy nimi. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct {     PyListObject list;     int state; } Shoddy;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct {     PyListObject list;     int stan; } Shoddy;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The primary difference for derived type objects is that the base type's object structure must be the first value. The base type will already include the :cfunc:`PyObject_HEAD` at the beginning of its structure.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Główna różnica dla odziedziczonych przedmiotów typu jest tym że struktura przedmiotu typu bazowego musi być pierwszą wartością. Typ bazowy będzie już zawierał :cfunc:`PyObject_HEAD` na początku struktury.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a Python object is a :class:`Shoddy` instance, its *PyObject\** pointer can be safely cast to both *PyListObject\** and *Shoddy\**. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy przedmiot języka pytonowskiego jest przykładem uogólnienia :class:`Shoddy`, jego wskaźnik *PyObject\** może być bezpiecznie zrzutować na zarówno *PyListObject\** i *Shoddy\**. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject *)self, args, kwds) &lt; 0)        return -1;     self-&gt;state = 0;     return 0; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds) {     if (PyList_Type.tp_init((PyObject *)self, args, kwds) &lt; 0)        return -1;     self-&gt;stan = 0;     return 0; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the :attr:`__init__` method for our type, we can see how to call through to the :attr:`__init__` method of the base type.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W sposobie postępowania :attr:`__init__` dla naszego typu, możemy zobaczyć jak wywołać sposób postępowania :attr:`__init__` typu bazowego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This pattern is important when writing a type with custom :attr:`new` and :attr:`dealloc` methods. The :attr:`new` method should not actually create the memory for the object with :attr:`tp_alloc`, that will be handled by the base class when calling its :attr:`tp_new`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wzorzec jest istotny gdy pisze się typ z szczególnym wypełnieniem sposobów postępowania :attr:`new` i :attr:`dealloc`. Sposób postępowania :attr:`new` nie powinien właściwie tworzyć pamięci dla przedmiotu z :attr:`tp_alloc`, który będzie obsługiwany przez uogólnienie bazowe gdy wywoływany będzie jego sposób postępowania :attr:`tp_new`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When filling out the :cfunc:`PyTypeObject` for the :class:`Shoddy` type, you see a slot for :cfunc:`tp_base`. Due to cross platform compiler issues, you can't fill that field directly with the :cfunc:`PyList_Type`; it can be done later in the module's :cfunc:`init` function. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy wypełniany jest :cfunc:`PyTypeObject` dla typu :class:`Shoddy`, zobaczysz gniazdo dla :cfunc:`tp_base`. W związku z problemami krzyżowej kompilacji na różnych maszynach/środowiskach, nie możesz wypełnić tego pola bezpośrednio za pomocą :cfunc:`PyList_Type`; można to zrobić później w zadaniu inicjującym modułu :cfunc:`init`. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      ShoddyType.tp_base = &amp;PyList_Type;     if (PyType_Ready(&amp;ShoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;shoddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&amp;ShoddyType);     PyModule_AddObject(m, "Shoddy", (PyObject *) &amp;ShoddyType);     return m; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyMODINIT_FUNC PyInit_shoddy(void) {     PyObject *m;      ShoddyType.tp_base = &amp;PyList_Type;     if (PyType_Ready(&amp;ShoddyType) &lt; 0)         return NULL;      m = PyModule_Create(&amp;shoddymodule);     if (m == NULL)         return NULL;      Py_INCREF(&amp;ShoddyType);     PyModule_AddObject(m, "Shoddy", (PyObject *) &amp;ShoddyType);     return m; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before calling :cfunc:`PyType_Ready`, the type structure must have the :attr:`tp_base` slot filled in. When we are deriving a new type, it is not necessary to fill out the :attr:`tp_alloc` slot with :cfunc:`PyType_GenericNew` -- the allocate function from the base type will be inherited.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przed wywołaniem :cfunc:`PyType_Ready`, struktura typu musi mieć gniazdo :attr:`tp_base` zapełnione. Gdy nowy typ pochodzi od istniejącego, nie jest konieczne wypełnianie gniazda :attr:`tp_alloc` za pomocą :cfunc:`PyType_GenericNew` -- zadanie umieszczania w pamięci zostanie odziedziczone po typie bazowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After that, calling :cfunc:`PyType_Ready` and adding the type object to the module is the same as with the basic :class:`Noddy` examples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Po tym, wezwanie :cfunc:`PyType_Ready` i dodanie przedmiotu typu do modułu będzie tym samym jak w podstawowych przykładach uogólnienia :class:`Noddy`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type Methods</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania typu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section aims to give a quick fly-by on the various type methods you can implement and what they do.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział ma na celu szybko oblecieć różne sposoby postępowania typów które możesz wypełnić i omówić co one robią.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is the definition of :ctype:`PyTypeObject`, with some fields only used in debug builds omitted:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest definicja :ctype:`PyTypeObject`, z pewnymi polami tylko używanymi w budowach odpluskwiania zazwyczaj pomijanych:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */     int tp_basicsize, tp_itemsize; /* For allocation */      /* Methods to implement standard operations */      destructor tp_dealloc;     printfunc tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void *tp_reserved;     reprfunc tp_repr;      /* Method suites for standard classes */      PyNumberMethods *tp_as_number;     PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping;      /* More standard operations (here for binary compatibility) */      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Functions to access object as input/output buffer */     PyBufferProcs *tp_as_buffer;      /* Flags to define presence of optional/expanded features */     long tp_flags;      char *tp_doc; /* Documentation string */      /* call function for all accessible objects */     traverseproc tp_traverse;      /* delete references to contained objects */     inquiry tp_clear;      /* rich comparisons */     richcmpfunc tp_richcompare;      /* weak reference enabler */     long tp_weaklistoffset;      /* Iterators */     getiterfunc tp_iter;     iternextfunc tp_iternext;      /* Attribute descriptor and subclassing stuff */     struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc tp_free; /* Low-level free-memory routine */     inquiry tp_is_gc; /* For PyObject_IS_GC */     PyObject *tp_bases;     PyObject *tp_mro; /* method resolution order */     PyObject *tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct _typeobject {     PyObject_VAR_HEAD     char *tp_name; /* Dla wypisywania, w formacie "&lt;moduł&gt;.&lt;nazwa&gt;" */     int tp_basicsize, tp_itemsize; /* Dla lokowania w pamięci */      /* Sposoby postępowania aby wypełnić standardowe operacje */      destructor tp_dealloc;     printfunc tp_print;     getattrfunc tp_getattr;     setattrfunc tp_setattr;     void *tp_reserved;     reprfunc tp_repr;      /* Zestawy sposobów postępowania dla uogólnień standardowych */      PyNumberMethods *tp_as_number;     PySequenceMethods *tp_as_sequence;     PyMappingMethods *tp_as_mapping;      /* Więcej standardowych operacji (tutaj tylko dla binarnej zgodności) */      hashfunc tp_hash;     ternaryfunc tp_call;     reprfunc tp_str;     getattrofunc tp_getattro;     setattrofunc tp_setattro;      /* Zadania aby uzyskać przedmiot dostępu jako wejściowo/wyjściową przestrzenią wymiany */     PyBufferProcs *tp_as_buffer;      /* Flagi aby zdefiniować obecność opcjonalnych/rozszerzonych właściwości */     long tp_flags;      char *tp_doc; /* Ciągi dokumentacji */      /* wywołanie zadania dla wszystkich dostępnych przedmiotów */     traverseproc tp_traverse;      /* skasować odniesienia do zawartych tam przedmiotów */     inquiry tp_clear;      /* bogate porównania */     richcmpfunc tp_richcompare;      /* umożliwianie słabych odniesień */     long tp_weaklistoffset;      /* iteratory */     getiterfunc tp_iter;     iternextfunc tp_iternext;      /* deskryptor właściwości i sprawy dziedziczenia */     struct PyMethodDef *tp_methods;     struct PyMemberDef *tp_members;     struct PyGetSetDef *tp_getset;     struct _typeobject *tp_base;     PyObject *tp_dict;     descrgetfunc tp_descr_get;     descrsetfunc tp_descr_set;     long tp_dictoffset;     initproc tp_init;     allocfunc tp_alloc;     newfunc tp_new;     freefunc tp_free; /* Nisko-poziomowe zadanie zwalniające pamięć */     inquiry tp_is_gc; /* Dla PyObject_IS_GC */     PyObject *tp_bases;     PyObject *tp_mro; /* kolejność rozwiązywania sposobów postępowania */     PyObject *tp_cache;     PyObject *tp_subclasses;     PyObject *tp_weaklist;  } PyTypeObject;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that's a *lot* of methods.  Don't worry too much though - if you have a type you want to define, the chances are very good that you will only implement a handful of these.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Cóż, to jest *dużo* sposobów postępowania. Nie martw się za bardzo jednak - jeśli masz typ który chcesz zdefiniować, szanse są bardzo dobre, że będziesz wypełniał tylko kilka z nich.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you probably expect by now, we're going to go over this and give more information about the various handlers.  We won't go in the order they are defined in the structure, because there is a lot of historical baggage that impacts the ordering of the fields; be sure your type initialization keeps the fields in the right order!  It's often easiest to find an example that includes all the fields you need (even if they're initialized to ``0``) and then change the values to suit your new type. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak już pewnie spodziewasz się teraz, przejdziemy się ponad tym i podamy więcej informacji o różnych obsługach. Nie będziemy wdawać się w kolejność w której są one zdefiniowane w strukturze ponieważ jest mnóstwo historycznego bagażu który wpływa na poszeregowanie pól; upewnij się że twoje inicjowanie typu utrzymuje pola we właściwym porządku! Czasem najłatwiej jest znaleźć przykład, który zawiera wszystkie pola których potrzebujesz (nawet jeśli są one zainicjowane ``0``) i potem zmienić wartości aby odpowiadały twojemu nowemu typowi. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>char *tp_name; /* For printing */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>char *tp_name; /* Dla wypisywania */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the type - as mentioned in the last section, this will appear in various places, almost entirely for diagnostic purposes. Try to choose something that will be helpful in such a situation! ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa typu - jak wymieniono w poprzednim rozdziale, to będzie pojawiało się w różnych miejscach, prawie całkowicie dla celów diagnostycznych. Spróbuj wybrać coś co będzie pomocne w takiej sytuacji! ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int tp_basicsize, tp_itemsize; /* For allocation */</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int tp_basicsize, tp_itemsize; /* Dla umieszczania w pamięci */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These fields tell the runtime how much memory to allocate when new objects of this type are created.  Python has some built-in support for variable length structures (think: strings, lists) which is where the :attr:`tp_itemsize` field comes in.  This will be dealt with later. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te pola mówią dla programu uruchomionego jak dużo pamięci przeznaczyć kiedy nowe przedmioty tego typu są tworzone. Język pytonowski ma pewne wbudowane wsparcie dla różnej długości struktur (mam na myśli: ciągi znaków, listy) które jest tam, gdzie pole :attr:`tp_itemsize` pojawia się. Tym zajmiemy się później. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>char *tp_doc;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>char *tp_doc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can put a string (or its address) that you want returned when the Python script references ``obj.__doc__`` to retrieve the doc string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu możesz wstawić ciąg znaków (lub jego adres) który chcesz zwrócić gdy skrypt języka pytonowskiego odnosi się do ``obj.__doc__`` aby otrzymać ciąg znaków dokumentacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we come to the basic type methods---the ones most extension types will implement.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>A teraz dochodzimy do podstawowego typu sposobów postępowania---te których większość typów rozszerzeń będzie wypełniać.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finalization and De-allocation</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Finalizowanie i Zwalnianie-miejsca</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>destructor tp_dealloc;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>destructor tp_dealloc;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is called when the reference count of the instance of your type is reduced to zero and the Python interpreter wants to reclaim it.  If your type has memory to free or other clean-up to perform, put it here.  The object itself needs to be freed here as well.  Here is an example of this function::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest wywoływane gdy liczba odniesień przykładu twojego typu jest zredukowana do zera i program interpretujący polecenia języka pytonowskiego chce przejąć je na powrót. Jeśli twój typ ma pamięć do zwolnienia lub inne czyszczenie do wykonania, wstaw je tutaj. Przedmiot sam potrzebuje być zwolniony także tutaj. Tu jest przykład tego zadania::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static void newdatatype_dealloc(newdatatypeobject * obj) {     free(obj-&gt;obj_UnderlyingDatatypePtr);     Py_TYPE(obj)-&gt;tp_free(obj); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static void newdatatype_dealloc(newdatatypeobject * obj) {     free(obj-&gt;obj_UnderlyingDatatypePtr);     Py_TYPE(obj)-&gt;tp_free(obj); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One important requirement of the deallocator function is that it leaves any pending exceptions alone.  This is important since deallocators are frequently called as the interpreter unwinds the Python stack; when the stack is unwound due to an exception (rather than normal returns), nothing is done to protect the deallocators from seeing that an exception has already been set.  Any actions which a deallocator performs which may cause additional Python code to be executed may detect that an exception has been set.  This can lead to misleading errors from the interpreter.  The proper way to protect against this is to save a pending exception before performing the unsafe action, and restoring it when done.  This can be done using the :cfunc:`PyErr_Fetch` and :cfunc:`PyErr_Restore` functions::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednym istotnym wymaganiem zadania zwalniania pamięci jest to, że pozostawia jakiekolwiek oczekujące wyjątki same sobie. To jest istotne odkąd zadania zwalniające pamięć są często wywoływane gdy program interpretujący odwija stertę programu interpretującego polecenia języka pytonowskiego; gdy sterta jest odwinięta z powodu wyjątku (zamiast normalnych powrotów), nic nie jest robione aby bronić zadania uwalniające miejsca w pamięci przed zobaczeniem że wyjątek już został zgłoszony. Jakiekolwiek akcje które zadanie zwalniania pamięci wykonają które mogą spowodować wykonanie dodatkowego kodu języka pytonowskiego mogą wykryć że wyjątek został ustawiony. To może prowadzić do wprowadzających zamieszanie błędów ze strony programu interpretującego. Właściwą drogą aby bronić się przeciwko temu jest zapamiętać oczekujący wyjątek przed wykonaniem niebezpiecznego działania, a potem odtworzyć je gdy się skończy to ostatnie. To może być wykonywane używając zadań :cfunc:`PyErr_Fetch` i :cfunc:`PyErr_Restore`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static void my_dealloc(PyObject *obj) {     MyObject *self = (MyObject *) obj;     PyObject *cbresult;      if (self-&gt;my_callback != NULL) {         PyObject *err_type, *err_value, *err_traceback;         int have_error = PyErr_Occurred() ? 1 : 0;          if (have_error)             PyErr_Fetch(&amp;err_type, &amp;err_value, &amp;err_traceback);          cbresult = PyObject_CallObject(self-&gt;my_callback, NULL);         if (cbresult == NULL)             PyErr_WriteUnraisable(self-&gt;my_callback);         else             Py_DECREF(cbresult);          if (have_error)             PyErr_Restore(err_type, err_value, err_traceback);          Py_DECREF(self-&gt;my_callback);     }     Py_TYPE(obj)-&gt;tp_free((PyObject*)self); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static void my_dealloc(PyObject *obj) {     MyObject *self = (MyObject *) obj;     PyObject *cbresult;      if (self-&gt;my_callback != NULL) {         PyObject *err_type, *err_value, *err_traceback;         int have_error = PyErr_Occurred() ? 1 : 0;          if (have_error)             PyErr_Fetch(&amp;err_type, &amp;err_value, &amp;err_traceback);          cbresult = PyObject_CallObject(self-&gt;my_callback, NULL);         if (cbresult == NULL)             PyErr_WriteUnraisable(self-&gt;my_callback);         else             Py_DECREF(cbresult);          if (have_error)             PyErr_Restore(err_type, err_value, err_traceback);          Py_DECREF(self-&gt;my_callback);     }     Py_TYPE(obj)-&gt;tp_free((PyObject*)self); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object Presentation</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Prezentacja Przedmiotów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Python, there are two ways to generate a textual representation of an object: the :func:`repr` function, and the :func:`str` function.  (The :func:`print` function just calls :func:`str`.)  These handlers are both optional.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w języku pytonowskim, istnieją dwa sposoby aby wygenerować tekstową reprezentację przedmiotu: zadanie :func:`repr`, i zadanie :func:`str`. (Zadanie :func:`print` po prostu wywołuje zadanie :func:`str`.) Ta zadania obsługi są oba opcjonalne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>reprfunc tp_repr; reprfunc tp_str;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>reprfunc tp_repr; reprfunc tp_str;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_repr` handler should return a string object containing a representation of the instance for which it is called.  Here is a simple example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania obsługi :attr:`tp_repr` powinien zwrócić przedmiot ciągu znaków zawierający reprezentację przykładu dla którego został wywołany. Tu jest prosty przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * newdatatype_repr(newdatatypeobject * obj) {     return PyString_FromFormat("Repr-ified_newdatatype{{size:\%d}}",                                obj-&gt;obj_UnderlyingDatatypePtr-&gt;size); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * newdatatype_repr(newdatatypeobject * obj) {     return PyString_FromFormat("Repr-ified_newdatatype{{size:\%d}}",                                obj-&gt;obj_UnderlyingDatatypePtr-&gt;size); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no :attr:`tp_repr` handler is specified, the interpreter will supply a representation that uses the type's :attr:`tp_name` and a uniquely-identifying value for the object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli żadna :attr:`tp_repr` obsługa nie jest określona, program interpretujący polecenia języka pytonowskiego dostarczy reprezentację, która używa :attr:`tp_name` należącego do typu i jednoznacznie-identyfikującą wartość dla przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_str` handler is to :func:`str` what the :attr:`tp_repr` handler described above is to :func:`repr`; that is, it is called when Python code calls :func:`str` on an instance of your object.  Its implementation is very similar to the :attr:`tp_repr` function, but the resulting string is intended for human consumption.  If :attr:`tp_str` is not specified, the :attr:`tp_repr` handler is used instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługa :attr:`tp_str` jest dla zadania :func:`str` tym, czym obsługa :attr:`tp_repr` opisywana powyżej dla zadania :func:`repr`; to jest, jest wzywana gdy kod języka pytonowskiego wywołuje :func:`str` na przykładzie twojego przedmiotu. Jego wypełnienie jest bardzo podobne do zadania :attr:`tp_repr`, ale wynikający ciąg znaków jest przeznaczony do przeczytania dla człowieka. Jeśli :attr:`tp_str` jest nieokreślona, obsługa :attr:`tp_repr` jest używana zamiast tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a simple example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest prosty przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * newdatatype_str(newdatatypeobject * obj) {     return PyString_FromFormat("Stringified_newdatatype{{size:\%d}}",                                obj-&gt;obj_UnderlyingDatatypePtr-&gt;size); }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * newdatatype_str(newdatatypeobject * obj) {     return PyString_FromFormat("Stringified_newdatatype{{size:\%d}}",                                obj-&gt;obj_UnderlyingDatatypePtr-&gt;size); }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute Management</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zarządzanie własnościami</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every object which can support attributes, the corresponding type must provide the functions that control how the attributes are resolved.  There needs to be a function which can retrieve attributes (if any are defined), and another to set attributes (if setting attributes is allowed).  Removing an attribute is a special case, for which the new value passed to the handler is *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla każdego przedmiotu który może wspierać własności, odpowiadający typ musi dostarczać zadań które kontrolują jak właściwości są rozwiązywane. Potrzebne jest zadanie, które może przechwytywać właściwości (jeśli jakiekolwiek są określone), i następny, aby ustawiać właściwości (jeśli ustawianie właściwości jest dozwolone). Usunięcie właściwości jest szczególnym przypadkiem, dla którego nowa wartość przekazywana do obsługi jest *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python supports two pairs of attribute handlers; a type that supports attributes only needs to implement the functions for one pair.  The difference is that one pair takes the name of the attribute as a :ctype:`char\*`, while the other accepts a :ctype:`PyObject\*`.  Each type can use whichever pair makes more sense for the implementation's convenience. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski wspiera dwie pary zadań obsługujących właściwości; typ który wspiera właściwości potrzebuje tylko wypełnić zadania dla jednej pary. Różnica polega na tym, że jedna para przyjmuje nazwę właściwości jako :ctype:`char\*`, podczas gdy inne akceptują :ctype:`PyObject\*`. Każdy typ może użyć którejkolwiek z par, która ma więcej sensu dla możliwego wypełnienia. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getattrfunc  tp_getattr;        /* char * version */ setattrfunc  tp_setattr; /* ... */ getattrofunc tp_getattro;       /* PyObject * version */ setattrofunc tp_setattro;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>getattrfunc  tp_getattr;        /* wersja char * */ setattrfunc  tp_setattr; /* ... */ getattrofunc tp_getattro;       /* wersja PyObject * */ setattrofunc tp_setattro;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If accessing attributes of an object is always a simple operation (this will be explained shortly), there are generic implementations which can be used to provide the :ctype:`PyObject\*` version of the attribute management functions. The actual need for type-specific attribute handlers almost completely disappeared starting with Python 2.2, though there are many examples which have not been updated to use some of the new generic mechanism that is available.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli dostawanie dostępu do własności przedmiotu jest zawsze prostą operacją (to zostanie wyjaśnione niedługo), to istnieją proste wypełnienia, które mogą być użyte aby dostarczyć wersję :ctype:`PyObject\*` zadań zarządzających własnościami. Właściwa potrzeba dla szczególnego-dla-typu zadania obsługi własności prawie przestała istnieć poczynając od języka pytonowskiego w wersji 2.2, chociaż istnieje wiele przykładów, które nie zostały uaktualnione do używania nowego zastępczego mechanizmu chociaż jest on dostępny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generic Attribute Management</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zastępcze zarządzanie właściwościami</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most extension types only use *simple* attributes.  So, what makes the attributes simple?  There are only a couple of conditions that must be met:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość typów rozszerzeń używa tylko *prostych* właściwości. Więc, co sprawia że właściwości są proste? Istnieje tylko kilka warunków które należy spełnić:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the attributes must be known when :cfunc:`PyType_Ready` is called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa właściwości musi być znana gdy zadanie :cfunc:`PyType_Ready` jest wzywane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No special processing is needed to record that an attribute was looked up or set, nor do actions need to be taken based on the value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Żadne szczególne przetwarzanie nie jest potrzebne aby zarejestrować, że właściwość została pobrana lub ustawiona, ani też działania nie muszą być podejmowane w oparciu o wartość.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this list does not place any restrictions on the values of the attributes, when the values are computed, or how relevant data is stored.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że ta lista nie umieszcza żadnych ograniczeń na wartościach właściwości, gdy wartości są obliczane, lub jak istotne dane są przechowywane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :cfunc:`PyType_Ready` is called, it uses three tables referenced by the type object to create :term:`descriptor`\s which are placed in the dictionary of the type object.  Each descriptor controls access to one attribute of the instance object.  Each of the tables is optional; if all three are *NULL*, instances of the type will only have attributes that are inherited from their base type, and should leave the :attr:`tp_getattro` and :attr:`tp_setattro` fields *NULL* as well, allowing the base type to handle attributes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy zadanie :cfunc:`PyType_Ready` jest wywoływane, używa trzech tabeli określonych przez przedmiot typu aby tworzyć :term:`element opisujący`\e które są umieszczane w słowniku typu przedmiotu. Każdy element opisujący kontroluje dostęp do jednej właściwości przykładu przedmiotu. Każda z tabel jest opcjonalna; jeśli wszystkie trzy są *NULL*, przykłady typu będą miały właściwości, które są dziedziczone z ich typu bazowego, i powinny pozostawić pola :attr:`tp_getattro` i :attr:`tp_setattro` na *NULL* zarówno, pozwalając aby typ bazowy obsługiwał właściwości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The tables are declared as three fields of the type object::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tabele są zadeklarowane jako trzy pola przedmiotu typu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members; struct PyGetSetDef *tp_getset;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members; struct PyGetSetDef *tp_getset;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If :attr:`tp_methods` is not *NULL*, it must refer to an array of :ctype:`PyMethodDef` structures.  Each entry in the table is an instance of this structure::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli :attr:`tp_methods` nie jest *NULL*, wtedy musi odnosić się do tabeli struktur :ctype:`PyMethodDef`. Każdy wpis w tabeli jest przykładem tej struktury::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct PyMethodDef {     char        *ml_name;       /* method name */     PyCFunction  ml_meth;       /* implementation function */     int          ml_flags;      /* flags */     char        *ml_doc;        /* docstring */ } PyMethodDef;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct PyMethodDef {     char        *ml_name;       /* nazwa sposobu postępowania */     PyCFunction  ml_meth;       /* zadanie wypełnienia */     int          ml_flags;      /* flagi */     char        *ml_doc;        /* ciąg dokumentacji */ } PyMethodDef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One entry should be defined for each method provided by the type; no entries are needed for methods inherited from a base type.  One additional entry is needed at the end; it is a sentinel that marks the end of the array.  The :attr:`ml_name` field of the sentinel must be *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeden wpis powinien być określony dla każdego sposobu postępowania dostarczonego przez typ; żadne wpisy nie są potrzebne dla sposobów postępowania odziedziczonych z typu bazowego. Jeden dodatkowy wpis jest konieczny na końcu; jest to ochroniarz który oznacza koniec tabeli. Pole :attr:`ml_name` ochroniarza musi być *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XXX Need to refer to some unified discussion of the structure fields, shared with the next section.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>XXX Potrzeba odniesienia do pewnych systematycznych dyskusji pól struktury, dzielonych z następną sekcją.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second table is used to define attributes which map directly to data stored in the instance.  A variety of primitive C types are supported, and access may be read-only or read-write.  The structures in the table are defined as::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Druga tabela jest używana aby określać właściwości które odnoszą się bezpośrednio do danych przechowywanych w przykładzie. Różnorodne podstawowe typy C są wspierane, i dostęp może być albo tylko-do-odczytu lub odczyt-i-zapis. Struktury w tabeli są określone jako::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct PyMemberDef {     char *name;     int   type;     int   offset;     int   flags;     char *doc; } PyMemberDef;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct PyMemberDef {     char *name;     int   type;     int   offset;     int   flags;     char *doc; } PyMemberDef;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each entry in the table, a :term:`descriptor` will be constructed and added to the type which will be able to extract a value from the instance structure.  The :attr:`type` field should contain one of the type codes defined in the :file:`structmember.h` header; the value will be used to determine how to convert Python values to and from C values.  The :attr:`flags` field is used to store flags which control how the attribute can be accessed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla każdego wpisu w tabeli, zostanie skonstruowany :term:`element opisujący` - z ang. - :term:`descriptor` i dodany do typu, który będzie mógł wydobyć wartość ze struktury przykładu. Pole :attr:`type` powinno zawierać jeden z kodów typu określonych w nagłówku :file:`structmember.h`; wartość będzie użyta do określenia jak zamienić wartości języka pytonowskiego z i na wartości C. Pole :attr:`flags` jest używane do przechowywania flag które kontrolują, jak można uzyskać dostęp do właściwości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XXX Need to move some of this to a shared section!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>XXX Potrzeba przełożyć część z tego do współdzielonego rozdziału!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following flag constants are defined in :file:`structmember.h`; they may be combined using bitwise-OR.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące stałe flag są określone w pliku :file:`structmember.h`; mogą złączone przy użyciu bitowego-LUB.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constant</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stała</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Meaning</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Znaczenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:const:`READONLY`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:const:`READONLY`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Never writable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nigdy nie do wpisywania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:const:`READ_RESTRICTED`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:const:`READ_RESTRICTED`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not readable in restricted mode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie do czytania w trybie z ograniczeniami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:const:`WRITE_RESTRICTED`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:const:`WRITE_RESTRICTED`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not writable in restricted mode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie do pisania w trybie z ograniczeniami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:const:`RESTRICTED`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:const:`RESTRICTED`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not readable or writable in restricted mode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie do czytania ani pisania w trybie z ograniczeniami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interesting advantage of using the :attr:`tp_members` table to build descriptors that are used at runtime is that any attribute defined this way can have an associated doc string simply by providing the text in the table.  An application can use the introspection API to retrieve the descriptor from the class object, and get the doc string using its :attr:`__doc__` attribute.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Interesującą zaletą używania tabeli :attr:`tp_members` do budowania elementów opisujących ( - z ang. - descriptors), które są używane w czasie wykonania programu jest to, że jakiekolwiek właściwości określone w ten sposób mogą mieć dołączony ciąg znaków dokumentacji po prostu przez dostarczenie tekstu w tabeli. Aplikacja może używać sprzęgu wglądu wewnętrznego aby odbierać element opisujący z przedmiotu uogólnienia, i pobierać ciąg znaków używając jego właściwości :attr:`__doc__`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the :attr:`tp_methods` table, a sentinel entry with a :attr:`name` value of *NULL* is required.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak, jak w tabeli :attr:`tp_methods`, wpis ochroniarza z właściwością :attr:`name` o wartości *NULL* jest wymagany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-specific Attribute Management</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Szczególne-dla-typu-przedmiotu zarządzanie właściwościami</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For simplicity, only the :ctype:`char\*` version will be demonstrated here; the type of the name parameter is the only difference between the :ctype:`char\*` and :ctype:`PyObject\*` flavors of the interface. This example effectively does the same thing as the generic example above, but does not use the generic support added in Python 2.2.  It explains how the handler functions are called, so that if you do need to extend their functionality, you'll understand what needs to be done.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla prostoty, tylko wersja :ctype:`char\*` będzie zademonstrowana tutaj; typ parametru nazwy jest jedyną różnicą pomiędzy odcieniami sprzęgu :ctype:`char\*` i :ctype:`PyObject\*`. Ten przykład efektywnie czyni tę samą rzecz, jak zastępcze przykłady powyżej, ale nie używa zastępczego wsparcia dodanego w wersji języka pytonowskiego 2.2. To wyjaśnia, jak zadania obsługi są wywoływane, tak że jeśli potrzebujesz rozszerzyć ich możliwości, będziesz rozumiał co trzeba zrobić.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_getattr` handler is called when the object requires an attribute look-up.  It is called in the same situations where the :meth:`__getattr__` method of a class would be called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania obsługi właściwości :attr:`tp_getattr` jest wzywany gdy przedmiot wymaga podejrzenia wartości właściwości. Jest wzywany w tych samych sytuacjach, gdzie sposób postępowania :meth:`__getattr__` byłoby wezwane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * newdatatype_getattr(newdatatypeobject *obj, char *name) {     if (strcmp(name, "data") == 0)     {         return PyInt_FromLong(obj-&gt;data);     }      PyErr_Format(PyExc_AttributeError,                  "'%.50s' object has no attribute '%.400s'",                  tp-&gt;tp_name, name);     return NULL; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * newdatatype_getattr(newdatatypeobject *obj, char *name) {     if (strcmp(name, "data") == 0)     {         return PyInt_FromLong(obj-&gt;data);     }      PyErr_Format(PyExc_AttributeError,                  "'%.50s' przedmiot nie ma właściwości '%.400s'",                  tp-&gt;tp_name, name);     return NULL; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_setattr` handler is called when the :meth:`__setattr__` or :meth:`__delattr__` method of a class instance would be called.  When an attribute should be deleted, the third parameter will be *NULL*.  Here is an example that simply raises an exception; if this were really all you wanted, the :attr:`tp_setattr` handler should be set to *NULL*. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługa właściwości :attr:`tp_setattr` jest wywoływana gdy sposoby postępowania :meth:`__setattr__` lub :meth:`__delattr__` przykładu uogólnienia byłyby wzywane. Gdy właściwość powinna być skasowana, trzeci parametr będzie *NULL*. Tutaj jest przykład, który prosto wywołuje wyjątek; jeśli to byłoby wszystkim czego potrzebujesz, obsługa :attr:`tp_setattr` powinna być ustawiona na *NULL*. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v) {     (void)PyErr_Format(PyExc_RuntimeError, "Read-only attribute: \%s", name);     return -1; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v) {     (void)PyErr_Format(PyExc_RuntimeError, "właściwość tylko-do-odczytu: \%s", name);     return -1; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object Comparison</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Porównywanie przedmiotów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>richcmpfunc tp_richcompare;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>richcmpfunc tp_richcompare;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :attr:`tp_richcompare` handler is called when comparisons are needed.  It is analogous to the :ref:`rich comparison methods &lt;richcmpfuncs&gt;`, like :meth:`__lt__`, and also called by :cfunc:`PyObject_RichCompare` and :cfunc:`PyObject_RichCompareBool`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sposób postępowania obsługi :attr:`tp_richcompare` jest wywoływany gdy porównania są oczekiwane. Jest to analogiczne z :ref:`sposobami postępowania bogatego porównywania &lt;richcmpfuncs&gt;` - z ang. - :ref:`rich comparison methods &lt;richcmpfuncs&gt;`, jak :meth:`__lt__` i także wzywane przez :cfunc:`PyObject_RichCompare` i :cfunc:`PyObject_RichCompareBool`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is called with two Python objects and the operator as arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, ``Py_GT``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with respect to the specified operator and return ``Py_True`` or ``Py_False`` if the comparison is successfull, ``Py_NotImplemented`` to indicate that comparison is not implemented and the other object's comparison method should be tried, or *NULL* if an exception was set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest wzywane z dwoma przedmiotami języka pytonowskiego i operatorem jako parametrami, gdzie operator jest jednym z ``Py_EQ``, ``Py_NE``, ``Py_LE``, ``Py_GT``, ``Py_LT`` lub ``Py_GT``. Powinno porównywać dwa przedmioty z uwzględnieniem wyszczególnionego operatora i zwracać ``Py_True`` lub ``Py_False`` jeśli porównanie jest udane, ``Py_NotImplemented`` aby zaznaczyć że porównanie nie jest wypełnione i że inny sposób porównania przedmiotów powinien być wypróbowany, lub *NULL* jeśli wyjątek został ustawiony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a sample implementation, for a datatype that is considered equal if the size of an internal pointer is equal::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest przykładowe wypełnienie, dla typu danych który jest uznawany za równy, jeśli rozmiar wewnętrznego wskaźnika jest równy::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static int newdatatype_richcmp(PyObject *obj1, PyObject *obj2, int op) {     PyObject *result;     int c, size1, size2;      /* code to make sure that both arguments are of type        newdatatype omitted */      size1 = obj1-&gt;obj_UnderlyingDatatypePtr-&gt;size;     size2 = obj2-&gt;obj_UnderlyingDatatypePtr-&gt;size;      switch (op) {     case Py_LT: c = size1 &lt;  size2; break;     case Py_LE: c = size1 &lt;= size2; break;     case Py_EQ: c = size1 == size2; break;     case Py_NE: c = size1 != size2; break;     case Py_GT: c = size1 &gt;  size2; break;     case Py_GE: c = size1 &gt;= size2; break;     }     result = c ? Py_True : Py_False;     Py_INCREF(result);     return result;  }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static int newdatatype_richcmp(PyObject *obj1, PyObject *obj2, int op) {     PyObject *result;     int c, size1, size2;      /* kod do upewnienia się że oba parametry są typu        newdatatype pominięty */      size1 = obj1-&gt;obj_UnderlyingDatatypePtr-&gt;size;     size2 = obj2-&gt;obj_UnderlyingDatatypePtr-&gt;size;      switch (op) {     case Py_LT: c = size1 &lt;  size2; break;     case Py_LE: c = size1 &lt;= size2; break;     case Py_EQ: c = size1 == size2; break;     case Py_NE: c = size1 != size2; break;     case Py_GT: c = size1 &gt;  size2; break;     case Py_GE: c = size1 &gt;= size2; break;     }     result = c ? Py_True : Py_False;     Py_INCREF(result);     return result;  }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abstract Protocol Support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie protokołu abstrakcyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python supports a variety of *abstract* 'protocols;' the specific interfaces provided to use these interfaces are documented in :ref:`abstract`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski wspiera różne *abstrakcyjne* 'protokoły;' szczegółowe sprzęgi dostarczone do użycia tych sprzęgów są udokumentowane w :ref:`abstract` - z ang. - :ref:`abstrakt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A number of these abstract interfaces were defined early in the development of the Python implementation.  In particular, the number, mapping, and sequence protocols have been part of Python since the beginning.  Other protocols have been added over time.  For protocols which depend on several handler routines from the type implementation, the older protocols have been defined as optional blocks of handlers referenced by the type object.  For newer protocols there are additional slots in the main type object, with a flag bit being set to indicate that the slots are present and should be checked by the interpreter.  (The flag bit does not indicate that the slot values are non-*NULL*. The flag may be set to indicate the presence of a slot, but a slot may still be unfilled.) ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pewna część z tych abstrakcyjnych sprzęgów została zdefiniowana wcześnie w czasie tworzenia wypełnienia języka pytonowskiego. W szczególności protokoły liczbowy, mapowania i sekwencyjny były częścią języka pytonowskiego od początku. Inne protokoły były dodawane później. Dla protokołów, które zależą od kilku sposobów postępowania z wypełnienia typu, starsze protokoły zostały zdefiniowane jako opcjonalne bloki uchwytów obsługi do których odnosi się przedmiot typu. Dla nowszych protokołów istnieją dodatkowe gniazda w głównym przedmiocie typu, z bitem flagi ustawionym aby wskazywać że gniazda są obecne i powinny być sprawdzane przez program interpretujący polecenia języka pytonowskiego. (Bit flagi nie wskazuje, że wartości gniazd są niepuste - (non-*NULL*). Flaga może zostać ustawiona aby wskazać obecność gniazda, ale gniazdo wciąż może być niezapełnione.) ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyNumberMethods   tp_as_number; PySequenceMethods tp_as_sequence; PyMappingMethods  tp_as_mapping;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyNumberMethods   tp_as_number; PySequenceMethods tp_as_sequence; PyMappingMethods  tp_as_mapping;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish your object to be able to act like a number, a sequence, or a mapping object, then you place the address of a structure that implements the C type :ctype:`PyNumberMethods`, :ctype:`PySequenceMethods`, or :ctype:`PyMappingMethods`, respectively. It is up to you to fill in this structure with appropriate values. You can find examples of the use of each of these in the :file:`Objects` directory of the Python source distribution. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli wolisz aby twój przedmiot był w stanie działać jak liczba, sekwencja, lub przedmiot mapujący, wtedy umieszczasz adres struktury która wypełnia zadania typu C :ctype:`PyNumberMethods`, :ctype:`PySequenceMethods`, lub :ctype:`PyMappingMethods`, odpowiednio. To już zależy od Ciebie, aby wypełnić tą strukturę odpowiednimi wartościami. Można znaleźć przykłady użycia każdego z tych w katalogu :file:`Objects` dystrybucji źródłowej języka pytonowskiego. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hashfunc tp_hash;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>hashfunc tp_hash;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function, if you choose to provide it, should return a hash number for an instance of your data type. Here is a moderately pointless example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie, jeśli wybierzesz aby je dostarczyć, powinno zwrócić numer hash dla przykładu twojego typu danych. Tu jest umiarkowanie bezużyteczny przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static long newdatatype_hash(newdatatypeobject *obj) {     long result;     result = obj-&gt;obj_UnderlyingDatatypePtr-&gt;size;     result = result * 3;     return result; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static long newdatatype_hash(newdatatypeobject *obj) {     long result;     result = obj-&gt;obj_UnderlyingDatatypePtr-&gt;size;     result = result * 3;     return result; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ternaryfunc tp_call;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ternaryfunc tp_call;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is called when an instance of your data type is "called", for example, if ``obj1`` is an instance of your data type and the Python script contains ``obj1('hello')``, the :attr:`tp_call` handler is invoked.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest wzywane gdy przykład twojego typu danych jest "wzywany", dla przykładu, jeśli ``obj1`` jest przykładem twojego typu danych i skrypt języka pytonowskiego zawiera ``obj1('hello')``, uchwyt obsługi :attr:`tp_call` jest wywoływany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function takes three arguments:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie pobiera trzy parametry:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*arg1* is the instance of the data type which is the subject of the call. If the call is ``obj1('hello')``, then *arg1* is ``obj1``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*arg1* jest przykładem typu danych który jest przedmiotem wywołania. Jeśli wywołanie jest ``obj1('hello')``, wtedy *arg1* jest ``obj1``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*arg2* is a tuple containing the arguments to the call.  You can use :cfunc:`PyArg_ParseTuple` to extract the arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*arg2* jest krotką zawierającą parametry wywołania. Można użyć :cfunc:`PyArg_ParseTuple` aby wydobyć parametry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*arg3* is a dictionary of keyword arguments that were passed. If this is non-*NULL* and you support keyword arguments, use :cfunc:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want to support keyword arguments and this is non-*NULL*, raise a :exc:`TypeError` with a message saying that keyword arguments are not supported.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*arg3* jest słownikiem parametrów słów kluczowych które zostały przekazane. Jeśli to jest niepuste ( - z ang. - non-*NULL*) a ty wspierasz parametry słów kluczowych, użyj :cfunc:`PyArg_ParseTupleAndKeywords` aby wydobyć parametry. Jeśli nie chcesz wspierać parametrów słów kluczowych i to jest niepuste (non-*NULL*), zgłoś :exc:`TypeError` z wiadomością mówiącą że parametry słów kluczowych nie są wspierane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a desultory example of the implementation of the call function. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest niepełny przykład wypełnienia wywołania zadania. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* Implement the call function.  *    obj1 is the instance receiving the call.  *    obj2 is a tuple containing the arguments to the call, in this  *         case 3 strings.  */ static PyObject * newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *other) {     PyObject *result;     char *arg1;     char *arg2;     char *arg3;      if (!PyArg_ParseTuple(args, "sss:call", &amp;arg1, &amp;arg2, &amp;arg3)) {         return NULL;     }     result = PyString_FromFormat(         "Returning -- value: [\%d] arg1: [\%s] arg2: [\%s] arg3: [\%s]\n",         obj-&gt;obj_UnderlyingDatatypePtr-&gt;size,         arg1, arg2, arg3);     printf("\%s", PyString_AS_STRING(result));     return result; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>/* Wypełnienie zadania wywołania.  *    obj1 jest przykładem otrzymującym wywołanie.  *    obj2 jest krotką zawierającą parametry wywołania, w tym przypadku 3 ciągi znaków.  */ static PyObject * newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *other) {     PyObject *result;     char *arg1;     char *arg2;     char *arg3;      if (!PyArg_ParseTuple(args, "sss:call", &amp;arg1, &amp;arg2, &amp;arg3)) {         return NULL;     }     result = PyString_FromFormat(         "Powrotne -- wartość: [\%d] arg1: [\%s] arg2: [\%s] arg3: [\%s]\n",         obj-&gt;obj_UnderlyingDatatypePtr-&gt;size,         arg1, arg2, arg3);     printf("\%s", PyString_AS_STRING(result));     return result; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XXX some fields need to be added here... ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>XXX niektóre pola powinny być tu dodane... ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>/* Iteratory */ getiterfunc tp_iter; iternextfunc tp_iternext;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These functions provide support for the iterator protocol.  Any object which wishes to support iteration over its contents (which may be generated during iteration) must implement the ``tp_iter`` handler.  Objects which are returned by a ``tp_iter`` handler must implement both the ``tp_iter`` and ``tp_iternext`` handlers. Both handlers take exactly one parameter, the instance for which they are being called, and return a new reference.  In the case of an error, they should set an exception and return *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te zadania dostarczają wsparcia dla protokołu iteratora. Każdy przedmiot który chce wspierać iterację po swojej zawartości (która może być tworzona w czasie iteracji) musi wypełnić uchwyt obsługi ``tp_iter``. Przedmioty, które są zwracane przez obsługę ``tp_iter`` muszą wypełniać uchwyty obsługi zarówno ``tp_iter``, jak i ``tp_iternext``. Oba uchwyty obsługi pobierają dokładnie jeden parametr, przykład dla którego zostały wywołane, i zwracają nowe odniesienie. W przypadku błędu, powinny ustawiać wyjątek i zwracać *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For an object which represents an iterable collection, the ``tp_iter`` handler must return an iterator object.  The iterator object is responsible for maintaining the state of the iteration.  For collections which can support multiple iterators which do not interfere with each other (as lists and tuples do), a new iterator should be created and returned.  Objects which can only be iterated over once (usually due to side effects of iteration) should implement this handler by returning a new reference to themselves, and should also implement the ``tp_iternext`` handler.  File objects are an example of such an iterator.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przedmiotu który reprezentuje możliwą do iterowania kolekcję, uchwyt obsługi ``tp_iter`` musi zwracać przedmiot iterujący. Przedmiot iterujący jest odpowiedzialny za utrzymywanie stanu iteracji. Dla kolekcji które mogą wspierać wiele przedmiotów iterujących, które nie nachodzą na siebie (tak jak listy i krotki), nowy przedmiot iterujący powinien być utworzony i zwrócony. Przedmioty które mogą tylko być iterowane raz (zwykle z powodu efektów ubocznych iteracji) powinny wypełniać ten uchwyt obsługi, przez zwrócenie nowego odniesienia do nich samych i powinny także wypełniać uchwyt obsługi ``tp_iternext``. Przedmioty pliku są przykładami takich przedmiotów iterujących.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Iterator objects should implement both handlers.  The ``tp_iter`` handler should return a new reference to the iterator (this is the same as the ``tp_iter`` handler for objects which can only be iterated over destructively).  The ``tp_iternext`` handler should return a new reference to the next object in the iteration if there is one.  If the iteration has reached the end, it may return *NULL* without setting an exception or it may set :exc:`StopIteration`; avoiding the exception can yield slightly better performance.  If an actual error occurs, it should set an exception and return *NULL*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty iterujące powinny wypełniać oba uchwyty obsługujące. Uchwyt obsługi ``tp_iter`` powinien zwracać nowe odniesienie do przedmiotu iterującego (to jest tak samo jak dla uchwytu obsługi ``tp_iter`` dla przedmiotów, które mogą tylko iterować destrukcyjnie). Uchwyt obsługi ``tp_iternext`` powinien zwracać nowe odniesienie do następnego przedmiotu w iteracji jeśli jest taki. Jeśli iteracja dobiegła końca, może zwrócić *NULL* bez ustawiania wyjątku lub może ustawić wyjątek :exc:`StopIteration`; pominięcie wyjątku może dawać nieco lepsze wyniki czasu działania. Jeśli właściwe błędy nastąpią, powinno się ustawić wyjątek i zwrócić *NULL*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Weak Reference Support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla słabych odniesień</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the goals of Python's weak-reference implementation is to allow any type to participate in the weak reference mechanism without incurring the overhead on those objects which do not benefit by weak referencing (such as numbers).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednym z celów wypełnienia słabych odniesień języka pytonowskiego jest pozwolenie aby jakikolwiek typ brał udział w mechanizmie słabych odniesień bez powodowania nadwyżki obliczeń na tych przedmiotach które nie korzystają ze słabych odniesień (takich jak liczby).  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For an object to be weakly referencable, the extension must include a :ctype:`PyObject\*` field in the instance structure for the use of the weak reference mechanism; it must be initialized to *NULL* by the object's constructor.  It must also set the :attr:`tp_weaklistoffset` field of the corresponding type object to the offset of the field. For example, the instance type is defined with the following structure::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przedmiotu aby można było słabo się do niego odnieść, rozszerzenie musi zawierać pole :ctype:`PyObject\*` w strukturze przykładu dla użycia mechanizmu słabych odniesień; musi być zainicjowane na *NULL* przez konstruktor przedmiotu. Musi też ustawiać pole :attr:`tp_weaklistoffset` odpowiadającego przedmiotu typu na przesunięcie względne pola. Dla przykładu, typ przykładu jest określony z następującą strukturą::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>typedef struct {     PyObject_HEAD     PyClassObject *in_class;       /* The class object */     PyObject      *in_dict;        /* A dictionary */     PyObject      *in_weakreflist; /* List of weak references */ } PyInstanceObject;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typedef struct {     PyObject_HEAD     PyClassObject *in_class;       /* Przedmiot uogólnienia */     PyObject      *in_dict;        /* Słownik */     PyObject      *in_weakreflist; /* Lista słabych odniesień */ } PyInstanceObject;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The statically-declared type object for instances is defined this way::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Statycznie-określony typ przedmiotu dla przykładów jest określony w ten sposób::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PyTypeObject PyInstance_Type = {     PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)     0,     "module.instance",      /* Lots of stuff omitted for brevity... */      Py_TPFLAGS_DEFAULT,                         /* tp_flags */     0,                                          /* tp_doc */     0,                                          /* tp_traverse */     0,                                          /* tp_clear */     0,                                          /* tp_richcompare */     offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */ };</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>PyTypeObject PyInstance_Type = {     PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)     0,     "module.instance",      /* Mnóstwo rzeczy pominięte dla skrótowości... */      Py_TPFLAGS_DEFAULT,                         /* tp_flags */     0,                                          /* tp_doc */     0,                                          /* tp_traverse */     0,                                          /* tp_clear */     0,                                          /* tp_richcompare */     offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */ };</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The type constructor is responsible for initializing the weak reference list to *NULL*::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor jest odpowiedzialny za zainicjowanie listy słabych odniesień na *NULL*::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static PyObject * instance_new() {     /* Other initialization stuff omitted for brevity */      self-&gt;in_weakreflist = NULL;      return (PyObject *) self; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static PyObject * instance_new() {     /* Inne sprawy inicjowania pominięte dla skrótowości */      self-&gt;in_weakreflist = NULL;      return (PyObject *) self; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only further addition is that the destructor needs to call the weak reference manager to clear any weak references.  This should be done before any other parts of the destruction have occurred, but is only required if the weak reference list is non-*NULL*::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedyny dalszy dodatek jest tym że destruktor potrzebuje wezwać zarządcę słabych odniesień aby wyczyścił jakiekolwiek słabe odniesienia. To powinno być zrobione przed tym jak jakiekolwiek inne części destrukcji nastąpiły, ale jest wymagane tylko jeśli lista słabych odniesień jest nie pusta - z ang. - non-*NULL*::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>static void instance_dealloc(PyInstanceObject *inst) {     /* Allocate temporaries if needed, but do not begin        destruction just yet.      */      if (inst-&gt;in_weakreflist != NULL)         PyObject_ClearWeakRefs((PyObject *) inst);      /* Proceed with object destruction normally. */ }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>static void instance_dealloc(PyInstanceObject *inst) {     /* Przeznacz miejsce dla tymczasowych jeśli potrzeba, ale nie zaczynaj destrukcji jeszcze w tej chwili.      */      if (inst-&gt;in_weakreflist != NULL)         PyObject_ClearWeakRefs((PyObject *) inst);      /* Postępuj z destrukcją przedmiotów normalnie. */ }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Suggestions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Więcej sugestii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember that you can omit most of these functions, in which case you provide ``0`` as a value.  There are type definitions for each of the functions you must provide.  They are in :file:`object.h` in the Python include directory that comes with the source distribution of Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pamiętaj że możesz pominąć większość z tych zadań, w którym to przypadku, dostarczysz ``0`` jako wartość. Istnieją definicje typu dla każdego zadania które musisz dostarczyć. Są one w pliku :file:`object.h` w katalogu załączania języka pytonowskiego, który dostarczony jest w źródłowej dystrybucji języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to learn how to implement any specific method for your new data type, do the following: Download and unpack the Python source distribution.  Go to the :file:`Objects` directory, then search the C source files for ``tp_`` plus the function you want (for example, ``tp_richcompare``).  You will find examples of the function you want to implement.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W celu nauczenia się jak wypełniać jakiekolwiek szczególne metody dla twojego nowego typu danych, wykonaj poniższe: Ściągnij i rozpakuj dystrybucję źródłową języka pytonowskiego. Przejdź do katalogu :file:`Objects`, a następnie przeszukaj pliki źródłowe C w poszukiwaniu ``tp_`` plus nazwę zadania której potrzebujesz (na przykład, ``tp_richcompare``). Znajdziesz przykłady zadań, które chcesz wypełnić.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to verify that an object is an instance of the type you are implementing, use the :cfunc:`PyObject_TypeCheck` function. A sample of its use might be something like the following::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kiedy potrzebujesz zweryfikować że przedmiot jest przykładem typu który wypełniasz, użyj zadania :cfunc:`PyObject_TypeCheck`. Przykład jego użycia mógłby być czymś następującym::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (! PyObject_TypeCheck(some_object, &amp;MyType)) {     PyErr_SetString(PyExc_TypeError, "arg #1 not a mything");     return NULL; }</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>if (! PyObject_TypeCheck(some_object, &amp;MyType)) {     PyErr_SetString(PyExc_TypeError, "arg #1 nie moja rzecz");     return NULL; }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is true when we know that the object is a basic type, like a string or a float.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest prawdziwe gdy wiemy że przedmiot jest typem bazowym, jak ciąg znaków lub liczba zmiennoprzecinkowa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We relied on this in the :attr:`tp_dealloc` handler in this example, because our type doesn't support garbage collection. Even if a type supports garbage collection, there are calls that can be made to "untrack" the object from garbage collection, however, these calls are advanced and not covered here.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oparliśmy się na tym w uchwycie obsługi :attr:`tp_dealloc` w tym przykładzie, ponieważ nasz typ nie wspiera zbierania śmieci. Nawet jeśli typ wspiera zbieranie śmieci, istnieją wywołania którymi można uczynić przedmiot "nieśledzonym" przez zbiórkę śmieci, jednakże, te wywołania są zaawansowane i nie są omawiane tutaj. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now know that the first and last members are strings, so perhaps we could be less careful about decrementing their reference counts, however, we accept instances of string subclasses. Even though deallocating normal strings won't call back into our objects, we can't guarantee that deallocating an instance of a string subclass won't call back into our objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz wiemy, że pierwszy i ostatni członek są ciągami znaków, więc być może moglibyśmy być mniej ostrożni w temacie zmniejszania ich liczby odniesień, jednakże, akceptujemy przykłady podrzędnych uogólnień ciągu znaków. Nawet chociaż odbieranie przydzielonego miejsca w pamięci dla normalnych ciągów znaków nie daje wywołania wstecznego do naszych przedmiotów, nie możemy zagwarantować, że zabranie miejsca w pamięci dla przykładu ciągu znaków nie wywoła wstecznie do naszego przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Even in the third version, we aren't guaranteed to avoid cycles.  Instances of string subclasses are allowed and string subclasses could allow cycles even if normal strings don't.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nawet w trzeciej wersji, nie dostajemy gwarancji że ominiemy cykle. Przykłady podrzędnych uogólnień względem ciągów znaków są tolerowane i podrzędne uogólnienia względem ciągu znaków mogłyby pozwolić na cykle nawet jeśli normalne ciągi znaków nie są tolerowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building C and C++ Extensions on Windows</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Budowanie Rozszerzeń C i C++ na Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter briefly explains how to create a Windows extension module for Python using Microsoft Visual C++, and follows with more detailed background information on how it works.  The explanatory material is useful for both the Windows programmer learning to build Python extensions and the Unix programmer interested in producing software which can be successfully built on both Unix and Windows.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział krótko wyjaśnia jak stworzyć moduł rozszerzający dla Windows dla języka pytonowskiego używając Microsoft Visual C++, i dalej wyjaśnia bardziej szczegółowo informacje tła o tym jak on działa. Wyjaśniający materiał jest użyteczny dla zarówno programisty Windows uczącego się budować rozszerzenia języka pytonowskiego i dla programisty Unix zainteresowanego wyprodukowaniem oprogramowania które może być z sukcesem zbudowane zarówno w Unixie jak i Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Module authors are encouraged to use the distutils approach for building extension modules, instead of the one described in this section. You will still need the C compiler that was used to build Python; typically Microsoft Visual C++.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Autorzy modułów są zachęcani aby użyć podejścia distutils dla budowania rozszerzających modułów, zamiast tego opisanego w tej sekcji. Wciąż będziesz potrzebował kompilatora C który był użyty do zbudowania języka pytonowskiego; typowo Microsoft Visual C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter mentions a number of filenames that include an encoded Python version number.  These filenames are represented with the version number shown as ``XY``; in practice, ``'X'`` will be the major version number and ``'Y'`` will be the minor version number of the Python release you're working with.  For example, if you are using Python 2.2.1, ``XY`` will actually be ``22``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten rozdział wspomina pewną ilość nazw plików które zawierają zakodowany numer wersji języka pytonowskiego. Te nazwy plików są reprezentowane przez numer wersji pokazany jako ``XY``; w praktyce, ``'X'`` będzie numerem wersji głównej zaś ``'Y'`` będzie numerem wersji pobocznym względem wydania języka pytonowskiego z którym pracujesz. Dla przykładu, jeśli używasz języka pytonowskiego 2.2.1, ``XY`` będzie ``22``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Cookbook Approach</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejście ksiązki kucharskiej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two approaches to building extension modules on Windows, just as there are on Unix: use the :mod:`distutils` package to control the build process, or do things manually.  The distutils approach works well for most extensions; documentation on using :mod:`distutils` to build and package extension modules is available in :ref:`distutils-index`.  This section describes the manual approach to building Python extensions written in C or C++.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją dwa podejścia do budowania modułów rozszerzających w Windows, tak jak istnieją na Unix-ie: użyj pakietu :mod:`distutils` aby kontrolować proces budowania, lub rób rzeczy ręcznie. Podejście distutils działa dobrze na większości rozszerzeń; dokumentacja, jak używać :mod:`distutils` aby budować rozszerzające pakiety jest dostępna w :ref:`distutils-index`. Ta sekcja opisuje ręczne podejście do budowania rozszerzeń napisanych w C lub C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build extensions using these instructions, you need to have a copy of the Python sources of the same version as your installed Python. You will need Microsoft Visual C++ "Developer Studio"; project files are supplied for VC++ version 7.1, but you can use older versions of VC++.  Notice that you should use the same version of VC++that was used to build Python itself. The example files described here are distributed with the Python sources in the :file:`PC\\example_nt\\` directory.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zbudować rozszerzenia używając tych instrukcji, potrzebujesz mieć kopię języka pytonowskiego tej samej wersji jak twój zainstalowany język pytonowski. Będziesz potrzebował Microsoft Visual C++ "Developer Studio"; pliki projektu są dostarczone dla wersji VC++ 7.1, ale możesz używać starszej wersji VC++.  Zauważ że powinieneś używać tej samej wersji VC++ która była użyta aby zbudować język pytonowski sam w sobie. Przykładowe pliki opisane tutaj są dystrybuowane ze źródłowymi plikami języka pytonowskiego w katalogu :file:`PC\example_nt\`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Copy the example files** ---  The :file:`example_nt` directory is a subdirectory of the :file:`PC` directory, in order to keep all the PC-specific files under the same directory in the source distribution.  However, the :file:`example_nt` directory can't actually be used from this location.  You first need to copy or move it up one level, so that :file:`example_nt` is a sibling of the :file:`PC` and :file:`Include` directories.  Do all your work from within this new location.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Skopiuj przykłady plików** --- Katalog :file:`example_nt` jest podkatalogiem katalogu :file:`PC`, w celu utrzymania wszystkich szczególnych dla PC-ta plików w tym samym katalogu w źródłowej dystrybucji. Jednakże, katalog :file:`example_nt` nie może być użyty z tej lokacji. Najpierw potrzebujesz skopiować lub przenieść go o jeden poziom wyżej, tak że :file:`example_nt` jest siostrzane względem katalogu :file:`PC` i katalogu :file:`include`. Wykonuj całą swoją pracę z wnętrza tej nowej lokalizacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Open the project** ---  From VC++, use the :menuselection:`File --&gt; Open Solution` dialog (not :menuselection:`File --&gt; Open`!).  Navigate to and select the file :file:`example.sln`, in the *copy* of the :file:`example_nt` directory you made above.  Click Open.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Otwórz projekt** --- Z VC++, użyj :menuselection:`File --&gt; Open Solution` - z ang. - :menuselection:`Plik --&gt; Otwórz rozwiązanie` (nie :menuselection:`File --&gt; Open`!). Przejdź i wybierz plik :file:`example.sln`, w *kopii* katalogu :file:`example_nt` którą uczyniłeś powyżej. Kliknij Otwórz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Build the example DLL** ---  In order to check that everything is set up right, try building:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Zbuduj przykładowy DLL** --- W celu sprawdzenia czy wszystko jest ustawione właściwie, spróbuj zbudować:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select a configuration.  This step is optional.  Choose :menuselection:`Build --&gt; Configuration Manager --&gt; Active Solution Configuration` and select either :guilabel:`Release`  or :guilabel:`Debug`.  If you skip this step, VC++ will use the Debug configuration by default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wybierz konfigurację. Ten krok jest opcjonalny. Wybierz :menuselection:`Build --&gt; Configuration Manager --&gt; Active Solution Configuration` z ang. - :menuselection:`Buduj --&gt; Zarządca Konfiguracji--&gt;Konfiguracja Aktywnego Rozwiązania` i wybierz albo :guilabel:`Release` albo :guilabel:`Debug`. Jeśli pominiesz ten krok, VC++ będzie używało konfiguracji Debug domyślnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the DLL.  Choose :menuselection:`Build --&gt; Build Solution`.  This creates all intermediate and result files in a subdirectory called either :file:`Debug` or :file:`Release`, depending on which configuration you selected in the preceding step.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zbuduj DLL. Wybierz :menuselection:`Buduj --&gt; Buduj Rozwiązanie`. To tworzy wszystkie pośrednie i wynikowe pliki w podkatalogu nazwanym albo :file:`Debug` albo :file:`Release`, w zależności od tego, którą konfiguracje wybrałeś w poprzednim kroku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Testing the debug-mode DLL** ---  Once the Debug build has succeeded, bring up a DOS box, and change to the :file:`example_nt\\Debug` directory.  You should now be able to repeat the following session (``C&gt;`` is the DOS prompt, ``&gt;&gt;&gt;`` is the Python prompt; note that build information and various debug output from Python may not match this screen dump exactly)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Testowanie w trybie-debug DLL** --- Gdy budowanie Debug powiodło się, wywołaj okno DOS'a i zmień katalog na :file:`example_nt\Debug`. Powinieneś teraz być w stanie powtórzyć następującą sesję (``C&gt;`` jest zachętą DOS'a, ``&gt;&gt;&gt;`` jest zachętą języka pytonowskiego; zauważ, że informacja o budowaniu i rożne treści wychodzące przy debugowaniu z języka pytonowskiego mogą nie pasować do tego zrzutu ekranu dokładnie)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C&gt;..\..\PCbuild\python_d Adding parser accelerators ... Done. Python 2.2 (#28, Dec 19 2001, 23:26:37) [MSC 32 bit (Intel)] on win32 Type "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import example [4897 refs] &gt;&gt;&gt; example.foo() Hello, world [4903 refs] &gt;&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>C&gt;..\..\PCbuild\python_d Adding parser accelerators ... Done. Python 2.2 (#28, Dec 19 2001, 23:26:37) [MSC 32 bit (Intel)] on win32 Type "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import example [4897 refs] &gt;&gt;&gt; example.foo() Hello, world [4903 refs] &gt;&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations!  You've successfully built your first Python extension module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gratulacje! z powodzeniem zbudowałeś swój pierwszy moduł rozszerzający języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Creating your own project** ---  Choose a name and create a directory for it.  Copy your C sources into it.  Note that the module source file name does not necessarily have to match the module name, but the name of the initialization function should match the module name --- you can only import a module :mod:`spam` if its initialization function is called :cfunc:`initspam`, and it should call :cfunc:`Py_InitModule` with the string ``"spam"`` as its first argument (use the minimal :file:`example.c` in this directory as a guide). By convention, it lives in a file called :file:`spam.c` or :file:`spammodule.c`. The output file should be called :file:`spam.pyd` (in Release mode) or :file:`spam_d.pyd` (in Debug mode). The extension :file:`.pyd` was chosen to avoid confusion with a system library :file:`spam.dll` to which your module could be a Python interface.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Tworzenie twojego własnego projektu** --- Wybierz nazwę i utwórz katalog dla niej. Przekopiuj pliki źródłowe C do niego. Zauważ, że nazwa pliku źródłowego modułu nie koniecznie musi odpowiadać nazwie modułu, ale nazwa zadania inicjującego powinna odpowiadać nazwie modułu --- możesz tylko importować moduł :mod:`spam` jeśli jego zadanie inicjujące jest nazwane :cfunc:`initspam`, i powinno wywołać :cfunc:`PyInitModule` z ciągiem znaków ``"spam"`` jako pierwszym parametrem (użyj minimalnego pliku :file:`example.c` w tym katalogu jako przewodnika). Przez konwencję, on przebywa w pliku nazywanym :file:`spam.c` lub :file:`spammodule.c`. Plik wyjściowy powinien być nazwany :file:`spam.pyd` (w trybie Wydania - z ang. - Release) lub :file:`spam_d.pyd` (w trybie Debugowania). Rozszerzenie :file:`.pyd` zostało wybrane aby uniknąć pomyłek z systemową biblioteką :file:`spam.dll` do której twój moduł mógłby być sprzęgiem języka Pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now your options are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz twoje opcje są następujące:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:file:`spam.\*`, and edit them by hand, or</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:file:`spam.\*`, do zmian ręcznych, lub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a brand new project; instructions are below.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz zupełnie nowy projekt; instrukcje są poniżej. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In either case, copy :file:`example_nt\\example.def` to :file:`spam\\spam.def`, and edit the new :file:`spam.def` so its second line contains the string '``initspam``'.  If you created a new project yourself, add the file :file:`spam.def` to the project now.  (This is an annoying little file with only two lines.  An alternative approach is to forget about the :file:`.def` file, and add the option :option:`/export:initspam` somewhere to the Link settings, by manually editing the setting in Project Properties dialog).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W każdym razie, skopiuj plik :file:`example_nt\example.def` do :file:`spam\spam.def`, i zmień nowy plik :file:`spam.def` tak aby jego druga linia zawierała ciąg '``initspam``'. Jeśli utworzyłeś nowy projekt własnoręcznie, dodaj plik :file:`spam.def` do projektu teraz. (To jest ten denerwujący mały plik tylko z dwiema liniami. Alternatywnym podejściem jest zapomnieć o pliku :file:`.def`, i dodać opcję :option:`/export:initspam` gdzieś w ustawieniach łączenia (z ang. - Link Settings) ręcznie zmieniając ustawienia w dialogowym okienku właściwości projektu).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Creating a brand new project** ---  Use the :menuselection:`File --&gt; New --&gt; Project` dialog to create a new Project Workspace.  Select :guilabel:`Visual C++ Projects/Win32/ Win32 Project`, enter the name (``spam``), and make sure the Location is set to parent of the :file:`spam` directory you have created (which should be a direct subdirectory of the Python build tree, a sibling of :file:`Include` and :file:`PC`).  Select Win32 as the platform (in my version, this is the only choice).  Make sure the Create new workspace radio button is selected.  Click OK.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Tworzenie zupełnie nowego projektu** --- Użyj okna dialogowego :menuselection:`File --&gt; New --&gt; Project` - z ang. - :menuselection:`Plik --&gt; Nowy --&gt; Projekt` aby stworzyć nową przestrzeń pracy Projektu. Wybierz :guilabel:`Visual C++ Projects/Win32/Win32 Project`, wpisz nazwę (``spam``) i upewnij się że lokacja jest ustawiona na katalog nadrzędny względem katalogu :file:`spam` który utworzyłeś (który powinien być bezpośrednim podkatalogiem drzewa budowania języka pytonowskiego, siostrzanym względem :file:`Include` i :file:`PC`). Wybierz Win32 jako maszynę/środowisko (w mojej wersji, to jest jedyny wybór). Upewnij się że opcja "Stwórz nową przestrzeń pracy" jest wybrana. Kliknij OK.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should now create the file :file:`spam.def` as instructed in the previous section. Add the source files to the project, using :menuselection:`Project --&gt; Add Existing Item`. Set the pattern to ``*.*`` and select both :file:`spam.c` and :file:`spam.def` and click OK.  (Inserting them one by one is fine too.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Powinieneś teraz utworzyć plik :file:`spam.def` jak powiedziano w poprzednim rozdziale. Dodaj pliki źródłowe do projektu, używając :menuselection:`Project --&gt; Add Existing Item` z ang. - :menuselection:`Projekt --&gt; Dodaj Istniejący Element`. Ustaw wzorzec na ``*.*`` i wybierz zarówno :file:`spam.c` i :file:`spam.def` i naciśnij OK. (Wstawianie ich jeden po drugim też jest w porządku.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now open the :menuselection:`Project --&gt; spam properties` dialog. You only need to change a few settings.  Make sure :guilabel:`All Configurations` is selected from the :guilabel:`Settings for:` dropdown list.  Select the C/C++ tab.  Choose the General category in the popup menu at the top.  Type the following text in the entry box labeled :guilabel:`Additional Include Directories`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz otwórz okno dialogowe :menuselection:`Project --&gt; spam properties` - z ang. - :menuselection:`Projekt --&gt; właściwości spam`. Potrzebujesz zmienić tylko kilka opcji. Upewnij się, że :guilabel:`Wszystkie konfiguracje` jest zaznaczony z listy rozwijalnej :guilabel:`Ustawienia dla:`. Wybierz zakładkę C/C++. Wybierz kategorię Ogólną w menu spod prawego przycisku na górze. Wpisz następujący tekst w polu wprowadzania oznaczonym :guilabel:`Dodatkowe Katalogi Załączania` -z ang. - :guilabel:`Additional Include Directories`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>..\Include,..\PC</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>..\Include,..\PC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, choose the General category in the Linker tab, and enter ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następnie, wybierz kategorię ogólną w zakładce załączania, i wpisz ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>..\PCbuild</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>..\PCbuild</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the text box labelled :guilabel:`Additional library Directories`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w polu tekstowym oznaczonym :guilabel:`Dodatkowe katalogi biblioteczne`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to add some mode-specific settings:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Teraz potrzebujesz dodać pewne ustawienia szczególne dla trybu-pracy:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select :guilabel:`Release` in the :guilabel:`Configuration` dropdown list. Choose the :guilabel:`Link` tab, choose the :guilabel:`Input` category, and append ``pythonXY.lib`` to the list in the :guilabel:`Additional Dependencies` box.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wybierz :guilabel:`Release` - z ang. - :guilabel:`Wydanie` w liście rozwijalnej :guilabel:`Configuration` - z ang. - :guilabel:`Konfiguracja`. Wybierz zakładkę :guilabel:`Link` - z ang. - :guilabel:`Połączenia`, wybierz kategorię :guilabel:`Input` - z ang. - :guilabel:`Wprowadzanie`, i dodaj ``pythonXY.lib`` do listy w polu :guilabel:`Dodatkowe Zależności` - z ang. - :guilabel:`Additional Dependencies`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select :guilabel:`Debug` in the :guilabel:`Configuration` dropdown list, and append ``pythonXY_d.lib`` to the list in the :guilabel:`Additional Dependencies` box.  Then click the C/C++ tab, select :guilabel:`Code Generation`, and select :guilabel:`Multi-threaded Debug DLL` from the :guilabel:`Runtime library` dropdown list.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wybierz :guilabel:`Debug` z listy rozwijalnej :guilabel:`Konfiguracja` i dodaj ``pythonXY_d.lib`` do listy w polu :guilabel:`Dodatkowe Zależności`. Potem kliknij zakładkę C/C++, wybierz :guilabel:`Generacja Kodu`, i wybierz :guilabel:`Wielo-wątkowa biblioteka DLL Debugowania` z listy rozwijalnej :guilabel:`biblioteka czasu wykonania`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select :guilabel:`Release` again from the :guilabel:`Configuration` dropdown list.  Select :guilabel:`Multi-threaded DLL` from the :guilabel:`Runtime library` dropdown list.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wybierz :guilabel:`Release` jeszcze raz z listy rozwijalnej :guilabel:`Konfiguracji`. Wybierz :guilabel:`Wielo-wątkowa biblioteka DLL` z listy rozwijalnej :guilabel:`Biblioteki czasu wykonania`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your module creates a new type, you may have trouble with this line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli twój moduł tworzy nowy typ, możesz mieć problemy z tą linijką::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change it to::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień ją na::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the following to the module initialization function::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>i dodaj następujące do zadania zainicjowania modułu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MyObject_Type.ob_type = &amp;PyType_Type;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>MyObject_Type.ob_type = &amp;PyType_Type;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Refer to section 3 of the `Python FAQ &lt;http://www.python.org/doc/faq&gt;`_ for details on why you must do this.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odwołaj się do rozdziału 3 `FAQ (z ang. - często zadawane pytania) języka pytonowskiego  &lt;http://www.python.org/doc/faq&gt;`_ po szczegóły na temat tego, dlaczego musisz to robić.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences Between Unix and Windows</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Różnice pomiędzy Unix-em i Windows-em</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unix and Windows use completely different paradigms for run-time loading of code.  Before you try to build a module that can be dynamically loaded, be aware of how your system works.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Unix i Windows używają kompletnie różnych zwyczajów dla ładowania kodu w czasie wykonania. Zanim spróbujesz zbudować moduł który może być dynamicznie załadowany, przypomnij sobie jak działa twój system.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Unix, a shared object (:file:`.so`) file contains code to be used by the program, and also the names of functions and data that it expects to find in the program.  When the file is joined to the program, all references to those functions and data in the file's code are changed to point to the actual locations in the program where the functions and data are placed in memory. This is basically a link operation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W Unix-ie, pliki współdzielonych przedmiotów (:file:`.so`) zawierają kod do użycia przez program, a także nazwy zadań i danych których spodziewa się znaleźć w programie. Gdy plik jest łączony z programem, wszystkie odniesienia do tych zadań i danych w kodzie pliku są zmieniane aby wskazywać na konkretne położenia w programie gdzie zadania i dane są umieszczane w pamięci. To jest właściwie operacja połączenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Windows, a dynamic-link library (:file:`.dll`) file has no dangling references.  Instead, an access to functions or data goes through a lookup table.  So the DLL code does not have to be fixed up at runtime to refer to the program's memory; instead, the code already uses the DLL's lookup table, and the lookup table is modified at runtime to point to the functions and data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W Windows, plik dynamicznie-łączonej biblioteki (:file:`.dll`) nie ma żadnych wiszących odniesień. Zamiast tego, dostęp do zadań lub danych przechodzi przez tablicę podglądania. Więc kod DLL nie musi być naprawiany w czasie wykonania aby odnosić się do pamięci programu; zamiast tego, kod już używa tablicy podglądania DLL, i tablica podglądania jest zmieniana w czasie wykonania aby wskazywać na zadania i dane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Unix, there is only one type of library file (:file:`.a`) which contains code from several object files (:file:`.o`).  During the link step to create a shared object file (:file:`.so`), the linker may find that it doesn't know where an identifier is defined.  The linker will look for it in the object files in the libraries; if it finds it, it will include all the code from that object file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W Unix-ie, istnieje tylko jeden typ pliku biblioteki (:file:`.a`), który zawiera kod z kilku plików przedmiotów (:file:`.o`). W czasie kroku łączenia aby utworzyć współdzielony plik przedmiotu (:file:`.so`), program łączący może stwierdzić że nie wie gdzie jest zdefiniowany identyfikator. Program łączący poszuka go w plikach przedmiotów w bibliotekach; jeśli go znajdzie, załączy cały kod z takiego pliku przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Windows, there are two types of library, a static library and an import library (both called :file:`.lib`).  A static library is like a Unix :file:`.a` file; it contains code to be included as necessary. An import library is basically used only to reassure the linker that a certain identifier is legal, and will be present in the program when the DLL is loaded.  So the linker uses the information from the import library to build the lookup table for using identifiers that are not included in the DLL.  When an application or a DLL is linked, an import library may be generated, which will need to be used for all future DLLs that depend on the symbols in the application or DLL.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W Windows, istnieją dwa typy bibliotek, statyczna biblioteka i biblioteka importu (obie zwane :file:`.lib`). Statyczna biblioteka jest jak Unix-owy plik :file:`.a`; zawiera kod do załączenia gdy potrzeba. Biblioteka importu jest w zasadzie używana tylko aby zapewnić program łączący, że dany identyfikator jest legalny, i będzie obecny w programie gdy DLL jest ładowany. Więc program łączący używa informacji z biblioteki importu aby zbudować tabelę podglądania dla użycia identyfikatorów, które nie są załączone w pliku DLL. Gdy aplikacja lub DLL jest łączony biblioteka importu może być wygenerowana, która może być potrzebna do użycia dla wszystkich przyszłych plików DLL, które zależą od symboli w aplikacji lub pliku DLL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you are building two dynamic-load modules, B and C, which should share another block of code A.  On Unix, you would *not* pass :file:`A.a` to the linker for :file:`B.so` and :file:`C.so`; that would cause it to be included twice, so that B and C would each have their own copy.  In Windows, building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it just contains information which will be used at runtime to access A's code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Załóżmy że budujesz dwa dynamicznie-ładowane moduły, B i C, które powinny współdzielić inny blok kodu A. W Unix-ie *nie* podałbyś pliku :file:`A.a` dla programu łączącego dla pliku `B.so` i pliku :file:`C.so`; to mogłoby spowodować że będzie on załączony dwukrotnie, więc B i C miałyby mieć każdy swoją własną kopię. W Windows, zbudowanie pliku :file:`A.dll` zbuduje także :file:`A.lib`. Przekazujesz plik :file:`A.lib` dla programu łączącego B i C. Plik :file:`A.lib` nie zawiera kodu; zawiera tylko informacje, które będą użyte w czasie wykonania aby uzyskać dostęp do kodu A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Windows, using an import library is sort of like using ``import spam``; it gives you access to spam's names, but does not create a separate copy.  On Unix, linking with a library is more like ``from spam import *``; it does create a separate copy.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W Windows, używanie bibliotek importu jest trochę jak używanie ``import spam``; daje Ci dostęp do nazw spamu, ale nie tworzy oddzielnej kopii. Na Unix-ie, połączenie z biblioteką jest bardziej jak ``from spam import *``; tworzy oddzielną kopię.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using DLLs in Practice</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używanie DLLów w praktyce</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Windows Python is built in Microsoft Visual C++; using other compilers may or may not work (though Borland seems to).  The rest of this section is MSVC++ specific.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski w Windows jest zbudowany w Microsoft Visual C++; użycie innych kompilatorów może lub może nie działać (chociaż Borland wydaje się). Reszta tego rozdziału jest szczególna dla MSVC++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the linker. To build two DLLs, spam and ni (which uses C functions found in spam), you could use these commands::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy tworzymy pliki DLL w Windows, trzeba przekazać plik :file:`pythonXY.lib` dla programu łączącego. Aby zbudować dwa DLL, spam i ni (który używa zadań C znajdujących się w spam), możesz użyć tych poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cl /LD /I/python/include spam.c ../libs/pythonXY.lib cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cl /LD /I/python/include spam.c ../libs/pythonXY.lib cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first command created three files: :file:`spam.obj`, :file:`spam.dll` and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python functions (such as :cfunc:`PyArg_ParseTuple`), but it does know how to find the Python code thanks to :file:`pythonXY.lib`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwsze polecenie utworzyło trzy pliki: :file:`spam.obj`, :file:`spam.dll` i :file:`spam.lib`. Plik :file:`Spam.dll` nie zawiera żadnych zadań języka pytonowskiego (takich jak :cfunc:`PyArg_ParseTuple`), ale wie jak znaleźć kod języka pytonowskiego dzięki plikowi :file:`pythonXY.lib`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second command created :file:`ni.dll` (and :file:`.obj` and :file:`.lib`), which knows how to find the necessary functions from spam, and also from the Python executable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Drugie polecenie utworzyło plik :file:`ni.dll` (i pliki :file:`.obj` i :file:`.lib`), które wiedzą jak znaleźć konieczne zadania ze spamu, a także z pliku wykonywalnego języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not every identifier is exported to the lookup table.  If you want any other modules (including Python) to be able to see your identifiers, you have to say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie każdy identyfikator jest exportowany do tabeli podglądania. Jeśli chcesz jakichkolwiek innych modułów (a także języka pytonowskiego) aby mogły widzieć twoje identyfikatory, musisz powiedzieć ``_declspec(dllexport)``, jak w ``void _declspec(dllexport) initspam(void)`` lub ``PyObject _declspec(dllexport) *NiGetSpamData(void)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Developer Studio will throw in a lot of import libraries that you do not really need, adding about 100K to your executable.  To get rid of them, use the Project Settings dialog, Link tab, to specify *ignore default libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Studio Rozwoju będzie wrzucało mnóstwo bibliotek import których nie potrzebujesz tak naprawdę, dodając około 100K do twojego pliku wykonywalnego. Aby się go pozbyć, użyj okna dialogowego Ustawienia Projektu, zakładki Połączeń, aby określić *ignoruj domyślne biblioteki*. Dodaj właściwy plik :file:`msvcrtxx.lib` do listy bibliotek.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
