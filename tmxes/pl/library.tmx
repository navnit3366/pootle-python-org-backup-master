<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.1.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>2to3 - Automated Python 2 to 3 code translation</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2to3 Zautomatyzowany tłumacz kodu z języka pytonowskiego w wersji 2 do wersji 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2to3 is a Python program that reads Python 2.x source code and applies a series of *fixers* to transform it into valid Python 3.x code.  The standard library contains a rich set of fixers that will handle almost all code.  2to3 supporting library :mod:`lib2to3` is, however, a flexible and generic library, so it is possible to write your own fixers for 2to3.  :mod:`lib2to3` could also be adapted to custom applications in which Python code needs to be edited automatically.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2to3 jest programem języka pytonowskiego który wczytuje kod źródłowy języka pytonowskiego 2.x i zastosowuje serię *ulepszeń* aby przełożyć go do poprawnej postaci kodu języka pytonowskiego 3.x. Standardowa biblioteka zawiera bogaty zbiór ulepszeń które przełożą prawie cały kod. biblioteka wspierająca 2to3 :mod:`lib2to3` jest jednakże elastyczną i podstawową biblioteką, więc jest możliwe napisanie swoich własnych ulepszeń dla 2to3. :mod:`lib2to3` może być także przystosowana do szczególnych aplikacji w których kod języka pytonowskiego miałby być edytowany automatycznie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using 2to3</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użycie 2to3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2to3 will usually be installed with the Python interpreter as a script.  It is also located in the :file:`Tools/scripts` directory of the Python root.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2to3 jest zwykle instalowane z programem interpretującym polecenia języka pytonowskiego jako skrypt. Jest też umieszczone w podkatalogu :file:`Tools/scripts` drzewa katalogowego języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2to3's basic arguments are a list of files or directories to transform.  The directories are to recursively traversed for Python sources.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podstawowymi argumentami 2to3 jest lista plików lub katalogów to zamiany. Podkatalogi są przeszukiwane rekursywnie w poszukiwaniu plików źródłowych języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a sample Python 2.x source file, :file:`example.py`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oto przykład pliku źródłowego napisanego w języku pytonowskim w wersji 2.x -  :file:`example.py`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def greet(name):     print "Hello, {0}!".format(name) print "What's your name?" name = raw_input() greet(name)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def greet(name):print "Cześć, {0}!".format(name) print "Jak masz na imię?" name = raw_input() greet(name)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be converted to Python 3.x code via 2to3 on the command line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Można to zamienić na kod w języku pytonowskim w wersji 3.x przez 2to3 w linii poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ 2to3 example.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ 2to3 example.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A diff against the original source file is printed.  2to3 can also write the needed modifications right back to the source file.  (A backup of the original file is made unless :option:`-n` is also given.)  Writing the changes back is enabled with the :option:`-w` flag::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisywane są różnice względem pierwotnego pliku źródłowego. 2to3 może też zapisać oczekiwane modyfikacje wprost do pliku źródłowego. (Jest sporządzana kopia zapasowa pliku źródłowego, chyba że wywołanie nastąpiło z opcją :option:`-n`.) Zapis zmian do pliku źródłowego jest możliwy z flagą :option:`-w`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ 2to3 -w example.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ 2to3 -w example.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After transformation, :file:`example.py` looks like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Po transformacji, plik :file:`example.py` wygląda następująco::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def greet(name):     print("Hello, {0}!".format(name)) print("What's your name?") name = input() greet(name)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def greet(name): print("Cześć, {0}!".format(name)) print("Jak masz na imię?") name = input() greet(name)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Comments and exact indentation are preserved throughout the translation process.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Komentarze i dokładne wcięcia są zachowywane podczas procesu tłumaczenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, 2to3 runs a set of :ref:`predefined fixers &lt;2to3-fixers&gt;`.  The :option:`-l` flag lists all available fixers.  An explicit set of fixers to run can be given with :option:`-f`.  Likewise the :option:`-x` explicitly disables a fixer.  The following example runs only the ``imports`` and ``has_key`` fixers::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie, 2to3 wykonuje serię `predefiniowanych przekształceń &lt;2to3-fixers&gt;`. Przełącznik :option:`-l` wypisuje wszystkie dostępne przekształcenia. Precyzyjny zestaw przekształceń do wykonania może zostać podany po parametrze :option:`-f`. Podobnie przełącznik :option:`-x` wyraźnie wyłącza przekształcenie. Następujący przykład uruchamia tylko przekształcenia ``imports`` i ``has_key``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ 2to3 -f imports -f has_key example.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ 2to3 -f imports -f has_key example.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command runs every fixer except the ``apply`` fixer::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta komenda uruchamia każde przekształcenie oprócz przekształcenia ``apply``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ 2to3 -x apply example.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ 2to3 -x apply example.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some fixers are *explicit*, meaning they aren't run by default and must be listed on the command line to be run.  Here, in addition to the default fixers, the ``idioms`` fixer is run::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niektóre przekształcenia są *szczególne*, co oznacza że nie są uruchamiane domyślnie i muszą być wymienione w linii poleceń aby zostać uruchomionymi. Tutaj w uzupełnieniu domyślnych przekształceń, przekształcenie ``idioms`` jest uruchamiane::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ 2to3 -f all -f idioms example.py</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ 2to3 -f all -f idioms example.py</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice how passing ``all`` enables all default fixers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że przekazanie ``all`` włącza wszystkie domyślne przekształcenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes 2to3 will find a place in your source code that needs to be changed, but 2to3 cannot fix automatically.  In this case, 2to3 will print a warning beneath the diff for a file.  You should address the warning in order to have compliant 3.x code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami 2to3 znajduje miejsce w twoim kodzie źródłowym które potrzebuje zmiany, ale 2to3 nie może go zmienić automatycznie. W takim przypadku, 2to3 wypisuje ostrzeżenie poniżej różnicy dla pliku. Powinieneś odpowiedzieć na ostrzeżenie w celu zapewnienia kodu zgodnego z wersją 3.x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2to3 can also refactor doctests.  To enable this mode, use the :option:`-d` flag.  Note that *only* doctests will be refactored.  This also doesn't require the module to be valid Python.  For example, doctest like examples in a reST document could also be refactored with this option.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2to3 może także poprawiać dokumenty typu doctest. Aby umożliwić ten tryb, użyj przełącznika :option:`-d`. Zauważ że *tylko* dokumenty doctest zostaną poprawione. Nie jest także wymagane aby moduł był prawidłowym plikiem Pythona. Na przykład, przykłady doctest w dokumencie reST mogą też być poprawiane przy użyciu tej opcji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :option:`-v` option enables output of more information on the translation process.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcja :option:`-v` włącza wypisywanie większej ilości informacji o procesie tłumaczenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since some print statements can be parsed as function calls or statements, 2to3 cannot always read files containing the print function.  When 2to3 detects the presence of the ``from __future__ import print_function`` compiler directive, it modifies its internal grammar to interpert :func:`print` as a function.  This change can also be enabled manually with the :option:`-p` flag.  Use :option:`-p` to run fixers on code that already has had its print statements converted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Od kiedy niektóre polecenia print można wczytywać jako odwołania do zadania lub polecenia, 2to3 nie zawsze może wczytać pliki zawierające zadanie print. Gdy 2to3 wykryje obecność dyrektywy kompilatora``from __future__ import print_function``, modyfikuje swoją wewnętrzną gramatykę aby interpretować :func:`print` jako zadanie. Ta zmiana może także być włączana ręcznie przy użyciu przełącznika :option:`-p`. Użyj :option:`-p` aby uruchomić przekształcenia na kodzie na którym uprzednio wykonano konwersję poleceń print.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przekształcenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each step of transforming code is encapsulated in a fixer.  The command ``2to3 -l`` lists them.  As :ref:`documented above &lt;2to3-using&gt;`, each can be turned on and off individually.  They are described here in more detail.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każdy krok transformacji kodu jest zawarty w jednym przekształceniu. Polecenie ``2to3 -l`` wypisuje je. Jak :ref:`udokumentowano powyżej &lt;2to3-using&gt;`, każde przekształcenie może być włączane i wyłączane indywidualnie. Są tu opisane w większych szczegółach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes usage of :func:`apply`.  For example ``apply(function, *args, **kwargs)`` is converted to ``function(*args, **kwargs)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyłącza użycie zadania :func:`apply`. Na przykład ``apply(function, *args, **kwargs)`` jest zamieniane na ``function(*args, **kwargs)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts :class:`basestring` to :class:`str`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia :class:`basestring` na :class:`str`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts :class:`buffer` to :class:`memoryview`.  This fixer is optional because the :class:`memoryview` API is similar but not exactly the same as that of :class:`buffer`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia uogólnienie :class:`buffer` na :class:`memoryview`. To przekształcenie jest nieobowiązkowe ponieważ sprzęg programowwania aplikacji ( - z ang. - API) uogólnienia :class:`memoryview` jest podobny choć nie dokładnie taki sam jak ten z uogólnienia :class:`buffer`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts ``callable(x)`` to ``isinstance(x, collections.Callable)``, adding an import to :mod:`collections` if needed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia ``callable(x)`` na ``isinstance(x,collections.Callable)``, dodając import do :mod:`collections` jeśli trzeba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixes dictionary iteration methods.  :meth:`dict.iteritems` is converted to :meth:`dict.items`, :meth:`dict.iterkeys` to :meth:`dict.keys`, and :meth:`dict.itervalues` to :meth:`dict.values`.  Similarly, :meth:`dict.viewitems`, :meth:`dict.viewkeys` and :meth:`dict.viewvalues` are converted respectively to :meth:`dict.items`, :meth:`dict.keys` and :meth:`dict.values`.  It also wraps existing usages of :meth:`dict.items`, :meth:`dict.keys`, and :meth:`dict.values` in a call to :class:`list`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Naprawia metody iterujące słowniki. :meth:`dict.iteritems` jest zamieniane na :meth:`dict.items`, :meth:`dict.iterkeys` na :meth:`dict.keys`, i :meth:`dict.itervalues` na :meth:`dict.values`. Podobnie, :meth:`dict.viewitems`, :meth:`dict.viewkeys` i :meth:`dict.viewvalues` są konwertowane odpowienio do :meth:`dict.items`, :meth:`dict.keys` i :meth:`dict.values`. Opakowuje też istniejące użycia :meth:`dict.items`, :meth:`dict.keys`, i :meth:`dict.values` w wywołaniu :class:`list`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts ``except X, T`` to ``except X as T``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia ``except X, T`` na ``except X as T``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts the :keyword:`exec` statement to the :func:`exec` function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia wyrażenie :keyword:`exec` na zadanie :func:`exec`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes usage of :func:`execfile`.  The argument to :func:`execfile` is wrapped in calls to :func:`open`, :func:`compile`, and :func:`exec`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwa użycie :func:`execfile`. Argument :func:`execfile` jest opakowywany w wywołanie zadania :func:`open`, :func:`compile`, i :func:`exec`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes assignment of :attr:`sys.exitfunc` to use of the :mod:`atexit` module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zmienia przypisanie właściwości :attr:`sys.exitfunc` dla użycia modułu :mod:`atexit`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wraps :func:`filter` usage in a :class:`list` call.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opakowuje zadanie :func:`filter` w wywołanie uogólnienia :class:`list`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixes function attributes that have been renamed.  For example, ``my_function.func_closure`` is converted to ``my_function.__closure__``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Naprawia właściwości zadania których nazwy zostały zmienione. Na przykład, ``my_function.func_closure`` jest zamieniana na ``my_function.__closure__``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes ``from __future__ import new_feature`` statements.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwa wyrażenia ``from __future__ import new_feature`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renames :func:`os.getcwdu` to :func:`os.getcwd`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zmienia funkcję :func:`os.getcwdu` na :func:`os.getcwd`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes ``dict.has_key(key)`` to ``key in dict``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zmienia ``dict.has_key(key)`` na ``key in dict``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This optional fixer performs several transformations that make Python code more idiomatic.  Type comparisons like ``type(x) is SomeClass`` and ``type(x) == SomeClass`` are converted to ``isinstance(x, SomeClass)``. ``while 1`` becomes ``while True``.  This fixer also tries to make use of :func:`sorted` in appropriate places.  For example, this block ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To opcjonalne przekształcenie wykonuje kilka transformacji które czynią kod języka pytonowskiego bardziej idiomatycznym. Porównania typów takie jak ``type(x) is PewneUogolnienie`` i ``type(x) == PewneUogolnienie`` są przekształcane na ``isinstance(x, PewneUogolnienie)``. ``while 1`` staje się ``while True``. Ta poprawka także próbuje użyć zadania :func:`sorted` we właściwych miejscach. Na przykład, ten blok::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>L = list(some_iterable) L.sort()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>L = list(pewne_iterowalne) L.sort()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is changed to ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>jest zamieniany na ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>L = sorted(some_iterable)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>L = sorted(pewne_iterowalne)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Detects sibling imports and converts them to relative imports.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykrywa pokrewne importowania i przekształca je na względne importowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handles module renames in the standard library.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługuje zmiany nazw modułów w bibliotece standardowej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handles other modules renames in the standard library.  It is separate from the :2to3fixer:`imports` fixer only because of technical limitations.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zarządza zmianami nazw innych modułów w bibliotece standardowej. Jest oddzielony od przekształcenia :2to3fixer:`imports` tylko z powodu ograniczeń technicznych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts ``input(prompt)`` to ``eval(input(prompt))``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia ``input(prompt)`` na ``eval(input(prompt))``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts :func:`intern` to :func:`sys.intern`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia :func:`intern` na :func:`sys.intern`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixes duplicate types in the second argument of :func:`isinstance`.  For example, ``isinstance(x, (int, int))`` is converted to ``isinstance(x, (int))``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poprawia zduplikowanie typu w drugim parametrze zadania :func:`isinstance`. Na przykład, ``isinstance(x, (int,int))`` jest zamieniane na ``isinstance(x, (int))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes imports of :func:`itertools.ifilter`, :func:`itertools.izip`, and :func:`itertools.imap`.  Imports of :func:`itertools.ifilterfalse` are also changed to :func:`itertools.filterfalse`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwa przywołania :func:`itertools.ifilter`, :func:`itertools.izip`, i :func:`itertools.imap`. Przywołania :func:`itertools.ifilterfalse` są także zamieniane na :func:`itertools.filterfalse`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes usage of :func:`itertools.ifilter`, :func:`itertools.izip`, and :func:`itertools.imap` to their built-in equivalents. :func:`itertools.ifilterfalse` is changed to :func:`itertools.filterfalse`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zmienia użycie funkcji :func:`itertools.ifilter`, :func:`itertools.zip`, i :func:`itertools.imap` na równoważniki wbudowane. Zadanie :func:`itertools.ifilterfalse` jest zamieniane na zadanie :func:`itertools.filterfalse`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strips the ``L`` prefix on long literals and renames :class:`long` to :class:`int`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zabiera przedrostek ``L`` na długich literałach i zmienia nazwę uogólnienia :class:`long` na :class:`int`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wraps :func:`map` in a :class:`list` call.  It also changes ``map(None, x)`` to ``list(x)``.  Using ``from future_builtins import map`` disables this fixer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opakowuje zadanie :func:`map` w wywołaniu :class:`list`. Zamienia także ``map(None, x)`` na ``list(x)``. Użycie ``from future_builtins import map`` wyłącza tą poprawkę.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts the old metaclass syntax (``__metaclass__ = Meta`` in the class body) to the new (``class X(metaclass=Meta)``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia starą składnię metaclass (``__metaclass__ = Meta`` w ciele uogólnienia) na nową (``class X(metaclass=Meta)``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixes old method attribute names.  For example, ``meth.im_func`` is converted to ``meth.__func__``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Naprawia nazwy starych właściwości sposobów postepowania. Na przykład, ``meth.im_func`` jest zamieniana na ``meth.__func__``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts the old not-equal syntax, ``&lt;&gt;``, to ``!=``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia starą składnię nie-równości, ``&lt;&gt;``, na ``!=``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts the use of iterator's :meth:`~iterator.next` methods to the :func:`next` function.  It also renames :meth:`next` methods to :meth:`~object.__next__`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia użycie sposobu postępowania iteratora :meth:`~iterator.next` na zadanie :func:`next`. Zamienia także nazwę :meth:`next` na :meth:`~object.__next__`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renames :meth:`~object.__nonzero__` to :meth:`~object.__bool__`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia sposób postępowania :meth:`~object.__nonzero__` na :meth:`~object.__bool__`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts octal literals into the new syntax.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia literały ósemkowe na nową składnię.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add extra parenthesis where they are required in list comprehensions.  For example, ``[x for x in 1, 2]`` becomes ``[x for x in (1, 2)]``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaje dodatkowe nawiasy, gdzie są wymagane w zrozumieniu list. Na przykład, ``[x for x in 1, 2]`` staje się ``[x for x in (1, 2)]``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts the :keyword:`print` statement to the :func:`print` function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia wyrażenie :keyword:`print` na zadanie :func:`print`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts ``raise E, V`` to ``raise E(V)``, and ``raise E, V, T`` to ``raise E(V).with_traceback(T)``.  If ``E`` is a tuple, the translation will be incorrect because substituting tuples for exceptions has been removed in 3.0.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia ``raise E, V`` na ``raise E(V)``, i ``raise E, V, T`` na ``raise E(V).with_traceback(T)``. Jeśli ``E`` jest krotką, zamiana będzie nieprawidłowa ponieważ zamiana krotek na wyjątki została usunięta w wersji 3.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converts :func:`raw_input` to :func:`input`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia zadanie :func:`raw_input` na :func:`input`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handles the move of :func:`reduce` to :func:`functools.reduce`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługuje przesunięcie zadania :func:`reduce` do :func:`functools.reduce`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes :data:`sys.maxint` to :data:`sys.maxsize`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia :data:`sys.maxint` na :data:`sys.maxsize`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replaces backtick repr with the :func:`repr` function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia cytowany repr na zadanie :func:`repr`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replaces use of the :class:`set` constructor with set literals.  This fixer is optional.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia użycie konstruktora uogólnienia :class:`set` na literały zbiorów. Ta zamiana jest opcjonalna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renames :exc:`StandardError` to :exc:`Exception`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia nazwę wyjątku :exc:`StandardError` na :exc:`Exception`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes the deprecated :data:`sys.exc_value`, :data:`sys.exc_type`, :data:`sys.exc_traceback` to use :func:`sys.exc_info`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia przedawnione :data:`sys.exc_value`, :data:`sys.exc_type`, :data:`sys.exc_traceback` aby używać :func:`sys.exc_info`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixes the API change in generator's :meth:`throw` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Naprawia zmianę sprzęgu API w generatorze sposobu postępowania :meth:`throw`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes implicit tuple parameter unpacking.  This fixer inserts temporary variables.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwa niejawny parametr krotki odpakowania. Ta poprawka wstawia tymczasowe zmienne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fixes code broken from the removal of some members in the :mod:`types` module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Naprawia kod popsuty z powodu usunięcia niektórych członków modułu :mod:`types`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renames :class:`unicode` to :class:`str`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia nazwę uogólnienia :class:`unicode` na :class:`str`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handles the rename of :mod:`urllib` and :mod:`urllib2` to the :mod:`urllib` package.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługuje zmianę nazwy :mod:`urllib` i :mod:`urllib2` na pakiet :mod:`urllib`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes excess whitespace from comma separated items.  This fixer is optional.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwa nadmiarowe białe znaki z rozdzielonych przecinkiem elementów. Ta poprawka jest opcjonalna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renames :func:`xrange` to :func:`range` and wraps existing :func:`range` calls with :class:`list`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia :func:`xrange` na :func:`range` i opakowuje istniejące wywołania :func:`range` za pomocą :class:`list`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes ``for x in file.xreadlines()`` to ``for x in file``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia ``for x in file.xreadlines()`` na ``for x in file``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wraps :func:`zip` usage in a :class:`list` call.  This is disabled when ``from future_builtins import zip`` appears.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opakowuje użycie zadania :func:`zip` w wywołanie uogólnienia :class:`list`. To jest wyłączone gdy pojawia się ``from future_builtins import zip``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`lib2to3` - 2to3's library</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`lib2to3` biblioteka 2to3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`lib2to3` API should be considered unstable and may change drastically in the future.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sprzęg (API) modułu :mod:`lib2to3` powinno być uważane za niestabilne i może się zmienić znacząco w przyszłości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`__future__` --- Future statement definitions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`__future__` ---  Definicje przyszłych wyrażeń</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`__future__` is a real module, and serves three purposes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`__future__` jest prawdziwym modułem, i służy trzem celom:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid confusing existing tools that analyze import statements and expect to find the modules they're importing.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uniknąć pomylenia istniejących narzędzi które analizują wyrażenia importu i oczekiwać, że znajdzie moduł, który importuje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ensure that :ref:`future statements &lt;future&gt;` run under releases prior to 2.1 at least yield runtime exceptions (the import of :mod:`__future__` will fail, because there was no module of that name prior to 2.1).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapewnić że :ref:`przyszłe wyrażenia &lt;future&gt;` uruchamiane pod wydaniami sprzed 2.1 przynajmniej dają wyjątki czasu wykonania (import :mod:`__future__ zawiedzie, gdyż nie było takiego modułu przed wersją 2.1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To document when incompatible changes were introduced, and when they will be --- or were --- made mandatory.  This is a form of executable documentation, and can be inspected programmatically via importing :mod:`__future__` and examining its contents.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dokumentować kiedy niezgodne zmiany zostały wprowadzone, i kiedy zostaną --- lub zostały --- obowiązujące. To jest forma dokumentacji programu, i może być sprawdzana programowo przez importowanie modułu :mod:`__future__` i przeegzaminowanie jego zawartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each statement in :file:`__future__.py` is of the form::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każde wyrażenie w pliku :file:`__future__.py` jest w formie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FeatureName = _Feature(OptionalRelease, MandatoryRelease,                        CompilerFlag)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>NazwaWłasności = _Feature(OptionalRelease, MandatoryRelease,                        CompilerFlag)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where, normally, *OptionalRelease* is less than *MandatoryRelease*, and both are 5-tuples of the same form as ``sys.version_info``::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdzie, normalnie, *OpcjonalneWydanie* jest mniej niż *ObowiązkowymWydaniem*, i oba są 5-krotkami o tej samej formie jak ``sys.version_info``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int  PY_MINOR_VERSION, # the 1; an int  PY_MICRO_VERSION, # the 0; an int  PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string  PY_RELEASE_SERIAL # the 3; an int )</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(PY_MAJOR_VERSION, # 2 w 2.1.0a3; liczba całkowita  PY_MINOR_VERSION, # 1; liczba całkowita  PY_MICRO_VERSION, # 0; liczba całkowita  PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; ciąg znaków  PY_RELEASE_SERIAL # 3; liczba całkowita )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*OptionalRelease* records the first release in which the feature was accepted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*OpcjonalneWydanie* zapamiętuje pierwsze wydanie w którym własność była zaakceptowana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of a *MandatoryRelease* that has not yet occurred, *MandatoryRelease* predicts the release in which the feature will become part of the language.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W przypadku gdy *ObowiązkoweWydanie* jeszcze nie nastąpiło, *ObowiązkoweWydanie* przewiduje wydanie, w którym właściwość stanie się częścią języka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Else *MandatoryRelease* records when the feature became part of the language; in releases at or after that, modules no longer need a future statement to use the feature in question, but may continue to use such imports.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W przeciwnym razie *MandatoryRelease* zapisuje kiedy właściwość stała się częścią języka; w wydaniach w tym lub późniejszych, moduły nie potrzebują więcej określenia przyszłości aby używać własności o której jest mowa, ale mogą nadal używać takich importów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*MandatoryRelease* may also be ``None``, meaning that a planned feature got dropped.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*MandatoryRelease* może także być ``None``, w znaczeniu że planowana właściwość została pominięta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of class :class:`_Feature` have two corresponding methods, :meth:`getOptionalRelease` and :meth:`getMandatoryRelease`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnienia :class:`_Feature` mają dwa odpowiadające sposoby postępowania, :meth:`getOptionalRelease` i :meth:`getMandatoryRelease`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*CompilerFlag* is the (bitfield) flag that should be passed in the fourth argument to the built-in function :func:`compile` to enable the feature in dynamically compiled code.  This flag is stored in the :attr:`compiler_flag` attribute on :class:`_Feature` instances.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*CompilerFlag* - Flaga kompilatora (pole bitowe) która powinna być przekazywana w czwartym parametrze do wbudowanego zadania :func:`compile` aby włączyć właściwość w dynamicznie kompilowanym kodzie. Ta flaga jest przechowywana we właściwości :attr:`compiler_flag` w przykładach :class:`_Feature`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No feature description will ever be deleted from :mod:`__future__`. Since its introduction in Python 2.1 the following features have found their way into the language using this mechanism:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Żadne opisy właściwości nie będą nigdy kasowane z :mod:`__future__`. Od momentu jego wprowadzenia w języku pytonowskim w wersji 2.1 następujące właściwości znalazły się jako część języka przy użyciu tego mechanizmu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>feature</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>właściwość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>optional in</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opcjonalna w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mandatory in</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>obowiązuje od</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>effect</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>efekt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>nested_scopes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zagnieżdżone_zakresy_widoczności</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.1.0b1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.1.0b1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`227`: *Statically Nested Scopes*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`227`: *Statycznie zagnieżdżone zakresy widoczności*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>generators</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>generatory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.2.0a1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.2.0a1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.3</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`255`: *Simple Generators*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`255`: *Proste Generatory*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>division</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dzielenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.2.0a2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.2.0a2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3.0</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>3.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`238`: *Changing the Division Operator*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`238`: *Zmiana operatora dzielenia*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>absolute_import</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>absolute_import</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.5.0a1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.5.0a1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.7</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`328`: *Imports: Multi-Line and Absolute/Relative*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`328`: *Importy: Wielo-linijkowe i Bezwzględne/Względne*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with_statement</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wyrażenie_with</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.6</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`343`: *The "with" Statement*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`343`: *polecenie "with"*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>print_function</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zadanie_print</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.6.0a2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2.6.0a2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`3105`: *Make print a function*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`3105`: *Uczynić print zadaniem*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unicode_literals</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>literały_unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pep:`3112`: *Bytes literals in Python 3000*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:pep:`3112`: *Kęsowe literały w języku pytonowskim 3000*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz też</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How the compiler treats future imports.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak kompilator traktuje przyszłe importy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`__main__` --- Top-level script environment</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`__main__` --- środowisko skryptów nadrzędnego poziomu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module represents the (otherwise anonymous) scope in which the interpreter's main program executes --- commands read either from standard input, from a script file, or from an interactive prompt.  It is this environment in which the idiomatic "conditional script" stanza causes a script to run::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł reprezentuje (zazwyczaj anonimowy) zakres w którym główny program interpretujący polecenia języka pytonowskiego operuje --- polecenia wczytane albo ze standardowego wejścia, z pliku skryptu, lub z współpracującego z użytkownikiem programu zapytań. To jest to środowisko w którym idiomatyczna zwrotka "warunkowego skryptu" powoduje, że skrypt biegnie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if __name__ == "__main__":     main()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>if __name__ == "__main__":     main()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`_dummy_thread` --- Drop-in replacement for the :mod:`_thread` module</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`dummy_thread` --- tymczasowy zamiennik dla modułu :mod:`_thread`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides a duplicate interface to the :mod:`_thread` module.  It is meant to be imported when the :mod:`_thread` module is not provided on a platform.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza zduplikowany sprzęg do modułu :mod:`_thread`. Ma on być importowany gdy moduł :mod:`_thread` nie jest dostarczony dla maszyny/środowiska.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suggested usage is::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sugerowane użycie jest::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try:     import _thread except ImportError:     import dummy_thread as _thread</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>try:     import _thread except ImportError:     import dummy_thread as _thread</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful to not use this module where deadlock might occur from a thread being created that blocks waiting for another thread to be created.  This often occurs with blocking I/O.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uważaj aby nie używać tego modułu tam gdzie może nastąpić wyścig krytyczny z wątku, który jest tworzony i który blokuje czekając na następny wątek aby został utworzony. To często następuje z zablokowaniem wejścia/wyjścia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`_thread` --- Low-level threading API</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`_thread` --- Niskiego poziomu sprzęg wątków ( - z ang. - API)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides low-level primitives for working with multiple threads (also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple threads of control sharing their global data space.  For synchronization, simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are provided. The :mod:`threading` module provides an easier to use and higher-level threading API built on top of this module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza niskiego-poziomu figury dla pracy z wieloma wątkami (zwane także :dfn:`niewielkiej-wagi procesy` lub :dfn:`zadania`) --- wiele wątków kontroli wspólnie-dzielących ich nadrzędną przestrzeń danych. Dla synchronizacji, proste blokady (zwane także :dfn:`mutexami` lub :dfn:`binarnymi semaforami`) są dostarczane. Moduł :mod:`threading` dostarcza łatwiejsze w użyciu i wyższego poziomu sprzęgi wątkowe (API) zbudowane na wierzchu ponad tym modułem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module is optional.  It is supported on Windows, Linux, SGI IRIX, Solaris 2.x, as well as on systems that have a POSIX thread (a.k.a. "pthread") implementation.  For systems lacking the :mod:`_thread` module, the :mod:`_dummy_thread` module is available. It duplicates this module's interface and can be used as a drop-in replacement.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł jest opcjonalny. Jest wspierany w Windows, Linux, SGI IRIX, Solaris 2.x, zarówno jak też na systemach, które mają wypełnienie wątków POSIX-owych (in.zn.j. "pthread"). Dla systemów którym brakuje :mod:`_thread`, moduł :mod:`_dummy_thread` jest dostępny. Duplikuje sprzęg modułu i może być użyty jako tymczasowe zastępstwo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It defines the following constants and functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Definiuje następujące stałe i zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raised on thread-specific errors.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wystawiany podczas szczególnych dla wątku błędów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the type of lock objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest typ przedmiotów blokujących.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start a new thread and return its identifier.  The thread executes the function *function* with the argument list *args* (which must be a tuple).  The optional *kwargs* argument specifies a dictionary of keyword arguments. When the function returns, the thread silently exits.  When the function terminates with an unhandled exception, a stack trace is printed and then the thread exits (but other threads continue to run).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zacznij nowy wątek i zwróć jego identyfikator. Wątek wykonuje zadanie *function* z listą parametrów *args* (które muszą być krotką). Opcjonalny parametr *kwargs* wyszczególnia słownik parametrów słów kluczowych. Gdy zadanie powraca, wątek milcząco wyłącza się. Gdy zadanie kończy się z nieobsłużonym wyjątkiem, wypis sterty jest drukowany i wtedy wątek kończy się (ale inne wątki pracują dalej).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raise a :exc:`KeyboardInterrupt` exception in the main thread.  A subthread can use this function to interrupt the main thread.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłoś wyjątek :exc:`KeyboardInterrupt` w głównym wątku. Wątek podrzędny może używać tego zadania aby przerywać wątek główny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raise the :exc:`SystemExit` exception.  When not caught, this will cause the thread to exit silently.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłoś wyjątek :exc:`SystemExit`. Gdy nie złapany, to spowoduje że wątek wyjdzie po cichu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a new lock object.  Methods of locks are described below.  The lock is initially unlocked.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć nowy przedmiot blokady. Sposoby postępowania blokad są opisane poniżej. Blokada początkowo jest odblokowana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the 'thread identifier' of the current thread.  This is a nonzero integer.  Its value has no direct meaning; it is intended as a magic cookie to be used e.g. to index a dictionary of thread-specific data.  Thread identifiers may be recycled when a thread exits and another thread is created.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć 'identyfikator wątku' dla obecnego wątku. To jest niezerowa liczba całkowita. Jej wartość nie ma żadnego bezpośredniego znaczenia; jest ona pomyślana jako magiczne ciasteczko do użycia np. aby indeksować słownik szczególnych-dla-wątku danych. Identyfikatory wątku mogą być ponownie użyte gdy wątek kończy a następny wątek jest tworzony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the thread stack size used when creating new threads.  The optional *size* argument specifies the stack size to be used for subsequently created threads, and must be 0 (use platform or configured default) or a positive integer value of at least 32,768 (32kB). If changing the thread stack size is unsupported, a :exc:`ThreadError` is raised.  If the specified stack size is invalid, a :exc:`ValueError` is raised and the stack size is unmodified.  32kB is currently the minimum supported stack size value to guarantee sufficient stack space for the interpreter itself.  Note that some platforms may have particular restrictions on values for the stack size, such as requiring a minimum stack size &gt; 32kB or requiring allocation in multiples of the system memory page size - platform documentation should be referred to for more information (4kB pages are common; using multiples of 4096 for the stack size is the suggested approach in the absence of more specific information). Availability: Windows, systems with POSIX threads.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć rozmiar sterty używany do tworzenia nowych wątków. Opcjonalny parametr *rozmiaru* określa rozmiar sterty do użycia dla później tworzonych wątków, i musi być 0 (używać wartości domyślnej wynikającej z maszyny/środowiska lub konfiguracji) lub dodatniej liczby całkowitej o wartości co najmniej 32,768 (32kB). Jeśli zmiana rozmiaru sterty wątku jest niewspierana, :exc:`ThreadError` jest zgłaszany. Jeśli określony rozmiar sterty jest nieprawidłowy, :exc:`ValueError` jest zgłaszany i rozmiar sterty nie jest modyfikowany. 32kB jest obecnie minimalnym wspieranym rozmiarem sterty gwarantującym wystarczający rozmiar sterty dla programu interpretującego polecenia języka pytonowskiego samego w sobie. Zauważ, że niektóre maszyny/środowiska mogą mieć szczególne ograniczenia na wartości dla rozmiaru sterty, takie jak wymaganie minimalnego rozmiaru sterty &gt; 32kB lub wymaganie umieszczenia w wielokrotności rozmiaru strony pamięci systemu - dokumentacja maszyny/środowiska powinna zostać sprawdzona w celu uzyskania większej ilości informacji na ten temat (strony 4kB są znane; użycie wielokrotności 4096 dla rozmiaru sterty jest sugerowanym podejściem w obliczu braku bardziej szczegółowych informacji). Dostępność: Windows, systemy z wątkami POSIX. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum value allowed for the *timeout* parameter of :meth:`Lock.acquire`. Specifiying a timeout greater than this value will raise an :exc:`OverflowError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Maksymalna wartość dozwolona dla parametru *timeout* do sposobu postępowania :meth:`Lock.acquire`. Określenie parametru timeout większego niż ta wartość będzie zgłaszać :exc:`OverflowError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lock objects have the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty blokad mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without any optional argument, this method acquires the lock unconditionally, if necessary waiting until it is released by another thread (only one thread at a time can acquire a lock --- that's their reason for existence).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bez żadnych opcjonalnych argumentów, ta metoda przejmuje blokadę bezwarunkowo, jeśli to konieczne czekając aż zostanie zwolniona przez inny wątek (tylko jeden wątek na raz może przejąć blokadę --- to ich sens istnienia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the integer *waitflag* argument is present, the action depends on its value: if it is zero, the lock is only acquired if it can be acquired immediately without waiting, while if it is nonzero, the lock is acquired unconditionally as above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli całkowita liczba parametr *waitflag* - z ang. - *flagaoczekiwania* - jest obecna, akcja zależy od jej wartości: jeśli jest ona równa zero, blokada jest tylko przejmowana jeśli może być przejęta natychmiast bez czekania, podczas gdy jest ona niezerowa, blokada jest przejmowana bezwarunkowo jak powyżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the floating-point *timeout* argument is present and positive, it specifies the maximum wait time in seconds before returning.  A negative *timeout* argument specifies an unbounded wait.  You cannot specify a *timeout* if *waitflag* is zero.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli zmienno-przecinkowy *koniecczasu* - z ang. - *timeout* parametr jest obecny i dodatni, określa on maksymalny czas oczekiwania w sekundach przed powrotem. Ujemny parametr *końcaczasu* określa nieograniczone oczekiwanie. Nie możesz określić parametru *końcaczasu* jeśli *flagaoczekiwania* jest zero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The return value is ``True`` if the lock is acquired successfully, ``False`` if not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość zwracana jest ``Prawdą`` - z ang. - ``True`` jeśli blokada jest przejmowana w udany sposób, ``Fałsz`` - z ang. - ``False`` jeśli nie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Releases the lock.  The lock must have been acquired earlier, but not necessarily by the same thread.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwalnia blokadę. Blokada musiała być przejęta wcześniej, ale nie koniecznie przez ten sam wątek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the status of the lock: ``True`` if it has been acquired by some thread, ``False`` if not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć status blokady: ``Prawda`` - z ang. - ``True`` jeśli została przejęta przez jakiś wątek, ``Fałsz`` - z ang. - ``False`` jeśli nie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to these methods, lock objects can also be used via the :keyword:`with` statement, e.g.::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W dodatku do tych sposobów postępowania, przedmioty blokad mogą także być użyte przez polecenie :keyword:`with`, np.::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import _thread  a_lock = _thread.allocate_lock()  with a_lock:     print("a_lock is locked while this executes")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import _thread  zamek = _thread.allocate_lock()  with zamek:     print("zamek jest zablokowany podczas gdy to się wykonuje")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Caveats:**</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>**Zakawyczki:**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt` exception will be received by an arbitrary thread.  (When the :mod:`signal` module is available, interrupts always go to the main thread.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wątki oddziałują dziwnie z przerwaniami: wyjątek :exc:`KeyboardInterrupt` zostanie odebrany przez dowolny wątek. (Gdy moduł :mod:`signal` jest dostępny, przerwania zawsze idą do głównego wątku.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is equivalent to calling :func:`_thread.exit`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołanie :func:`sys.exit` lub zgłoszenie wyjątku :exc:`SystemExit` jest równoważne z wezwaniem zadania :func:`_thread.exit`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not all built-in functions that may block waiting for I/O allow other threads to run.  (The most popular ones (:func:`time.sleep`, :meth:`file.read`, :func:`select.select`) work as expected.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie wszystkie wbudowane zadania które mogą blokować oczekiwanie na wejście/wyjście pozwalają innym wątkom działać. (Najpopularniejsze to (:func:`time.sleep`, :meth:`file.read`, :func:`select.select`) pracują zgodnie z oczekiwaniami.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to interrupt the :meth:`acquire` method on a lock --- the :exc:`KeyboardInterrupt` exception will happen after the lock has been acquired.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie jest możliwe przerwanie wykonanie :meth:`acquire` na blokadzie --- wyjątek :exc:`KeyboardInterrupt` zdarzy się po tym jak blokada zostanie przejęta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the main thread exits, it is system defined whether the other threads survive.  On most systems, they are killed without executing :keyword:`try` ... :keyword:`finally` clauses or executing object destructors.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy główny wątek wychodzi, jest zdefiniowane przez system czy inne wątki nie zostaną zakończone. W większości systemów, są one kończone bez wykonywania klauzul :keyword:`try` ... :keyword:`finally` lub wykonywania destrukcji przedmiotów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the main thread exits, it does not do any of its usual cleanup (except that :keyword:`try` ... :keyword:`finally` clauses are honored), and the standard I/O files are not flushed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy główny wątek kończy się, nie wykonuje on żadnego typowego sprzątania (z wyjątkiem klauzul :keyword:`try` ... :keyword:`finally` które są honorowane), i standardowe pliki wejścia/wyjścia nie są czyszczone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`abc` --- Abstract Base Classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł :mod:`abc` --- abstrakcyjne podstawowe uogólnienia </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the infrastructure for defining an :term:`abstract base class` (ABCs) in Python, as outlined in :pep:`3119`; see the PEP for why this was added to Python. (See also :pep:`3141` and the :mod:`numbers` module regarding a type hierarchy for numbers based on ABCs.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza infrastrukturę dla definiowania :term:`abstrakcyjnych podstawowych uogólnień` (ABC-ów) w języku pytonowskim, jak określono w propozycji :pep:`3119`; zobacz PEP dla sprawdzenia co sprawiło że zostało to dodane do języka pytonowskiego. (Zobacz także :pep:`3141` i moduł :mod:`numbers` w odniesieniu do hierarchii typów dla liczb opartych o ABC-e.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`collections` module has some concrete classes that derive from ABCs; these can, of course, be further derived. In addition the :mod:`collections` module has some ABCs that can be used to test whether a class or instance provides a particular interface, for example, is it hashable or a mapping.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`collections` posiada pewne konkretne uogólnienia które dziedziczą po ABC-ach; te mogą oczywiście być dalej dziedziczone. W dodatku moduł :mod:`collections` ma pewne ABC-e, które mogą być użyte aby sprawdzić czy uogólnienie lub przykład uogólnienia dostarcza szczególny sprzęg dla przykładu, czy jest on mieszany czy jest on mapowany etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the following class:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza następujące uogólnienie:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metaclass for defining Abstract Base Classes (ABCs).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pośrednie uogólnienie dla definiowania abstrakcyjnych uogólnień podstawowych (w skr. z ang. - ABC - Abstract Base Class).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as "virtual subclasses" -- these and their descendants will be considered subclasses of the registering ABC by the built-in :func:`issubclass` function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via :func:`super`). [#]_</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używaj tego uogólnienia pośredniego aby utworzyć abstrakcyjne uogólnienie podstawowe (w skr. z ang. ABC). ABC może być wykorzystane do tworzenia następnych uogólnień bezpośrednio, i wtedy działa jako uogólnienie domieszki. Możesz także zarejestrować niezwiązane uogólnienia konkretne (nawet wbudowane uogólnienia) i niezwiązane abstrakcyjne uogólnienia podstawowe jako "sztuczne podrzędne uogólnienia" -- te uogólnienia i pochodne po nich będą uznawane za podrzędne uogólnienia rejestrowanego uogólnienia podstawowego abstrakcyjnego przez wbudowane zadanie :func:`issubclass`, ale rejestrowanie abstrakcyjnego uogólnienia bazowego nie pokaże się w ich sposobie rozwiązywania sposobów postępowania (w skr. MRO - z ang. - Method Resolution Order) ani też wypełnienia sposobów postępowania określone przez rejestrowanie abstrakcyjnych bazowych uogólnień nie będą wywoływalne (nawet nie przez użycie :func:`super`). [#]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes created with a metaclass of :class:`ABCMeta` have the following method:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienia stworzone za pomocą pośredniego uogólnienia :class:`ABCMeta` mają następujący sposób postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register *subclass* as a "virtual subclass" of this ABC. For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zarejestruj *podrzędne uogólnienie* jako "wirtualne podrzędne uogólnienie" tego uogólnienia abstrakcyjnego podstawowego. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>from abc import ABCMeta  class MyABC(metaclass=ABCMeta):     pass  MyABC.register(tuple)  assert issubclass(tuple, MyABC) assert isinstance((), MyABC)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>from abc import ABCMeta  class MyABC(metaclass=ABCMeta):     pass  MyABC.register(tuple)  assert issubclass(tuple, MyABC) assert isinstance((), MyABC)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also override this method in an abstract base class:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz także obejść ten sposób postępowania w abstrakcyjnym bazowym uogólnieniu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Must be defined as a class method.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(Musi być określona jako sposób postępowania uogólnienia.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check whether *subclass* is considered a subclass of this ABC.  This means that you can customize the behavior of ``issubclass`` further without the need to call :meth:`register` on every class you want to consider a subclass of the ABC.  (This class method is called from the :meth:`__subclasscheck__` method of the ABC.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdzi czy *podrzędne uogólnienie* jest uważane za podrzędne względem tego abstrakcyjnego uogólnienia bazowego. To oznacza, że możesz dostosować zachowanie ``issubclass``, dalej bez konieczności wzywania sposobu postępowania :meth:`register` w każdym uogólnieniu które chcesz uważać za podrzędne uogólnienie względem tego abstrakcyjnego uogólnienia podstawowego. (Ten sposób postępowania uogólnienia jest wzywany ze sposobu postępowania :meth:`__subclasscheck__` tego abstrakcyjnego uogólnienia podstawowego.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method should return ``True``, ``False`` or ``NotImplemented``.  If it returns ``True``, the *subclass* is considered a subclass of this ABC. If it returns ``False``, the *subclass* is not considered a subclass of this ABC, even if it would normally be one.  If it returns ``NotImplemented``, the subclass check is continued with the usual mechanism.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania powinien zwrócić ``Prawdę`` - z ang. - ``True``, ``Fałsz`` - z ang. - ``False`` lub ``niewypełnione`` - z ang. - ``NotImplemented``. Jeśli zwraca ``True``, *podrzędne uogólnienie* jest uważanie za podrzędne względem tego abstrakcyjnego uogólnienia podstawowego. Jeśli zwraca ``Fałsz``, *podrzędne uogólnienie* nie jest uważane za podrzędne względem tego abstrakcyjnego uogólnienia podstawowego, nawet jeśli zwykle byłoby takim. Jeśli zwraca ``NotImplemented``, sprawdzenie podrzędnego uogólnienia jest kontynuowane z typowym mechanizmem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a demonstration of these concepts, look at this example ABC definition::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla demonstracji tych pomysłów, popatrz na tę przykładową definicję abstrakcyjnego uogólnienia podstawowego::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Foo:     def __getitem__(self, index):         ...     def __len__(self):         ...     def get_iterator(self):         return iter(self)  class MyIterable(metaclass=ABCMeta):      @abstractmethod     def __iter__(self):         while False:             yield None      def get_iterator(self):         return self.__iter__()      @classmethod     def __subclasshook__(cls, C):         if cls is MyIterable:             if any("__iter__" in B.__dict__ for B in C.__mro__):                 return True         return NotImplemented  MyIterable.register(Foo)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class Foo:     def __getitem__(self, index):         ...     def __len__(self):         ...     def get_iterator(self):         return iter(self)  class MyIterable(metaclass=ABCMeta):      @abstractmethod     def __iter__(self):         while False:             yield None      def get_iterator(self):         return self.__iter__()      @classmethod     def __subclasshook__(cls, C):         if cls is MyIterable:             if any("__iter__" in B.__dict__ for B in C.__mro__):                 return True         return NotImplemented  MyIterable.register(Foo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ABC ``MyIterable`` defines the standard iterable method, :meth:`__iter__`, as an abstract method.  The implementation given here can still be called from subclasses.  The :meth:`get_iterator` method is also part of the ``MyIterable`` abstract base class, but it does not have to be overridden in non-abstract derived classes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjne uogólnienie podstawowe ``MyIterable`` określa standardowy iterowalny sposób postępowania, :meth:`__iter__`, jako abstrakcyjny sposób postępowania. Wypełnienie podane tutaj może wciąż być wzywane z podrzędnych uogólnień. Sposób postępowania :meth:`get_iterator` jest także częścią abstrakcyjnego podstawowego uogólnienia ``MyIterable``, ale nie musi być to obchodzone w nie-abstrakcyjnym uogólnieniu pochodnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`__subclasshook__` class method defined here says that any class that has an :meth:`__iter__` method in its :attr:`__dict__` (or in that of one of its base classes, accessed via the :attr:`__mro__` list) is considered a ``MyIterable`` too.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sposób postępowania uogólnienia :meth:`__subclasshook__` mówi, że każde uogólnienie które ma sposób postępowania :meth:`__iter__`  w swoim słowniku :attr:`__dict__` (lub w jednym należącym do jego uogólnienia bazowego, dostępnego przez listę :attr:`__mro__`) jest uważane także za ``MyIterable``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, the last line makes ``Foo`` a virtual subclass of ``MyIterable``, even though it does not define an :meth:`__iter__` method (it uses the old-style iterable protocol, defined in terms of :meth:`__len__` and :meth:`__getitem__`).  Note that this will not make ``get_iterator`` available as a method of ``Foo``, so it is provided separately.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatecznie, ostatnia linia czyni ``Foo`` wirtualnym podrzędnym uogólnieniem względem ``MyIterable``, nawet jeśli nie definiuje ono sposobu postępowania :meth:`__iter__` (używa ono protokołu iterowalności w-starym-stylu, zdefiniowanej w ramach :meth:`__len__` i :meth:`__getitem__`). Zauważ, że to nie uczyni sposobu postępowania ``get_iterator`` dostępnym jako sposobu postępowania należącego do ``Foo``, więc jest on dostarczony oddzielnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also provides the following decorators:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcza także następujące dekoratory:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A decorator indicating abstract methods.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekorator wskazujący abstrakcyjne sposoby postępowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using this decorator requires that the class's metaclass is :class:`ABCMeta` or is derived from it. A class that has a metaclass derived from :class:`ABCMeta` cannot be instantiated unless all of its abstract methods and properties are overridden. The abstract methods can be called using any of the normal 'super' call mechanisms.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użycie tego dekoratora wymaga, żeby pośrednim uogólnieniem (metaclass) tego uogólnienia było :class:`ABCMeta` lub było po nim odziedziczone. Dla uogólnienia którego pośrednie uogólnienie odziedziczone jest po :class:`ABCMeta` nie można dać przykładu, chyba że wszystkie jego sposoby postępowania abstrakcyjne i właściwości zostaną przesłonięte. Abstrakcyjne sposoby postępowania mogą być wywołane przy użyciu dowolnego ze zwykłych mechanizmów odwołań 'super'. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are not supported.  The :func:`abstractmethod` only affects subclasses derived using regular inheritance; "virtual subclasses" registered with the ABC's :meth:`register` method are not affected.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dynamiczne dodawanie abstrakcyjnych sposobów postępowania do uogólnienia, lub próbowanie modyfikacji statusu abstrakcji sposobu postępowania lub uogólnienia gdy już zostanie utworzone nie jest wspierane. Zadanie :func:`abstractmethod` dotyczy tylko podrzędnych uogólnień odziedziczonych przy użyciu zwykłego dziedziczenia; "sztucznego podrzędnego uogólnienia" ( - z ang. - "virtual subclasses") zarejestrowanego za pomocą sposobu postępowania :meth:`register` należącego do abstrakcyjnego uogólnienia podstawowego ten sposób postępowania nie dotyczy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użycie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C(metaclass=ABCMeta):     @abstractmethod     def my_abstract_method(self, ...):         ...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class C(metaclass=ABCMeta):     @abstractmethod     def my_abstract_method(self, ...):         ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike Java abstract methods, these abstract methods may have an implementation. This implementation can be called via the :func:`super` mechanism from the class that overrides it.  This could be useful as an end-point for a super-call in a framework that uses cooperative multiple-inheritance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W przeciwieństwie do abstrakcyjnych sposobów postępowania Javy, te abstrakcyjne sposoby postępowania mogą mieć swoje wypełnienie. To wypełnienie może być wzywane przez mechanizm odwołań do zadania :func:`super`, z uogólnienia które przesłania taki sposób postępowania. To może być użyteczne jako punkt końcowy super-wywołania w ramach udogodnienia które używa współpracującego wielokrotnego-dziedziczenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A subclass of the built-in :func:`property`, indicating an abstract property.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podrzędne uogólnienie wbudowanego zadania :func:`property` wskazujące abstrakcyjną właściwość.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using this function requires that the class's metaclass is :class:`ABCMeta` or is derived from it. A class that has a metaclass derived from :class:`ABCMeta` cannot be instantiated unless all of its abstract methods and properties are overridden. The abstract properties can be called using any of the normal 'super' call mechanisms.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używanie tego zadania wymaga aby pośrednie-uogólnienie uogólnienia było :class:`ABCMeta` lub pochodne po nim. Nie można dawać przykładu uogólnienia którego  uogólnienie-pośrednie pochodne jest po :class:`ABCMeta`, chyba, że jego wszystkie abstrakcyjne sposoby postępowania i właściwości zostaną przesłonięte. Abstrakcyjne właściwości mogą być wzywane przy użyciu dowolnego ze zwykłych mechanizmów wywołań 'super'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C(metaclass=ABCMeta):     @abstractproperty     def my_abstract_property(self):         ...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class C(metaclass=ABCMeta):     @abstractproperty     def my_abstract_property(self):         ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines a read-only property; you can also define a read-write abstract property using the 'long' form of property declaration::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To definiuje właściwość tylko-do-odczytu; możesz też zdefiniować wczytywaną-zapisywaną abstrakcyjną właściwość używając 'długiej' formy deklaracji właściwości::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class C(metaclass=ABCMeta):     def getx(self): ...     def setx(self, value): ...     x = abstractproperty(getx, setx)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class C(metaclass=ABCMeta):     def getx(self): ...     def setx(self, value): ...     x = abstractproperty(getx, setx)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Footnotes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przypisy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C++ programmers should note that Python's virtual base class concept is not the same as C++'s.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Programiści C++ powinni zauważyć, że koncepcja wirtualnego uogólnienia podstawowego z języka pytonowskiego nie jest tożsame z tym z C++'a.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`aifc` --- Read and write AIFF and AIFC files</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`aifc` --- Wczytaj i zapisz pliki AIFF i AIFC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides support for reading and writing AIFF and AIFF-C files. AIFF is Audio Interchange File Format, a format for storing digital audio samples in a file.  AIFF-C is a newer version of the format that includes the ability to compress the audio data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza wsparcie dla wczytywania i zapisywania plików AIFF i AIFF-C. Pliki AIFF są formatem plików wymiany audio (Audio Interchange File Format), formatem dla przechowywania cyfrowych próbek audio (dźwięku) w pliku. AIFF-C jest nowszą wersją formatu która zawiera możliwość kompresji danych audio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some operations may only work under IRIX; these will raise :exc:`ImportError` when attempting to import the :mod:`cl` module, which is only available on IRIX.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niektóre operacje mogą działać tylko pod IRIX; te zgłoszą wyjątek :exc:`ImportError` gdy nastąpi próba importowania modułu :mod:`cl`, który jest jedynie dostępny na IRIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Audio files have a number of parameters that describe the audio data. The sampling rate or frame rate is the number of times per second the sound is sampled.  The number of channels indicate if the audio is mono, stereo, or quadro.  Each frame consists of one sample per channel.  The sample size is the size in bytes of each sample.  Thus a frame consists of *nchannels*\**samplesize* bytes, and a second's worth of audio consists of *nchannels*\**samplesize*\**framerate* bytes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pliki dźwiękowe ( - z ang. - audio files) mają pewną liczbę parametrów które opisują dane audio. Częstość próbkowania ( - z ang. - sampling rate) lub częstość ramek ( - z ang. - frame rate) jest liczbą chwil na sekundę w których dźwięk jest próbkowany. Liczba kanałów wskazuje czy dźwięk jest mono, stereo, czy quadro (jedno- dwu- lub cztero-kanałowy). Każda ramka składa się z jednej próbki na kanał. Rozmiar próbki jest rozmiarem w kęsach ( - z ang. - bytes) każdej próbki. Dlatego też ramka składa się z *nchannels*\**samplesize* bajtów (kęsów), zaś sekunda trwania dźwięku składa się z *nchannels*\**samplesize*\**framerate* bajtów (kęsów).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, CD quality audio has a sample size of two bytes (16 bits), uses two channels (stereo) and has a frame rate of 44,100 frames/second.  This gives a frame size of 4 bytes (2\*2), and a second's worth occupies 2\*2\*44100 bytes (176,400 bytes).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, dźwięk jakości CD ma rozmiar próbki dwóch bajtów (16 bitów), używa dwóch kanałów (stereo) i ma rozmiar próbki 44,100 ramek/sekundę. To daje rozmiar ramki 4 bajtów (2\*2), i dźwięk długości jednej sekundy zajmuje 2\*2\*44100 bajtów (kęsów) (176,400 kęsów).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Module :mod:`aifc` defines the following function:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`aifc` określa następujące zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open an AIFF or AIFF-C file and return an object instance with methods that are described below.  The argument *file* is either a string naming a file or a file object.  *mode* must be ``'r'`` or ``'rb'`` when the file must be opened for reading, or ``'w'``  or ``'wb'`` when the file must be opened for writing.  If omitted, ``file.mode`` is used if it exists, otherwise ``'rb'`` is used.  When used for writing, the file object should be seekable, unless you know ahead of time how many samples you are going to write in total and use :meth:`writeframesraw` and :meth:`setnframes`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Otwiera plik AIFF lub AIFF-C i zwraca przykład przedmiotu ze sposobami postępowania, które są opisane poniżej. Parametr *plik* ( - z ang - *file*) jest albo ciągiem znaków nazwy pliku lub przedmiotem samego pliku. *tryb* ( - z ang. - *mode*) musi być ``'r'`` lub ``'rb'`` gdy plik musi być otwarty do wczytania, lub ``'w'`` lub ``'wb'`` gdy plik musi być otwarty do zapisu. Jeśli pominięte, ``file.mode`` jest używane jeśli istnieje, w przeciwnym razie używane jest ``'rb'``. Gdy używane do zapisu, przedmiot pliku powinien być możliwy do przeszukania, chyba że wiesz z wyprzedzeniem czasu ile próbek masz zamiar zapisać w całości i użyjesz sposobów postępowania :meth:`writeframesraw` i :meth:`setnframes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects returned by :func:`.open` when a file is opened for reading have the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty zwrócone przez zadanie :func:`.open` gdy plik jest otwierany dla wczytywania, mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the number of audio channels (1 for mono, 2 for stereo).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć liczbę kanałów dźwięku (1 dla mono, 2 dla stereo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the size in bytes of individual samples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć rozmiar w kęsach (bajtach) indywidualnych próbek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the sampling rate (number of audio frames per second).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć częstość próbkowania (liczbę ramek dźwięku na sekundę)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the number of audio frames in the file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć liczbę ramek dźwięku w pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a bytes array of length 4 describing the type of compression used in the audio file.  For AIFF files, the returned value is ``b'NONE'``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć tablicę bajtów o długości 4 określającą typ kompresji użytej w pliku dźwiękowym. Dla plików AIFF zwracana wartość jest ``b'NONE'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a bytes array convertible to a human-readable description of the type of compression used in the audio file.  For AIFF files, the returned value is ``b'not compressed'``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć tablicę bajtów do zamiany w czytelny dla człowieka opis typu kompresji użytej w pliku dźwiękowym. Dla plików AIFF, zwracana wartość jest ``b'not compressed'`` ( - z ang. - nie skompresowane).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a tuple consisting of all of the above values in the above order.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć krotkę składającą się ze wszystkich z powyższych wartości w powyższym porządku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a list of markers in the audio file.  A marker consists of a tuple of three elements.  The first is the mark ID (an integer), the second is the mark position in frames from the beginning of the data (an integer), the third is the name of the mark (a string).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć listę znaczników w pliku dźwiękowym. Znacznik składa się z krotki trzech elementów. Pierwszym jest ID znacznika (liczba całkowita), drugim jest pozycja znacznika w ramkach od początku danych (liczba całkowita), a trzecim jest nazwa znacznika (ciąg znaków).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the tuple as described in :meth:`getmarkers` for the mark with the given *id*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć krotkę, jak opisano w sposobie postępowania :meth:`getmarkers` dla znacznika o danym *id*. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read and return the next *nframes* frames from the audio file.  The returned data is a string containing for each frame the uncompressed samples of all channels.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj i zwróć następne *nramek* ramek z pliku dźwiękowego. Zwrócone dane są ciąg zawierający dla każdej ramki nieupakowane próbki ze wszystkich kanałów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rewind the read pointer.  The next :meth:`readframes` will start from the beginning.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przewiń wskaźnik wczytywania. Następne wczytanie ramek :meth:`readframes` zacznie się od początku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Seek to the specified frame number.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poszukaj ramki o określonym numerze.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the current frame number.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć obecny numer ramki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the AIFF file.  After calling this method, the object can no longer be used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamknij plik AIFF. Po wezwaniu tego sposobu postępowania, przedmiot nie może być już więcej użyty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Objects returned by :func:`.open` when a file is opened for writing have all the above methods, except for :meth:`readframes` and :meth:`setpos`.  In addition the following methods exist.  The :meth:`get\*` methods can only be called after the corresponding :meth:`set\*` methods have been called.  Before the first :meth:`writeframes` or :meth:`writeframesraw`, all parameters except for the number of frames must be filled in.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty, zwracane przez zadanie :func:`.open`, gdy plik jest otwierany do pisania, mają wszystkie powyższe sposoby postępowania, z wyjątkiem sposobów postępowania :meth:`readframes` i :meth:`setpos`. W dodatku następujące sposoby postępowania istnieją. Sposób postępowania :meth:`get\*` może być wezwana tylko po tym jak zostanie wezwane odpowiadający mu sposób postępowania :meth:`set\*`. Przed pierwszym :meth:`writeframes` lub :meth:`writeframesraw`, wszystkie parametry oprócz liczby ramek muszą być wprowadzone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an AIFF file.  The default is that an AIFF-C file is created, unless the name of the file ends in ``'.aiff'`` in which case the default is an AIFF file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz plik AIFF. Domyślnie plik AIFF-C jest tworzony, chyba że nazwa pliku kończy się na ``'.aiff'`` w którym to przypadku domyślny jest plik AIFF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an AIFF-C file.  The default is that an AIFF-C file is created, unless the name of the file ends in ``'.aiff'`` in which case the default is an AIFF file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz plik AIFF-C. Domyślnie plik AIFF-C jest tworzony, chyba że nazwa pliku kończy się na ``'.aiff'`` w którym to przypadku domyślny jest plik AIFF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the number of channels in the audio file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określ liczbę kanałów w pliku dźwiękowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the size in bytes of audio samples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określ rozmiar w kęsach (bajtach) ilości próbek dźwięku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the sampling frequency in frames per second.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określ częstotliwość próbkowania wyrażoną w ramkach na sekundę.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the number of frames that are to be written to the audio file. If this parameter is not set, or not set correctly, the file needs to support seeking.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określ liczbę ramek które mają zostać zapisane do pliku dźwiękowego. Jeśli ten parametr nie jest ustawiony, lub ustawiony nieprawidłowo, plik powinien wspierać wyszukiwanie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the compression type.  If not specified, the audio data will not be compressed.  In AIFF files, compression is not possible. The name parameter should be a human-readable description of the compression type as a bytes array, the type parameter should be a bytes array of length 4.  Currently the following compression types are supported: ``b'NONE'``, ``b'ULAW'``, ``b'ALAW'``, ``b'G722'``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określ typ upakowania danych. Jeśli nie określone dane dźwiękowe nie będą upakowane. W plikach AIFF, upakowanie nie jest możliwe. Parametr nazwy powinien być czytelnym dla człowieka opisem rodzaju upakowania jako tablica kęsów (bajtów), parametr rodzaju powinien być tabelą kęsów o długości 4. Obecnie następujące rodzaje kompresji są dostępne: ``b'NONE'``, ``b'ULAW'``, ``b'ALAW'``,``b'G722'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set all the above parameters at once.  The argument is a tuple consisting of the various parameters.  This means that it is possible to use the result of a :meth:`getparams` call as argument to :meth:`setparams`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw wszystkie powyższe parametry na raz. Parametr jest krotką składającą się z różnych parametrów. To oznacza że jest możliwe użycie wyniku sposobu postępowania :meth:`getparams` jako parametru dla sposobu postępowania :meth:`setparams`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a mark with the given id (larger than 0), and the given name at the given position.  This method can be called at any time before :meth:`close`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj znacznik o danym identyfikatorze (większym niż 0), i daną nazwą na danej pozycji. Ten sposób postępowania może być wywołany w dowolnym momencie przed wywołaniem :meth:`close`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the current write position in the output file.  Useful in combination with :meth:`setmark`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć obecne miejsce zapisu w pliku wynikowym. Użyteczne w kombinacji ze sposobem postępowania :meth:`setmark`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write data to the output file.  This method can only be called after the audio file parameters have been set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz dane do wynikowego pliku. Ten sposób postępowania może być wywoływany tylko po tym jak parametry pliku dźwiękowego zostały ustawione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like :meth:`writeframes`, except that the header of the audio file is not updated.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobnie do sposobu postępowania :meth:`writeframes`, z wyjątkiem tego że nagłówek pliku dźwiękowego nie jest uaktualniany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the AIFF file.  The header of the file is updated to reflect the actual size of the audio data. After calling this method, the object can no longer be used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz plik AIFF. Nagłówek pliku jest aktualizowany aby oddać aktualny rozmiar pliku dźwiękowego. Po wezwaniu tego sposobu postępowania, przedmiot nie może być więcej używany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generic Operating System Services</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zastępcze Usługi Systemu Operacyjnego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The modules described in this chapter provide interfaces to operating system features that are available on (almost) all operating systems, such as files and a clock.  The interfaces are generally modeled after the Unix or C interfaces, but they are available on most other systems as well.  Here's an overview:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduły opisane w tym rozdziale dostarczają sprzęgi dla własności systemu operacyjnego, które są dostępne w (prawie) wszystkich systemach operacyjnych, takich jak pliki i zegar. Sprzęgi są zwykle modelowane zgodnie ze sprzęgami Unix-a lub C, ale są one dostępne na większości innych systemów także. Tu jest przegląd:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data Compression and Archiving</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kompresja (upakowanie) Danych i Archiwizacja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The modules described in this chapter support data compression with the zlib, gzip, and bzip2 algorithms, and  the creation of ZIP- and tar-format archives.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduły opisane w tym rozdziale wspierają kompresję danych z algorytmami zlib, gzip, i bzip2, i kreacją archiwów w formacie ZIP- i tar-.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`argparse` -- Parser for command line options, arguments and sub-commands</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`argparse` -- Czytnik dla opcji linii poleceń, parametrów i podrzędnych poleceń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`argparse` module makes it easy to write user friendly command line interfaces. The program defines what arguments it requires, and :mod:`argparse` will figure out how to parse those out of :data:`sys.argv`.  The :mod:`argparse` module also automatically generates help and usage messages and issues errors when users give the program invalid arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`argparse` czyni łatwym pisanie przyjaznych dla użytkownika sprzęgów linii poleceń. Program określa których parametrów wymaga, i :mod:`argparse` domyśli się jak wczytać te z :data:`sys.argv`. Moduł :mod:`argparse` także automatycznie generuje pomoc i wiadomości o użyciu i kieruje błędami gdy użytkownicy podadzą programowi nieprawidłowe parametry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following code is a Python program that takes a list of integers and produces either the sum or the max::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący kod jest programem języka pytonowskiego, który pobiera listę liczb całkowitych i daje albo sumę albo maximum::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import argparse  parser = argparse.ArgumentParser(description='Process some integers.') parser.add_argument('integers', metavar='N', type=int, nargs='+',                    help='an integer for the accumulator') parser.add_argument('--sum', dest='accumulate', action='store_const',                    const=sum, default=max,                    help='sum the integers (default: find the max)')  args = parser.parse_args() print(args.accumulate(args.integers))</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import argparse  parser = argparse.ArgumentParser(description='Przetwórz pewne liczby.') parser.add_argument('integers', metavar='N', type=int, nargs='+',                    help='liczba całkowita dla akumulatora') parser.add_argument('--sum', dest='skumuluj', action='store_const',                    const=sum, default=max,                    help='zsumuj liczby (domyślne: znajdź maximum)')  args = parser.parse_args() print(args.accumulate(args.integers))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assuming the Python code above is saved into a file called ``prog.py``, it can be run at the command line and provides useful help messages::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakładając, że powyższy kod jest zapisany do pliku nazwanego ``prog.py``, może być uruchomiony w linii poleceń i dostarcza użytecznych wiadomości pomocowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ prog.py -h usage: prog.py [-h] [--sum] N [N ...]  Process some integers.  positional arguments:  N           an integer for the accumulator  optional arguments:  -h, --help  show this help message and exit  --sum       sum the integers (default: find the max)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ prog.py -h użycie: prog.py [-h] [--sum] N [N ...] Przetwórz pewne liczby całkowite. Parametry pozycyjne: N liczba dla akumulatora opcjonalne parametry -h, --help pokaż tą wiadomość pomocy i wyjdź --sum sumuj liczby całkowite (domyślnie: znajdź maximum)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When run with the appropriate arguments, it prints either the sum or the max of the command-line integers::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy uruchomione z właściwymi parametrami, wypisuje albo sumę albo maksimum liczb całkowitych z wiersza poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ prog.py 1 2 3 4 4  $ prog.py 1 2 3 4 --sum 10</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ prog.py 1 2 3 4 4  $ prog.py 1 2 3 4 --sum 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If invalid arguments are passed in, it will issue an error::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli nieprawidłowe parametry zostaną przekazane, wystosuje błąd::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ prog.py a b c usage: prog.py [-h] [--sum] N [N ...] prog.py: error: argument N: invalid int value: 'a'</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ prog.py a b c użycie: prog.py [-h] [--sum] N [N ...] prog.py: błąd: parametr N: niewłaściwa wartość liczby całkowitej: 'a'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following sections walk you through this example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sekcje przeprowadzają cię przez ten przykład.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a parser</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzenie czytnika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step in using the :mod:`argparse` is creating an :class:`ArgumentParser` object::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwszym krokiem w użyciu modułu :mod:`argparse` jest utworzenie przedmiotu :class:`ArgumentParser`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(description='Process some integers.')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(description='Przetwórz pewne liczby całkowite.')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`ArgumentParser` object will hold all the information necessary to parse the command line into python data types.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmiot :class:`ArgumentParser` przetrzyma wszystkie informacje konieczne do wczytania wiersza poleceń do typów danych języka pytonowskiego. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding arguments</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodawanie parametrów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Filling an :class:`ArgumentParser` with information about program arguments is done by making calls to the :meth:`~ArgumentParser.add_argument` method. Generally, these calls tell the :class:`ArgumentParser` how to take the strings on the command line and turn them into objects.  This information is stored and used when :meth:`~ArgumentParser.parse_args` is called. For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnienie uogólnienia :class:`ArgumentParser` za pomocą informacji o parametrach programu jest wykonywane przez wykonywanie odwołań do sposobu postępowania :meth:`~ArgumentParser.add_argument`. Ogólnie te wywołania mówią uogólnieniu :class:`ArgumentParser` jak wziąć ciągi z linii poleceń i zamienić je na przedmioty. Ta informacja jest przechowywana i używana gdy :meth:`~ArgumentParser.parse_args` jest wywoływane. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.add_argument('integers', metavar='N', type=int, nargs='+', ...                     help='an integer for the accumulator') &gt;&gt;&gt; parser.add_argument('--sum', dest='accumulate', action='store_const', ...                     const=sum, default=max, ...                     help='sum the integers (default: find the max)')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.add_argument('integers', metavar='N', type=int, nargs='+', ... help='liczba całkowita dla akumulatora') &gt;&gt;&gt; parser.add_argument('--sum', dest='accumulate', action='store_const', ... const=sum, default=max, ... help='zsumuj liczby całkowite (domyślne: znajdź maksimum)')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Later, calling :meth:`parse_args` will return an object with two attributes, ``integers`` and ``accumulate``.  The ``integers`` attribute will be a list of one or more ints, and the ``accumulate`` attribute will be either the :func:`sum` function, if ``--sum`` was specified at the command line, or the :func:`max` function if it was not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Później wywołanie :meth:`parse_args` zwróci przedmiot z dwoma właściwościami, ``całkowitymi liczbami`` i ``akumulacją``. Właściwość ``liczb całkowitych`` będzie listą jednego lub więcej liczb całkowitych, zaś właściwość ``akumulacji`` będzie albo zadaniem sumy - :func:`sum`, jeśli parametr ``--sum`` był określony w wierszu poleceń lub zadaniem :func:`max` jeśli nie był.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parsing arguments</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytywanie paramterów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`ArgumentParser` parses args through the :meth:`~ArgumentParser.parse_args` method.  This will inspect the command-line, convert each arg to the appropriate type and then invoke the appropriate action. In most cases, this means a simple namespace object will be built up from attributes parsed out of the command-line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`ArgumentParser` wczytuje parametry przez sposób postępowania :meth:`~ArgumentParser.parse_args`. To przejrzy wiersz poleceń, zamieni każdy parametr do właściwego typu i potem sprowokuje odpowiednie działanie. W większości przypadków, to oznacza że prosty przedmiot przestrzeni nazw będzie zbudowany z właściwości wczytanych z wiersza poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.parse_args(['--sum', '7', '-1', '42']) Namespace(accumulate=&lt;built-in function sum&gt;, integers=[7, -1, 42])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.parse_args(['--sum', '7', '-1', '42']) Namespace(accumulate=&lt;wbudowane zadanie sumy&gt;, integers=[7, -1, 42])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a script, :meth:`~ArgumentParser.parse_args` will typically be called with no arguments, and the :class:`ArgumentParser` will automatically determine the command-line args from :data:`sys.argv`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W skrypcie, sposób postępowania :meth:`~ArgumentParser.parse_args` typowo będzie wzywany bez żadnych parametrów, i uogólnienie :class:`ArgumentParser` automatycznie ustali parametry wiersza-polecenia z danych :data:`sys.argv`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArgumentParser objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Czytnika ArgumentParser</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new :class:`ArgumentParser` object.  Each parameter has its own more detailed description below, but in short they are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stwórz nowy przedmiot :class:`ArgumentParser`. Każdy parametr ma swój własny bardziej szczegółowy opis poniżej, ale po krótce są one:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>description_ - Text to display before the argument help.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>description_ - Tekst do wyświetlenia przed pomocą w sprawie parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>epilog_ - Text to display after the argument help.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>epilog_ - Tekst do wyświetlenia po pomocy w sprawie parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add_help_ - Add a -h/--help option to the parser. (default: ``True``)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>add_help_ - Dodaje opcję -h/--help do czytnika. (domyślnie ``Prawda`` - z ang. - ``True``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>argument_default_ - Set the global default value for arguments. (default: ``None``)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>argument_default_ - Ustawia nadrzędną domyślną wartość dla parametru (domyślnie: ``Żadna`` - z ang. - ``None``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>parents_ - A list of :class:`ArgumentParser` objects whose arguments should also be included.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>parents_ - Lista przedmiotów :class:`ArgumentParser`, których parametry powinny także być załączone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>prefix_chars_ - The set of characters that prefix optional arguments. (default: '-')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>prefix_chars_ - zestaw znaków które są przedrostkami parametrów opcjonalnych. (domyślnie: '-')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>fromfile_prefix_chars_ - The set of characters that prefix files from which additional arguments should be read. (default: ``None``)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>fromfile_prefix_chars_ - Zestaw znaków które są przedrostkami nazw plików z których dodatkowe parametry powinny zostać wczytane. (domyślne: ``None``)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>formatter_class_ - A class for customizing the help output.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>formatter_class_ - uogólnienie dla uszczegółowienia wypisów pomocy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>conflict_handler_ - Usually unnecessary, defines strategy for resolving conflicting optionals.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>conflict_handler_ - Zwykle niepotrzebne, określa strategię dla rozwiązywania konfliktujących się opcji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>prog_ - The name of the program (default: :data:`sys.argv[0]`)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>prog_ - nazwa programu (domyślnie: dane :data:`sys.argv[0]`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>usage_ - The string describing the program usage (default: generated)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>usage_ - z ang. - użycie_ - ciąg znaków określający użycie programu (domyślnie: generowane)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following sections describe how each of these are used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sekcje opisują jak każda z tych jest użyta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>description</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>opis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most calls to the :class:`ArgumentParser` constructor will use the ``description=`` keyword argument.  This argument gives a brief description of what the program does and how it works.  In help messages, the description is displayed between the command-line usage string and the help messages for the various arguments::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość wywołań konstruktora :class:`ArgumentParser` będzie używało słowa kluczowego ``description=``. Ten parametr daje krótki opis tego co program robi i jak działa. W wiadomościach pomocy, opis jest pokazany pomiędzy ciągiem użycia wiersza-poleceń i wiadomości pomocy dla różnych parametrów::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(description='A foo that bars') &gt;&gt;&gt; parser.print_help() usage: argparse.py [-h]  A foo that bars  optional arguments:  -h, --help  show this help message and exit</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(description='fuu które baruje') &gt;&gt;&gt; parser.print_help() użycie: argparse.py [-h] Fuu, którego baruje opcjonalne parametry: -h, --help pokazuje ten napis pomocy i wychodzi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the description will be line-wrapped so that it fits within the given space.  To change this behavior, see the formatter_class_ argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie, opis będzie zawiniętym wierszem, tak, że będzie mieścił się wewnątrz danego miejsca. Aby zmienić to zachowanie, zobacz parametr formatter_class_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>epilog</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>epilog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some programs like to display additional description of the program after the description of the arguments.  Such text can be specified using the ``epilog=`` argument to :class:`ArgumentParser`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niektóre programy lubią wyświetlać dodatkowy opis programu po opisie parametrów. Taki tekst może być specyfikowany przy użyciu parametru ``epilog=`` dla uogólnienia :class:`ArgumentParser`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ...     description='A foo that bars', ...     epilog="And that's how you'd foo a bar") &gt;&gt;&gt; parser.print_help() usage: argparse.py [-h]  A foo that bars  optional arguments:  -h, --help  show this help message and exit  And that's how you'd foo a bar</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ... description='Foo które baruje', ... epilog="A to jest sposób w jaki foo baruje") &gt;&gt;&gt; parser.print_help() użycie: argparse.py [-h] Foo, które baruje opcjonalne parametry: -h, --help pokazuje tą wiadomość pomocy i wychodzi. A to jest sposób w jaki foo baruje</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the description_ argument, the ``epilog=`` text is by default line-wrapped, but this behavior can be adjusted with the formatter_class_ argument to :class:`ArgumentParser`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak jak z parametrem opisu description_, ``epilog=`` tekst jest domyślnie zawijanym wierszem, ale to zachowanie może być dostosowane za pomocą parametru formatter_class_ dla uogólnienia :class:`ArgumentParser`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add_help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>add_help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, ArgumentParser objects add a ``-h/--help`` option which simply displays the parser's help message.  For example, consider a file named ``myprogram.py`` containing the following code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie, przedmioty ArgumentParser dodają opcję ``-h/--help`` która po prostu wyświetla wiadomość pomocy czytnika. Na przykład, rozważ plik nazwany ``myprogram.py`` zawierający następujący kod::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import argparse parser = argparse.ArgumentParser() parser.add_argument('--foo', help='foo help') args = parser.parse_args()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import argparse parser = argparse.ArgumentParser() parser.add_argument('--foo', help='pomoc foo') args = parser.parse_args()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If ``-h`` or ``--help`` is supplied is at the command-line, the ArgumentParser help will be printed::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli ``-h`` lub ``--help`` jest dostarczony w wierszu poleceń, pomoc ArgumentParser'a będzie wypisana::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ python myprogram.py --help usage: myprogram.py [-h] [--foo FOO]  optional arguments:  -h, --help  show this help message and exit  --foo FOO   foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$ python myprogram.py --help użycie: myprogram.py [-h] [--foo FOO] opcjonalne parametry: -h, --help pokazuje tą wiadomość pomocy i wychodzi --foo FOO pomoc foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Occasionally, it may be useful to disable the addition of this help option. This can be achieved by passing ``False`` as the ``add_help=`` argument to :class:`ArgumentParser`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Okazjonalnie, może być użyteczne wyłączenie dodatku tej opcji pomocy. To można osiągnąć przez przekazanie ``False`` dla ``add_help=`` parametru :class:`ArgumentParser`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', add_help=False) &gt;&gt;&gt; parser.add_argument('--foo', help='foo help') &gt;&gt;&gt; parser.print_help() usage: PROG [--foo FOO]  optional arguments:  --foo FOO  foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', add_help=False) &gt;&gt;&gt; parser.add_argument('--foo', help='foo help') &gt;&gt;&gt; parser.print_help() użycie: PROG [--foo FOO]  opcjonalne parametry:  --foo FOO  foo help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>prefix_chars</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>znaki_przedrostka - z ang. - prefix_chars</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most command-line options will use ``'-'`` as the prefix, e.g. ``-f/--foo``. Parsers that need to support additional prefix characters, e.g. for options like ``+f`` or ``/foo``, may specify them using the ``prefix_chars=`` argument to the ArgumentParser constructor::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>większość opcji wiersza polecenia będzie używało ``'-'`` jako przedrostka, np. ``-f/--foo``. Czytniki, które wymagają wsparcia dodatkowych znaków przedrostka, np. dla opcji takich, jak ``+f`` lub ``/foo``, mogą określać je używając parametru ``prefix_chars=`` dla konstruktora ArgumentParser::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+') &gt;&gt;&gt; parser.add_argument('+f') &gt;&gt;&gt; parser.add_argument('++bar') &gt;&gt;&gt; parser.parse_args('+f X ++bar Y'.split()) Namespace(bar='Y', f='X')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+') &gt;&gt;&gt; parser.add_argument('+f') &gt;&gt;&gt; parser.add_argument('++bar') &gt;&gt;&gt; parser.parse_args('+f X ++bar Y'.split()) Namespace(bar='Y', f='X')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of characters that does not include ``'-'`` will cause ``-f/--foo`` options to be disallowed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr ``prefix_chars=`` domyślnie jest równy ``'-'``. Dostarczając zbiór znaków który nie zawiera ``'-'`` spowoduje że opcje ``-f/--foo`` będą niedozwolone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>fromfile_prefix_chars</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>fromfile_prefix_chars - z ang. - zpliku_znaki_przedrostka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, for example when dealing with a particularly long argument lists, it may make sense to keep the list of arguments in a file rather than typing it out at the command line.  If the ``fromfile_prefix_chars=`` argument is given to the :class:`ArgumentParser` constructor, then arguments that start with any of the specified characters will be treated as files, and will be replaced by the arguments they contain.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>czasami, dla przykładu gdy w grę wchodzą szczególnie długie listy parametrów, może mieć sens przechowywanie listy parametrów w pliku zamiast wpisywać je w wierszu poleceń. Jeśli parametr ``formfile_prefix_chars=`` jest dany dla konstruktora uogólnienia :class:`ArgumentParser`, wtedy parametry które zaczynają się na którekolwiek z podanych znaków będą traktowane jak pliki i będą zamienione przez zawartość którą posiadają. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; with open('args.txt', 'w') as fp: ...    fp.write('-f\nbar') &gt;&gt;&gt; parser = argparse.ArgumentParser(fromfile_prefix_chars='@') &gt;&gt;&gt; parser.add_argument('-f') &gt;&gt;&gt; parser.parse_args(['-f', 'foo', '@args.txt']) Namespace(f='bar')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; with open('args.txt', 'w') as fp: ...    fp.write('-f\nbar') &gt;&gt;&gt; parser = argparse.ArgumentParser(fromfile_prefix_chars='@') &gt;&gt;&gt; parser.add_argument('-f') &gt;&gt;&gt; parser.parse_args(['-f', 'foo', '@args.txt']) Namespace(f='bar')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arguments read from a file must by default be one per line (but see also :meth:`convert_arg_line_to_args`) and are treated as if they were in the same place as the original file referencing argument on the command line.  So in the example above, the expression ``['-f', 'foo', '@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-f', 'bar']``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry wczytywane z pliku muszą domyślnie być jeden na linię (ale zobacz też sposób postępowania :meth:`convert_arg_line_to_args`) i są traktowane tak jakby były w tym samym miejscu, jak oryginalny plik odnoszący się do parametru w wierszu polecenia. Więc na przykład w powyższym wyrażenie ``['-f', 'foo', '@args.txt']`` jest uważane za równoważne wyrażeniu ``['-f', 'foo', '-f', 'bar']``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that arguments will never be treated as file references.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr ``fromfile_prefix_chars=`` domyślnie równy jest ``None``, w znaczeniu, że parametry nigdy nie będą traktowane jako odniesienia do plików.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>argument_default</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>parametr_domyślny - z ang. - argument_default</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally, argument defaults are specified either by passing a default to :meth:`add_argument` or by calling the :meth:`set_defaults` methods with a specific set of name-value pairs.  Sometimes however, it may be useful to specify a single parser-wide default for arguments.  This can be accomplished by passing the ``argument_default=`` keyword argument to :class:`ArgumentParser`. For example, to globally suppress attribute creation on :meth:`parse_args` calls, we supply ``argument_default=SUPPRESS``::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ogólnie, domyślne parametry są określane albo przez przekazanie domyślnej wartości do sposobu postępowania :meth:`add_argument` albo przez wezwanie sposobu postępowania :meth:`set_defaults` ze szczególnym zbiorem par nazwa-wartość. Czasami jednakże, może być użyteczne określenie pojedynczej szerokości-czytnika domyślnej wartości dla parametrów. To może być osiągnięte przez przekazanie parametru słowa kluczowego ``argument_default=`` dla uogólnienia :class:`ArgumentParser`. Dla przykładu, aby nadrzędnie wycofać tworzenie właściwości w przypadku wywołania :meth:`parse_args`, dostarczamy ``argument_default=SUPPRESS``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS) &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.add_argument('bar', nargs='?') &gt;&gt;&gt; parser.parse_args(['--foo', '1', 'BAR']) Namespace(bar='BAR', foo='1') &gt;&gt;&gt; parser.parse_args([]) Namespace()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS) &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.add_argument('bar', nargs='?') &gt;&gt;&gt; parser.parse_args(['--foo', '1', 'BAR']) Namespace(bar='BAR', foo='1') &gt;&gt;&gt; parser.parse_args([]) Namespace()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>parents</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>rodzice - z ang. - parents</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, several parsers share a common set of arguments. Rather than repeating the definitions of these arguments, a single parser with all the shared arguments and passed to ``parents=`` argument to :class:`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :class:`ArgumentParser` objects, collects all the positional and optional actions from them, and adds these actions to the :class:`ArgumentParser` object being constructed::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami, kilka czytników współdzieli wspólny zestaw parametrów. Zamiast powtarzać definicje tych parametrów, pojedynczy czytnik ze wszystkimi współdzielonymi parametrami i przekazany do parametru ``parents=`` dla uogólnienia :class:`ArgumentParser` może być użyty. Parametr ``parents=`` przyjmuje listę przedmiotów :class:`ArgumentParser`, zbiera wszystkie pozycyjne i opcjonalne działania od nich, i dodaje te działania do przedmiotu :class:`ArgumentParser` będącego konstruowanym::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parent_parser = argparse.ArgumentParser(add_help=False) &gt;&gt;&gt; parent_parser.add_argument('--parent', type=int)  &gt;&gt;&gt; foo_parser = argparse.ArgumentParser(parents=[parent_parser]) &gt;&gt;&gt; foo_parser.add_argument('foo') &gt;&gt;&gt; foo_parser.parse_args(['--parent', '2', 'XXX']) Namespace(foo='XXX', parent=2)  &gt;&gt;&gt; bar_parser = argparse.ArgumentParser(parents=[parent_parser]) &gt;&gt;&gt; bar_parser.add_argument('--bar') &gt;&gt;&gt; bar_parser.parse_args(['--bar', 'YYY']) Namespace(bar='YYY', parent=None)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parent_parser = argparse.ArgumentParser(add_help=False) &gt;&gt;&gt; parent_parser.add_argument('--parent', type=int)  &gt;&gt;&gt; foo_parser = argparse.ArgumentParser(parents=[parent_parser]) &gt;&gt;&gt; foo_parser.add_argument('foo') &gt;&gt;&gt; foo_parser.parse_args(['--parent', '2', 'XXX']) Namespace(foo='XXX', parent=2)  &gt;&gt;&gt; bar_parser = argparse.ArgumentParser(parents=[parent_parser]) &gt;&gt;&gt; bar_parser.add_argument('--bar') &gt;&gt;&gt; bar_parser.parse_args(['--bar', 'YYY']) Namespace(bar='YYY', parent=None)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that most parent parsers will specify ``add_help=False``.  Otherwise, the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the parent and one in the child) and raise an error.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że większość czytników rodziców będzie określała ``add_help=False``. W przeciwnym razie przedmiot :class:`ArgumentParser` zobaczy dwie ``-h/--help`` opcje (jedną dla rodzica jedną dla potomka) i zgłosi błąd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>formatter_class</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>formatter_class - uogolnienie_formatujace</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`ArgumentParser` objects allow the help formatting to be customized by specifying an alternate formatting class.  Currently, there are three such classes: :class:`argparse.RawDescriptionHelpFormatter`, :class:`argparse.RawTextHelpFormatter` and :class:`argparse.ArgumentDefaultsHelpFormatter`.  The first two allow more control over how textual descriptions are displayed, while the last automatically adds information about argument default values.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty :class:`ArgumentParser` pozwalają formatowaniu pomocy aby była uszczegółowiona przez określenie alternatywnego uogólnienia formatującego. Obecnie istnieją trzy takie uogólnienia: :class:`argparse.RawDescriptionHelpFormatter` :class:`argparse.RawTextHelpFormatter` i :class:`argparse.ArgumentDefaultsHelpFormatter`. Pierwsze dwa pozwalają na więcej kontroli ponad tym jak opisy tekstowe są pokazywane, podczas gdy ostatni automatycznie dodaje informacje o wartościach domyślnych parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, :class:`ArgumentParser` objects line-wrap the description_ and epilog_ texts in command-line help messages::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie, przedmioty :class:`ArgumentParser` zawijają wiersze opisu - z ang. - description_ i epilogu - epilog_ w wiadomościach pomocy wiersza polecenia::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ...     prog='PROG', ...     description='''this description ...         was indented weird ...             but that is okay''', ...     epilog=''' ...             likewise for this epilog whose whitespace will ...         be cleaned up and whose words will be wrapped ...         across a couple lines''') &gt;&gt;&gt; parser.print_help() usage: PROG [-h]  this description was indented weird but that is okay  optional arguments:  -h, --help  show this help message and exit  likewise for this epilog whose whitespace will be cleaned up and whose words will be wrapped across a couple lines</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ... prog='PROG', ... description='''ten opis ... był wcięty dziwnie ... ale to nie szkodzi''', ... epilog=''' ... podobnie dla epilogu, którego białe znaki będą ... uporządkowane i którego słowa zostaną zawinięte ... na przestrzeni kilku wierszy''') &gt;&gt;&gt; parser.print_help() użycie: PROG [-h] ten opis był wcięty dziwnie ale to nie szkodzi opcjonalne parametry: -h, --help pokaż tą wiadomość pomocy i wyjdź podobnie dla epilogu, którego białe znak będą uporządkowane i którego słowa zostaną zawinięte na przestrzeni kilku wierszy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing :class:`argparse.RawDescriptionHelpFormatter` as ``formatter_class=`` indicates that description_ and epilog_ are already correctly formatted and should not be line-wrapped::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przekazanie :class:`argparse.RawDescriptionHelpFormatter jako ``formatter_class=`` wskazuje, że opis - z ang. - description_ i epilog - epilog_ są już prawidłowo sformatowane i nie powinny być zawijane wierszami::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ...     prog='PROG', ...     formatter_class=argparse.RawDescriptionHelpFormatter, ...     description=textwrap.dedent('''\ ...         Please do not mess up this text! ...         -------------------------------- ...             I have indented it ...             exactly the way ...             I want it ...         ''')) &gt;&gt;&gt; parser.print_help() usage: PROG [-h]  Please do not mess up this text! --------------------------------    I have indented it    exactly the way    I want it  optional arguments:  -h, --help  show this help message and exit</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ... prog='PROG', ... formatter_class=argparse.RawDescriptionHelpFormatter, ... description=textwrap.dedent('''\ ... Proszę nie pomieszaj tego tekstu! ... ------------------------------------- ... Wciąłem go ... dokładnie w sposób ... w jaki tego pragnąłem ... ''')) &gt;&gt;&gt; parser.print_help() użycie: PROG [-h] Proszę nie pomieszaj tego tekstu! ----------------------------------------- Wciąłem go dokładnie w sposób w jaki tego pragnąłem opcjonalne parametry: -h, --help pokaż tą wiadomość pomocy i wyjdź</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`RawTextHelpFormatter` maintains whitespace for all sorts of help text including argument descriptions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`RawTextHelpFormatter` utrzymuje białe znaki dla wszystkich rodzajów tekstu pomocy zawierającego opisy parametrów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other formatter class available, :class:`ArgumentDefaultsHelpFormatter`, will add information about the default value of each of the arguments::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pozostałe dostępne uogólnienie przedmiotu formatującego :class:`ArgumentDefaultsHelpFormatter`, będzie dodawało informacje o domyślnej wartości każdego z parametrów:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ...     prog='PROG', ...     formatter_class=argparse.ArgumentDefaultsHelpFormatter) &gt;&gt;&gt; parser.add_argument('--foo', type=int, default=42, help='FOO!') &gt;&gt;&gt; parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!') &gt;&gt;&gt; parser.print_help() usage: PROG [-h] [--foo FOO] [bar [bar ...]]  positional arguments:  bar         BAR! (default: [1, 2, 3])  optional arguments:  -h, --help  show this help message and exit  --foo FOO   FOO! (default: 42)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser( ...     prog='PROG', ...     formatter_class=argparse.ArgumentDefaultsHelpFormatter) &gt;&gt;&gt; parser.add_argument('--foo', type=int, default=42, help='FOO!') &gt;&gt;&gt; parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!') &gt;&gt;&gt; parser.print_help() usage: PROG [-h] [--foo FOO] [bar [bar ...]]  pozycyjne parametry:  bar         BAR! (default: [1, 2, 3])  opcjonalne parametry:  -h, --help  pokaż tą wiadomość pomocy i wyjdź --foo FOO   FOO! (default: 42)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>conflict_handler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>rozstrzyganie_konfilktow - z ang. - conflict_handler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`ArgumentParser` objects do not allow two actions with the same option string.  By default, :class:`ArgumentParser` objects raises an exception if an attempt is made to create an argument with an option string that is already in use::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmioty :class:`ArgumentParser` nie pozwalają na dwa działania o tym samym ciągu znaków opcji. Domyślnie, przedmioty :class:`ArgumentParser` zgłaszają wyjątek, jeśli próba jest podejmowana aby utworzyć parametr z  ciągiem znaków opcji który już jest używany::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-f', '--foo', help='old foo help') &gt;&gt;&gt; parser.add_argument('--foo', help='new foo help') Traceback (most recent call last):  .. ArgumentError: argument --foo: conflicting option string(s): --foo</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-f', '--foo', help='stara pomoc foo') &gt;&gt;&gt; parser.add_argument('--foo', help='nowa pomoc foo') Wypis (najmłodsze wywołanie ostatnie):  .. ArgumentError: parametr --foo: skonfliktowane ciągi znaków opcji: --foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes (e.g. when using parents_) it may be useful to simply override any older arguments with the same option string.  To get this behavior, the value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument of :class:`ArgumentParser`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami (np. gdy używa się rodziców - z ang. - parents_) to może być użyteczne aby po prostu przesłonić wszelkie starsze parametry tym samym ciągiem znaków opcji. Aby uzyskać takie zachowanie, wartość ``'resolve'`` może być dostarczona do parametru ``rozstrzyganie_konfliktu`` ``conflict_handler`` uogólnienia :class:`ArgumentParser`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve') &gt;&gt;&gt; parser.add_argument('-f', '--foo', help='old foo help') &gt;&gt;&gt; parser.add_argument('--foo', help='new foo help') &gt;&gt;&gt; parser.print_help() usage: PROG [-h] [-f FOO] [--foo FOO]  optional arguments:  -h, --help  show this help message and exit  -f FOO      old foo help  --foo FOO   new foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve') &gt;&gt;&gt; parser.add_argument('-f', '--foo', help='stara pomoc foo') &gt;&gt;&gt; parser.add_argument('--foo', help='nowa pomoc foo') &gt;&gt;&gt; parser.print_help() użycie: PROG [-h] [-f FOO] [--foo FOO]  opcjonalne parametry:  -h, --help  pokaż ten komunikat pomocy i wyjdź  -f FOO      stara pomoc foo  --foo FOO   nowa pomoc foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that :class:`ArgumentParser` objects only remove an action if all of its option strings are overridden.  So, in the example above, the old ``-f/--foo`` action is retained as the ``-f`` action, because only the ``--foo`` option string was overridden.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że przedmioty :class:`ArgumentParser` usuwają działanie tylko jeśli wszystkie z ich ciągów znaków opcji zostaną przesłonięte. Więc w przykładzie powyższym, stare działanie ``-f/--foo`` jest zachowane jako działanie ``-f``, gdyż tylko ciąg znaków ``--foo`` został przesłonięty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>prog</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>prog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, :class:`ArgumentParser` objects uses ``sys.argv[0]`` to determine how to display the name of the program in help messages.  This default is almost always desirable because it will make the help messages match how the program was invoked on the command line.  For example, consider a file named ``myprogram.py`` with the following code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie, przedmioty :class:`ArgumentParser` używają ``sys.argv[0]`` aby określić jak wyświetlić nazwę programu w wiadomościach pomocy. Ta domyślna wartość jest prawie zawsze oczekiwana ponieważ spowoduje że wiadomości pomocy będą odpowiadały temu jak program został wywołany w wierszu poleceń. Na przykład, rozważ plik nazwany ``myprogram.py`` z następującym kodem::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The help for this program will display ``myprogram.py`` as the program name (regardless of where the program was invoked from)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pomoc dla tego programu będzie wyświetlała ``myprogram.py`` jako nazwę programu (niezależnie od tego skąd program został wywołany)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ python myprogram.py --help usage: myprogram.py [-h] [--foo FOO]  optional arguments:  -h, --help  show this help message and exit  --foo FOO   foo help $ cd .. $ python subdir\myprogram.py --help usage: myprogram.py [-h] [--foo FOO]  optional arguments:  -h, --help  show this help message and exit  --foo FOO   foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>$python myprogram.py --help użycie: myprogram.py [-h] [--foo FOO] opcjonalne parametry: -h, --help pokaż ten komunikat pomocy i wyjdź -- foo FOO foo help $ cd .. $ python subdir\myprogram.py --help użycie: myprogram.py [-h] [--foo FOO] opcjonalne parametry: -h --help pokaż ten komunikat pomocy i wyjdź --foo FOO foo help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change this default behavior, another value can be supplied using the ``prog=`` argument to :class:`ArgumentParser`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zmienić to domyślne zachowanie, inne wartość może być dostarczona używając parametru ``prog=`` dla uogólnienia :class:`ArgumentParser`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='myprogram') &gt;&gt;&gt; parser.print_help() usage: myprogram [-h]  optional arguments:  -h, --help  show this help message and exit</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='myprogram') &gt;&gt;&gt; parser.print_help() użycie: myprogram [-h]  opcjonalne parametry:  -h, --help  pokaż tą wiadomość pomocy i wyjdź</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the program name, whether determined from ``sys.argv[0]`` or from the ``prog=`` argument, is available to help messages using the ``%(prog)s`` format specifier.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że nazwa programu, określona przez ``sys.argv[0]`` lub przez argument ``prog=`` jest dostępna dla wiadomości pomocy używając ``%(prog)s`` określnika formatującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='myprogram') &gt;&gt;&gt; parser.add_argument('--foo', help='foo of the %(prog)s program') &gt;&gt;&gt; parser.print_help() usage: myprogram [-h] [--foo FOO]  optional arguments:  -h, --help  show this help message and exit  --foo FOO   foo of the myprogram program</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='myprogram') &gt;&gt;&gt; parser.add_argument('--foo', help='foo należący do programu %(prog)s') &gt;&gt;&gt; parser.print_help() użycie: myprogram [-h] [--foo FOO]  opcjonalne parametry:  -h, --help  pokaż tą wiadomość pomocy i wyjdź  --foo FOO   foo należący do programu myprogram</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>usage</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>użycie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, :class:`ArgumentParser` calculates the usage message from the arguments it contains::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie uogólnienie :class:`ArgumentParser` oblicza wiadomość użycia z parametrów które zawiera::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--foo', nargs='?', help='foo help') &gt;&gt;&gt; parser.add_argument('bar', nargs='+', help='bar help') &gt;&gt;&gt; parser.print_help() usage: PROG [-h] [--foo [FOO]] bar [bar ...]  positional arguments:  bar          bar help  optional arguments:  -h, --help   show this help message and exit  --foo [FOO]  foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--foo', nargs='?', help='foo help') &gt;&gt;&gt; parser.add_argument('bar', nargs='+', help='bar help') &gt;&gt;&gt; parser.print_help() użycie: PROG [-h] [--foo [FOO]] bar [bar ...]  pozycyjne parametry:  bar          bar help  opcjonalne parametry:  -h, --help   pokaż tą wiadomość pomocy i wyjdź  --foo [FOO]  foo help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default message can be overridden with the ``usage=`` keyword argument::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślna wiadomość może być przesłonięta za pomocą parametru słowa kluczowego ``usage=``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]') &gt;&gt;&gt; parser.add_argument('--foo', nargs='?', help='foo help') &gt;&gt;&gt; parser.add_argument('bar', nargs='+', help='bar help') &gt;&gt;&gt; parser.print_help() usage: PROG [options]  positional arguments:  bar          bar help  optional arguments:  -h, --help   show this help message and exit  --foo [FOO]  foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [opcje]') &gt;&gt;&gt; parser.add_argument('--foo', nargs='?', help='foo help') &gt;&gt;&gt; parser.add_argument('bar', nargs='+', help='bar help') &gt;&gt;&gt; parser.print_help() użycie: PROG [opcje]  pozycyjne parametry:  bar          bar help  opcjonalne parametry:  -h, --help   pokaż tą wiadomość pomocy i wyjdź  --foo [FOO]  foo help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``%(prog)s`` format specifier is available to fill in the program name in your usage messages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Określenie formatu ``%(prog)s`` jest dostępne do wpisania nazwy programu w twojej wiadomości o użyciu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The add_argument() method</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania add_argument()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define how a single command line argument should be parsed.  Each parameter has its own more detailed description below, but in short they are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdefiniuj jak pojedynczy parametr linii poleceń będzie wczytywany. Każdy parametr ma swój własny bardziej szczegółowy opis poniżej, ale w skrócie są to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`name or flags`_ - Either a name or a list of option strings, e.g. ``foo`` or ``-f, --foo``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>`name or flags`_ - nazwa lub flagi - Albo nazwa albo lista ciągów znaków opcji, np. ``foo`` lub ``-f, --foo``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>action_ - The basic type of action to be taken when this argument is encountered at the command-line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>action_ - Podstawowy typ działania podejmowanego gdy ten parametr jest napotykany w wierszu-polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>nargs_ - The number of command-line arguments that should be consumed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nargs_ - liczba parametrów wiersza-polecenia które powinny być skonsumowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>const_ - A constant value required by some action_ and nargs_ selections.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>const_ - stała wartość wymagana przez pewne działanie - action_ i nargs_ wyborów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default_ - The value produced if the argument is absent from the command-line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>default_ - wartość tworzona jeśli parametr jest nieobecny w wierszu-polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>type_ - The type to which the command-line arg should be converted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>type_ - typ do którego wiersz-poleceń powinien zostać zamieniony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>choices_ - A container of the allowable values for the argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>choices_ - pojemnik dozwolonych wartości parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>required_ - Whether or not the command-line option may be omitted (optionals only).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>required_ - Czy opcja wiersza-polecenia może zostać pominięta (tylko dla opcjonalnych).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>help_ - A brief description of what the argument does.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>help_ - krótki opis co parametr robi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>metavar_ - A name for the argument in usage messages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>metavar_ - Nazwa parametru w wiadomościach o użyciu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dest_ - The name of the attribute to be added to the object returned by :meth:`parse_args`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dest_ - nazwa właściwości do dodania do przedmiotu zwróconego przez :meth:`parse_args`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>name or flags</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nazwa lub flagi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`add_argument` method must know whether an optional argument, like ``-f`` or ``--foo``, or a positional argument, like a list of filenames, is expected.  The first arguments passed to :meth:`add_argument` must therefore be either a series of flags, or a simple argument name.  For example, an optional argument could be created like::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`add_argument` musi wiedzieć czy opcjonalny parametr, taki jak ``-f`` lub ``--foo``, lub pozycyjny parametr, jak lista nazw plików, jest oczekiwana. Pierwszy parametr przekazany do :meth:`add_argument` musi zatem być albo szeregiem flag, albo prostą nazwą parametru. Na przykład, opcjonalny parametr może być tworzony jak w::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.add_argument('-f', '--foo')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.add_argument('-f', '--foo')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>while a positional argument could be created like::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podczas gdy pozycyjny parametr mógłby być utworzony, jak w::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.add_argument('bar')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.add_argument('bar')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :meth:`parse_args` is called, optional arguments will be identified by the ``-`` prefix, and the remaining arguments will be assumed to be positional::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy :meth:`parse_args` jest wzywane, opcjonalne parametry będą identyfikowane przez przedrostek ``-``, i pozostałe parametry będą uznawane za pozycyjne::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-f', '--foo') &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_args(['BAR']) Namespace(bar='BAR', foo=None) &gt;&gt;&gt; parser.parse_args(['BAR', '--foo', 'FOO']) Namespace(bar='BAR', foo='FOO') &gt;&gt;&gt; parser.parse_args(['--foo', 'FOO']) usage: PROG [-h] [-f FOO] bar PROG: error: too few arguments</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-f', '--foo') &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_args(['BAR']) Namespace(bar='BAR', foo=None) &gt;&gt;&gt; parser.parse_args(['BAR', '--foo', 'FOO']) Namespace(bar='BAR', foo='FOO') &gt;&gt;&gt; parser.parse_args(['--foo', 'FOO']) użycie: PROG [-h] [-f FOO] bar PROG: error: za mało parametrów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>action</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>akcja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`ArgumentParser` objects associate command-line args with actions.  These actions can do just about anything with the command-line args associated with them, though most actions simply add an attribute to the object returned by :meth:`parse_args`.  The ``action`` keyword argument specifies how the command-line args should be handled. The supported actions are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmioty :class:`ArgumentParser` kojarzą parametry wiersza poleceń z działaniami. Te działania mogą robić dowolne rzeczy z parametrami wiersza-poleceń skojarzonymi z nimi, chociaż większość działań po prostu dodaje właściwość do przedmiotu zwracanego przez :meth:`parse_args`. Parametr słowa kluczowego ``akcji`` określa jak parametry wiersza poleceń powinny być obsługiwane. Dostępne działania to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>action. For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>akcja. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.parse_args('--foo 1'.split()) Namespace(foo='1')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.parse_args('--foo 1'.split()) Namespace(foo='1')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>argument.  (Note that the const_ keyword argument defaults to the rather unhelpful ``None``.)  The ``'store_const'`` action is most commonly used with optional arguments that specify some sort of flag.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>parametr. (Zauważ, że parametr słowa kluczowego const_ domyślnie jest równy raczej mało użytecznemu ``None``.) Działanie ``'store_const'`` jest najczęściej używane z opcjonalnymi parametrami, które określają pewnego rodzaju flagę. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='store_const', const=42) &gt;&gt;&gt; parser.parse_args('--foo'.split()) Namespace(foo=42)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='store_const', const=42) &gt;&gt;&gt; parser.parse_args('--foo'.split()) Namespace(foo=42)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'store_true'`` and ``'store_false'`` - These store the values ``True`` and ``False`` respectively.  These are special cases of ``'store_const'``.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'store_true'`` i ``'store_false'`` - Te zachowują wartości ``True`` i ``False`` odpowiednio. To są szczególne przypadki ``'store_const'``. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='store_true') &gt;&gt;&gt; parser.add_argument('--bar', action='store_false') &gt;&gt;&gt; parser.parse_args('--foo --bar'.split()) Namespace(bar=False, foo=True)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='store_true') &gt;&gt;&gt; parser.add_argument('--bar', action='store_false') &gt;&gt;&gt; parser.parse_args('--foo --bar'.split()) Namespace(bar=False, foo=True)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'append'`` - This stores a list, and appends each argument value to the list.  This is useful to allow an option to be specified multiple times. Example usage::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'append'`` - To zachowuje listę, i dopisuje każdą wartość parametru do listy. To jest użyteczne aby pozwolić aby opcja była określona kilkukrotnie. Przykładowe użycie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='append') &gt;&gt;&gt; parser.parse_args('--foo 1 --foo 2'.split()) Namespace(foo=['1', '2'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='append') &gt;&gt;&gt; parser.parse_args('--foo 1 --foo 2'.split()) Namespace(foo=['1', '2'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'append_const'`` - This stores a list, and appends the value specified by the const_ keyword argument to the list.  (Note that the const_ keyword argument defaults to ``None``.)  The ``'append_const'`` action is typically useful when multiple arguments need to store constants to the same list. For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'append_const'`` - To zachowuje listę, i dopisuje wartość określoną przez parametr słowa kluczowego const_ do listy. (Zauważ, że parametr słowa kluczowego const_ domyślnie równy jest ``None``.) Akcja ``'append_const'`` jest typowo użyteczna gdy wielokrotne parametry potrzebują dodać stałe wartości do tej samej listy. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--str', dest='types', action='append_const', const=str) &gt;&gt;&gt; parser.add_argument('--int', dest='types', action='append_const', const=int) &gt;&gt;&gt; parser.parse_args('--str --int'.split()) Namespace(types=[&lt;type 'str'&gt;, &lt;type 'int'&gt;])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--str', dest='types', action='append_const', const=str) &gt;&gt;&gt; parser.add_argument('-- int' dest='types', action='append_const', const=int) &gt;&gt;&gt; parser.parse_args('--str -- int'.split()) Namespace(types=[&lt;type 'str'&gt;, &lt;type 'int'&gt;])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'version'`` - This expects a ``version=`` keyword argument in the :meth:`add_argument` call, and prints version information and exits when invoked.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'version'`` - To oczekuje słowa kluczowego ``version=``  w wywołaniu :meth:`add_argument`, i wypisuje informacje o wersji i wychodzi gdy wywołane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import argparse &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--version', action='version', version='%(prog)s 2.0') &gt;&gt;&gt; parser.parse_args(['--version']) PROG 2.0</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import argparse &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--version', action='version', version='%(prog)s 2.0') &gt;&gt;&gt; parser.parse_args(['--version']) PROG 2.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also specify an arbitrary action by passing an object that implements the Action API.  The easiest way to do this is to extend :class:`argparse.Action`, supplying an appropriate ``__call__`` method.  The ``__call__`` method should accept four parameters:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz także określić dowolne działanie przez przekazanie przedmiotu który wypełnia sprzęg programowania Akcji. Najłatwiejszym sposobem aby to osiągnąć jest rozszerzenie uogólnienia :class:`argparse.Action`, dostarczając odpowiednie wywołanie sposobu postępowania ``__call__``. Sposób postępowania ``__call__`` powinien akceptować cztery parametry:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``parser`` - The ArgumentParser object which contains this action.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``parser`` - przedmiot ArgumentParser który zawiera to działanie. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``namespace`` - The namespace object that will be returned by :meth:`parse_args`.  Most actions add an attribute to this object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``namespace`` - przedmiot przestrzeni nazw który będzie zwrócony przez :meth:`parse_args`. Większość działań dodaje właściwość do przedmiotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``values`` - The associated command-line args, with any type-conversions applied.  (Type-conversions are specified with the type_ keyword argument to :meth:`add_argument`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``values`` - Skojarzone parametry wiersza-poleceń, z wszystkimi zamianami-typów zastosowanymi. (Zamiana-typu są określone za pomocą parametru słowa kluczowego type_ dla sposobu postępowania :meth:`add_argument`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``option_string`` - The option string that was used to invoke this action. The ``option_string`` argument is optional, and will be absent if the action is associated with a positional argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``option_string`` - ciąg znaków opcji który był użyty do wywołania działania. Parametr ``option_string`` jest opcjonalny, i będzie nieobecny jeśli działanie jest związane z pozycyjnym parametrem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of a custom action::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład szczególnego działania::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; class FooAction(argparse.Action): ...     def __call__(self, parser, namespace, values, option_string=None): ...     print('%r %r %r' % (namespace, values, option_string)) ...     setattr(namespace, self.dest, values) ... &gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action=FooAction) &gt;&gt;&gt; parser.add_argument('bar', action=FooAction) &gt;&gt;&gt; args = parser.parse_args('1 --foo 2'.split()) Namespace(bar=None, foo=None) '1' None Namespace(bar='1', foo=None) '2' '--foo' &gt;&gt;&gt; args Namespace(bar='1', foo='2')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; class FooAction(argparse.Action): ...     def __call__(self, parser, namespace, values, option_string=None): ...     print('%r %r %r' % (namespace, values, option_string)) ...     setattr(namespace, self.dest, values) ... &gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action=FooAction) &gt;&gt;&gt; parser.add_argument('bar', action=FooAction) &gt;&gt;&gt; args = parser.parse_args('1 --foo 2'.split()) Namespace(bar=None, foo=None) '1' None Namespace(bar='1', foo=None) '2' '--foo' &gt;&gt;&gt; args Namespace(bar='1', foo='2')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>nargs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nargs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArgumentParser objects usually associate a single command-line argument with a single action to be taken.  The ``nargs`` keyword argument associates a different number of command-line arguments with a single action..  The supported values are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty ArgumentParser zwykle wiąże pojedynczy parametr wiersza-poleceń z pojedynczym działaniem do wykonania. Parametr słowa kluczowego ``nargs`` kojarzy inną ilość parametrów wiersza-poleceń z pojedynczą akcją.. Dostępne wartości to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>N (an integer).  N args from the command-line will be gathered together into a list.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>N (liczba całkowita). N parametrów z linii poleceń będzie zebrane razem w listę. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser()  &gt;&gt;&gt; parser.add_argument('--foo', nargs=2)  &gt;&gt;&gt; parser.add_argument('bar', nargs=1)  &gt;&gt;&gt; parser.parse_args('c --foo a b'.split())  Namespace(bar=['c'], foo=['a', 'b'])  Note that ``nargs=1`` produces a list of one item.  This is different from the default, in which the item is produced by itself.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', nargs=2) &gt;&gt;&gt; parser.add_argument('bar', nargs=1) &gt;&gt;&gt; parser.parse_args('c --foo a b'.split()) Namespace(bar=['c'], foo=['a', 'b']) Zauważ, że ``nargs=1`` tworzy listę jedno-elementową. To jest różne od domyślnego, gdzie element jest tworzony przez samego siebie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'?'``. One arg will be consumed from the command-line if possible, and produced as a single item.  If no command-line arg is present, the value from default_ will be produced.  Note that for optional arguments, there is an additional case - the option string is present but not followed by a command-line arg.  In this case the value from const_ will be produced.  Some examples to illustrate this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'?'``. Jeden parametr będzie skonsumowany z wiersza-poleceń jeśli możliwe, i wyprodukowany jako pojedynczy element. Jeśli żaden parametr wiersza-poleceń nie jest obecny, wartość z domyślnej (z ang. - default_) zostanie wyprodukowany. Zauważ że dla opcjonalnych parametrów, istnieje dodatkowy przypadek - ciąg znaków opcji jest obecny ale nie następuje po nich parametr wiersza-poleceń. W tym przypadku wartość z const_ będzie produkowana. Niektóre przykłady aby to zilustrować::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', nargs='?', const='c', default='d') &gt;&gt;&gt; parser.add_argument('bar', nargs='?', default='d') &gt;&gt;&gt; parser.parse_args('XX --foo YY'.split()) Namespace(bar='XX', foo='YY') &gt;&gt;&gt; parser.parse_args('XX --foo'.split()) Namespace(bar='XX', foo='c') &gt;&gt;&gt; parser.parse_args(''.split()) Namespace(bar='d', foo='d')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', nargs='?', const='c', default='d') &gt;&gt;&gt; parser.add_argument('bar', nargs='?', default='d') &gt;&gt;&gt; parser.parse_args('XX --foo YY'.split()) Namespace(bar='XX', foo='YY') &gt;&gt;&gt; parser.parse_args('XX --foo'.split()) Namespace(bar='XX', foo='c') &gt;&gt;&gt; parser.parse_args(''.split()) Namespace(bar='d', foo='d')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the more common uses of ``nargs='?'`` is to allow optional input and output files::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedno z częściej spotykanych użyć ``nargs='?'`` jest aby umożliwić opcjonalne pliki wejściowe i wyjściowe::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin) &gt;&gt;&gt; parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout) &gt;&gt;&gt; parser.parse_args(['input.txt', 'output.txt']) Namespace(infile=&lt;open file 'input.txt', mode 'r' at 0x...&gt;, outfile=&lt;open file 'output.txt', mode 'w' at 0x...&gt;) &gt;&gt;&gt; parser.parse_args([]) Namespace(infile=&lt;open file '&lt;stdin&gt;', mode 'r' at 0x...&gt;, outfile=&lt;open file '&lt;stdout&gt;', mode 'w' at 0x...&gt;)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin) &gt;&gt;&gt; parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout) &gt;&gt;&gt; parser.parse_args(['input.txt', 'output.txt']) Namespace(infile=&lt;open file 'input.txt', mode 'r' at 0x...&gt;, outfile=&lt;open file 'output.txt', mode 'w' at 0x...&gt;) &gt;&gt;&gt; parser.parse_args([]) Namespace(infile=&lt;open file '&lt;stdin&gt;', mode 'r' at 0x...&gt;, outfile=&lt;open file '&lt;stdout&gt;', mode 'w' at 0x...&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'*'``.  All command-line args present are gathered into a list.  Note that it generally doesn't make much sense to have more than one positional argument with ``nargs='*'``, but multiple optional arguments with ``nargs='*'`` is possible.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'*'``. Wszystkie parametry wiersza-poleceń obecne są zbierane w listę. Zauważ że zwykle nie ma za dużo sensu mieć więcej niż jeden pozycyjny parametr ``nargs='*'``, ale wiele opcjonalnych parametrów z ``nargs='*'`` jest możliwe. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', nargs='*') &gt;&gt;&gt; parser.add_argument('--bar', nargs='*') &gt;&gt;&gt; parser.add_argument('baz', nargs='*') &gt;&gt;&gt; parser.parse_args('a b --foo x y --bar 1 2'.split()) Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', nargs='*') &gt;&gt;&gt; parser.add_argument('--bar', nargs='*') &gt;&gt;&gt; parser.add_argument('baz', nargs='*') &gt;&gt;&gt; parser.parse_args('a b --foo x y --bar 1 2'.split()) Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'+'``. Just like ``'*'``, all command-line args present are gathered into a list.  Additionally, an error message will be generated if there wasn't at least one command-line arg present.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'+'``. Tak jak ``'*'``, wszystkie parametry wiersza-poleceń obecne zbierane są w listę. Dodatkowo, wiadomość o błędzie będzie wytworzona jeśli nie było przynajmniej jednego parametru wiersza polecenia obecnego. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', nargs='+') &gt;&gt;&gt; parser.parse_args('a b'.split()) Namespace(foo=['a', 'b']) &gt;&gt;&gt; parser.parse_args(''.split()) usage: PROG [-h] foo [foo ...] PROG: error: too few arguments</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', nargs='+') &gt;&gt;&gt; parser.parse_args('a b'.split()) Namespace(foo=['a', 'b']) &gt;&gt;&gt; parser.parse_args(''.split()) użycie: PROG [-h] foo [foo ...] PROG: error: za mało parametrów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the ``nargs`` keyword argument is not provided, the number of args consumed is determined by the action_.  Generally this means a single command-line arg will be consumed and a single item (not a list) will be produced.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli parametr słowa kluczowego ``nargs`` nie jest dostarczony, liczba parametrów konsumowanych jest określona przez action_. Zwykle to oznacza że pojedynczy parametr wiersza poleceń będzie skonsumowany i pojedynczy element (nie lista) będzie wyprodukowany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>const</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>const</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``const`` argument of :meth:`add_argument` is used to hold constant values that are not read from the command line but are required for the various ArgumentParser actions.  The two most common uses of it are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr ``const`` dla sposobu postępowania :meth:`add_argument` jest używany aby przechowywać stałe wartości które nie są wczytywane z wiersza poleceń ale są wymagane dla różnych działań ( - z ang - actions) ArgumentParser'a. Dwa najczęstsze użycia tego są to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :meth:`add_argument` is called with ``action='store_const'`` or ``action='append_const'``.  These actions add the ``const`` value to one of the attributes of the object returned by :meth:`parse_args`.  See the action_ description for examples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy sposób postępowania :meth:`add_argument` jest wywoływany z ``action=''store_const'`` lub ``action='append_const'``. Te działania dodają stałe (z ang. - ``const``) wartości do jednej z właściwości przedmiotu zwróconej przez :meth:`parse_args`. Zobacz opis action_ dla przykładów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :meth:`add_argument` is called with option strings (like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional argument that can be followed by zero or one command-line args.  When parsing the command-line, if the option string is encountered with no command-line arg following it, the value of ``const`` will be assumed instead. See the nargs_ description for examples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy sposób postępowania :meth:`add_argument` jest wywoływany z ciągami opcji (takimi jak ``-f`` lub ``--foo``) i ``nargs='?'``. To tworzy dodatkowy nadobowiązkowy parametr, po którym można podać zero lub jeden parametr wiersza-poleceń. Gdy wczytywany jest wiersz poleceń, jeśli ciąg znaków opcji jest napotkany bez parametru wiersza polecenia następującego po nim, wartość ``const`` będzie przyjęta zamiast tej. Zobacz opis nargs_ dla przykładów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``const`` keyword argument defaults to ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr słowa kluczowego ``const`` domyślnie równy jest ``None``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>default</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>domyślnie ( - z ang. - default)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All optional arguments and some positional arguments may be omitted at the command-line.  The ``default`` keyword argument of :meth:`add_argument`, whose value defaults to ``None``, specifies what value should be used if the command-line arg is not present.  For optional arguments, the ``default`` value is used when the option string was not present at the command line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie opcjonalne parametry i niektóre parametry pozycyjne mogą być pominięte w wierszu-poleceń. Domyślny - z ang. - ``default`` parametr słowa kluczowego dla sposobu postępowania :meth:`add_argument` którego wartość domyślnie równa jest ``None``, określa która wartość powinna być użyta jeśli parametr wiersza poleceń nie jest obecny. Dla opcjonalnych parametrów wartość ``domyślna`` - z ang. - ``default`` jest używana gdy ciąg znaków opcji nie był obecny w wierszu polecenia::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default=42) &gt;&gt;&gt; parser.parse_args('--foo 2'.split()) Namespace(foo='2') &gt;&gt;&gt; parser.parse_args(''.split()) Namespace(foo=42)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default=42) &gt;&gt;&gt; parser.parse_args('--foo 2'.split()) Namespace(foo='2') &gt;&gt;&gt; parser.parse_args(''.split()) Namespace(foo=42)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For positional arguments with nargs_ ``='?'`` or ``'*'``, the ``default`` value is used when no command-line arg was present::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla pozycyjnych parametrów z nargs_ ``='?'`` lub ``'*'``, domyślna ( - z ang. - ``default`` ) wartość jest używana gdy żadne parametry wiersza-poleceń nie są obecne::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('foo', nargs='?', default=42) &gt;&gt;&gt; parser.parse_args('a'.split()) Namespace(foo='a') &gt;&gt;&gt; parser.parse_args(''.split()) Namespace(foo=42)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('foo', nargs='?', default=42) &gt;&gt;&gt; parser.parse_args('a'.split()) Namespace(foo='a') &gt;&gt;&gt; parser.parse_args(''.split()) Namespace(foo=42)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if the command-line argument was not present.::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarczenie ``default=argparse.SUPPRESS`` powoduje że żadna właściwość nie będzie dodana jeśli parametr wiersza polecenia nie był obecny.::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default=argparse.SUPPRESS) &gt;&gt;&gt; parser.parse_args([]) Namespace() &gt;&gt;&gt; parser.parse_args(['--foo', '1']) Namespace(foo='1')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default=argparse.SUPPRESS) &gt;&gt;&gt; parser.parse_args([]) Namespace() &gt;&gt;&gt; parser.parse_args(['--foo', '1']) Namespace(foo='1')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>type</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, ArgumentParser objects read command-line args in as simple strings. However, quite often the command-line string should instead be interpreted as another type, like a :class:`float`, :class:`int` or :class:`file`.  The ``type`` keyword argument of :meth:`add_argument` allows any necessary type-checking and type-conversions to be performed.  Many common built-in types can be used directly as the value of the ``type`` argument::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie przedmioty ArgumentParser wczytują parametry wiersza-poleceń jako proste ciągi znaków. Jednakże, całkiem często ciąg znaków wiersza-poleceń powinien być interpretowany jako następny typ, jako :class:`float`, :class:`int` lub :class:`file`. parametr słowa kluczowego ``type`` sposobu postępowania :meth:`add_argument` pozwala dowolnym koniecznym sprawdzeniom typu i konwersjom typu aby były przeprowadzone. Wiele wspólnych wbudowanych typów może być użyte bezpośrednio jako wartości parametru ``type``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('foo', type=int) &gt;&gt;&gt; parser.add_argument('bar', type=file) &gt;&gt;&gt; parser.parse_args('2 temp.txt'.split()) Namespace(bar=&lt;open file 'temp.txt', mode 'r' at 0x...&gt;, foo=2)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('foo', type=int) &gt;&gt;&gt; parser.add_argument('bar', type=file) &gt;&gt;&gt; parser.parse_args('2 temp.txt'.split()) Namespace(bar=&lt;open file 'temp.txt', mode 'r' at 0x...&gt;, foo=2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ease the use of various types of files, the argparse module provides the factory FileType which takes the ``mode=`` and ``bufsize=`` arguments of the ``file`` object.  For example, ``FileType('w')`` can be used to create a writable file::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby ułatwić użycie różnych typów plików, moduł argparse dostarcza fabrykę FileType która pobiera parametry ``mode=`` i ``bufsize=`` przedmiotu ``file``. Dla przykładu ``FileType('w')`` może być użyte do utworzenia zapisywalnego pliku::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('bar', type=argparse.FileType('w')) &gt;&gt;&gt; parser.parse_args(['out.txt']) Namespace(bar=&lt;open file 'out.txt', mode 'w' at 0x...&gt;)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('bar', type=argparse.FileType('w')) &gt;&gt;&gt; parser.parse_args(['out.txt']) Namespace(bar=&lt;open file 'out.txt', mode 'w' at 0x...&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``type=`` can take any callable that takes a single string argument and returns the type-converted value::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``type=`` może brać dowolną wywoływalną która pobiera pojedynczy parametr ciągu znaków i zwraca zamienioną według typu wartość::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; def perfect_square(string): ...     value = int(string) ...     sqrt = math.sqrt(value) ...     if sqrt != int(sqrt): ...         msg = "%r is not a perfect square" % string ...         raise argparse.ArgumentTypeError(msg) ...     return value ... &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', type=perfect_square) &gt;&gt;&gt; parser.parse_args('9'.split()) Namespace(foo=9) &gt;&gt;&gt; parser.parse_args('7'.split()) usage: PROG [-h] foo PROG: error: argument foo: '7' is not a perfect square</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; def perfect_square(string): ...     value = int(string) ...     sqrt = math.sqrt(value) ...     if sqrt != int(sqrt): ...         msg = "%r nie jest idealnym kwadratem" % string ...         raise argparse.ArgumentTypeError(msg) ...     return value ... &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', type=perfect_square) &gt;&gt;&gt; parser.parse_args('9'.split()) Namespace(foo=9) &gt;&gt;&gt; parser.parse_args('7'.split()) użycie: PROG [-h] foo PROG: error: parametr foo: '7' nie jest idealnym kwadratem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The choices_ keyword argument may be more convenient for type checkers that simply check against a range of values::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr słowa kluczowego choices_ może być bardziej przydatny dla sprawdzenia typu które po prostu sprawdzają z zakresem wartości::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', type=int, choices=xrange(5, 10)) &gt;&gt;&gt; parser.parse_args('7'.split()) Namespace(foo=7) &gt;&gt;&gt; parser.parse_args('11'.split()) usage: PROG [-h] {5,6,7,8,9} PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', type=int, choices=xrange(5, 10)) &gt;&gt;&gt; parser.parse_args('7'.split()) Namespace(foo=7) &gt;&gt;&gt; parser.parse_args('11'.split()) użycie: PRG [-h] {5,6,7,8,9} PROG: błąd: parametr foo: niewłaściwy wybór: 11 (wybierz z 5, 6, 7, 8, 9)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the choices_ section for more details.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz rozdział choices_ po więcej szczegółów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>choices</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>choices (- z ang. - wybory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some command-line args should be selected from a restricted set of values. These can be handled by passing a container object as the ``choices`` keyword argument to :meth:`add_argument`.  When the command-line is parsed, arg values will be checked, and an error message will be displayed if the arg was not one of the acceptable values::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niektóre parametry wiersza-poleceń powinny być wybierane z ograniczonego zbioru wartości. Takie parametry mogą być obsłużone przez przekazanie przedmiotu kontenera jako parametr ``choices`` dla sposobu postępowania :meth:`add_argument`. Gdy wiersz poleceń jest wczytywany, wartości parametrów zostaną sprawdzone, i wiadomość o błędzie będzie wyświetlona, jeśli parametr nie był jedną z akceptowalnych wartości::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', choices='abc') &gt;&gt;&gt; parser.parse_args('c'.split()) Namespace(foo='c') &gt;&gt;&gt; parser.parse_args('X'.split()) usage: PROG [-h] {a,b,c} PROG: error: argument foo: invalid choice: 'X' (choose from 'a', 'b', 'c')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', choices='abc') &gt;&gt;&gt; parser.parse_args('c'.split()) Namespace(foo='c') &gt;&gt;&gt; parser.parse_args('X'.split()) użycie: PROG [-h] {a,b,c} PROG: błąd: parametr foo: niewłaściwy wybór: 'X' (wybierz z 'a', 'b', 'c')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that inclusion in the ``choices`` container is checked after any type_ conversions have been performed, so the type of the objects in the ``choices`` container should match the type_ specified::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że zawarcie w pojemniku ``choices`` jest sprawdzane po tym jak wszelkie konwersje typu - type_ - zostały wykonane, tak że typ przedmiotów w pojemniku ``choices`` powinien odpowiadać określonemu typowi - type_::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', type=complex, choices=[1, 1j]) &gt;&gt;&gt; parser.parse_args('1j'.split()) Namespace(foo=1j) &gt;&gt;&gt; parser.parse_args('-- -4'.split()) usage: PROG [-h] {1,1j} PROG: error: argument foo: invalid choice: (-4+0j) (choose from 1, 1j)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('foo', type=complex, choices=[1, 1j]) &gt;&gt;&gt; parser.parse_args('1j'.split()) Namespace(foo=1j) &gt;&gt;&gt; parser.parse_args('-- -4'.split()) usage: PROG [-h] {1,1j} PROG: błąd: parametr foo: niewłaściwy wybór: (-4+0j) (wybierz z 1, 1j)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any object that supports the ``in`` operator can be passed as the ``choices`` value, so :class:`dict` objects, :class:`set` objects, custom containers, etc. are all supported.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dowolne przedmioty które wspierają operator ``in`` mogą być przekazywane jako wartość ``choices``, tak że przedmioty słownika - :class:`dict`, przedmioty zbiorów - :class:`set` szczególne pojemniki, itd. są wszystkie wspierane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>required</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wymagane</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, the argparse module assumes that flags like ``-f`` and ``--bar`` indicate *optional* arguments, which can always be omitted at the command-line. To make an option *required*, ``True`` can be specified for the ``required=`` keyword argument to :meth:`add_argument`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ogólnie, moduł argparse zakłada że flagi takie, jak ``-f`` i ``--bar`` wskazują parametry *opcjonalne*, które zawsze mogą być pominięte w wierszu polecenia. Aby uczynić opcję *wymaganą*, ``True`` może być określne dla parametru słowa kluczowego ``required=`` dla sposobu postępowania :meth:`add_argument`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', required=True) &gt;&gt;&gt; parser.parse_args(['--foo', 'BAR']) Namespace(foo='BAR') &gt;&gt;&gt; parser.parse_args([]) usage: argparse.py [-h] [--foo FOO] argparse.py: error: option --foo is required</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', required=True) &gt;&gt;&gt; parser.parse_args(['--foo', 'BAR']) Namespace(foo='BAR') &gt;&gt;&gt; parser.parse_args([]) użycie: argparse.py [-h] [--foo FOO] argparse.py: błąd: opcja --foo jest wymagana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the example shows, if an option is marked as ``required``, :meth:`parse_args` will report an error if that option is not present at the command line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jak pokazuje powyższy przykład, jeśli opcja jest oznaczona jako ``wymagana`` ( - z ang. - ``required``), sposób postępowania :meth:`parse_args` zgłosi błąd jeśli ta opcja nie będzie obecna w wierszu polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Required options are generally considered bad form because users expect *options* to be *optional*, and thus they should be avoided when possible.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcje wymagane są zwykle uważane za niewłaściwą formę ponieważ użytkownicy oczekują *opcji* aby były *opcjonalne*, więc ich konieczność powinna być możliwe do uniknięcia gdy tylko jest to możliwe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>pomoc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``help`` value is a string containing a brief description of the argument. When a user requests help (usually by using ``-h`` or ``--help`` at the command-line), these ``help`` descriptions will be displayed with each argument::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wartość ``help`` jest ciągiem znaków zawierającym krótki opis parametrów. Gdy użytkownik zażąda pomocy (zwykle przez użycie ``-h`` lub ``--help`` w wierszu polecenia), te opisy ``pomocy`` będą wyświetlone z każdym parametrem::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='frobble') &gt;&gt;&gt; parser.add_argument('--foo', action='store_true', ...         help='foo the bars before frobbling') &gt;&gt;&gt; parser.add_argument('bar', nargs='+', ...         help='one of the bars to be frobbled') &gt;&gt;&gt; parser.parse_args('-h'.split()) usage: frobble [-h] [--foo] bar [bar ...]  positional arguments:  bar     one of the bars to be frobbled  optional arguments:  -h, --help  show this help message and exit  --foo   foo the bars before frobbling</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='frobble') &gt;&gt;&gt; parser.add_argument('--foo', action='store_true', ...         help='zfufaj bary przed frobblaniem') &gt;&gt;&gt; parser.add_argument('bar', nargs='+', ...         help='jeden z barów do zfrobblania') &gt;&gt;&gt; parser.parse_args('-h'.split()) użycie: frobble [-h] [--foo] bar [bar ...]  pozycyjne parametry:  bar     jeden z barów do zfrobblania opcjonalne parametry:  -h, --help  pokaż tą wiadomość pomocy i wyjdź  --foo   zfufaj bary przed frobblaniem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``help`` strings can include various format specifiers to avoid repetition of things like the program name or the argument default_.  The available specifiers include the program name, ``%(prog)s`` and most keyword arguments to :meth:`add_argument`, e.g. ``%(default)s``, ``%(type)s``, etc.::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ciągi znaków ``pomocy`` mogą zawierać różne określenia formatu aby uniknąć powtórzeń rzeczy takich jak nazwa programu lub parametru domyślnego - z ang. - default_. Dostępne określenia zawierają nazwę programu, ``%(prog)s`` i większość parametrów słów kluczowych dla sposobu postępowania :meth:`add_argument`, np. ``%(default)s``, ``%(type)s``, itp.::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='frobble') &gt;&gt;&gt; parser.add_argument('bar', nargs='?', type=int, default=42, ...         help='the bar to %(prog)s (default: %(default)s)') &gt;&gt;&gt; parser.print_help() usage: frobble [-h] [bar]  positional arguments:  bar     the bar to frobble (default: 42)  optional arguments:  -h, --help  show this help message and exit</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='frobble') &gt;&gt;&gt; parser.add_argument('bar', nargs='?', type=int, default=42, ...         help='bar dla %(prog)s (domyślnie: %(default)s)') &gt;&gt;&gt; parser.print_help() użycie: frobble [-h] [bar]  pozycyjne parametry:  bar     bar dla frobble (domyślnie: 42)  opcjonalne parametry:  -h, --help  pokaż tą wiadomość pomocy i wyjdź</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>metavar</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>metavar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When :class:`ArgumentParser` generates help messages, it need some way to refer to each expected argument.  By default, ArgumentParser objects use the dest_ value as the "name" of each object.  By default, for positional argument actions, the dest_ value is used directly, and for optional argument actions, the dest_ value is uppercased.  So, a single positional argument with ``dest='bar'`` will that argument will be referred to as ``bar``. A single optional argument ``--foo`` that should be followed by a single command-line arg will be referred to as ``FOO``.  An example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy uogólnienie :class:`ArgumentParser` generuje wiadomości pomocy, potrzebuje pewnego sposobu aby odnieść się do każdego oczekiwanego parametru. Domyślnie, przedmioty ArgumentParser używają wartości dest_ jako "nazwy" każdego przedmiotu. Domyślnie, dla pozycyjnych akcji parametrów wartość dest_ jest używana bezpośrednio, a dla akcji opcjonalnych parametrów, wartość dest_ jest pisana z dużej litery. Więc, pojedynczy pozycyjny parametr z ``dest='bar'```będzie określony jako ``bar``. Pojedynczy opcjonalny parametr ``--foo`` po którym powinien wystąpić pojedynczy parametr wiersza-poleceń będzie określany jako ``FOO``. Na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_args('X --foo Y'.split()) Namespace(bar='X', foo='Y') &gt;&gt;&gt; parser.print_help() usage:  [-h] [--foo FOO] bar  positional arguments:  bar  optional arguments:  -h, --help  show this help message and exit  --foo FOO</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_args('X --foo Y'.split()) Namespace(bar='X', foo='Y') &gt;&gt;&gt; parser.print_help() użycie: [-h] [--foo FOO] bar pozycyjne parametry: bar opcjonalne parametry: -h, --help pokaż tą wiadomość pomocy i wyjdź --foo FOO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative name can be specified with ``metavar``::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Alternatywna nazwa może być określona za pomocą ``metavar``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', metavar='YYY') &gt;&gt;&gt; parser.add_argument('bar', metavar='XXX') &gt;&gt;&gt; parser.parse_args('X --foo Y'.split()) Namespace(bar='X', foo='Y') &gt;&gt;&gt; parser.print_help() usage:  [-h] [--foo YYY] XXX  positional arguments:  XXX  optional arguments:  -h, --help  show this help message and exit  --foo YYY</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', metavar='YYY') &gt;&gt;&gt; parser.add_argument('bar', metavar='XXX') &gt;&gt;&gt; parser.parse_args('X --foo Y'.split()) Namespace(bar='X', foo='Y') parser.print_help() użycie: [-h] [--foo YYY] XXX pozycyjne parametry: XXX opcjonalne parametry: -h, --help pokaż tą wiadomość pomocy i wyjdź --foo YYY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that ``metavar`` only changes the *displayed* name - the name of the attribute on the :meth:`parse_args` object is still determined by the dest_ value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że ``metavar`` tylko zmienia *wyświetlaną* nazwę - nazwa parametru przedmiotu :meth:`parse_args` jest wciąż określana przez wartość dest_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different values of ``nargs`` may cause the metavar to be used multiple times. Providing a tuple to ``metavar`` specifies a different display for each of the arguments::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Różne wartości ``nargs`` mogą spowodować że metavar będzie użyte kilkakrotnie. Dostarczając krotkę do ``metavar`` określa inną wyświetlaną nazwę dla każdego parametru::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x', nargs=2) &gt;&gt;&gt; parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz')) &gt;&gt;&gt; parser.print_help() usage: PROG [-h] [-x X X] [--foo bar baz]  optional arguments:  -h, --help     show this help message and exit  -x X X  --foo bar baz</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x', nargs=2) &gt;&gt;&gt; parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz')) &gt;&gt;&gt; parser.print_help() użycie: PROG [-h] [-x X X] [--foo bar baz] opcjonalne parametry: -h, -help pokaż tą wiadomość pomocy i wyjdź -x X X --foo bar baz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dest</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most :class:`ArgumentParser` actions add some value as an attribute of the object returned by :meth:`parse_args`.  The name of this attribute is determined by the ``dest`` keyword argument of :meth:`add_argument`.  For positional argument actions, ``dest`` is normally supplied as the first argument to :meth:`add_argument`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość działań uogólnienia :class:`ArgumentParser` dodaj pewną wartość jako właściwość przedmiotu zwracaną przez :meth:`parse_args`. Nazwa tej właściwości jest określana przez parametr słowa kluczowego ``dest`` dla sposobu postępowania :meth:`add_argument`. Dla działań parametrów pozycyjnych, ``dest`` jest zwykle dostarczana jako pierwszy parametr dla sposobu postępowania :meth:`add_argument`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_args('XXX'.split()) Namespace(bar='XXX')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_args('XXX'.split()) Namespace(bar='XXX')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For optional argument actions, the value of ``dest`` is normally inferred from the option strings.  :class:`ArgumentParser` generates the value of ``dest`` by taking the first long option string and stripping away the initial ``'--'`` string.  If no long option strings were supplied, ``dest`` will be derived from the first short option string by stripping the initial ``'-'`` character.  Any internal ``'-'`` characters will be converted to ``'_'`` characters to make sure the string is a valid attribute name.  The examples below illustrate this behavior::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla opcjonalnych działań parametrów, wartość ``dest`` jest zwykle wnioskowana z ciągów znaków opcji. Uogólnienie :class:`ArgumentParser` generuje wartość ``dest`` przez wzięcie pierwszego długiego ciągu znaków opcji i odcięciu początkowego ciągu znaków ``'--'``. Jeśli żadna długa opcja nie została dostarczona, ``dest`` będzie pochodną pierwszego krótkiego ciągu opcji przez obcięcie początkowego znaku ``'-'``. Dowolne wewnętrzne znaki ``'-'`` będą zamienione na ``'_'`` aby zapewnić że ciąg znaków jest poprawną nazwą właściwości. Przykłady poniżej ilustrują to zachowanie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('-f', '--foo-bar', '--foo') &gt;&gt;&gt; parser.add_argument('-x', '-y') &gt;&gt;&gt; parser.parse_args('-f 1 -x 2'.split()) Namespace(foo_bar='1', x='2') &gt;&gt;&gt; parser.parse_args('--foo 1 -y 2'.split()) Namespace(foo_bar='1', x='2')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('-f', '--foo-bar', '--foo') &gt;&gt;&gt; parser.add_argument('-x', '-y') &gt;&gt;&gt; parser.parse_args('-f 1 -x 2'.split()) Namespace(foo_bar='1', x='2') &gt;&gt;&gt; parser.parse_args('--foo 1 -y 2'.split()) Namespace(foo_bar='1', x='2')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``dest`` allows a custom attribute name to be provided::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``dest`` pozwala szczególnym nazwom właściwości aby były dostarczane::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', dest='bar') &gt;&gt;&gt; parser.parse_args('--foo XXX'.split()) Namespace(bar='XXX')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', dest='bar') &gt;&gt;&gt; parser.parse_args('--foo XXX'.split()) Namespace(bar='XXX')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parse_args() method</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sposób postępowania parse_args()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert argument strings to objects and assign them as attributes of the namespace.  Return the populated namespace.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień ciągi znaków parametrów na przedmioty i przypisz je jako właściwości przestrzeni nazw. Zwróć zapełnioną przestrzeń nazw.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previous calls to :meth:`add_argument` determine exactly what objects are created and how they are assigned. See the documentation for :meth:`add_argument` for details.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poprzednie wywołania :meth:`add_argument` określają dokładnie, które przedmioty są tworzone i jak są one przypisywane. Zobacz dokumentację dla sposobu postępowania :meth:`add_argument` dla szczegółów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the arg strings are taken from :data:`sys.argv`, and a new empty :class:`Namespace` object is created for the attributes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie ciągi znaków arg są brane z :data:`sys.argv`, i nowa pusta przestrzeń nazw :class:`Namespace` jest tworzona dla właściwości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Option value syntax</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>składnia wartości opcji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`parse_args` method supports several ways of specifying the value of an option (if it takes one).  In the simplest case, the option and its value are passed as two separate arguments::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`parse_args` wspiera kilka sposobów określania wartości opcji (jeśli pobiera ona jedną). W najprostszym przypadku, opcja i jej wartość są przekazywane jako dwa oddzielne parametry::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x') &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.parse_args('-x X'.split()) Namespace(foo=None, x='X') &gt;&gt;&gt; parser.parse_args('--foo FOO'.split()) Namespace(foo='FOO', x=None)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x') &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.parse_args('-x X'.split()) Namespace(foo=None, x='X') &gt;&gt;&gt; parser.parse_args('--foo FOO'.split()) Namespace(foo='FOO', x=None)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For long options (options with names longer than a single character), the option and value can also be passed as a single command line argument, using ``=`` to separate them::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla opcji długich (opcji z nazwami dłuższymi niż pojedynczy znak), opcja i wartość mogą także  być przekazane jako pojedynczy parametr wiersza polecenia, używając ``=`` aby je rozdzielić::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.parse_args('--foo=FOO'.split()) Namespace(foo='FOO', x=None)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.parse_args('--foo=FOO'.split()) Namespace(foo='FOO', x=None)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For short options (options only one character long), the option and its value can be concatenated::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla opcji krótkich (opcji o długości tylko pojedynczego znaku), opcja i jej wartość mogą być połączone::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.parse_args('-xX'.split()) Namespace(foo=None, x='X')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.parse_args('-xX'.split()) Namespace(foo=None, x='X')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Several short options can be joined together, using only a single ``-`` prefix, as long as only the last option (or none of them) requires a value::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>kilka krótkich opcji może być połączone razem, używając tylko pojedynczego znaku przedrostka ``-``, tak długo jak tylko ostatnia opcja (lub żadna z nich) wymaga wartości::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x', action='store_true') &gt;&gt;&gt; parser.add_argument('-y', action='store_true') &gt;&gt;&gt; parser.add_argument('-z') &gt;&gt;&gt; parser.parse_args('-xyzZ'.split()) Namespace(x=True, y=True, z='Z')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x', action='store_true') &gt;&gt;&gt; parser.add_argument('-y', action='store_true') &gt;&gt;&gt; parser.add_argument('-z') &gt;&gt;&gt; parser.parse_args('-xyzZ'.split()) Namespace(x=True, y=True, z='Z')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invalid arguments</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nieważne parametry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While parsing the command-line, ``parse_args`` checks for a variety of errors, including ambiguous options, invalid types, invalid options, wrong number of positional arguments, etc.  When it encounters such an error, it exits and prints the error along with a usage message::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podczas wczytywania wiersza polecenia, ``parse_args`` sprawdza różne błędy, zawierające wieloznaczne opcje, nieważne typy, nieważne opcje, niewłaściwe liczby parametrów pozycyjnych, itp. Gdy napotka ona taki błąd, wychodzi ona i wypisuje błąd razem z wiadomością użycia::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--foo', type=int) &gt;&gt;&gt; parser.add_argument('bar', nargs='?')  &gt;&gt;&gt; # invalid type &gt;&gt;&gt; parser.parse_args(['--foo', 'spam']) usage: PROG [-h] [--foo FOO] [bar] PROG: error: argument --foo: invalid int value: 'spam'  &gt;&gt;&gt; # invalid option &gt;&gt;&gt; parser.parse_args(['--bar']) usage: PROG [-h] [--foo FOO] [bar] PROG: error: no such option: --bar  &gt;&gt;&gt; # wrong number of arguments &gt;&gt;&gt; parser.parse_args(['spam', 'badger']) usage: PROG [-h] [--foo FOO] [bar] PROG: error: extra arguments found: badger</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--foo', type=int) parser.add_argument('bar', nargs='?') &gt;&gt;&gt; # niewłaściwy typ &gt;&gt;&gt; parser.parse_args('[--foo', 'spam']) użycie: PROG [-h] [--foo FOO] [bar] PROG: error: argument --foo: niewłaściwa wartość całkowita: 'spam' &gt;&gt;&gt; # niewłaściwa opcja &gt;&gt;&gt; parser.parse_args(['--bar']) użycie: PROG [-h] [--foo FOO] [bar] PROG: błąd: brak takiej opcji: --bar &gt;&gt;&gt; # nieprawidłowa liczba argumentów &gt;&gt;&gt; parser.parse_args(['spam', 'borsuk']) użycie: PROG [-h] [--foo FOO] [bar] PROG: błąd: nadmiarowe parametry napotkane: borsuk</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arguments containing ``"-"``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry zawierające ``"-"``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``parse_args`` method attempts to give errors whenever the user has clearly made a mistake, but some situations are inherently ambiguous.  For example, the command-line arg ``'-1'`` could either be an attempt to specify an option or an attempt to provide a positional argument.  The ``parse_args`` method is cautious here: positional arguments may only begin with ``'-'`` if they look like negative numbers and there are no options in the parser that look like negative numbers::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania ``parse_args`` próbuje dawać błędy za każdym razem gdy użytkownik w jasny sposób się pomylił, ale niektóre sytuacje są samoistnie wieloznaczne. Dla przykładu, parametr wiersza-poleceń ``'-1'`` może być albo próbą określenia opcji lub próbą dostarczenia parametru pozycyjnego. Sposób postępowania ``parse_args`` jest ostrożny tutaj: pozycyjne parametry mogą zaczynać się tylko od ``'-'`` jeśli wyglądają jak liczby ujemne i nie ma opcji w czytniku która wyglądałaby jak liczba ujemna::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x') &gt;&gt;&gt; parser.add_argument('foo', nargs='?')  &gt;&gt;&gt; # no negative number options, so -1 is a positional argument &gt;&gt;&gt; parser.parse_args(['-x', '-1']) Namespace(foo=None, x='-1')  &gt;&gt;&gt; # no negative number options, so -1 and -5 are positional arguments &gt;&gt;&gt; parser.parse_args(['-x', '-1', '-5']) Namespace(foo='-5', x='-1')  &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-1', dest='one') &gt;&gt;&gt; parser.add_argument('foo', nargs='?')  &gt;&gt;&gt; # negative number options present, so -1 is an option &gt;&gt;&gt; parser.parse_args(['-1', 'X']) Namespace(foo=None, one='X')  &gt;&gt;&gt; # negative number options present, so -2 is an option &gt;&gt;&gt; parser.parse_args(['-2']) usage: PROG [-h] [-1 ONE] [foo] PROG: error: no such option: -2  &gt;&gt;&gt; # negative number options present, so both -1s are options &gt;&gt;&gt; parser.parse_args(['-1', '-1']) usage: PROG [-h] [-1 ONE] [foo] PROG: error: argument -1: expected one argument</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-x') &gt;&gt;&gt; parser.add_argument('foo', nargs='?') &gt;&gt;&gt; # brak opcji liczb ujemnych, więc -1 jest pozycyjnym parametrem &gt;&gt;&gt; parser.parse_args(['-x', '-1'] Namespace(foo=None, x='-1') &gt;&gt;&gt; # brak opcji liczb ujemnych, więc -1 i -5 są parametrami pozycyjnymi &gt;&gt;&gt; parser.parse_args(['-x', '-1', '-5']) Namespace(foo='-5', x='-1') &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-1', dest='one') &gt;&gt;&gt; parser.add_argument('foo', nargs='?') &gt;&gt;&gt; # opcje ujemnych liczb obecne, więc -1 jest opcją &gt;&gt;&gt; parser.parse_args(['-1', 'X']) Namespace(foo=None, one='X') &gt;&gt;&gt; # obecne opcje liczb ujemnych wiec -2 jest opcją &gt;&gt;&gt; parser.parse_args['-2']) użycie: PROG [-h] [-1 ONE] [foo] PROG: błąd: brak takiej opcji: -2 &gt;&gt;&gt; # opcje liczb ujemnych obecne, więc oba zapisy -1 są opcjami &gt;&gt;&gt; parser. parse_args(['-1', '-1']) użycie: PROG [-h] [-1 ONE] [foo] PROG: błąd: parametr -1: oczekiwano pojedynczego parametru</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have positional arguments that must begin with ``'-'`` and don't look like negative numbers, you can insert the pseudo-argument ``'--'`` which tells ``parse_args`` that everything after that is a positional argument::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli masz pozycyjne parametry które muszą zaczynać się od ``'-'`` i nie wyglądają jak liczby ujemne, możesz wstawić pseudo parametr ``'--'`` który mówi ``parse_args``, że wszystko potem jest parametrem pozycyjnym::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.parse_args(['--', '-f']) Namespace(foo='-f', one=None)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.parse_args(['--', '-f']) Namespace(foo='-f', one=None)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Argument abbreviations</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skróty parametrów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`parse_args` method allows long options to be abbreviated if the abbreviation is unambiguous::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`parse_args` pozwala na skracanie długich opcji jeśli skrót nie jest wieloznaczny::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-bacon') &gt;&gt;&gt; parser.add_argument('-badger') &gt;&gt;&gt; parser.parse_args('-bac MMM'.split()) Namespace(bacon='MMM', badger=None) &gt;&gt;&gt; parser.parse_args('-bad WOOD'.split()) Namespace(bacon=None, badger='WOOD') &gt;&gt;&gt; parser.parse_args('-ba BA'.split()) usage: PROG [-h] [-bacon BACON] [-badger BADGER] PROG: error: ambiguous option: -ba could match -badger, -bacon</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('-bolak') &gt;&gt;&gt; parser.add_argument('-borsuk') &gt;&gt;&gt; parser.parse_args('-bol MMM'.split()) Namespace(bolak='MMM', borsuk=None) &gt;&gt;&gt; parser.parse_args('-bor DRZEWO'.split()) Namespace(bolak=None, borsuk='DRZEWO') &gt;&gt;&gt; parser.parse_args('-bo BO'.split()) użycie:PROG [-h] [-bolak BOLAK] [-borsuk BORSUK] PROG: błąd: wieloznaczna opcja -bo może pasować do borsuka i bolaka  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An error is produced for arguments that could produce more than one options.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Błąd jest tworzony dla parametrów które mogłyby stworzyć więcej niż jedną opcję.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond ``sys.argv``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poza ``sys.argv``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it may be useful to have an ArgumentParser parse args other than those of :data:`sys.argv`.  This can be accomplished by passing a list of strings to ``parse_args``.  This is useful for testing at the interactive prompt::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami może być użyteczne wczytanie parametrów przez uogólnienie ArgumentParser innych niż te z :data:`sys.argv`. To można osiągnąć przez przekazanie listy ciągów znaków dla ``parse_args``. To jest użyteczne dla testowania współdziałającego wiersza zapytań::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument( ...     'integers', metavar='int', type=int, choices=xrange(10), ...  nargs='+', help='an integer in the range 0..9') &gt;&gt;&gt; parser.add_argument( ...     '--sum', dest='accumulate', action='store_const', const=sum, ...   default=max, help='sum the integers (default: find the max)') &gt;&gt;&gt; parser.parse_args(['1', '2', '3', '4']) Namespace(accumulate=&lt;built-in function max&gt;, integers=[1, 2, 3, 4]) &gt;&gt;&gt; parser.parse_args('1 2 3 4 --sum'.split()) Namespace(accumulate=&lt;built-in function sum&gt;, integers=[1, 2, 3, 4])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument( ... 'integers', metavar='int', type=int, choices=xrange(10), ... nargs='+', help='liczba całkowita z przedziału 0..9') &gt;&gt;&gt; parser.add_argument( ... '--sum', dest='accumulate', action='store_const', const=sum, ... default=max, help='suma liczb całkowitych (domyślnie: znajdź maksimum)') &gt;&gt;&gt; parser.parse_args(['1', '2', '3', '4']) Namespace(accumulate=&lt;zadanie wbudowane max&gt;, integers=[1, 2, 3, 4]) &gt;&gt;&gt; parser.parse_args('1 2 3 4 --sum'.split()) Namespace(accumulate=&lt;zadanie wbudowane sum&gt;, integers=[1, 2, 3, 4])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom namespaces</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Szczególne przestrzenie nazw</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It may also be useful to have an :class:`ArgumentParser` assign attributes to an already existing object, rather than the newly-created :class:`Namespace` object that is normally used.  This can be achieved by specifying the ``namespace=`` keyword argument::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To może być także użyteczne, aby uogólnienie :class:`ArgumentParser` przypisało właściwości do już istniejącego przedmiotu, zamiast do nowo-tworzonego przedmiotu :class:`Namespace`. To można osiągnąć przez użycie parametru słowa kluczowego ``namespace=``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; class C(object): ...     pass ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.parse_args(args=['--foo', 'BAR'], namespace=c) &gt;&gt;&gt; c.foo 'BAR'</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; class C(object): ... pass ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo') &gt;&gt;&gt; parser.parse_args(args=['--foo', 'BAR'], namespace=c) &gt;&gt;&gt; c.foo 'BAR'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other utilities</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Inne użytki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sub-commands</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podrzędne polecenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many programs split up their functionality into a number of sub-commands, for example, the ``svn`` program can invoke sub-commands like ``svn checkout``, ``svn update``, and ``svn commit``.  Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. :class:`ArgumentParser` supports the creation of such sub-commands with the :meth:`add_subparsers` method.  The :meth:`add_subparsers` method is normally called with no arguments and returns an special action object.  This object has a single method, ``add_parser``, which takes a command name and any :class:`ArgumentParser` constructor arguments, and returns an :class:`ArgumentParser` object that can be modified as usual.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wiele programów dzieli swoje możliwości działania na pewną liczbę podrzędnych poleceń, na przykład program svn może wywoływać podrzędne polecenia takie jak ``svn checkout``, ``svn update``, i ``svn commit``. Dzielenie możliwości działania w ten sposób może być szczególnie dobrym pomysłem gdy program wykonuje kilka różnych działań które wymagają różnego rodzaju parametrów wiersza-poleceń. Uogólnienie :class:`ArgumentParser` wspiera tworzenie takich podrzędnych poleceń za pomocą sposobu postępowania :meth:`add_subparsers. Sposób postępowania :meth:`add_subparsers` jest zwykle wywoływany bez parametrów i zwraca szczególny przedmiot działania. Ten przedmiot ma pojedynczy sposób postępowania, ``add_parser``, który pobiera nazwę polecenia i dowolne parametry konstruktora, i zwraca przedmiot :class:`ArgumentParser`, który może być modyfikowany w znane sposoby.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some example usage::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pewne przykładowe użycie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; # create the top-level parser &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--foo', action='store_true', help='foo help') &gt;&gt;&gt; subparsers = parser.add_subparsers(help='sub-command help') &gt;&gt;&gt; &gt;&gt;&gt; # create the parser for the "a" command &gt;&gt;&gt; parser_a = subparsers.add_parser('a', help='a help') &gt;&gt;&gt; parser_a.add_argument('bar', type=int, help='bar help') &gt;&gt;&gt; &gt;&gt;&gt; # create the parser for the "b" command &gt;&gt;&gt; parser_b = subparsers.add_parser('b', help='b help') &gt;&gt;&gt; parser_b.add_argument('--baz', choices='XYZ', help='baz help') &gt;&gt;&gt; &gt;&gt;&gt; # parse some arg lists &gt;&gt;&gt; parser.parse_args(['a', '12']) Namespace(bar=12, foo=False) &gt;&gt;&gt; parser.parse_args(['--foo', 'b', '--baz', 'Z']) Namespace(baz='Z', foo=True)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; # stwórz nadrzędnego poziomu czytnik &gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; parser.add_argument('--foo', action='store_true', help='pomoc foo') &gt;&gt;&gt; subparsers = parser.add_subparsers(help='pomoc podrzędnego polecenia') &gt;&gt;&gt; &gt;&gt;&gt; # utwórz czytnik dla polecenia "a" &gt;&gt;&gt; parser_a = subparsers.add_parser('a', help='pomoc a') &gt;&gt;&gt; parser_a.add_argument('bar', type=int, help='pomoc bar') &gt;&gt;&gt; &gt;&gt;&gt; # utwórz czytnik dla polecenia "b" &gt;&gt;&gt; parser_b = subparsers.add_parser('b', help='pomoc b') &gt;&gt;&gt; parser_b.add_argument('--baz', choices='XYZ', help='pomoc baz') &gt;&gt;&gt; &gt;&gt;&gt; # wczytaj pewne listy parametrów &gt;&gt;&gt; parser.parse_args(['a', '12']) Namespace(bar=12, foo=False) &gt;&gt;&gt; parser.parse_args(['--foo', 'b', '--baz', 'Z']) Namespace(baz='Z', foo=True)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the object returned by :meth:`parse_args` will only contain attributes for the main parser and the subparser that was selected by the command line (and not any other subparsers).  So in the example above, when the ``"a"`` command is specified, only the ``foo`` and ``bar`` attributes are present, and when the ``"b"`` command is specified, only the ``foo`` and ``baz`` attributes are present.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że przedmiot zwracany przez sposób postępowania :meth:`parse_args` będzie zawierał tylko właściwości dla głównego czytnika i podrzędnego czytnika, który został wybrany przez wiersz polecenia (i żadne inne podrzędne czytniki). Więc w powyższym przykładzie gdy polecenie ``"a"`` jest określane, tylko właściwości ``foo`` i ``bar`` są obecne, i gdy polecenie ``"b"`` jest określane, tylko właściwości ``foo`` i ``baz`` są obecne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, when a help message is requested from a subparser, only the help for that particular parser will be printed.  The help message will not include parent parser or sibling parser messages.  (A help message for each subparser command, however, can be given by supplying the ``help=`` argument to ``add_parser`` as above.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobnie, gdy wiadomość pomocy jest oczekiwana od podrzędnego czytnika, tylko pomoc dla tego konkretnego czytnika będzie wypisana. Wiadomość pomocy nie będzie zawierała czytnika nadrzędnego ani wiadomości siostrzanych czytników. (Wiadomość pomocy dla każdego polecenia podrzędnego czytnika, może być podana przez dostarczenie parametru ``help=`` dla ``add_parser`` jak powyżej.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser.parse_args(['--help']) usage: PROG [-h] [--foo] {a,b} ...  positional arguments:   {a,b}   sub-command help a     a help b     b help  optional arguments:   -h, --help  show this help message and exit   --foo   foo help  &gt;&gt;&gt; parser.parse_args(['a', '--help']) usage: PROG a [-h] bar  positional arguments:   bar     bar help  optional arguments:   -h, --help  show this help message and exit  &gt;&gt;&gt; parser.parse_args(['b', '--help']) usage: PROG b [-h] [--baz {X,Y,Z}]  optional arguments:   -h, --help     show this help message and exit   --baz {X,Y,Z}  baz help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser.parse_args(['--help']) użycie: PROG [-h] [--foo] {a,b} ... pozycyjne parametry: {a,b} pomoc podrzędnych poleceń a a pomoc b b pomoc opcjonalne parametry: -h, --help pokaż tą wiadomość pomocy i wyjdź --foo pomoc foo &gt;&gt;&gt; parser.parse_args(['a', '--help']) użycie: PROG a [-h] bar pozycyjne parametry: -h, --help pokaż tą wiadomość pomocy i wyjdź &gt;&gt;&gt; parser.parse_args(['b', '--help']) użycie: PROG b [-h] [--baz {X,Y,Z}] opcjonalne parametry: -h --help pokaż tą wiadomość pomocy i wyjdź --baz {X,Y,Z} pomoc baz </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`add_subparsers` method also supports ``title`` and ``description`` keyword arguments.  When either is present, the subparser's commands will appear in their own group in the help output.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`add_subparsers` także wspiera parametry słów kluczowych ``tytuł`` i ``opis`` - z ang - ``title`` i ``description``. Gdy którykolwiek z nich jest obecny, podrzędne polecenia będą pojawiały się w swoich własnych grupach w wyjściu produkowanym przez pomoc. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; subparsers = parser.add_subparsers(title='subcommands', ...                                    description='valid subcommands', ...                                    help='additional help') &gt;&gt;&gt; subparsers.add_parser('foo') &gt;&gt;&gt; subparsers.add_parser('bar') &gt;&gt;&gt; parser.parse_args(['-h']) usage:  [-h] {foo,bar} ...  optional arguments:   -h, --help  show this help message and exit  subcommands:   valid subcommands    {foo,bar}   additional help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; subparsers = parser.add_subparsers(title='podrzędne polecenia', ... description='poprawne podrzędne polecenia', ... help='dodatkowa pomoc') &gt;&gt;&gt; subparsers.add_parser('foo') &gt;&gt;&gt; subparsers.add_parser('bar') &gt;&gt;&gt; parser.parse_args(['-h']) użycie: [-h] {foo,bar} ... opcjonalne parametry: -h --help pokaż tą wiadomość pomocy i wyjdź podrzędne polecenia: poprawne podrzędne polecenia {foo,bar} dodatkowa pomoc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One particularly effective way of handling sub-commands is to combine the use of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` so that each subparser knows which Python function it should execute.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jednym ze szczególnie efektywnych sposobów obsługi podrzędnych poleceń jest połączenie użycia :meth:`add_subparsers` z wywołaniami :meth:`set_defaults` tak że każdy podrzędny czytnik wie które zadanie powinien wykonywać. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; # sub-command functions &gt;&gt;&gt; def foo(args): ...     print(args.x * args.y) ... &gt;&gt;&gt; def bar(args): ...     print('((%s))' % args.z) ... &gt;&gt;&gt; # create the top-level parser &gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; subparsers = parser.add_subparsers() &gt;&gt;&gt; &gt;&gt;&gt; # create the parser for the "foo" command &gt;&gt;&gt; parser_foo = subparsers.add_parser('foo') &gt;&gt;&gt; parser_foo.add_argument('-x', type=int, default=1) &gt;&gt;&gt; parser_foo.add_argument('y', type=float) &gt;&gt;&gt; parser_foo.set_defaults(func=foo) &gt;&gt;&gt; &gt;&gt;&gt; # create the parser for the "bar" command &gt;&gt;&gt; parser_bar = subparsers.add_parser('bar') &gt;&gt;&gt; parser_bar.add_argument('z') &gt;&gt;&gt; parser_bar.set_defaults(func=bar) &gt;&gt;&gt; &gt;&gt;&gt; # parse the args and call whatever function was selected &gt;&gt;&gt; args = parser.parse_args('foo 1 -x 2'.split()) &gt;&gt;&gt; args.func(args) 2.0 &gt;&gt;&gt; &gt;&gt;&gt; # parse the args and call whatever function was selected &gt;&gt;&gt; args = parser.parse_args('bar XYZYX'.split()) &gt;&gt;&gt; args.func(args) ((XYZYX))</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; # podrzędne zadania &gt;&gt;&gt; def foo(args): ... print(args.x * args.y) ... &gt;&gt;&gt; def bar(args): ... print('((%s))' % args.z) ... &gt;&gt;&gt; #utwórz nadrzędnego poziomu czytnik &gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; subparsers = parser.add_subparsers() &gt;&gt;&gt; # utwórz czytnik dla polecenia "foo" &gt;&gt;&gt; parser_foo = subparsers.add_parser('foo') &gt;&gt;&gt; parser_foo.add_argument('-x', type=int, default=1) &gt;&gt;&gt; parser_foo.add_argument('y', type=float) &gt;&gt;&gt; parser_foo.set_defaults(func=foo) &gt;&gt;&gt; &gt;&gt;&gt; # utwórz czytnik dla polecenia "bar" &gt;&gt;&gt; parser_bar = subparsers.add_parser('bar') &gt;&gt;&gt; parser_bar.add_argument('z') &gt;&gt;&gt; parser_bar.set_defaults(func=bar) &gt;&gt;&gt; &gt;&gt;&gt; # wczytaj parametry i wywołaj to zadanie które zostało wybrane &gt;&gt;&gt; args = parser.parse_args('foo 1 -x 2'.split()) &gt;&gt;&gt; args.func(args) 2.0 &gt;&gt;&gt; &gt;&gt;&gt; # wczytaj parametry i wywołaj dowolne zadanie które zostało wybrane &gt;&gt;&gt; args = parser.parse_args('bar XYZYX'.split()) &gt;&gt;&gt; args.func(args) ((XYZYX))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This way, you can let :meth:`parse_args` does the job of calling the appropriate function after argument parsing is complete.  Associating functions with actions like this is typically the easiest way to handle the different actions for each of your subparsers.  However, if it is necessary to check the name of the subparser that was invoked, the ``dest`` keyword argument to the :meth:`add_subparsers` call will work::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tym sposobem możesz pozwolić aby sposób postępowania :meth:`parse_args` wykona pracę wywołania odpowiedniego zadania po dokończeniu wczytywania parametrów. Połączenie zadań z działaniami w ten sposób jest typowo najłatwiejszym sposobem aby obsłużyć różne działania każdego z podrzędnych czynników. Jednakże, jeśli jest konieczne sprawdzenie nazwy podrzędnego czytnika który został wywołany, parametr słowa kluczowego ``dest`` dla wywołania sposobu postępowania :meth:`add_subparsers` będzie działał::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; subparsers = parser.add_subparsers(dest='subparser_name') &gt;&gt;&gt; subparser1 = subparsers.add_parser('1') &gt;&gt;&gt; subparser1.add_argument('-x') &gt;&gt;&gt; subparser2 = subparsers.add_parser('2') &gt;&gt;&gt; subparser2.add_argument('y') &gt;&gt;&gt; parser.parse_args(['2', 'frobble']) Namespace(subparser_name='2', y='frobble')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; subparsers = parser.add_subparsers(dest='subparser_name') &gt;&gt;&gt; subparser1 = subparsers.add_parser('1') &gt;&gt;&gt; subparser1.add_argument('-x') &gt;&gt;&gt; subparser2 = subparsers.add_parser('2') &gt;&gt;&gt; subparser2.add_argument('y') &gt;&gt;&gt; parser.parse_args(['2', 'frobble']) Namespace(subparser_name='2', y='frobble')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FileType objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmioty FileType</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`FileType` factory creates objects that can be passed to the type argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:`FileType` objects as their type will open command-line args as files with the requested modes and buffer sizes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Fabryka :class:`FileType` tworzy przedmioty które mogą być przekazywane dla typu parametru sposobu postępowania :meth:`ArgumentParser.add_argument`. Parametry które mają przedmioty uogólnienia :class:`FileType` jako ich typ otwierają parametry wiersza-polecenia jako pliki z żądanymi trybami i rozmiarami przestrzeni wymiany:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--output', type=argparse.FileType('wb', 0)) &gt;&gt;&gt; parser.parse_args(['--output', 'out']) Namespace(output=&lt;open file 'out', mode 'wb' at 0x...&gt;)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--output', type=argparse.FileType('wb', 0)) &gt;&gt;&gt; parser.parse_args(['--output', 'out']) Namespace(output=&lt;otwarty plik 'out', tryb 'wb' w 0x...&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FileType objects understand the pseudo-argument ``'-'`` and automatically convert this into ``sys.stdin`` for readable :class:`FileType` objects and ``sys.stdout`` for writable :class:`FileType` objects:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty FileType rozróżniają pseudo-parametr ``'-'`` i automatycznie zamieniają go w ``sys.stdin`` dla czytelnych przedmiotów :class:`FileType` i ``sys.stdout`` dla możliwych do zapisania przedmiotów :class:`FileType`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('infile', type=argparse.FileType('r')) &gt;&gt;&gt; parser.parse_args(['-']) Namespace(infile=&lt;open file '&lt;stdin&gt;', mode 'r' at 0x...&gt;)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('infile', type=argparse.FileType('r')) &gt;&gt;&gt; parser.parse_args(['-']) Namespace(infile=&lt;open file '&lt;stdin&gt;', mode 'r' at 0x...&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Argument groups</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Grupy parametrów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, :class:`ArgumentParser` groups command-line arguments into "positional arguments" and "optional arguments" when displaying help messages. When there is a better conceptual grouping of arguments than this default one, appropriate groups can be created using the :meth:`add_argument_group` method::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślnie uogólnienie :class:`ArgumentParser` grupuje parametry wiersza-polecenia w "parametry pozycyjne" i "parametry opcjonalne" podczas wyświetlania wiadomości pomocy. Gdy istnieje lepszy koncept zgrupowania parametrów niż ten domyślny, właściwe grupy mogą być tworzone przy użyciu sposobu postępowania :meth:`add_argument_group`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', add_help=False) &gt;&gt;&gt; group = parser.add_argument_group('group') &gt;&gt;&gt; group.add_argument('--foo', help='foo help') &gt;&gt;&gt; group.add_argument('bar', help='bar help') &gt;&gt;&gt; parser.print_help() usage: PROG [--foo FOO] bar  group:   bar    bar help   --foo FOO  foo help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', add_help=False) &gt;&gt;&gt; grupa = parser.add_argument_group('grupa') &gt;&gt;&gt; group.add_argument('--foo', help='foo help') &gt;&gt;&gt; group.add_argument('bar', help='bar help') &gt;&gt;&gt; parser.print_help() użycie: PROG [--foo FOO] bar  grupa:   bar    pomoc bar    --foo FOO  foo help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`add_argument_group` method returns an argument group object which has an :meth:`~ArgumentParser.add_argument` method just like a regular :class:`ArgumentParser`.  When an argument is added to the group, the parser treats it just like a normal argument, but displays the argument in a separate group for help messages.  The :meth:`add_argument_group` method accepts ``title`` and ``description`` arguments which can be used to customize this display::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`add_argument_group` zwraca przedmiot grupy parametrów, który ma sposób postępowania :meth:`~ArgumentParser.add_argument` tak jak zwykłe uogólnienie :class:`ArgumentParser`. Gdy parametr jest dodawany do grupy czytnik traktuje go jak zwykły parametr, ale wyświetla parametr w oddzielnej grupie dla wiadomości pomocy. Sposób postępowania :meth:`add_argument_group` akceptuje parametry ``title i ``description`` - z ang. - ``tytuł`` i ``opis``, które mogą być użyte do dostosowania wyświetlania::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', add_help=False) &gt;&gt;&gt; group1 = parser.add_argument_group('group1', 'group1 description') &gt;&gt;&gt; group1.add_argument('foo', help='foo help') &gt;&gt;&gt; group2 = parser.add_argument_group('group2', 'group2 description') &gt;&gt;&gt; group2.add_argument('--bar', help='bar help') &gt;&gt;&gt; parser.print_help() usage: PROG [--bar BAR] foo  group1:   group1 description    foo    foo help  group2:   group2 description    --bar BAR  bar help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG', add_help=False) &gt;&gt;&gt; group1 = parser.add_argument_group('group1', 'opis group1') &gt;&gt;&gt; group1.add_argument('foo', help='pomoc foo') &gt;&gt;&gt; group2 = parser.add_argument_group('group2', 'opis group2') &gt;&gt;&gt; group2.add_argument('--bar', help='pomoc bar') &gt;&gt;&gt; parser.print_help() użycie: PROG [--bar BAR] foo  group1:   opis group1    foo    pomoc foo  group2:   opis group2    --bar BAR  pomoc bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that any arguments not your user defined groups will end up back in the usual "positional arguments" and "optional arguments" sections.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że wszelkie parametry nie w twoich zdefiniowanych grupach skończą z powrotem w dotychczasowych sekcjach "parametrów pozycyjnych" i "parametrach opcjonalnych".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutual exclusion</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wzajemne wykluczenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a mutually exclusive group. argparse will make sure that only one of the arguments in the mutually exclusive group was present on the command line::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stwórz wzajemnie wykluczającą się grupę. argparse będzie pilnował żeby tylko pojedynczy parametr we wzajemnie wykluczających się grupach był obecny w wierszu poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; group = parser.add_mutually_exclusive_group() &gt;&gt;&gt; group.add_argument('--foo', action='store_true') &gt;&gt;&gt; group.add_argument('--bar', action='store_false') &gt;&gt;&gt; parser.parse_args(['--foo']) Namespace(bar=True, foo=True) &gt;&gt;&gt; parser.parse_args(['--bar']) Namespace(bar=False, foo=False) &gt;&gt;&gt; parser.parse_args(['--foo', '--bar']) usage: PROG [-h] [--foo | --bar] PROG: error: argument --bar: not allowed with argument --foo</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser  = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; group = parser.add_mutually_exclusive_group() &gt;&gt;&gt; group.add_argument('--foo', action='store_true') &gt;&gt;&gt; group.add_argument('--bar', action='store_false') &gt;&gt;&gt; parser.parse_args(['--foo']) Namespace(bar=True, foo=True) &gt;&gt;&gt; parser.parse_args(['--bar']) Namespace(bar=False, foo=False) &gt;&gt;&gt; parser.parse_args(['--foo', '--bar']) użycie: PROG [-h] [--foo | --bar] PROG: błąd: parametr --bar: nie dozwolony z parametrem --foo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`add_mutually_exclusive_group` method also accepts a ``required`` argument, to indicate that at least one of the mutually exclusive arguments is required::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`add_mutually_exclusive_group` przyjmuje także parametr ``wymagane`` - z ang. - ``required``, aby wskazać że co najmniej jeden z wzajemnie wykluczających się parametrów jest wymagany::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; group = parser.add_mutually_exclusive_group(required=True) &gt;&gt;&gt; group.add_argument('--foo', action='store_true') &gt;&gt;&gt; group.add_argument('--bar', action='store_false') &gt;&gt;&gt; parser.parse_args([]) usage: PROG [-h] (--foo | --bar) PROG: error: one of the arguments --foo --bar is required</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG') &gt;&gt;&gt; group = parser.add_mutually_exclusive_group(required=True) &gt;&gt;&gt; group.add_argument('--foo', action='store_true') &gt;&gt;&gt; group.add_argument('--bar', action='store_false') &gt;&gt;&gt; parser.parse_args([]) użycie: PROG [-h] (--foo | --bar) PROG: błąd: jeden z parametrów --foo --bar jest wymagany</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that currently mutually exclusive argument groups do not support the ``title`` and ``description`` arguments of :meth:`add_argument_group`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że obecnie wzajemnie wykluczające się grupy parametrów nie wspierają parametrów ``tytułu`` i ``opisu`` - z ang. - ``title`` i ``description`` dla sposobu postępowania :meth:`add_argument_group`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parser defaults</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślne czytnika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time, the attributes of the object returned by :meth:`parse_args` will be fully determined by inspecting the command-line args and the argument actions.  :meth:`ArgumentParser.set_defaults` allows some additional attributes that are determined without any inspection of the command-line to be added::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W większości przypadków, właściwości przedmiotów zwracanych przez :meth:`parse_args` w pełni są określone przez sprawdzenie parametrów wiersza poleceń i akcji parametrów. Sposób postępowania :meth:`ArgumentParser.set_defaults` pozwala na dodanie pewnych dodatkowych właściwości określanych bez żadnego sprawdzenia wiersza poleceń::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('foo', type=int) &gt;&gt;&gt; parser.set_defaults(bar=42, baz='badger') &gt;&gt;&gt; parser.parse_args(['736']) Namespace(bar=42, baz='badger', foo=736)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('foo', type=int) &gt;&gt;&gt; parser.set_defaults(bar=42, baz='borsuk') &gt;&gt;&gt; parser.parse_args(['736']) Namespace(bar=42, baz='borsuk', foo=736)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that parser-level defaults always override argument-level defaults::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że wartości domyślne na poziomie czytnika zawsze przesłaniają wartości domyślne na poziomie parametrów::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default='bar') &gt;&gt;&gt; parser.set_defaults(foo='spam') &gt;&gt;&gt; parser.parse_args([]) Namespace(foo='spam')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default='bar') &gt;&gt;&gt; parser.set_defaults(foo='spam') &gt;&gt;&gt; parser.parse_args([]) Namespace(foo='spam')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parser-level defaults can be particularly useful when working with multiple parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an example of this type.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartości domyślne na poziomie czytnika mogą być szczególnie użyteczne podczas pracy z kilkoma czytnikami. Zobacz sposób postępowania :meth:`~ArgumentParser.add_subparsers` dla przykładu tego typu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the default value for a namespace attribute, as set by either :meth:`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Weź wartość domyślną dla przestrzeni nazw, jak ustalono przez :meth:`~ArgumentParser.add_argument` lub przez :meth:`~ArgumentParser.set_defaults`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default='badger') &gt;&gt;&gt; parser.get_default('foo') 'badger'</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', default='borsuk') &gt;&gt;&gt; parser.get_default('foo') 'borsuk'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Printing help</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisywanie pomocy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most typical applications, :meth:`parse_args` will take care of formatting and printing any usage or error messages.  However, several formatting methods are available:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W najbardziej typowych aplikacjach, :meth:`parse_args` zaopiekuje się formatowaniem i wypisywaniem dowolnych wiadomości o użyciu lub błędzie. Jednakże, kilka sposobów formatowania jest możliwych:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print a brief description of how the :class:`ArgumentParser` should be invoked on the command line.  If ``file`` is not present, ``sys.stderr`` is assumed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisz krótki opis tego jak :class:`ArgumentParser` powinien być wywoływany w wierszu poleceń. Jeśli plik ``file`` nie jest obecny, ``sys.stderr`` jest zakładany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print a help message, including the program usage and information about the arguments registered with the :class:`ArgumentParser`.  If ``file`` is not present, ``sys.stderr`` is assumed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisz wiadomość pomocy, zawierając użycie programu i informacje o parametrach zarejestrowanych przez uogólnienie :class:`ArgumentParser`. Jeśli parametr ``file`` nie jest obecny, ``sys.stderr`` jest podstawiany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are also variants of these methods that simply return a string instead of printing it:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją także odmiany tych sposobów postępowania które po prostu zwracają ciąg znaków zamiast drukować go:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a string containing a brief description of how the :class:`ArgumentParser` should be invoked on the command line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć ciąg znaków zawierający krótki opis tego, jak :class:`ArgumentParser` powinien być wywoływany w wierszu poleceń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a string containing a help message, including the program usage and information about the arguments registered with the :class:`ArgumentParser`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć ciąg znaków zawierający wiadomość pomocy, zawierający użycie programu, i informacje o parametrach zarejestrowanych za pomocą uogólnienia :class:`ArgumentParser`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Partial parsing</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Częściowe wczytywanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes a script may only parse a few of the command line arguments, passing the remaining arguments on to another script or program. In these cases, the :meth:`parse_known_args` method can be useful.  It works much like :meth:`~ArgumentParser.parse_args` except that it does not produce an error when extra arguments are present.  Instead, it returns a two item tuple containing the populated namespace and the list of remaining argument strings.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czasami skrypt może wczytać tylko kilka parametrów wiersza polecenia, przekazując pozostałe parametry dla innego skryptu lub programu. W tych przypadkach, sposób postępowania :meth:`parse_known_args` może być użyteczna. Pracuje ona tak jak :meth:`~ArgumentParser.parse_args` z wyjątkiem tego że nie produkuje ona błędu gdy dodatkowe parametry są obecne. Zamiast tego, zwraca dwuelementową krotkę zawierającą zapełnioną przestrzeń nazw i listę pozostałych ciągów znaków parametrów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='store_true') &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam']) (Namespace(bar='BAR', foo=True), ['--badger', 'spam'])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; parser = argparse.ArgumentParser() &gt;&gt;&gt; parser.add_argument('--foo', action='store_true') &gt;&gt;&gt; parser.add_argument('bar') &gt;&gt;&gt; parser.parse_known_args(['--foo', '--borsuk', 'BAR', 'spam']) (Namespace(bar='BAR', foo=True), ['--borsuk', 'spam'])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing file parsing</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostosowywanie wczytywania plików</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arguments that are read from a file (see the ``fromfile_prefix_chars`` keyword argument to the :class:`ArgumentParser` constructor) are read one argument per line. :meth:`convert_arg_line_to_args` can be overriden for fancier reading.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry, które są wczytywane z pliku (zobacz parametr słowa kluczowego ``fromfile_prefix_chars`` dla konstruktora uogólnienia :class:`ArgumentParser`) są wczytywane po jednym parametrze na linię. :meth:`convert_arg_line_to_args` może być przesłonięte dla ciekawszych wczytywań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method takes a single argument ``arg_line`` which is a string read from the argument file.  It returns a list of arguments parsed from this string. The method is called once per line read from the argument file, in order.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania pobiera pojedynczy parametr ``arg_line`` który jest ciągiem znaków wczytywanym z parametru pliku. Zwraca listę parametrów wczytanych z tego ciągu znaków. Sposób postępowania jest wywoływany jeden raz na linię wczytaną z parametru pliku w porządku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A useful override of this method is one that treats each space-separated word as an argument::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użytecznym przesłonięciem tego sposobu postępowania jest to które traktuje każde oddzielone odstępem słowo jako parametr::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def convert_arg_line_to_args(self, arg_line):     for arg in arg_line.split():         if not arg.strip():             continue         yield arg</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def convert_arg_line_to_args(self, arg_line):     for arg in arg_line.split():         if not arg.strip():             continue         yield arg</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Upgrading optparse code</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostosowywanie kodu optparse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Originally, the argparse module had attempted to maintain compatibility with optparse.  However, optparse was difficult to extend transparently, particularly with the changes required to support the new ``nargs=`` specifiers and better usage messages.  When most everything in optparse had either been copy-pasted over or monkey-patched, it no longer seemed practical to try to maintain the backwards compatibility.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pierwotnie, moduł argparse próbował zachować zgodność z modułem optparse. Jednakże, optparse był trudny do rozszerzenia w przejrzysty sposób, szczególnie ze zmianami wymaganymi dla wsparcia nowych określeń ``nargs=`` i lepszymi wiadomościami o użyciu. Gdy prawie wszystko z optparse zostało praktycznie skopiowane lub połatane, nie wydawało się praktycznym dalej utrzymywać wsteczną zgodność. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A partial upgrade path from optparse to argparse:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Droga częściowego dostosowania z optparse na argparse: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace all ``add_option()`` calls with :meth:`ArgumentParser.add_argument` calls.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień wszystkie wywołania ``add_option()`` na wywołania :meth:`ArgumentParser.add_argument`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace ``options, args = parser.parse_args()`` with ``args = parser.parse_args()`` and add additional :meth:`ArgumentParser.add_argument` calls for the positional arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień ``options, args = parser.parse_args()`` na ``args = parser.parse_args()`` i dodaj dodatkowe wywołania :meth:`ArgumentParser.add_argument` dla parametrów pozycyjnych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace callback actions and the ``callback_*`` keyword arguments with ``type`` or ``action`` arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień akcje wywołań wstecznych i parametry słów kluczowych ``callback_*`` na parametry ``type`` lub ``action`` z ang. - ``typ`` lub ``akcja``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace string names for ``type`` keyword arguments with the corresponding type objects (e.g. int, float, complex, etc).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień nazwy w ciągach znaków na parametry słów kluczowych ``type`` z odpowiadającymi przedmiotami typu (np. int, float, complex, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace :class:`optparse.Values` with :class:`Namespace` and :exc:`optparse.OptionError` and :exc:`optparse.OptionValueError` with :exc:`ArgumentError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień :class:`optparse.Values` na :class:`Namespace` i :exc:`optparse.OptionError` i :exc:`optparse.OptionValueError` na :exc:`ArgumentError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace strings with implicit arguments such as ``%default`` or ``%prog`` with the standard python syntax to use dictionaries to format strings, that is, ``%(default)s`` and ``%(prog)s``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień ciągi znaków z domyślnymi parametrami takimi jak ``%default`` lub ``%prog`` na standardową składnię języka pytonowskiego aby użyć słowników dla formatowania ciągów znaków, to jest ``%(default)s`` i ``%(prog)s``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace the OptionParser constructor ``version`` argument with a call to ``parser.add_argument('--version', action='version', version='&lt;the version&gt;')``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień parametr konstruktora OptionParser  ``version`` na wywołanie ``parser.add_argument('--version', action='version', version='&lt;the version&gt;')``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`array` --- Efficient arrays of numeric values</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`array` --- Efektywne tablice wartości numerycznych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module defines an object type which can compactly represent an array of basic values: characters, integers, floating point numbers.  Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained.  The type is specified at object creation time by using a :dfn:`type code`, which is a single character.  The following type codes are defined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł definiuje typ przedmiotu który może w zwarty sposób reprezentować tabelę podstawowych wartości: znaków, liczb całkowitych, liczb zmiennoprzecinkowych. Tablice są typami sekwencyjnymi i zachowują się bardzo podobnie do list, z wyjątkiem tego, że typy przedmiotów zachowanych w nich są ograniczone. Typ jest określony w czasie tworzenia przedmiotu przez użycie :dfn:`kodu typu` który jest pojedynczym znakiem. Następujące kody typów są określone:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type code</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kod typu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C Type</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ języka C </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python Type</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Minimum size in bytes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Minimalny rozmiar w bajtach</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'b'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'b'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>signed char</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ znakowy z bitem znaku</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'B'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'B'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unsigned char</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nieoznaczony typ znakowy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'u'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'u'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Py_UNICODE</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Py_UNICODE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unicode character</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>znak Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2 (see note)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2 (zobacz notatkę)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'h'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'h'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>signed short</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>oznaczony typ krótki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'H'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'H'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unsigned short</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nieoznaczony typ krótki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'i'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'i'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>signed int</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>oznaczony typ int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'I'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'I'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unsigned int</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nieoznaczony typ int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'l'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'I'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>signed long</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>oznaczony typ długi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>4</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'L'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'L'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unsigned long</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nieoznaczony typ długi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'f'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'f'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>float</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ (float) zmiennoprzecinkowy pojedynczej precyzji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'d'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'d'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>double</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>typ (double) zmiennoprzecinkowy podwójnej precyzji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``'u'`` typecode corresponds to Python's unicode character.  On narrow Unicode builds this is 2-bytes, on wide builds this is 4-bytes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kod typu ``'u'`` odpowiada znakowi Unicode języka pytonowskiego. Na "wąskiej" budowie Unikodu to jest 2-bajtowe, na szerokiej budowie unikodu to jest 4-bajtowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The actual representation of values is determined by the machine architecture (strictly speaking, by the C implementation).  The actual size can be accessed through the :attr:`itemsize` attribute.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aktualna reprezentacja wartości jest określana przez architekturę maszyny (ściśle mówiąc przez wypełnienie C). Konkretny rozmiar może być dostępny przez właściwość :attr:`itemsize`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module defines the following type:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł definiuje następujący typ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A new array whose items are restricted by *typecode*, and initialized from the optional *initializer* value, which must be a list, object supporting the buffer interface, or iterable over elements of the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nowa tablica której elementy są ograniczone przez *typecode*, i zainicjowane przez opcjonalną wartość *initializer*, która musi być listą, przedmiotem obsługującym sprzęg przestrzeni wymiany, lub możliwa do iteracji ponad elementami odpowiedniego typu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If given a list or string, the initializer is passed to the new array's :meth:`fromlist`, :meth:`fromstring`, or :meth:`fromunicode` method (see below) to add initial items to the array.  Otherwise, the iterable initializer is passed to the :meth:`extend` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli podano listę lub ciąg znaków, element inicjujący jest przekazywany do właściwego dla nowej tabeli sposobu postępowania :meth:`fromlist`, lub :meth:`fromstring`, lub :meth:`fromunicode` (zobacz poniżej) aby dodać początkowe wartości dla tablicy. W przeciwnym razie, możliwy do iterowania element inicjujący jest przekazywany dla sposobu postępowania :meth:`extend`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obsolete alias for :class:`array`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przestarzały synonim uogólnienia :class:`array`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A string with all available type codes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ciąg ze wszystkimi dostępnymi kodami typów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Array objects support the ordinary sequence operations of indexing, slicing, concatenation, and multiplication.  When using slice assignment, the assigned value must be an array object with the same type code; in all other cases, :exc:`TypeError` is raised. Array objects also implement the buffer interface, and may be used wherever buffer objects are supported.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty tabeli wspierają zwykłe operacje na sekwencjach, indeksowania, wycinka, łączenia i powielania. Gdy używa się przypisań wycinków, przypisywana wartość musi być przedmiotem tabeli o tym samym kodzie typu; we wszystkich innych przypadkach wyjątek :exc:`TypeError` jest zgłaszany. Przedmioty tabeli wypełniają także sprzęg przestrzeni wymiany, i mogą być używane wszędzie gdzie przedmioty przestrzeni wymiany są wspierane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following data items and methods are also supported:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące elementy danych i sposobów postępowania są także wspierane:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The typecode character used to create the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Znak kodujący typ używany do tworzenia tabeli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The length in bytes of one array item in the internal representation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>długość w bajtach (kęsach) jednego elementu tabeli w wewnętrznym przedstawieniu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Append a new item with value *x* to the end of the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj nowy element o wartości *x* na koniec tabeli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a tuple ``(address, length)`` giving the current memory address and the length in elements of the buffer used to hold array's contents.  The size of the memory buffer in bytes can be computed as ``array.buffer_info()[1] * array.itemsize``.  This is occasionally useful when working with low-level (and inherently unsafe) I/O interfaces that require memory addresses, such as certain :cfunc:`ioctl` operations.  The returned numbers are valid as long as the array exists and no length-changing operations are applied to it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć krotkę ``(adres, długość)`` dającą obecny adres w pamięci i długość w ilości elementów przestrzeni wymiany używanej do przechowywania zawartości tabeli. Rozmiar przestrzeni wymiany w kęsach (bajtach) może być obliczony jako ``array.buffer_info()[1] * array.itemsize`` To jest czasami przydatne gdy pracuje się z niskopoziomowymi (i samym przez się mniej bezpiecznym) sprzęgami wejścia/wyjścia które wymagają adresów pamięci, takich jak niektóre operacje :cfunc:`ioctl`. Zwracane liczby są ważne dopóki tabela istnieje i nie są wykonywane na niej operacje zmieniające jej długość.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using array objects from code written in C or C++ (the only way to effectively make use of this information), it makes more sense to use the buffer interface supported by array objects.  This method is maintained for backward compatibility and should be avoided in new code.  The buffer interface is documented in :ref:`bufferobjects`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy używa się tablic z kodu napisanego w języku C lub C++ (jedyna droga aby efektywnie skorzystać z tej informacji), to jest to bardziej sensowne aby użyć sprzęgu przestrzeni wymiany który jest wspierany przez przedmioty tablicowe. Ten sposób postępowania jest utrzymywany dla wstecznej zgodności i powinien być pomijany w nowym kodzie. Sprzęg przestrzeni wymiany jest opisany w :ref:`bufferobjects`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Byteswap" all items of the array.  This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, :exc:`RuntimeError` is raised.  It is useful when reading data from a file written on a machine with a different byte order.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Zamień miejscami kęsy" - z ang. - "Byteswap" wszystkie elementy tablicy. To jest wspierane tylko dla wartości które są 1, 2, 4, lub 8 w rozmiarze; dla innych typów wartości wyjątek :exc:`RuntimeError` jest zgłaszany. Jest to użyteczne gdy wczytuje się dane z pliku zapisanym na maszynie o odmiennym porządku bajtów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the number of occurrences of *x* in the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć liczbę wystąpień *x* w tablicy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Append items from *iterable* to the end of the array.  If *iterable* is another array, it must have *exactly* the same type code; if not, :exc:`TypeError` will be raised.  If *iterable* is not an array, it must be iterable and its elements must be the right type to be appended to the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przyklej elementy z przedmiotu *iterowalnego* na koniec tablicy. Jeśli *iterowalny* jest kolejną tablicą, musi mieć *dokładnie* ten sam typ kodu; Jeśli nie, wyjątek :exc:`TypeError będzie zgłoszony. Jeśli *iterowalny* nie jest tablicą, musi być iterowalny i jego elementy muszą być właściwego typu aby mogły być doklejone do tablicy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read *n* items (as machine values) from the file object *f* and append them to the end of the array.  If less than *n* items are available, :exc:`EOFError` is raised, but the items that were available are still inserted into the array. *f* must be a real built-in file object; something else with a :meth:`read` method won't do.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj *n* elementów (jako wartości maszyny) z przedmiotu pliku *f* i doklej je na koniec tablicy. Jeśli mniej niż *n* elementów jest dostępnych, :exc:`EOFError` jest zgłaszany, ale elementy które były dostępne są wciąż wstawiane do tablicy. *f* musi być rzeczywistym wbudowanym przedmiotem pliku; coś innego ze sposobem postępowania :meth:`read` nie wystarczy zamiast.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Append items from the list.  This is equivalent to ``for x in list: a.append(x)`` except that if there is a type error, the array is unchanged.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Doklej elementy z listy. To jest równoważne z ``for x in list: a.append(x)`` z wyjątkiem tego, że jeśli wystąpi błąd typu, tablica pozostanie niezmieniona. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Appends items from the string, interpreting the string as an array of machine values (as if it had been read from a file using the :meth:`fromfile` method).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dokleja elementy z ciągu znaków, interpretując ciąg jako tablicę wartości maszynowych (tak jakby były one wszytane z pliku używając sposobu postępowania :meth:`fromfile`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extends this array with data from the given unicode string.  The array must be a type ``'u'`` array; otherwise a :exc:`ValueError` is raised.  Use ``array.fromstring(unicodestring.encode(enc))`` to append Unicode data to an array of some other type.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerza tą tablicę za pomocą danych z danego ciągu znaków Unicode. Tablica musi być typu ``'u'``; w przeciwnym razie :exc:`ValueError` jest zgłaszany. Użyj ``array.fromstring(unicodestring.encode(enc))`` aby dopisać dane Unicode do tablicy innego typu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the smallest *i* such that *i* is the index of the first occurrence of *x* in the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć najmniejszy *i* taki że *i* jest indeksem pierwszego wystąpienia *x* w tablicy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert a new item with value *x* in the array before position *i*. Negative values are treated as being relative to the end of the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wstaw nowy element o wartości *x* w tabeli przed pozycją *i*. Ujemne wartości są traktowane jako będące odniesieniem do pozycji od końca tabeli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes the item with the index *i* from the array and returns it. The optional argument defaults to ``-1``, so that by default the last item is removed and returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuwa element o indeksie *i* z tablicy i zwraca go. Opcjonalny parametr domyślnie jest ``-1``, tak aby domyślnie ostatni element był usuwany i zwracany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the first occurrence of *x* from the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuń pierwsze wystąpienie *x* w tabeli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reverse the order of the items in the array.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odwróć kolejność elementów w tabeli.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write all items (as machine values) to the file object *f*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz wszystkie elementy (jako wartości maszynowe) do przedmiotu pliku *f*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the array to an ordinary list with the same items.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień tabelę na zwykłą listę o tych samych elementach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the array to an array of machine values and return the string representation (the same sequence of bytes that would be written to a file by the :meth:`tofile` method.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień tablicę na tablicę wartości maszynowych i zwróć reprezentację ciągu znaków (tę samą sekwencję bajtów która byłaby zapisana do pliku przez sposób postępowania :meth:`tofile`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the array to a unicode string.  The array must be a type ``'u'`` array; otherwise a :exc:`ValueError` is raised. Use ``array.tostring().decode(enc)`` to obtain a unicode string from an array of some other type.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień tablicę na ciąg znaków Unicode. Tablica musi być tablicą typu ``'u'``; w przeciwnym przypadku wyjątek :exc:`ValueError` jest zgłaszany. Użyj ``array.tostring().decode(enc)`` aby uzyskać ciąg znaków Unicode z tablicy innego typu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an array object is printed or converted to a string, it is represented as ``array(typecode, initializer)``.  The *initializer* is omitted if the array is empty, otherwise it is a string if the *typecode* is ``'u'``, otherwise it is a list of numbers.  The string is guaranteed to be able to be converted back to an array with the same type and value using :func:`eval`, so long as the :func:`array` function has been imported using ``from array import array``. Examples::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy przedmiot tablicy jest wypisywany lub zamieniany na ciąg znaków, jest on reprezentowany jako ``array(typecode, initializer)`` - z ang - ``tablica(kod typu, wartość inicjująca)`` *Wartość inicjująca* jest pomijana jeśli tablica jest pusta, w przeciwnym przypadku jest to ciąg znaków jeśli *kodem typu* jest ``'u'``, w przeciwnym razie jest to lista liczb. Ciąg znaków ma gwarantowane że będzie możliwy do skonwertowania wstecz na tablicę o tym samym typie i wartości używając zadania :func:`eval`, dopóty dopóki zadanie :func:`array` ( - z ang. - tablica) zostało zaimportowane używając ``from array import array``. Przykłady::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>array('l') array('u', 'hello \u2641') array('l', [1, 2, 3, 4, 5]) array('d', [1.0, 2.0, 3.14])</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>array('l') array('u', 'hello \u2641') array('l', [1, 2, 3, 4, 5]) array('d', [1.0, 2.0, 3.14])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packing and unpacking of heterogeneous binary data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pakowanie i odpakowanie jednorodnych danych binarnych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packing and unpacking of External Data Representation (XDR) data as used in some remote procedure call systems.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pakowanie i odpakowanie Danych  Zewnętrznej Reprezentacji (XDR) ( - z ang. - External Data Representation) jak używano w pewnych systemach zewnętrznego wywoływania procedur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Numeric Python extension (NumPy) defines another array type; see http://numpy.sourceforge.net/ for further information about Numerical Python. (A PDF version of the NumPy manual is available at http://numpy.sourceforge.net/numdoc/numdoc.pdf).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerzenie języka pytonowskiego numerycznego  (z ang. - NumPy) definiuje inny typ tablicowy; zobacz http://numpy.sourceforge.net/ dla dalszych informacji o numerycznym języku Pyton. (Wersja PDF podręcznika NumPy jest dostępna pod adresem http://numpy.sourceforge.net/numdoc/numdoc.pdf).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abstract Syntax Trees</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjne Drzewa Składniowe - z ang. - Abstract Syntax Trees</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`ast` module helps Python applications to process trees of the Python abstract syntax grammar.  The abstract syntax itself might change with each Python release; this module helps to find out programmatically what the current grammar looks like.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`ast` pomaga aplikacjom języka pytonowskiego przetwarzać drzewa abstrakcyjnych gramatyk składni języka pytonowskiego. Abstrakcyjna składnia sama w sobie może ulegać zmianom w każdym wydaniu języka pytonowskiego; ten moduł pozwala dowiedzieć się programowo, jak wygląda obecna gramatyka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An abstract syntax tree can be generated by passing :data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using the :func:`parse` helper provided in this module.  The result will be a tree of objects whose classes all inherit from :class:`ast.AST`.  An abstract syntax tree can be compiled into a Python code object using the built-in :func:`compile` function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjne drzewo składniowe może być wygenerowane przez przekazanie :data:`ast.PyCF_ONLY_AST` jako flagi dla zadania wbudowanego :func:`compile`, lub używając zadania :func:`parse` - pomocnika dostarczonego z tym modułem. Wynikiem będzie drzewo przedmiotów którego uogólnienia wszystkie dziedziczą po :class:`ast.AST`. Abstrakcyjne drzewo składniowe może być kompilowane do przedmiotu kodu języka pytonowskiego używając wbudowanego zadania :func:`compile`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Node classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienia węzła - z ang. - node</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the base of all AST node classes.  The actual node classes are derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:`below &lt;abstract-grammar&gt;`.  They are defined in the :mod:`_ast` C module and re-exported in :mod:`ast`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest podstawą wszystkich uogólnień węzła AST - z ang. - AST node classes. Konkretne uogólnienia węzła dziedziczą po pliku :file:`Parser/Python.asdl` który jest reprodukowany :ref:`poniżej &lt;abstrakcyjnej-gramatyki&gt;. Są one określone w module języka C :mod:`_ast` i ponownie eksportowane w module :mod:`ast`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one class defined for each left-hand side symbol in the abstract grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees.  For example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production rules with alternatives (aka "sums"), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje jedno uogólnienie określone dla każdego symbolu lewej strony w abstrakcyjnej gramatyce (na przykład, :class:`ast.stmt` lub :class:`ast.expr`). Na dodatek, istnieje jedno uogólnienie określone dla każdego konstruktora prawej-strony; te uogólnienia dziedziczą po uogólnieniach drzew lewej strony. Dla przykładu, :class:`ast.BinOp` dziedziczy po :class:`ast.expr`. Dla reguł produkcji z alternatywami (in. "sum"), lewa strona jest abstrakcyjna: tylko przykłady szczególnych węzłów konstruktorów są w ogóle kiedykolwiek tworzone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each concrete class has an attribute :attr:`_fields` which gives the names of all child nodes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każde konkretne uogólnienie ma właściwość :attr:`_fields` która daje nazwy wszystkich węzłów potomnych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each instance of a concrete class has one attribute for each child node, of the type as defined in the grammar.  For example, :class:`ast.BinOp` instances have an attribute :attr:`left` of type :class:`ast.expr`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każdy przykład konkretnego uogólnienia ma jedną właściwość dla każdego węzła potomnego, o typie zdefiniowanym w gramatyce. Dla przykładu przykłady :class:`ast.BinOp` mają właściwość :attr:`left` o typie :class:`ast.expr`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If these attributes are marked as optional in the grammar (using a question mark), the value might be ``None``.  If the attributes can have zero-or-more values (marked with an asterisk), the values are represented as Python lists.  All possible attributes must be present and have valid values when compiling an AST with :func:`compile`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli te właściwości są oznaczone jako opcjonalne w gramatyce (używając znaku zapytania) wartość może być ``None``. Jeśli właściwości mogą mieć zero-lub-więcej wartości (określonych za pomocą gwiazdki), wartości są reprezentowane jako listy języka Pyton. Wszystkie możliwe właściwości muszą być obecne i mieć właściwe wartości gdy kompiluje się AST za pomocą zadania :func:`compile`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:`lineno` and :attr:`col_offset` attributes.  The :attr:`lineno` is the line number of source text (1-indexed so the first line is line 1) and the :attr:`col_offset` is the UTF-8 byte offset of the first token that generated the node.  The UTF-8 offset is recorded because the parser uses UTF-8 internally.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnień podrzędnych względem :class:`ast.expr` i :class:`ast.stmt` mają właściwości :attr:`lineno` i :attr:`col_offset`. Właściwość :attr:`lineno` jest numerem wiersza w źródłowym tekście (indeksowanym od jednego tak że pierwsza linia odpowiada 1) i :attr:`col_offset` jest przesunięciem w bajtach UTF-8 pierwszego elementu składniowego który wygenerował węzeł. Przesunięcie UTF-8 jest zapisywane ponieważ czytnik używa UTF-8 wewnętrznie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The constructor of a class :class:`ast.T` parses its arguments as follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor uogólnienia :class:`ast.T` wczytuje swoje parametry jak następuje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are positional arguments, there must be as many as there are items in :attr:`T._fields`; they will be assigned as attributes of these names.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli są parametry pozycyjne, musi być ich tak wiele, jak jest elementów w :attr:`T._fields`; będą przypisane jako właściwości o tych nazwach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are keyword arguments, they will set the attributes of the same names to the given values.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli istnieją parametry słów kluczowych, ustawią one wartości tych samych nazw na zadane wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to create and populate an :class:`ast.UnaryOp` node, you could use ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, aby utworzyć i zapełnić węzeł :class:`ast.UnaryOp`, można użyć::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>node = ast.UnaryOp() node.op = ast.USub() node.operand = ast.Num() node.operand.n = 5 node.operand.lineno = 0 node.operand.col_offset = 0 node.lineno = 0 node.col_offset = 0</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>node = ast.UnaryOp() node.op = ast.USub() node.operand = ast.Num() node.operand.n = 5 node.operand.lineno = 0 node.operand.col_offset = 0 node.lineno = 0 node.col_offset = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or the more compact ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>lub bardziej zwięźle ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>node = ast.UnaryOp(ast.USub(), ast.Num(5, lineno=0, col_offset=0),                    lineno=0, col_offset=0)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>node = ast.UnaryOp(ast.USub(), ast.Num(5, lineno=0, col_offset=0),                    lineno=0, col_offset=0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abstract Grammar</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjna Gramatyka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module defines a string constant ``__version__`` which is the decimal Subversion revision number of the file shown below.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł definiuje stałą ciągu znaków ``__version__`` która jest dziesiątkową liczbą porządkową numerem rewizji Subversion pliku pokazanego poniżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The abstract grammar is currently defined as follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjna gramatyka jest obecnie określona jak następuje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`ast` Helpers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pomocnicy modułu :mod:`ast` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apart from the node classes, :mod:`ast` module defines these utility functions and classes for traversing abstract syntax trees:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poza uogólnieniami węzła, moduł :mod:`ast` definiuje następujące zadania pomocnicze i uogólnienia dla przeglądania abstrakcyjnych drzew składniowych:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse an expression into an AST node.  Equivalent to ``compile(expr, filename, mode, ast.PyCF_ONLY_AST)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj wyrażenie do węzła AST. Równoważne z ``compile(expr, filename, mode, ast.PyCF_ONLY_AST)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Safely evaluate an expression node or a string containing a Python expression.  The string or node provided may only consist of the following Python literal structures: strings, numbers, tuples, lists, dicts, booleans, and ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bezpiecznie przelicz węzeł wyrażenia lub ciąg zawierający wyrażenie języka Pyton. Ciąg znaków lub dostarczony węzeł mogą tylko składać się z następujących struktur literałów języka Pyton: ciągów, liczb, krotek, list, słowników, wartości logicznych i ``None`` - z ang. - ``Żaden``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To może być używane dla bezpiecznego obliczania ciągów zawierających wyrażenia języka Pyton z niezaufanych źródeł, bez konieczności przeliczania wartości własnoręcznie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the docstring of the given *node* (which must be a :class:`FunctionDef`, :class:`ClassDef` or :class:`Module` node), or ``None`` if it has no docstring.  If *clean* is true, clean up the docstring's indentation with :func:`inspect.cleandoc`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć ciąg dokumentacji dla danego *węzła* (który musi być węzłem :class:`FunctionDef` lub :class:`ClassDef` lub :class:`Module`), lub ``None`` jeśli nie ma ciągu dokumentacji. Jeśli *clean* jest prawdziwe, posprzątaj wcięcia ciągu dokumentacji za pomocą zadania :func:`inspect.cleandoc`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you compile a node tree with :func:`compile`, the compiler expects :attr:`lineno` and :attr:`col_offset` attributes for every node that supports them.  This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node.  It works recursively starting at *node*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy kompilujesz drzewo węzła za pomocą zadania :func:`compile`, kompilator oczekuje właściwości :attr:`lineno` i :attr:`col_offset` dla każdego węzła które wspiera te właściwości. Jest raczej nużącym wypełnianie wygenerowanych węzłów, więc ten element pomocniczy dodaje te właściwości rekursywnie tam gdzie nie zostały one jeszcze ustawione, przez ustawienie ich na wartości węzła nadrzędnego. Pracuje rekursywnie zaczynając od *węzła* - z ang. - *node*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment the line number of each node in the tree starting at *node* by *n*. This is useful to "move code" to a different location in a file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwiększ numer linii każdego węzła w drzewie zaczynając od *węzła* o *n*. To jest użyteczne aby przesunąć kod do innego położenia w pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy source location (:attr:`lineno` and :attr:`col_offset`) from *old_node* to *new_node* if possible, and return *new_node*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skopiuj źródłowe położenie (właściwości :attr:`lineno` i :attr:`col_offset`) ze *starego węzła* - z ang. - *old_node* do *nowego węzła* - z ang. - *new_node* jeśli to możliwe, i zwróć *nowy węzeł* - z ang. - *new_node*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` that is present on *node*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydaj dwójkę ``(nazwa pola, wartość)`` - z ang. - ``(fieldname, value)`` dla każdego pola w ``node._fields`` które jest obecne w *węźle* - z ang. - *node*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yield all direct child nodes of *node*, that is, all fields that are nodes and all items of fields that are lists of nodes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydaj wszystkie bezpośrednie węzły potomne *węzła*, to jest, wszystkie pola które są węzłami i wszystkie elementy pól które są listami węzłów. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Recursively yield all child nodes of *node*, in no specified order.  This is useful if you only want to modify nodes in place and don't care about the context.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rekurencyjnie wydaj wszystkie potomne węzły *węzła* - z ang. *node* bez szczególnego porządku. To jest użyteczne jeśli chcesz tylko zmienić węzły w miejscu i nie chcesz troszczyć się o kontekst.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found.  This function may return a value which is forwarded by the :meth:`visit` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie podstawowe wizytującego węzły który przegląda drzewo abstrakcyjnej składni i wywołuje zadanie wizyty dla każdego znalezionego węzła. To zadanie może zwrócić wartość która jest przekazywana przez sposób postępowania :meth:`visit`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class is meant to be subclassed, with the subclass adding visitor methods.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie jest przeznaczone do wystawienia uogólnienia podrzędnego względem niego, z uogólnieniem podrzędnym dodającym sposoby postępowania wizytujące.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visit a node.  The default implementation calls the method called :samp:`self.visit_{classname}` where *classname* is the name of the node class, or :meth:`generic_visit` if that method doesn't exist.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odwiedź węzeł. Domyślne wypełnienie wywołuje sposób postępowania zwany :samp:`self.visit_{nazwauogolnienia}` gdzie *nazwauogolnienia* jest nazwą uogólnienia węzła, lub :meth:`generic_visit` - zastępczych odwiedzin jeśli ten sposób postępowania nie istnieje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This visitor calls :meth:`visit` on all children of the node.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te odwiedzający wywołuje sposób postępowania :meth:`visit` we wszystkich węzłach potomnych węzła.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that child nodes of nodes that have a custom visitor method won't be visited unless the visitor calls :meth:`generic_visit` or visits them itself.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że węzły potomne węzłów które mają dostosowany sposób postępowania odwiedzin nie będą odwiedzane chyba że wizytujący wywoła sposób postępowania :meth:`generic_visit` lub odwiedzi je samodzielnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't use the :class:`NodeVisitor` if you want to apply changes to nodes during traversal.  For this a special visitor exists (:class:`NodeTransformer`) that allows modifications.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie używaj uogólnienia :class:`NodeVisitor` jeśli chcesz zastosować zmiany dla węzłów w czasie przeglądania. Do tego celu służy specjalny odwiedzający (:class:`NodeTransformer`), który pozwala na modyfikacje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`NodeVisitor` subclass that walks the abstract syntax tree and allows modification of nodes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`NodeVisitor` podrzędne które przegląda abstrakcyjne drzewo składni i pozwala na modyfikację węzłów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`NodeTransformer` will walk the AST and use the return value of the visitor methods to replace or remove the old node.  If the return value of the visitor method is ``None``, the node will be removed from its location, otherwise it is replaced with the return value.  The return value may be the original node in which case no replacement takes place.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`NodeTransformer` będzie przeglądało AST (abstrakcyjne drzewo składniowe) i użyje wartości zwracanej sposobu postępowania odwiedzającego do zamiany lub usunięcia starego węzła. Jeśli wartość zwracana sposobu postępowania odwiedzającego jest ``Żadna`` - z ang. - ``None``, węzeł będzie usunięty z jego położenia, w przeciwnym razie zostanie zamieniony na wartość zwracaną. Wartość zwracana może być oryginalnym węzłem w którym to przypadku żadna podmiana nie ma miejsca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example transformer that rewrites all occurrences of name lookups (``foo``) to ``data['foo']``::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest przykładowy zamiennik, który przepisuje wszystkie wystąpienia podejrzeń nazwy (``foo``) na ``data['foo']``::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class RewriteName(NodeTransformer):      def visit_Name(self, node):         return copy_location(Subscript(             value=Name(id='data', ctx=Load()),             slice=Index(value=Str(s=node.id)),             ctx=node.ctx         ), node)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class RewriteName(NodeTransformer):      def visit_Name(self, node):         return copy_location(Subscript(             value=Name(id='data', ctx=Load()),             slice=Index(value=Str(s=node.id)),             ctx=node.ctx         ), node)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth:`generic_visit` method for the node first.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pamiętaj że jeśli węzeł na którym wykonujesz operacje ma węzły potomne musisz albo transformować węzły potomne własnoręcznie albo wywołać sposób postępowania :meth:`generic_visit` dla węzła najpierw.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla węzłów które były częścią kolekcji stwierdzeń (to dotyczy wszystkich węzłów stwierdzeń), odwiedzający może także zwrócić listę węzłów zamiast pojedynczego węzła.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually you use the transformer like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwykle używa się zamiennika takiego jak ten::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>node = YourTransformer().visit(node)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>node = YourTransformer().visit(node)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a formatted dump of the tree in *node*.  This is mainly useful for debugging purposes.  The returned string will show the names and the values for fields.  This makes the code impossible to evaluate, so if evaluation is wanted *annotate_fields* must be set to False.  Attributes such as line numbers and column offsets are not dumped by default.  If this is wanted, *include_attributes* can be set to ``True``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć sformatowany zrzut drzewa w węźle. To jest głównie użyteczne dla celów debugowania. Zwrócony ciąg znaków pokaże nazwy i wartości pól. To powoduje że kod jest niemożliwy do obliczenia, więc jeśli obliczenie jest oczekiwane *annotate_fields* musi być ustawione na Fałsz. Właściwości takie jak numery linii i przesunięcia kolumn nie są zrzucane domyślnie. Jeśli jest to oczekiwane, można ustawić *include_attributes* na Prawdę - z ang - ``True``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`asynchat` --- Asynchronous socket command/response handler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`asynchat` --- Asynchroniczna obsługa gniazda komend/odpowiedzi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module builds on the :mod:`asyncore` infrastructure, simplifying asynchronous clients and servers and making it easier to handle protocols whose elements are terminated by arbitrary strings, or are of variable length. :mod:`asynchat` defines the abstract class :class:`async_chat` that you subclass, providing implementations of the :meth:`collect_incoming_data` and :meth:`found_terminator` methods. It uses the same asynchronous loop as :mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher` and :class:`asynchat.async_chat`, can freely be mixed in the channel map. Typically an :class:`asyncore.dispatcher` server channel generates new :class:`asynchat.async_chat` channel objects as it receives incoming connection requests.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł buduje na infrastrukturze modułu :mod:`asyncore`, upraszczając klientów i serwery asynchroniczne i czyniąc łatwiejszym obsługę protokołów których elementy są zakańczane przez zadane ciągi znaków, lub są zmiennej długości. Moduł :mod:`asynchat` określa abstrakcyjne uogólnienie :class:`async_chat` które możesz dostosować tworząc własne podrzędne uogólnienie, dostarczając wypełnień sposobów postępowania :meth:`collect_incoming_data` i :meth:`found_terminator`. Używa tej samej asynchronicznej pętli co moduł :mod:`asyncore`, i dwóch rodzajów kanałów,  - :class:`asyncore.dispatcher` i :class:`asynchat.async_chat`, mogą być dowolnie być mieszane w mapie kanałów. Typowo kanał serwera :class:`asyncore.dispatcher` generuje nowe przedmioty kanałów :class:`asynchat.async_chat` gdy otrzymuje wchodzące zapytania o połączenie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class is an abstract subclass of :class:`asyncore.dispatcher`. To make practical use of the code you must subclass :class:`async_chat`, providing meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` methods. The :class:`asyncore.dispatcher` methods can be used, although not all make sense in a message/response context.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie jest abstrakcyjnym  uogólnieniem podrzędnym względem uogólnienia :class:`asyncore.dispatcher`. Aby praktycznie użyć kodu musisz dostosować podrzędne uogólnienie względem uogólnienia :class:`async_chat`, dostarczając sensownego wypełnienia sposobu postępowania :meth:`collect_incoming_data` i sposobu postępowania :meth:`found_terminator`. Sposoby postępowania uogólnienia :class:`asyncore.dispatcher` mogą być używane, chociaż nie wszystkie mają sens w kontekście wiadomość/odpowiedź.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of events that are generated by an analysis of socket conditions after a :cfunc:`select` call. Once the polling loop has been started the :class:`async_chat` object's methods are called by the event-processing framework with no action on the part of the programmer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak jak w uogólnieniu :class:`asyncore.dispatcher` :class:`async_chat` określa zestaw zdarzeń które są generowane przez analizę warunków gniazda po wywołaniu zadania :cfunc:`select`. Gdy pętla sprawdzenia urządzenia została rozpoczęta sposoby postępowania uogólnienia :class:`async_chat` są wywoływane w szkielecie przetwarzającym zdarzenia bez ingerencji programisty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two class attributes can be modified, to improve performance, or possibly even to conserve memory.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dwie właściwości uogólnienia mogą być modyfikowane, aby poprawić wydajność, lub nawet aby możliwie oszczędzać pamięć.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The asynchronous input buffer size (default ``4096``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozmiar przestrzeni wymiany wejściowej asynchronicznej (domyślnie ``4096``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The asynchronous output buffer size (default ``4096``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozmiar przestrzeni wymiany wyjściowej asynchronicznej (domyślnie ``4096``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to define a first-in-first-out queue (fifo) of *producers*. A producer need have only one method, :meth:`more`, which should return data to be transmitted on the channel. The producer indicates exhaustion (*i.e.* that it contains no more data) by having its :meth:`more` method return the empty string. At this point the :class:`async_chat` object removes the producer from the fifo and starts using the next producer, if any. When the producer fifo is empty the :meth:`handle_write` method does nothing. You use the channel object's :meth:`set_terminator` method to describe how to recognize the end of, or an important breakpoint in, an incoming transmission from the remote endpoint.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W przeciwieństwie do uogólnienia :class:`asyncore.dispatcher`, uogólnienie :class:`async_chat` pozwala ci definiować kolejkę pierwszy-na-wejściu-pierwszy-na-wyjściu (fifo) *producentów*. Producent potrzebuje mieć tylko jeden sposób postępowania :meth:`more` - z ang. - :meth:`więcej`, który powinien zwrócić dane do transmisji w kanale. Producent zaznacza wyczerpanie (t.j. że nie posiada więcej danych) przez to że jego sposób postępowania :meth:`more` zwróci pusty ciąg znaków. W tym momencie przedmiot :class:`async_chat` zdejmuje producenta z kolejki fifo i zaczyna używać następnego producenta jeśli taki występuje. Gdy kolejka fifo producenta jest pusta sposób postępowania :meth:`handle_write` nie robi nic. Używa się sposobu postępowania :meth:`set_terminator` przedmiotu kanału aby opisać jak rozpoznać koniec, lub istotny przerywnik w nadchodzącym sygnale z punktu widzenia odległego krańca transmisji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build a functioning :class:`async_chat` subclass your  input methods :meth:`collect_incoming_data` and :meth:`found_terminator` must handle the data that the channel receives asynchronously. The methods are described below.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby zbudować funkcjonujące podrzędne uogólnienia względem uogólnienia :class:`async_chat`, twoje sposoby postępowania wprowadzania :meth:`collect_incoming_data` i :meth:`found_terminator` muszą obsługiwać dane które kanał otrzymuje asynchronicznie. Sposoby postępowania są opisane poniżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pushes a ``None`` on to the producer fifo. When this producer is popped off the fifo it causes the channel to be closed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przepycha ``Żaden`` - z ang. - ``None`` na kolejkę producenta. Gdy producent jest pobierany z wierzchu kolejki fifo, powoduje, że kanał jest zamykany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called with *data* holding an arbitrary amount of received data.  The default method, which must be overridden, raises a :exc:`NotImplementedError` exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływany z *danymi* przechowując określoną ilość otrzymanych danych. Domyślny sposób postępowania, który musi zostać przesłonięty, zgłasza wyjątek :exc:`NotImplementedError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In emergencies this method will discard any data held in the input and/or output buffers and the producer fifo.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W wyjątkowych sytuacjach ten sposób postępowania odrzuci dowolne dane przechowywane w przestrzeniach wymiany wejściowej i/lub wyjściowej i kolejce producenta fifo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the incoming data stream  matches the termination condition set by :meth:`set_terminator`. The default method, which must be overridden, raises a :exc:`NotImplementedError` exception. The buffered input data should be available via an instance attribute.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływana gdy przychodzący strumień danych odpowiada warunkowi zakończenia ustawionemu przez sposób postępowania :meth:`set_terminator`. Domyślny sposób postępowania, który musi być przesłonięty, zgłasza wyjątek :exc:`NotImplementedError`. Dane wejściowe z przestrzeni wymiany powinny być dostępne przez właściwość przykładu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the current terminator for the channel.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca obecne zakończenie dla kanału.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pushes data on to the channel's fifo to ensure its transmission. This is all you need to do to have the channel write the data out to the network, although it is possible to use your own producers in more complex schemes to implement encryption and chunking, for example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przepycha dane w kolejkę fifo kanału aby zapewnić jej przesyłanie. To jest wszystkim co musisz zrobić aby kanał zapisał dane na zewnątrz w sieci, chociaż jest możliwe użycie swoich własnych producentów w bardziej złożonych schematach aby wypełnić szyfrowanie lub kawałkowanie, dla przykładu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Takes a producer object and adds it to the producer fifo associated with the channel.  When all currently-pushed producers have been exhausted the channel will consume this producer's data by calling its :meth:`more` method and send the data to the remote endpoint.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pobiera przedmiot producenta i dodaje go do kolejki fifo producenta związanej z kanałem. Gdy wszyscy obecnie-przepychani producenci zostaną wyczerpani kanał skonsumuje dane producenta przez wezwanie swojego sposobu postępowania :meth:`more` - z ang. - :meth:`więcej` i wysłać dane do odległego drugiego końca linii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sets the terminating condition to be recognized on the channel.  ``term`` may be any of three types of value, corresponding to three different ways to handle incoming protocol data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustawia warunek zakończenia aby był rozpoznany przez kanał. ``term`` może być dowolną z trzech typów wartości, odpowiadających trzem różnym sposobom obsługi przychodzących danych protokołu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>term</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>term - z ang. - termin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*string*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*ciąg znaków*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will call :meth:`found_terminator` when the string is found in the input stream</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoła sposób postępowania :meth:`found_terminator` gdy ciąg znaków zostanie znaleziony w strumieniu wejściowym</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*integer*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*integer* - z ang. - *liczba całkowita*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will call :meth:`found_terminator` when the indicated number of characters have been received</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoła :meth:`found_terminator` gdy wskazana liczba znaków zostanie odebrana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``None``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``None`` - z ang. - ``Żaden``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The channel continues to collect data forever</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kanał nadal zbiera dane w pętli nieskończonej</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that any data following the terminator will be available for reading by the channel after :meth:`found_terminator` is called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że dowolne dane następujące po terminatorze będą dostępne dla przeczytania przez kanał po tym jak sposób postępowania :meth:`found_terminator` zostanie wywołany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>asynchat - Auxiliary Classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>asynchat - dodatkowe uogólnienia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`fifo` holding data which has been pushed by the application but not yet popped for writing to the channel.  A :class:`fifo` is a list used to hold data and/or producers until they are required.  If the *list* argument is provided then it should contain producers or data items to be written to the channel.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kolejka :class:`fifo` trzymająca dane które zostały popchnięte przez aplikację ale jeszcze nie pobrane do wpisania ich do kanału. Kolejka :class:`fifo` jest listą używaną do przetrzymywania danych i/lub producentów dopóki są one potrzebne. Jeśli parametr *listy* jest dostarczony wtedy powinien zawierać producentów lub elementy danych do wpisania do kanału.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns ``True`` if and only if the fifo is empty.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca ``Prawdę`` - ``True`` wtedy i tylko wtedy gdy kolejka fifo jest pusta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the least-recently :meth:`push`\ ed item from the fifo.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca najdawniej :meth:`popchnięty` - z ang - :meth:`push`\ ed element z kolejki fifo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adds the given data (which may be a string or a producer object) to the producer fifo.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaje podane dane (które mogą być ciągiem lub przedmiotem producenta) dla kolejki fifo producenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the fifo is not empty, returns ``True, first()``, deleting the popped item.  Returns ``False, None`` for an empty fifo.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli kolejka fifo nie jest pusta, zwraca ``Prawda, pierwszy()`` - z ang. - ``True, first()``, kasując pobrany element. Zwraca ``Fałsz, Żaden`` - z ang. - ``False, None`` dla pustej kolejki fifo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>asynchat Example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład asynchat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following partial example shows how HTTP requests can be read with :class:`async_chat`.  A web server might create an :class:`http_request_handler` object for each incoming client connection. Notice that initially the channel terminator is set to match the blank line at the end of the HTTP headers, and a flag indicates that the headers are being read.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący częściowy przykład pokazuje jak zapytania HTTP mogą być wczytane za pomocą :class:`async_chat`. Serwer sieci może tworzyć przedmiot :class:`http_request_handler` - z ang. - :class:`obsluge_zapytania_http` dla każdego przychodzącego połączenia klienckiego. Zauważ że początkowo zakończenie kanału jest ustalone aby odpowiadało pustej linii na końcu nagłówka HTTP, i flaga wskazująca że nagłówki są wczytywane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the headers have been read, if the request is of type POST (indicating that further data are present in the input stream) then the ``Content-Length:`` header is used to set a numeric terminator to read the right amount of data from the channel.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy już nagłówki zostaną wczytane, jeśli zapytanie jest typu POST (wskazując na to że dalsze dane są obecne w strumieniu wejściowym) wtedy nagłówek ``Content-Length:`` jest używany aby ustawić numeryczny terminator do wczytania właściwej ilości danych z kanału.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`handle_request` method is called once all relevant input has been marshalled, after setting the channel terminator to ``None`` to ensure that any extraneous data sent by the web client are ignored. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`handle_request` - z ang. - :meth:`obsloz_zapytanie` jest wywoływane gdy już całe istotne wejście zostało pobrane, po ustawieniu terminatora kanału na ``None`` - z ang. - ``Żaden`` aby upewnić się że jakiekolwiek nadmiarowe dane przesyłane przez klienta sieci są ignorowane. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class http_request_handler(asynchat.async_chat):      def __init__(self, sock, addr, sessions, log):         asynchat.async_chat.__init__(self, sock=sock)         self.addr = addr         self.sessions = sessions         self.ibuffer = []         self.obuffer = b""         self.set_terminator(b"\r\n\r\n")         self.reading_headers = True         self.handling = False         self.cgi_data = None         self.log = log      def collect_incoming_data(self, data):         """Buffer the data"""         self.ibuffer.append(data)      def found_terminator(self):         if self.reading_headers:             self.reading_headers = False             self.parse_headers("".join(self.ibuffer))             self.ibuffer = []             if self.op.upper() == b"POST":                 clen = self.headers.getheader("content-length")                 self.set_terminator(int(clen))             else:                 self.handling = True                 self.set_terminator(None)                 self.handle_request()         elif not self.handling:             self.set_terminator(None) # browsers sometimes over-send             self.cgi_data = parse(self.headers, b"".join(self.ibuffer))             self.handling = True             self.ibuffer = []             self.handle_request()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class http_request_handler(asynchat.async_chat):      def __init__(self, sock, addr, sessions, log):         asynchat.async_chat.__init__(self, sock=sock)         self.addr = addr         self.sessions = sessions         self.ibuffer = []         self.obuffer = b""         self.set_terminator(b"\r\n\r\n")         self.reading_headers = True         self.handling = False         self.cgi_data = None         self.log = log      def collect_incoming_data(self, data):         """Buforuj dane"""         self.ibuffer.append(data)      def found_terminator(self):         if self.reading_headers:             self.reading_headers = False             self.parse_headers("".join(self.ibuffer))             self.ibuffer = []             if self.op.upper() == b"POST":                 clen = self.headers.getheader("content-length")                 self.set_terminator(int(clen))             else:                 self.handling = True                 self.set_terminator(None)                 self.handle_request()         elif not self.handling:             self.set_terminator(None) # przeglądarki czasami przesyłają zbyt dużo             self.cgi_data = parse(self.headers, b"".join(self.ibuffer))             self.handling = True             self.ibuffer = []             self.handle_request()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`asyncore` --- Asynchronous socket handler</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`asyncore` --- Asynchroniczna obsługa gniazda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides the basic infrastructure for writing asynchronous  socket service clients and servers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza podstawową infrastrukturę do pisania asynchronicznych klientów i serwerów usługi gniazd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are only two ways to have a program on a single processor do  "more than one thing at a time." Multi-threaded programming is the  simplest and most popular way to do it, but there is another very different technique, that lets you have nearly all the advantages of  multi-threading, without actually using multiple threads.  It's really  only practical if your program is largely I/O bound.  If your program is processor bound, then pre-emptive scheduled threads are probably what you really need.  Network servers are rarely processor bound, however.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją tylko dwa sposoby aby program na pojedynczym procesorze robił "więcej niż jedną rzecz na raz." Wielo-wątkowe programowanie jest najprostszą i najczęściej spotykaną drogą aby to robić, ale istnieje inna bardzo odmienna technika, która pozwala mieć prawie wszystkie zalety wielowątkowości, bez używania wielu wątków. Jest ona tylko pomocna jeśli twój program jest w większości związany z wejściem/wyjściem. Jeśli twój program jest związany z procesorem, wtedy wywłaszczające planowane wątki są najczęściej tym czego potrzebujesz. Serwery sieciowe jednakże są rzadko związane z procesorem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your operating system supports the :cfunc:`select` system call in its I/O library (and nearly all do), then you can use it to juggle multiple communication channels at once; doing other work while your I/O is taking place in the "background."  Although this strategy can seem strange and complex, especially at first, it is in many ways easier to understand and control than multi-threaded programming.  The :mod:`asyncore` module solves many of the difficult problems for you, making the task of building sophisticated high-performance network servers and clients a snap.  For "conversational" applications and protocols the companion :mod:`asynchat` module is invaluable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli twój system operacyjny wspiera wywołanie systemowe :cfunc:`select`w swojej bibliotece wejścia/wyjścia (a prawie wszystkie wspierają), wtedy możesz używać go aby żonglować wiele kanałów komunikacji na raz; wykonywanie innych zadań gdy twoje wejście/wyjście ma miejsce w "tle". Chociaż ta strategia może wyglądać dziwnie i skomplikowanie, szczególnie na pierwszy rzut oka, jest ona na wiele sposobów łatwiejsza do zrozumienia i kontrolowania niż wielowątkowe programowanie. Moduł :mod:`asyncore` rozwiązuje wiele trudnych kłopotów za ciebie, czyniąc zadanie budowania zaawansowanych wysoko-wydajnych serwerów sieciowych i klientów oka-mgnieniem. Dla "konwersujących" aplikacji i protokołów dołączony moduł :mod:`asynchat` jest nieoceniony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic idea behind both modules is to create one or more network *channels*, instances of class :class:`asyncore.dispatcher` and :class:`asynchat.async_chat`.  Creating the channels adds them to a global map, used by the :func:`loop` function if you do not provide it with your own *map*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawowym pomysłem stojącym za oboma modułami jest stworzenie jednego lub więcej *kanałów*, przykładów uogólnienia :class:`asyncore.dispatcher` i :class:`asynchat.async_chat`. Utworzenie kanałów dodaje je do globalnej mapy, używanej przez zadanie :func:`loop` jeśli dostarczysz jej swojej własnej *mapy*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the initial channel(s) is(are) created, calling the :func:`loop` function activates channel service, which continues until the last channel (including any that have been added to the map during asynchronous service) is closed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy początkowy(e) kanał(y) jest(są) tworzony(e), wywołanie zadania :func:`loop` aktywuje usługę kanału, która kontynuuje zanim ostatni kanał (włączając w to jakiekolwiek które zostały dodane do mapy podczas asynchronicznej usługi) nie zostanie zamknięty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter a polling loop that terminates after count passes or all open channels have been closed.  All arguments are optional.  The *count* parameter defaults to None, resulting in the loop terminating only when all channels have been closed.  The *timeout* argument sets the timeout parameter for the appropriate :func:`select` or :func:`poll` call, measured in seconds; the default is 30 seconds.  The *use_poll* parameter, if true, indicates that :func:`poll` should be used in preference to :func:`select` (the default is ``False``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wejdź w pętlę odpytywania która kończy się po przekroczeniu zliczanej liczby lub gdy wszystkie otwarte kanały zostaną zamknięte. Wszystkie parametry są opcjonalne. Domyślną wartością *count* jest None - z ang. - Żaden, powodując że pętla kończy się tylko gdy wszystkie kanały zostaną zamknięte. Parametr *timeout* ustala parametr pozostałego czasu dla wywołań zadań :func:`select` lub :func:`poll` mierzonych w sekundach: domyślna wartość to 30 sekund. Parametr *use_poll* jeśli prawdziwy, wskazuje że zadanie :func:`poll` powinno być użyte w sposób preferowany względem :func:`select` (domyślnie jest ``Fałsz``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *map* parameter is a dictionary whose items are the channels to watch. As channels are closed they are deleted from their map.  If *map* is omitted, a global map is used. Channels (instances of :class:`asyncore.dispatcher`, :class:`asynchat.async_chat` and subclasses thereof) can freely be mixed in the map.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *map* jest słownikiem którego elementami są kanały do oglądania. Gdy kanały są zamykane są one kasowane z ich mapy. Jeśli *mapa* jest pominięta, nadrzędna mapa jest używana. Kanały (przykłady uogólnienia :class:`asyncore.dispatcher` i :class:`asynchat.async_chat` i podrzędne uogólnienia tychże) mogą dowolnie być mieszane wewnątrz mapy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`dispatcher` class is a thin wrapper around a low-level socket object. To make it more useful, it has a few methods for event-handling which are called from the asynchronous loop.   Otherwise, it can be treated as a normal non-blocking socket object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`dispatcher` jest cienkim opakowaniem wokół niskopoziomowego przedmiotu gniazda. Aby uczynić je bardziej użytecznym, ma kilka sposobów postępowania dla obsługi-zdarzeń które są wzywane z asynchronicznej pętli. Poza tym, może być traktowana jako zwyczajny nieblokujący przedmiot gniazda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The firing of low-level events at certain times or in certain connection states tells the asynchronous loop that certain higher-level events have taken place.  For example, if we have asked for a socket to connect to another host, we know that the connection has been made when the socket becomes writable for the first time (at this point you know that you may write to it with the expectation of success).  The implied higher-level events are:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpalanie niskopoziomowych zdarzeń w konkretnych momentach lub w konkretnych stanach połączeń mówi pętli asynchronicznej że konkretne wyższego poziomu zdarzenia miały miejsce. Dla przykładu, jeśli żądaliśmy aby gniazdo podłączone było do innego hosta, wiemy że połączenie zostało ustanowione gdy gniazdo stanie się możliwe do zapisania po raz pierwszy (w tym momencie wiesz że możesz zapisać do niego oczekując powodzenia). Dorozumiane zdarzenia wyższego poziomu to:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Event</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdarzenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``handle_connect()``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``handle_connect()``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implied by the first read or write event</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślne przez pierwsze zdarzenie odczytu lub zapisu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``handle_close()``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``handle_close()``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implied by a read event with no data available</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślne przy zdarzeniu odczytu bez dostępnych danych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``handle_accept()``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``handle_accept()``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implied by a read event on a listening socket</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślne przy zdarzeniu czytania na nasłuchującym gnieździe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During asynchronous processing, each mapped channel's :meth:`readable` and :meth:`writable` methods are used to determine whether the channel's socket should be added to the list of channels :cfunc:`select`\ ed or :cfunc:`poll`\ ed for read and write events.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podczas asynchronicznego przetwarzania, dla każdego mapowanego kanału sposoby postępowania :meth:`readable` i :meth:`writable` są używane, aby stwierdzić czy gniazdo danego kanału powinno być dodane do listy kanałów wybranych za pomocą zadania :cfunc:`select` lub odpytanych za pomocą zadania :cfunc:`poll` dla zdarzeń odczytu i zapisu. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the set of channel events is larger than the basic socket events.  The full set of methods that can be overridden in your subclass follows:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dlatego, zestaw zdarzeń kanałów jest większy, niż podstawowych zdarzeń gniazda. Pełny zestaw sposobów postępowania, które mogą być przesłonięte w twoim podrzędnym uogólnieniu jest następujący:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the asynchronous loop detects that a :meth:`read` call on the channel's socket will succeed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane, gdy asynchroniczna pętla wykryje, że wywołanie sposobu postępowania na gnieździe kanału odniesie sukces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the asynchronous loop detects that a writable socket can be written.  Often this method will implement the necessary buffering for performance.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane, gdy asynchroniczna pętla wykryje, że możliwe do zapisu gniazdo może być zapisane. Często ten sposób postępowania będzie wypełniał konieczne wczytywanie z wyprzedzeniem dla poprawy wydajności. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def handle_write(self):     sent = self.send(self.buffer)     self.buffer = self.buffer[sent:]</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def handle_write(self):     sent = self.send(self.buffer)     self.buffer = self.buffer[sent:]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when there is out of band (OOB) data for a socket connection.  This will almost never happen, as OOB is tenuously supported and rarely used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane gdy są dane poza zakresem (OOB) dla połączenia z gniazdem. To raczej nie wystąpi nigdy, jako że OOB jest rzadko wspierany i rzadziej jeszcze używany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the active opener's socket actually makes a connection.  Might send a "welcome" banner, or initiate a protocol negotiation with the remote endpoint, for example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane gdy gniazdo aktywnego otwierającego właściwie wywoła połączenie. Może wysłać "powitalny" banner, lub zainicjować negocjację protokołu z zewnętrznym punktem końcowym, dla przykładu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when the socket is closed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływany gdy gniazdo jest zamykane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called when an exception is raised and not otherwise handled.  The default version prints a condensed traceback.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane gdy wyjątek jest zgłaszany i nie jest inaczej obsługiwany. Domyślna wersja wypisuje skumulowany wypis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called on listening channels (passive openers) when a connection can be established with a new remote endpoint that has issued a :meth:`connect` call for the local endpoint.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływany w nasłuchujących kanałach (pasywnych otwarciach) gdy połączenie może być nawiązane z nowym odległym punktem końcowym który wystosował wywołanie sposobu postępowania :meth:`connect` - z ang. - :meth:`połącz` z lokalnym punktem końcowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called each time around the asynchronous loop to determine whether a channel's socket should be added to the list on which read events can occur.  The default method simply returns ``True``, indicating that by default, all channels will be interested in read events.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane za każdym razem dla asynchronicznej pętli aby ustalić, czy gniazdo kanału powinno być dodane do listy na której zdarzenia wczytywania mogą następować. Domyślny sposób po prostu zwraca ``Prawdę`` - z ang. - ``True``, wskazując że domyślnie wszystkie kanały będą zainteresowane zdarzeniami wczytywania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called each time around the asynchronous loop to determine whether a channel's socket should be added to the list on which write events can occur.  The default method simply returns ``True``, indicating that by default, all channels will be interested in write events.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane za każdym razem dla asynchronicznej pętli aby ustalić, czy gniazdo kanału powinno być dodawane do listy na której zdarzenia zapisu mogą następować. Domyślny sposób postępowania po prostu zwraca ``Prawdę`` - z ang. - ``True``, wskazując że domyślnie, wszystkie kanały będą zainteresowane zdarzeniami zapisu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, each channel delegates or extends many of the socket methods. Most of these are nearly identical to their socket partners.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na dodatek, każdy kanał deleguje lub rozszerza wiele ze sposobów postępowania gniazd. Większość z tych jest prawie identyczna z ich partnerami gniazda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is identical to the creation of a normal socket, and will use the same options for creation.  Refer to the :mod:`socket` documentation for information on creating sockets.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest identyczne z utworzeniem normalnego gniazda, i będzie używało tych samych opcji dla tworzenia. Zajrzyj do dokumentacji do :mod:`socket` - z ang. - :mod:`gniazda` po więcej informacji o tworzeniu gniazd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the normal socket object, *address* is a tuple with the first element the host to connect to, and the second the port number.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tak jak z normalnymi przedmiotami gniazd, *adres* - z ang. - *address* jest krotką z pierwszym elementem hosta do którego się podłącza, i drugim numerem portu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send *data* to the remote end-point of the socket.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Prześlij *dane* - z ang. - *data* do odległego punktu końcowego gniazda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read at most *buffer_size* bytes from the socket's remote end-point.  An empty string implies that the channel has been closed from the other end.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj większość bajtów (kęsów) o rozmiarze *buffer_size* z odległego punktu końcowego gniazda. Pusty ciąg znaków oznacza że kanał został zamknięty z przeciwległego końca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listen for connections made to the socket.  The *backlog* argument specifies the maximum number of queued connections and should be at least 1; the maximum value is system-dependent (usually 5).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nasłuchuj połączeń wykonywanych do gniazda. Parametr *wstecznego logu* - z ang. - *backlog* określa maksymalną liczbę kolejkowanych połączeń i powinien być równy przynajmniej 1; Wartość maksymalna jest zależna od systemu (zwykle jest równa 5).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bind the socket to *address*.  The socket must not already be bound.  (The format of *address* depends on the address family --- refer to the :mod:`socket` documentation for more information.)  To mark the socket as re-usable (setting the :const:`SO_REUSEADDR` option), call the :class:`dispatcher` object's :meth:`set_reuse_addr` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Połącz gniazdo z *adresem* - z ang. - *address*. Gniazdo nie może być już połączone z adresem. (Format *adresu* - z ang. - *address* zależy od rodziny adresów --- zajrzyj do dokumentacji :mod:`socket` - z ang. - :mod:`gniazda` po więcej informacji.) Aby oznaczyć gniazdo jako możliwe do ponownego użycia - z ang. - re-usable (ustawiając opcję :const:`SO_REUSEADDR`), wywołaj sposób postępowania :meth:`set_reuse_addr` przedmiotu :class:`dispatcher`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accept a connection.  The socket must be bound to an address and listening for connections.  The return value is a pair ``(conn, address)`` where *conn* is a *new* socket object usable to send and receive data on the connection, and *address* is the address bound to the socket on the other end of the connection.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Akceptuj połączenie. Gniazdo musi być podłączone do adresu i nasłuchiwać połączeń. Zwracana wartość jest parą ``(conn, address)`` gdzie *conn* jest *nowym* przedmiotem gniazda użytecznym do wysyłania i odbierania danych na połączeniu, i *adres* jest adresem złączonym z gniazdem do drugiego końca połączenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the socket.  All future operations on the socket object will fail. The remote end-point will receive no more data (after queued data is flushed).  Sockets are automatically closed when they are garbage-collected.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamknij gniazdo. Wszystkie przyszłe operacje na gnieździe zawiodą. Odległy koniec nie dostanie więcej danych (po tym jak zakolejkowane dane zostaną przesłane). Gniazda są automatycznie zamykane gdy są poddawane zbieraniu śmieci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A file_dispatcher takes a file descriptor or file object along with an optional map argument and wraps it for use with the :cfunc:`poll` or :cfunc:`loop` functions.  If provided a file object or anything with a :cfunc:`fileno` method, that method will be called and passed to the :class:`file_wrapper` constructor.  Availability: UNIX.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>file_dispatcher pobiera deskryptor pliku lub przedmiot pliku razem z opcjonalnym parametrem mapy i opakowuje go do użycia z zadaniami :cfunc:`poll` lub :cfunc:`loop`. Jeśli dostarczono przedmiot pliku lub cokolwiek ze sposobem postępowania :cfunc:`fileno`, ten sposób postępowania będzie wywołany i przekazany do konstruktora uogólnienia :class:`file_wrapper`. Dostępność: UNIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A file_wrapper takes an integer file descriptor and calls :func:`os.dup` to duplicate the handle so that the original handle may be closed independently of the file_wrapper.  This class implements sufficient methods to emulate a socket for use by the :class:`file_dispatcher` class.  Availability: UNIX.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opakowanie file_wrapper pobiera całkowito-liczbowy deskryptor pliku i wywołuje :func:`os.dup` aby zduplikować uchwyt tak że oryginalny uchwyt może być zamknięty niezależnie od opakowania file_wrapper. To uogólnienie wypełnia wystarczające sposoby postępowania do emulacji gniazda dla użycia przez uogólnienie :class:`file_dispatcher` Dostępność UNIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>asyncore Example basic HTTP client</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podstawowy klient HTTP Przykładu asyncore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a very basic HTTP client that uses the :class:`dispatcher` class to implement its socket handling::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest bardzo podstawowy klient HTTP który używa uogólnienia :class:`dispatcher` do wypełnienia jego obsługi gniazda::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import asyncore, socket  class http_client(asyncore.dispatcher):      def __init__(self, host, path):         asyncore.dispatcher.__init__(self)         self.create_socket(socket.AF_INET, socket.SOCK_STREAM)         self.connect( (host, 80) )         self.buffer = bytes('GET %s HTTP/1.0\r\n\r\n' % path, 'ascii')      def handle_connect(self):         pass      def handle_close(self):         self.close()      def handle_read(self):         print(self.recv(8192))      def writable(self):         return (len(self.buffer) &gt; 0)      def handle_write(self):         sent = self.send(self.buffer)         self.buffer = self.buffer[sent:]  c = http_client('www.python.org', '/')  asyncore.loop()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import asyncore, uogólnienie gniazda http_client(asyncore.dispatcher): def __init__(self, host, path): asyncore.dispatcher.__init__(self) self.create_socket(socket.AF_INET, socket.SOCK_STREAM) self.connect((host, 80) ) self.buffer = bytes('GET %s HTTP/1.0&#13;
&#13;
' % path, 'ascii') def handle_connect(self): pass def handle_close(self): self.close() def handle_read(self): print(self.recv(8192)) def writable(self): return (len(self.buffer) &gt; 0) def handle_write(self): sent = self.send(self.buffer) self.buffer = self.buffer[sent:] c = http_client('www.python.org', '/') asyncore.loop()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`atexit` --- Exit handlers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`atexit` --- obsługa Wychodzenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`atexit` module defines functions to register and unregister cleanup functions.  Functions thus registered are automatically executed upon normal interpreter termination.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł :mod:`atexit` definiuje zadania aby zarejestrować i wyrejestrować zadania porządkujące. Zadania tak zarejestrowane są automatycznie wykonywane w momencie normalnego zakończenia programu interpretującego polecenia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: the functions registered via this module are not called when the program is killed by a signal, when a Python fatal internal error is detected, or when :func:`os._exit` is called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ: zadania zarejestrowane przez ten moduł nie są wywoływane gdy program jest zamykany przez sygnał, lub gdy fatalny wewnętrzny błąd Pythona jest napotykany, ani gdy :func:`os._exit` jest wywoływane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register *func* as a function to be executed at termination.  Any optional arguments that are to be passed to *func* must be passed as arguments to :func:`register`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rejestruje *func* jako zadanie do wykonania w momencie zakończenia. Dowolne opcjonalne parametry które mają być przekazane do *funkcji* muszą być przekazywane jako parametry dla zadania :func:`register`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At normal program termination (for instance, if :func:`sys.exit` is called or the main module's execution completes), all functions registered are called in last in, first out order.  The assumption is that lower level modules will normally be imported before higher level modules and thus must be cleaned up later.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przy normalnym zakończeniu programu (dla przykładu, jeśli :func:`sys.exit` jest wywoływana lub zakończy się główne wykonanie modułu), wszystkie zadania zarejestrowane są w porządku "ostatni na wejściu pierwszy na wyjściu". To założenie polega na tym że niższego rzędu moduły będą normalnie importowane przed wyższego rzędu modułami a zatem muszą być sprzątnięte później.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an exception is raised during execution of the exit handlers, a traceback is printed (unless :exc:`SystemExit` is raised) and the exception information is saved.  After all exit handlers have had a chance to run the last exception to be raised is re-raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli wyjątek jest zgłaszany w czasie wykonania obsługi wyjścia, wypis wsteczny jest wypisywany (chyba, że :exc:`SystemExit` zostanie zgłoszony) i informacja o wyjątku jest zapisywana. Po tym jak wszystkie obsługujące elementy miały szansę uruchomienia, ostatni wyjątek do zgłoszenia jest zgłaszany-ponownie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function returns *func* which makes it possible to use it as a decorator without binding the original name to ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie zwraca *func* co umożliwia używanie tego jako dekoratora bez podłączania oryginalnej nazwy do ``None`` - z ang. - ``Żaden``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove a function *func* from the list of functions to be run at interpreter- shutdown.  After calling :func:`unregister`, *func* is guaranteed not to be called when the interpreter shuts down.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Usuń zadanie *func* z listy zadań do uruchomienia w momencie zakończenia działania programu interpretującego polecenia języka pytonowskiego. Po wywołaniu zadania :func:`unregister`, zadanie ma gwarantowane że nie będzie wywoływane gdy program interpretujący polecenia języka pytonowskiego będzie zamykany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Useful example of :mod:`atexit` to read and write :mod:`readline` history files.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użyteczny przykład modułu :mod:`atexit` do wczytywania i zapisu plików historii :mod:`readline` modułu "czytaj wiersz".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`atexit` Example</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład modułu :mod:`atexit`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following simple example demonstrates how a module can initialize a counter from a file when it is imported and save the counter's updated value automatically when the program terminates without relying on the application making an explicit call into this module at termination. ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący prosty przykład demonstruje jak moduł może inicjować licznik z pliku gdy jest importowany i zapisywać uaktualnioną wartość licznika automatycznie gdy program kończy się bez opierania się na aplikacji wykonującej jawne wywołanie do tego modułu w momencie zakończenia. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try:     _count = int(open("/tmp/counter").read()) except IOError:     _count = 0  def incrcounter(n):     global _count     _count = _count + n  def savecounter():     open("/tmp/counter", "w").write("%d" % _count)  import atexit atexit.register(savecounter)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>try:     _count = int(open("/tmp/counter").read()) except IOError:     _count = 0  def incrcounter(n):     global _count     _count = _count + n  def savecounter():     open("/tmp/counter", "w").write("%d" % _count)  import atexit atexit.register(savecounter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Positional and keyword arguments may also be passed to :func:`register` to be passed along to the registered function when it is called::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry pozycyjny i słowa kluczowego mogą także być przekazane do zadania :func:`register` aby były przekazywane razem do zarejestrowanego zadania gdy jest wywoływane::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def goodbye(name, adjective):     print('Goodbye, %s, it was %s to meet you.' % (name, adjective))  import atexit atexit.register(goodbye, 'Donny', 'nice')  # or: atexit.register(goodbye, adjective='nice', name='Donny')</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def goodbye(name, adjective):     print('Do zobaczenia, %s, było %s cię widzieć.' % (name, adjective))  import atexit atexit.register(goodbye, 'Danio', 'miło')  # or: atexit.register(goodbye, adjective='miło', name='Danio')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage as a :term:`decorator`::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użycie jako :term:`decorator`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import atexit  @atexit.register def goodbye():     print("You are now leaving the Python sector.")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import atexit  @atexit.register def dozobacznia():     print("Opuszczasz teraz sektor pytonowski.")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This obviously only works with functions that don't take arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To oczywiście działa tylko z zadaniami które nie pobierają parametrów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`audioop` --- Manipulate raw audio data</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`audioop` --- Obsługuj surowe dane dźwiękowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`audioop` module contains some useful operations on sound fragments. It operates on sound fragments consisting of signed integer samples 8, 16 or 32 bits wide, stored in Python strings.  All scalar items are integers, unless specified otherwise.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`audioop` zawiera pewne użyteczne operacje na fragmentach dźwięku. Operuje na fragmentach dźwięku składających się z próbek z liczb całkowitych ze znakiem 8, 16, lub 32 bitowej długości, zapamiętanych w ciągach znaków języka pytonowskiego. Wszystkie skalarne elementy są liczbami całkowitymi, chyba, że określono inaczej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza wsparcia dla kodowania a-LAW, u-LAW i Intel/DVI ADPCM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few of the more complicated operations only take 16-bit samples, otherwise the sample size (in bytes) is always a parameter of the operation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kilka z bardziej skomplikowanych operacji pobiera tylko 16-bitowe próbki, w przeciwnym razie rozmiar próbki (w bajtach - kęsach) jest zawsze parametrem operacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module defines the following variables and functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł definiuje następujące zmienne i zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This exception is raised on all errors, such as unknown number of bytes per sample, etc.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten wyjątek jest zgłaszany na wszystkich błędach takich jak nieznana liczba bajtów na próbkę, itp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a fragment which is the addition of the two samples passed as parameters. *width* is the sample width in bytes, either ``1``, ``2`` or ``4``.  Both fragments should have the same length.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć fragment, który jest dodaniem dwóch próbek przekazanych jako parametrów. *szerokość* jest szerokością próbki w bajtach, ``1``, ``2`` lub ``4``. Oba fragmenty powinny być tej samej długości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the description of :func:`lin2adpcm` for details on ADPCM coding. Return a tuple ``(sample, newstate)`` where the sample has the width specified in *width*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekoduj fragment zakodowany w Intel/DVI ADPCM do fragmentu liniowego. Zobacz opis zadania :func:`lin2adpcm` dla szczegółów o kodowaniu ADPCM. Zwróć krotkę ``(sample, newstate)`` gdzie sample ma szerokość określoną przez *width*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert sound fragments in a-LAW encoding to linearly encoded sound fragments. a-LAW encoding always uses 8 bits samples, so *width* refers only to the sample width of the output fragment here.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konwertuj fragmenty dźwięku w kodowaniu a-LAW do liniowo zakodowanych fragmentów dźwięku. Kodowanie a-LAW zawsze używa 8-bitowych próbek, więc *width* ( - z ang. - szerokość) odnosi się tylko do szerokości próbki wyjściowego fragmentu tutaj.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the average over all samples in the fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć średnią ze wszystkich próbek w tym fragmencie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the average peak-peak value over all samples in the fragment. No filtering is done, so the usefulness of this routine is questionable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć średnią wartość między-szczytową ponad wszystkimi próbkami w tym fragmencie. Żadne filtrowanie nie jest dokonywane, więc użyteczność tego zadania jest do zakwestionowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a fragment that is the original fragment with a bias added to each sample.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć fragment który jest oryginalnym fragmentem ze skrzywieniem ( - z ang. - bias )  dodanym do każdej próbki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the number of zero crossings in the fragment passed as an argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć liczbę przekroczeń zera we fragmencie przekazanym jako parametr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a factor *F* such that ``rms(add(fragment, mul(reference, -F)))`` is minimal, i.e., return the factor with which you should multiply *reference* to make it match as well as possible to *fragment*.  The fragments should both contain 2-byte samples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć współczynnik *F* taki, że ``rms(dodaj(fragment, mnozenie(odniesienie -F)))`` jest najmniejszy t.j. zwróć czynnik przez który powinno się pomnożyć *odniesienie* aby dopasować jak to się tylko da do *fragmentu*. Fragmenty powinny oba zawierać 2-bajtowe próbki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The time taken by this routine is proportional to ``len(fragment)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czas zabierany przez to zadanie jest proporcjonalny do długości fragmentu ``len(fragment)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try to match *reference* as well as possible to a portion of *fragment* (which should be the longer fragment).  This is (conceptually) done by taking slices out of *fragment*, using :func:`findfactor` to compute the best match, and minimizing the result.  The fragments should both contain 2-byte samples. Return a tuple ``(offset, factor)`` where *offset* is the (integer) offset into *fragment* where the optimal match started and *factor* is the (floating-point) factor as per :func:`findfactor`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Spróbuj dopasować *odniesienie* tak jak to się tylko da najlepiej do porcji *fragmentu* (która powinna być dłuższym fragmentem). To jest (w teorii) wykonywane przez wyjęcie wycinków z *fragmentu*, użycie zadania :func:`findfactor` aby znaleźć najlepsze dopasowanie, i minimalizując wynik. Fragmenty powinny oba zawierać 2-bajtowe próbki. Zwróć krotkę ``(offset, factor)`` gdzie *offset* jest (całkowitym) przesunięciem wewnątrz *fragmentu* gdzie zaczyna się optymalne dopasowanie, a *factor* jest (zmiennoprzecinkowym) czynnikiem jako dla zadania :func:`findfactor`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Search *fragment* for a slice of length *length* samples (not bytes!) with maximum energy, i.e., return *i* for which ``rms(fragment[i*2:(i+length)*2])`` is maximal.  The fragments should both contain 2-byte samples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przeszukaj *fragment* w poszukiwaniu wycinka o długości *length* próbek (nie bajtów!) z maksymalną energią, t.j., zwróć *i* dla którego ``rms(fragment[i*2:(i+length)*2])`` jest maksymalne. Fragmenty powinny oba zawierać 2-bajtowe próbki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The routine takes time proportional to ``len(fragment)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie zabiera czas proporcjonalny do długości fragmentu ``len(fragment)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the value of sample *index* from the fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wartość próbki spod *indeksu* z danego fragmentu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an adaptive coding scheme, whereby each 4 bit number is the difference between one sample and the next, divided by a (varying) step.  The Intel/DVI ADPCM algorithm has been selected for use by the IMA, so it may well become a standard.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień sample na kodowanie 4 bitowe Intel/DVI ADPCM. Kodowanie ADPCM jest schematem kodowania adaptacyjnego, gdzie każda 4 bitowa liczba jest różnicą pomiędzy jedną próbką a następną, podzielonym przez (różnej wielkości) krok. Algorytm Intel/DVI ADPCM został wybrany do użycia przez IMA, więc może całkiem prawdopodobnie zostanie on standardem. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*state* is a tuple containing the state of the coder.  The coder returns a tuple ``(adpcmfrag, newstate)``, and the *newstate* should be passed to the next call of :func:`lin2adpcm`.  In the initial call, ``None`` can be passed as the state. *adpcmfrag* is the ADPCM coded fragment packed 2 4-bit values per byte.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*stan* - z ang. *state* - jest krotką zawierającą stan kodera. Koder zwraca krotkę ``(adpcmfrag, nowystan)``, i *nowystan* powinien zostać przekazany do następnego wywołania zadania :func:`lin2adpcm`. W początkowym wywołaniu ``None`` może być przekazane jako stan. *adpcmfrag* jest fragmentem zakodowanym ADPCM zapakowanym dwoma 4-bitowymi wartościami na bajt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert samples in the audio fragment to a-LAW encoding and return this as a Python string.  a-LAW is an audio encoding format whereby you get a dynamic range of about 13 bits using only 8 bit samples.  It is used by the Sun audio hardware, among others.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień próbki we fragmencie dźwięku na kodowanie a-LAW i zwróć wynik jako ciąg znaków języka pytonowskiego. a-LAW jest formatem kodowania dźwięku gdzie dostajesz dynamiczną skalę około 13 bitów używając tylko 8-bitowych próbek. Jest on używany przez sprzęt audio firmy Sun, między innymi. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert samples between 1-, 2- and 4-byte formats.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień próbki pomiędzy 1-, 2- i 4- bajtowymi formatami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some audio formats, such as .WAV files, 16 and 32 bit samples are signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide samples for these formats, you need to also add 128 to the result::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W pewnych formatach dźwięku, takich jak plikach .WAV, 16 i 32 bitowe próbki są ze znakiem ale 8 bitowe próbki są bez znaku. Więc konwertując 8 bitowe próbki dla tych formatów, potrzeba także dodać 128 do wyniku::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>new_frames = audioop.lin2lin(frames, old_width, 1) new_frames = audioop.bias(new_frames, 1, 128)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>new_frames = audioop.lin2lin(frames, old_width, 1) new_frames = audioop.bias(new_frames, 1, 128)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same, in reverse, has to be applied when converting from 8 to 16 or 32 bit width samples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To samo, odwrócone, musi być stosowane gdy konwertuje się z 8 do 16 lub 32 bitów długości próbek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert samples in the audio fragment to u-LAW encoding and return this as a Python string.  u-LAW is an audio encoding format whereby you get a dynamic range of about 14 bits using only 8 bit samples.  It is used by the Sun audio hardware, among others.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień próbki we fragmencie dźwięku na kodowanie u-LAW i zwróć to jako ciąg znaków języka pytonowskiego. u-LAW jest formatem kodowania dźwięku gdzie dostajesz dynamiczną skalę około 14 bitów używając zaledwie 8-bitowych próbek. Jest używane przez sprzęt dźwiękowy firmy Sun między innymi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a tuple consisting of the minimum and maximum values of all samples in the sound fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć krotkę składającą się z wartości minimum i maksimum ze wszystkich próbek we fragmencie dźwięku. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the maximum of the *absolute value* of all samples in a fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć maksimum *wartości bezwzględnej* wszystkich próbek we fragmencie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the maximum peak-peak value in the sound fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć maksimum wartości między-szczytowej we fragmencie dźwięku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a fragment that has all samples in the original fragment multiplied by the floating-point value *factor*.  Overflow is silently ignored.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć fragment który ma wszystkie próbki z oryginalnego fragmentu pomnożone przez wartość zmiennoprzecinkową *factor*. Przekroczenie zakresu jest po cichu ignorowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the frame rate of the input fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień prędkość ramek wejściowego fragmentu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*state* is a tuple containing the state of the converter.  The converter returns a tuple ``(newfragment, newstate)``, and *newstate* should be passed to the next call of :func:`ratecv`.  The initial call should pass ``None`` as the state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*stan* ( z ang. - *state*) jest krotką zawierającą stan konwertera. Konwerter zwraca krotkę ``(nowyfragment, nowystan)``, i *nowystan* powinien być przekazany do następnego wywołania zadania :func:`ratecv`. Pierwotne wywołanie powinno przekazać ``None`` jako stan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *weightA* and *weightB* arguments are parameters for a simple digital filter and default to ``1`` and ``0`` respectively.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*WagaA* i *wagaB* parametry dla prostego filtra cyfrowego i domyślne wartości ``1`` i ``0`` odpowiednio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reverse the samples in a fragment and returns the modified fragment.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odwraca próbki we fragmencie i zwraca zmodyfikowany fragment.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the root-mean-square of the fragment, i.e. ``sqrt(sum(S_i^2)/n)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca rms wartość średnio-kwadratową fragmentu, t.j. ``sqrt(sum(S_i^2)/n)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a measure of the power in an audio signal.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To jest miara mocy w sygnale dźwiękowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a stereo fragment to a mono fragment.  The left channel is multiplied by *lfactor* and the right channel by *rfactor* before adding the two channels to give a mono signal.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień fragment stereo na fragment mono. Lewy kanał jest mnożony przez *lfactor* a prawy kanał przez *rfactor* przed dodaniem obu kanałów które dadzą sygnał mono.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate a stereo fragment from a mono fragment.  Each pair of samples in the stereo fragment are computed from the mono sample, whereby left channel samples are multiplied by *lfactor* and right channel samples by *rfactor*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Generuj fragment stereo z fragmentu mono. Każda para próbek we fragmencie stereo jest obliczana z próbki mono, gdzie próbki lewego kanału są mnożone przez *lfactor* a prawego kanału przez *rfactor*. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert sound fragments in u-LAW encoding to linearly encoded sound fragments. u-LAW encoding always uses 8 bits samples, so *width* refers only to the sample width of the output fragment here.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień fragmenty dźwięku w kodowaniu u-LAW na liniowo zakodowane fragmenty dźwięku. Kodowanie u-LAW zawsze używa 8-bitowych próbek, więc *szerokość* odnosi się tylko do szerokości próbki wyjściowego fragmentu tutaj.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that operations such as :func:`.mul` or :func:`.max` make no distinction between mono and stereo fragments, i.e. all samples are treated equal.  If this is a problem the stereo fragment should be split into two mono fragments first and recombined later.  Here is an example of how to do that::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że operacje takie jak :func:`.mul` lub :func:`.max` nie czynią żadnych rozróżnień pomiędzy fragmentami mono i stereo, t.j. wszystkie próbki są traktowane na równi. Jeśli jest to problem fragment stereo powinien być podzielony na dwa fragmenty mono wpierw i połączony ponownie później. Tu jest przykład jak to zrobić::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def mul_stereo(sample, width, lfactor, rfactor):     lsample = audioop.tomono(sample, width, 1, 0)     rsample = audioop.tomono(sample, width, 0, 1)     lsample = audioop.mul(sample, width, lfactor)     rsample = audioop.mul(sample, width, rfactor)     lsample = audioop.tostereo(lsample, width, 1, 0)     rsample = audioop.tostereo(rsample, width, 0, 1)     return audioop.add(lsample, rsample, width)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def mul_stereo(sample, width, lfactor, rfactor):     lsample = audioop.tomono(sample, width, 1, 0)     rsample = audioop.tomono(sample, width, 0, 1)     lsample = audioop.mul(sample, width, lfactor)     rsample = audioop.mul(sample, width, rfactor)     lsample = audioop.tostereo(lsample, width, 1, 0)     rsample = audioop.tostereo(rsample, width, 0, 1)     return audioop.add(lsample, rsample, width)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the ADPCM coder to build network packets and you want your protocol to be stateless (i.e. to be able to tolerate packet loss) you should not only transmit the data but also the state.  Note that you should send the *initial* state (the one you passed to :func:`lin2adpcm`) along to the decoder, not the final state (as returned by the coder).  If you want to use :func:`struct.struct` to store the state in binary you can code the first element (the predicted value) in 16 bits and the second (the delta index) in 8.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli używać kodera ADPCM aby zbudować pakiety sieciowe i chcesz aby twój protokół był bezstanowy (t.j. aby mógł tolerować utratę pakietów) powinieneś nie tylko przesyłać dane ale także stan. Zauważ, że powinieneś przesłać stan *początkowy* (ten który przesłałeś do zadania :func:`lin2adpcm`) do dekodera, nie zaś stan końcowy (jaki zwracał koder). Jeśli chcesz użyć zadania :func:`struct.struct`, aby zachować stan w postaci binarnej możesz zakodować pierwszy element (wartość przewidywaną) w 16 bitach i drugą wartość (delta indeks) w 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ADPCM coders have never been tried against other ADPCM coders, only against themselves.  It could well be that I misinterpreted the standards in which case they will not be interoperable with the respective standards.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodery ADPCM nigdy nie były próbowane naprzeciw innych koderów ADPCM, tylko naprzeciw samym sobie. Może się tak zdarzyć, że nadinterpretowałem standard w którym to przypadku nie będą współpracowały z odpowiadającymi im standardami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :func:`find\*` routines might look a bit funny at first sight. They are primarily meant to do echo cancellation.  A reasonably fast way to do this is to pick the most energetic piece of the output sample, locate that in the input sample and subtract the whole output sample from the input sample::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania :func:`find\*` mogą wyglądać trochę śmiesznie na pierwszy rzut oka. Są one pomyślane w pierwszej kolejności aby wykonywać anulowanie echa. Rozsądnie szybką drogą aby tego dokonać jest wybrać najbardziej energetyczny kawałek wyjściowych próbek, znaleźć to w próbkach wejściowych i odjąć całą wyjściową próbkę od próbki wejściowej::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>def echocancel(outputdata, inputdata):     pos = audioop.findmax(outputdata, 800)    # one tenth second     out_test = outputdata[pos*2:]     in_test = inputdata[pos*2:]     ipos, factor = audioop.findfit(in_test, out_test)     # Optional (for better cancellation):     # factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],     #              out_test)     prefill = '\0'*(pos+ipos)*2     postfill = '\0'*(len(inputdata)-len(prefill)-len(outputdata))     outputdata = prefill + audioop.mul(outputdata,2,-factor) + postfill     return audioop.add(inputdata, outputdata, 2)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>def echocancel(outputdata, inputdata):     pos = audioop.findmax(outputdata, 800)    # jedna dziesiąta sekundy     out_test = outputdata[pos*2:]     in_test = inputdata[pos*2:]     ipos, factor = audioop.findfit(in_test, out_test)     # Optional (dla lepszego anulowania):     # factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],     #              out_test)     prefill = '\0'*(pos+ipos)*2     postfill = '\0'*(len(inputdata)-len(prefill)-len(outputdata))     outputdata = prefill + audioop.mul(outputdata,2,-factor) + postfill     return audioop.add(inputdata, outputdata, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`base64` --- RFC 3548: Base16, Base32, Base64 Data Encodings</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł :mod:`base64` --- RFC 3548: kodowania danych Base16 Base32, Base64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides data encoding and decoding as specified in :rfc:`3548`. This standard defines the Base16, Base32, and Base64 algorithms for encoding and decoding arbitrary binary strings into text strings that can be safely sent by email, used as parts of URLs, or included as part of an HTTP POST request.  The encoding algorithm is not the same as the :program:`uuencode` program.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza kodowanie i dekodowanie jak określono w :rfc:`3548` Ten standard definiuje algorytmy kodowania i dekodowania Base16, Base32, Base64 danych binarnych ciągów na tekstowe ciągi znaków które mogą być bezpiecznie przesyłane przez email, użyte jako część adresu URL lub załączone jako część zapytania HTTP POST. Algorytm kodowania nie jest ten sam, jak program :program:`uuencode`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two interfaces provided by this module.  The modern interface supports encoding and decoding string objects using all three alphabets.  The legacy interface provides for encoding and decoding to and from file-like objects as well as strings, but only using the Base64 standard alphabet.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją dwa sprzęgi dostarczane przez ten moduł. Współczesny sprzęg wspiera kodowanie i dekodowanie przedmiotów ciągów przy użyciu wszystkich trzech alfabetów. Ubiegłe sprzęgi dostarczają kodowania i dekodowania do i z pliko-podobnych przedmiotów zarówno jak ciągów znaków, ale tylko przy użyciu standardowego alfabetu Base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The modern interface provides:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nowy sprzęg dostarcza:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode a string use Base64.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj ciąg znaków używając Base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*s* is the string to encode.  Optional *altchars* must be a string of at least length 2 (additional characters are ignored) which specifies an alternative alphabet for the ``+`` and ``/`` characters.  This allows an application to e.g. generate URL or filesystem safe Base64 strings.  The default is ``None``, for which the standard Base64 alphabet is used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*s* jest ciągiem znaków do zakodowania. Opcjonalne *altchars* alternatywne znaki muszą być ciągiem o długości co najmniej 2 znaków (dodatkowe znaki są ignorowane) co określa alternatywny alfabet dla znaków ``+`` i ``/``. To pozwala aplikacji na przykład do generowania adresów URL lub bezpiecznych dla systemu plików ciągów znaków Base64. Domyślne jest ``None``, dla którego standardowy alfabet Base64 jest używany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encoded string is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakodowany ciąg znaków jest zwracany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode a Base64 encoded string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduj zakodowany ciąg znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*s* is the string to decode.  Optional *altchars* must be a string of at least length 2 (additional characters are ignored) which specifies the alternative alphabet used instead of the ``+`` and ``/`` characters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*s* jest ciągiem do zdekodowania. Opcjonalne *altchars* muszą być ciągiem o długości co najmniej 2 znaków (dodatkowe znaki są ignorowane) które określają alternatywny alfabet używany zamiast znaków ``+`` i ``/``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The decoded string is returned.  A :exc:`TypeError` is raised if *s* were incorrectly padded or if there are non-alphabet characters present in the string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekodowany ciąg znaków jest zwracany. Wyjątek :exc:`TypeError` jest zgłaszany jeśli *s* zostały niewłaściwie uzupełnione lub jeśli są nie-alfabetyczne znaki obecne w ciągu znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode string *s* using the standard Base64 alphabet.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj ciąg *s* używając standardowego alfabetu Base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode string *s* using the standard Base64 alphabet.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduj ciąg znaków *s* używając standardowego alfabetu Base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode string *s* using a URL-safe alphabet, which substitutes ``-`` instead of ``+`` and ``_`` instead of ``/`` in the standard Base64 alphabet.  The result can still contain ``=``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj ciąg znaków *s* używając bezpieczny dla adresów URL alfabet, który zamienia ``-`` zamiast ``+`` i ``_`` zamiast ``/`` w standardowym alfabecie Base64. Wynik może wciąż zawierać znak ``=``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode string *s* using a URL-safe alphabet, which substitutes ``-`` instead of ``+`` and ``_`` instead of ``/`` in the standard Base64 alphabet.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduj ciąg znaków *s* używając alfabetu bezpiecznego dla adresów URL który zamienia ``-`` na ``+`` i ``_`` zamiast ``/`` w standardowym alfabecie Base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode a string using Base32.  *s* is the string to encode.  The encoded string is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj ciąg znaków używając Base32. *s* jest ciągiem do zakodowania. Zakodowany ciąg znaków jest zwracany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode a Base32 encoded string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduj ciąg znaków zakodowany używając kodowania Base32. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*s* is the string to decode.  Optional *casefold* is a flag specifying whether a lowercase alphabet is acceptable as input.  For security purposes, the default is ``False``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*s* jest ciągiem znaków do zdekodowania. Opcjonalna *casefold* jest flagą określającą czy alfabet małych liter jest akceptowalny jako wejście. Ze względów bezpieczeństwa, domyślnie jest to ``Fałsz`` - z ang. - ``False``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:rfc:`3548` allows for optional mapping of the digit 0 (zero) to the letter O (oh), and for optional mapping of the digit 1 (one) to either the letter I (eye) or letter L (el).  The optional argument *map01* when not ``None``, specifies which letter the digit 1 should be mapped to (when *map01* is not ``None``, the digit 0 is always mapped to the letter O).  For security purposes the default is ``None``, so that 0 and 1 are not allowed in the input.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:rfc:`3548` zezwala na dodatkowe mapowanie cyfry 0 (zero) do litery O (o), i opcjonalne mapowanie cyfry 1 (jeden) albo do litery I (i) lub litery L (el). Opcjonalny parametr *map01* jeśli nie ``Żaden`` - z ang. - ``None``, określa do których liter cyfra 1 powinna być zmapowana (gdy *map01* nie jest ``None``, cyfra 0 jest zawsze mapowana do litery O). Ze względów bezpieczeństwa domyślnie jest to ``Żaden`` - z ang. - ``None``, więc 0 i 1 nie są pozwalane w ciągu wejściowym. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode a string using Base16.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj ciąg znaków używając Base16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*s* is the string to encode.  The encoded string is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*s* jest ciągiem znaków do zakodowania. Zakodowany ciąg znaków jest zwracany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode a Base16 encoded string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduj ciąg znaków zakodowany za pomocą Base16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The legacy interface:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przestarzały sprzęg:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode the contents of the binary *input* file and write the resulting binary data to the *output* file. *input* and *output* must either be file objects or objects that mimic the file object interface working with bytes objects. *input* will be read until ``input.read()`` returns an empty string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduj zawartość binarnego pliku *wejściowego* i zapisz wynikowe dane binarne do pliku *wyjściowego*. *input* - z ang. - *wejściowy* i *output* - z ang. - *wyjściowy*  muszą być przedmiotami plików lub przedmiotami udającymi sprzęg przedmiotu pliku pracujący z przedmiotem bytes. *input* - z ang. - *wejściowy* będzie wczytywany dopóki ``input.read()`` nie zwróci pustego ciągu znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode the bytestring *s*, which must contain one or more lines of base64 encoded data, and return a bytestring containing the resulting binary data. ``decodestring`` is a deprecated alias.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdekoduje ciąg-bajtów *s*, który musi zawierać jedną lub więcej linię zakodowanych danych w base64, i zwraca ciąg bajtów zawierających wynikowe dane binarne. ``decodestring`` jest przestarzałym synonimem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode the contents of the binary *input* file and write the resulting base64 encoded data to the *output* file. *input* and *output* must either be file objects or objects that mimic the file object interface working with bytes objects. *input* will be read until ``input.read()`` returns an empty string. :func:`encode` returns the encoded data plus a trailing newline character (``b'\n'``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj zawartość binarnego pliku *wejściowego* i zapisz wynikające dane zakodowane w base64 do pliku *wyjściowego*. *Wejściowe* - z ang. - *input* i *wyjściowe* - z ang - *output* musi albo być przedmiotem pliku lub przedmiotami które udają sprzęg przedmiotu plikowego pracujący z przedmiotami bajtowymi. *wejściowy* będzie wczytywany dopóki ``input.read()`` nie zwróci pustego ciągu znaków. :func:`encode` zwraca zakodowane dane plus kończący znak nowego wiersza (``b'
'``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode the bytestring *s*, which can contain arbitrary binary data, and return a bytestring containing one or more lines of base64-encoded data. :func:`encodebytes` returns a string containing one or more lines of base64-encoded data always including an extra trailing newline (``b'\n'``). ``encodestring`` is a deprecated alias.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj ciąg bajtów *s*, który może zawierać dowolne binarne dane, i zwracać ciąg bajtów zawierający jedną lub więcej linii danych zakodowanych kodowaniem base64. Zadanie :func:`encodebytes` zwraca ciąg zawierający jedną lub więcej linii zakodowanych danych kodem base64 zawsze zawierający dodatkowy znak nowej linii (``b'
'``). ``encodestring`` jest przestarzałym synonimem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage of the module:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykładowe użycie modułu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; import base64 &gt;&gt;&gt; encoded = base64.b64encode('data to be encoded') &gt;&gt;&gt; encoded b'ZGF0YSB0byBiZSBlbmNvZGVk' &gt;&gt;&gt; data = base64.b64decode(encoded) &gt;&gt;&gt; data 'data to be encoded'</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; import base64 &gt;&gt;&gt; encoded = base64.b64encode('dane do zakodowania') &gt;&gt;&gt; encoded 'ZGFuZSBkbyB6YWtvZG93YW5pYQ==' &gt;&gt;&gt; data = base64.b64decode(encoded) &gt;&gt;&gt; data 'dane do zakodowania'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support module containing ASCII-to-binary and binary-to-ASCII conversions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wspierający moduł zawierający konwersję ASCII-do-binarnego i binarnego-do-ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Section 5.2, "Base64 Content-Transfer-Encoding," provides the definition of the base64 encoding.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sekcja 5.2, "Base64 Treść-Transfer-Kodowanie," dostarcza definicji kodowania base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`bdb` --- Debugger framework</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`bdb` --- szkielet debugowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`bdb` module handles basic debugger functions, like setting breakpoints or managing execution via the debugger.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`bdb` obsługuje podstawowe zadania debuggera, jak ustawianie punktów przerywania lub zarządzenie wykonaniem przez debugger.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following exception is defined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący wyjątek jest zdefiniowany:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception raised by the :class:`Bdb` class for quitting the debugger.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyjątek zgłaszany przez uogólnienie :class:`Bdb` dla wyjścia z odpluskwiania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`bdb` module also defines two classes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`bdb` definiuje dwa uogólnienia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class implements temporary breakpoints, ignore counts, disabling and (re-)enabling, and conditionals.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie wypełnia tymczasowe punkty przerywania, liczniki ignorowania, wyłączanie i (ponowne-)włączanie i warunkowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Breakpoints are indexed by number through a list called :attr:`bpbynumber` and by ``(file, line)`` pairs through :attr:`bplist`.  The former points to a single instance of class :class:`Breakpoint`.  The latter points to a list of such instances since there may be more than one breakpoint per line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Punkty przerywania są numerowane przez liczbę dla listy zwanej :attr:`bpbynumber` i przez pary ``(file, line)`` przez :attr:`bplist`. Poprzednie wskazuje na pojedynczy przykład uogólnienia :class:`Breakpoint` - z ang. - punkt przerywania. Ten drugi wskazuje na listę takich przykładów gdyż może być więcej niż jeden punkt przerywania na linię.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating a breakpoint, its associated filename should be in canonical form.  If a *funcname* is defined, a breakpoint hit will be counted when the first line of that function is executed.  A conditional breakpoint always counts a hit.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy tworzony jest punkt przerywania, związana z nim nazwa pliku powinna być w kanonicznej formie. Jeśli nazwa zadania jest określona - z ang. - *funcname*, uderzenie w punkt przerywania będzie się liczyła gdy pierwsza linia tego zadania będzie wykonana. Warunkowy punkt przerywania zawsze liczy się jako uderzenie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Breakpoint` instances have the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnienia :class:`Breakpoint` mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the breakpoint from the list associated to a file/line.  If it is the last breakpoint in that position, it also deletes the entry for the file/line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skasuj punkt przerywania wykonania z listy związanej z plikiem/linią. Jeśli jest to ostatni punkt przerywania w tej pozycji, on także kasuje wpis dla pliku/linii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark the breakpoint as enabled.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oznacz punkt przerywania wykonania jako włączony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark the breakpoint as disabled.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oznacz punkt przerywania wykonania jako wyłączony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print all the information about the breakpoint:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydrukuj wszystkie informacje o punkcie przerywania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The breakpoint number.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Numer punktu przerywania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is temporary or not.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Czy jest tymczasowy czy nie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Its file,line position.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jego pozycja plik,linia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The condition that causes a break.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Warunek który powoduje przerwanie wykonania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it must be ignored the next N times.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To czy musi być ignorowany następnych N razy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The breakpoint hit count.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczba trafień punktu przerywania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Bdb` class acts as a generic Python debugger base class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Bdb` działa jako zastępcze uogólnienie odpluskwiania języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class takes care of the details of the trace facility; a derived class should implement user interaction.  The standard debugger class (:class:`pdb.Pdb`) is an example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie zajmuje się szczegółami urządzenia śledzenia; pochodne uogólnienie powinno wypełniać interakcję z użytkownikiem. Standardowe uogólnienie odpluskwiania (:class:`pdb.Pdb`) jest przykładem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *skip* argument, if given, must be an iterable of glob-style module name patterns.  The debugger will not step into frames that originate in a module that matches one of these patterns. Whether a frame is considered to originate in a certain module is determined by the ``__name__`` in the frame globals.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *skip*, jeśli dany musi być iterowalnym wzorcem nazwy modułu w stylu-glob. Odpluskwianie nie wejdzie w ramki które zaczynają się w module który pasuje do jednego ze wzorców. To czy ramka jest uznawana za pochodzącą z konkretnego modułu jest określane przez nazwę ``__name__`` w globalnych ramkach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following methods of :class:`Bdb` normally don't need to be overridden.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące sposoby postępowania uogólnienia :class:`Bdb` zwykle nie potrzebują być przesłaniane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Auxiliary method for getting a filename in a canonical form, that is, as a case-normalized (on case-insensitive filesystems) absolute path, stripped of surrounding angle brackets.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodatkowy sposób postępowania dla pobierania nazwy pliku w kanonicznej formie, to jest, jako znormalizowane względem wielkości liter (w systemach plików niewrażliwych na rozmiar liter) bezwzględne ścieżki dostępu okrojone z otaczających ostrych nawiasów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the :attr:`botframe`, :attr:`stopframe`, :attr:`returnframe` and :attr:`quitting` attributes with values ready to start debugging.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw właściwości :attr:`botframe`, :attr:`stopframe`, :attr:`returnframe` i :attr:`quitting` z wartościami gotowymi do rozpoczęcia odpluskwiania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is installed as the trace function of debugged frames.  Its return value is the new trace function (in most cases, that is, itself).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest instalowane jako zadanie śledzenia odpluskwianych ramek. Jej wartość zwracana jest nowym zadaniem śledzenia (w większości przypadków, to jest, ono samo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default implementation decides how to dispatch a frame, depending on the type of event (passed as a string) that is about to be executed. *event* can be one of the following:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domyślne wypełnienie decyduje jak obsłużyć ramkę, w zależności od rodzaju zdarzenia (przekazanego jako ciąg znaków) które właśnie ma być wykonane. *event* może być jednym z następujących:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"line"``: A new line of code is going to be executed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"line"``: Nowa linia kodu będzie wykonywana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"call"``: A function is about to be called, or another code block entered.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"call"``: Zadanie będzie za chwilę wywołane, lub nastąpi wkroczenie do następnego bloku kodu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"return"``: A function or other code block is about to return.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"return"``: Zadanie lub inny blok kodu jest gotowy do powrotu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"exception"``: An exception has occurred.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"wyjątek"`` - z ang. - ``"exception"``: Wyjątek nastąpił.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"c_call"``: A C function is about to be called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"c_call"``: Zadanie C będzie wywoływane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"c_return"``: A C function has returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"c_return"``: Zadanie C wykonało powrót.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``"c_exception"``: A C function has thrown an exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``"wyjątek_c"`` - z ang. - ``"c_exception"``: zadanie C wyrzuciło wyjątek.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the Python events, specialized functions (see below) are called.  For the C events, no action is taken.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla zdarzeń języka pytonowskiego, specjalizowane zadania (zobacz poniżej) są wywoływane. Dla zdarzeń C, żadne działanie nie jest podejmowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *arg* parameter depends on the previous event.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *arg* zależy od poprzedniego zdarzenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the documentation for :func:`sys.settrace` for more information on the trace function.  For more information on code and frame objects, refer to :ref:`types`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zobacz dokumentację dla :func:`sys.settrace` po więcej informacji o zadaniu śledzenia. Po więcej informacji o kodzie i przedmiotach ramek, odwołaj się do :ref:`types`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the debugger should stop on the current line, invoke the :meth:`user_line` method (which should be overridden in subclasses). Raise a :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can be set from :meth:`user_line`).  Return a reference to the :meth:`trace_dispatch` method for further tracing in that scope.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli odpluskwianie powinno zatrzymać się na obecnej linii, wywołaj sposób postępowania :meth:`user_line` (która powinna być przesłonięta w podrzędnych uogólnieniach). Zgłoś wyjątek :exc:`BdbQuit` jeśli flaga :attr:`Bdb.quitting` jest ustawiona (co może zostać ustawione z :meth:`user_line`). Zwróć odniesienie do sposobu postępowania :meth:`trace_dispatch` dla dalszego śledzenia w tym kontekście.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the debugger should stop on this function call, invoke the :meth:`user_call` method (which should be overridden in subclasses). Raise a :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can be set from :meth:`user_call`).  Return a reference to the :meth:`trace_dispatch` method for further tracing in that scope.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli odpluskwianie powinno zakończyć się w tym wywołaniu zadania, wywołaj sposób postępowania :meth:`user_call` (co powinno być przesłonięte w podrzędnych uogólnieniach). Zgłoś wyjątek :exc:`BdbQuit` jeśli flaga :attr:`Bdb.quitting` jest ustawiona (co może być ustawione ze sposobu postępowania :meth:`user_call`). Zwróć odniesienie do sposobu postępowania :meth:`trace_dispatch` dla dalszego śledzenia w tym zakresie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the debugger should stop on this function return, invoke the :meth:`user_return` method (which should be overridden in subclasses). Raise a :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can be set from :meth:`user_return`).  Return a reference to the :meth:`trace_dispatch` method for further tracing in that scope.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli odpluskwianie powinno zatrzymać się na tym powrocie z zadania, wywołaj sposób postępowania :meth:`user_return` (która powinna być przesłonięty w podrzędnych uogólnieniach). Zgłasza wyjątek :exc:`BdbQuit` jeśli flaga :attr:`Bdb.quitting` jest ustawiona (co może być ustawione z :meth:`user_return`). Zwróć odniesienie do sposobu postępowania :meth:`trace_dispatch` dla dalszego śledzenia w tym zakresie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the debugger should stop at this exception, invokes the :meth:`user_exception` method (which should be overridden in subclasses). Raise a :exc:`BdbQuit` exception if the :attr:`Bdb.quitting` flag is set (which can be set from :meth:`user_exception`).  Return a reference to the :meth:`trace_dispatch` method for further tracing in that scope.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli odpluskwianie powinno zatrzymać się na tym wyjątku, zgłasza sposób postępowania :meth:`user_exception` (który powinien zostać przesłonięty w podrzędnym uogólnieniu). Zgłoś wyjątek :exc:`BdbQuit` jeśli flaga :attr:`Bdb.quitting` jest ustawiona (co może być ustawione ze sposobu postępowania :meth:`user_exception`). Zwróć odniesienie do sposobu postępowania :meth:`trace_dispatch` dla dalszego śledzenia w tym zakresie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally derived classes don't override the following methods, but they may if they want to redefine the definition of stopping and breakpoints.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Normalnie dziedziczone uogólnienia nie przesłaniają następujących sposobów postępowania, ale mogą jeśli chcą redefiniować definicję stopowania i punktów przerywania programu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method checks if the *frame* is somewhere below :attr:`botframe` in the call stack.  :attr:`botframe` is the frame in which debugging started.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania sprawdza czy *ramka* - z ang. - *frame* jest gdziekolwiek poniżej :attr:`botframe` na stercie wywołań. Właściwość :attr:`botframe` jest ramką od której odpluskwianie jest zaczynane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method checks if there is a breakpoint in the filename and line belonging to *frame* or, at least, in the current function.  If the breakpoint is a temporary one, this method deletes it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania sprawdza czy jest punkt przerywania wykonania programu w nazwie programu i linii należących do *ramki* lub przynajmniej obecnego zadania. Jeśli punkt przerywania jest tymczasowy, ten sposób postępowania kasuje go.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method checks if there is a breakpoint in the filename of the current frame.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania sprawdza czy jest punkt przerywania wykonania programu w nazwie pliku obecnej ramki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derived classes should override these methods to gain control over debugger operation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dziedziczone uogólnienia powinny przesłaniać te sposoby postępowania aby zyskać kontrolę ponad operacją odpluskwiania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is called from :meth:`dispatch_call` when there is the possibility that a break might be necessary anywhere inside the called function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania jest wywoływany z :meth:`dispatch_call` gdy jest możliwość że przerwanie programu może być konieczne gdzieś wewnątrz wywoływanego zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is called from :meth:`dispatch_line` when either :meth:`stop_here` or :meth:`break_here` yields True.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania jest wywoływany z :meth:`dispatch_line` gdy albo :meth:`stop_here` albo :meth:`break_here` zwraca Prawdę.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is called from :meth:`dispatch_return` when :meth:`stop_here` yields True.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania jest wywoływany ze sposobu postępowania :meth:`dispatch_return` gdy :meth:stop_here` daje Prawdę - z ang. - True.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is called from :meth:`dispatch_exception` when :meth:`stop_here` yields True.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania jest wywoływany z :meth:`dispatch_exception` gdy :meth:`stop_here` zwraca Prawdę.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handle how a breakpoint must be removed when it is a temporary one.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługuje jak punkt zatrzymania musi być usunięty gdy jest tymczasowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method must be implemented by derived classes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania musi być wypełniony przez odziedziczone uogólnienie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derived classes and clients can call the following methods to affect the stepping state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dziedziczące uogólnienia i klienci mogą wywoływać następujące sposoby postępowania aby wpływać na stan przechodzenia krok-po-kroku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop after one line of code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj się po jednej linii kodu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop on the next line in or below the given frame.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj się po następnej linii w lub poniżej danej ramki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop when returning from the given frame.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj się gdy następuje powrót z danej ramki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop when the line with the line no greater than the current one is reached or when returning from current frame</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj się gdy linia nie większa niż obecna jest osiągana lub gdy następuje powrót z obecnej ramki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start debugging from *frame*.  If *frame* is not specified, debugging starts from caller's frame.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zacznij odpluskwianie z *ramki*. Jeśli *ramka* jest nieokreślona, odpluskwianie zaczyna od ramki wywołującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stop only at breakpoints or when finished.  If there are no breakpoints, set the system trace function to None.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatrzymaj się tylko na punktach przerywania wykonania programu lub gdy zakończono. Jeśli nie ma punktów przerywania, ustaw zadanie śledzenia systemowego na None.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the :attr:`quitting` attribute to True.  This raises :exc:`BdbQuit` in the next call to one of the :meth:`dispatch_\*` methods.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw właściwość :attr:`quitting` na Prawdę. To zgłasza :exc:`BdbQuit` w następnym wywołaniu na jeden ze sposobów postępowania :meth:`dispatch_\*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derived classes and clients can call the following methods to manipulate breakpoints.  These methods return a string containing an error message if something went wrong, or ``None`` if all is well.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pochodne uogólnienia i klienci mogą wywoływać następujące sposoby postępowania aby zmieniać punkty przerywania wykonania programu. Te sposoby postępowania zwracają ciąg zawierający wiadomość o błędzie jeśli coś poszło nie tak, lub ``None`` jeśli wszystko jest w porządku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set a new breakpoint.  If the *lineno* line doesn't exist for the *filename* passed as argument, return an error message.  The *filename* should be in canonical form, as described in the :meth:`canonic` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw nowy punkt przerywania wykonania programu. Jeśli linia *lineno* nie istnieje fla pliku *filename* przekazywanego jako parametr, zwróć wiadomość o błędzie. Nazwa pliku - z ang. - *filename* powinna być w kanonicznej formie, jak opisano w sposobie postępowania :meth:`canonic`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the breakpoints in *filename* and *lineno*.  If none were set, an error message is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skasuj punkty przerywania programu w *nazwie pliku* i numer linii - z ang. - *lineno*. Jeśli żadne nie zostały ustawione, wiadomość o błędzie jest zwracana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the breakpoint which has the index *arg* in the :attr:`Breakpoint.bpbynumber`.  If *arg* is not numeric or out of range, return an error message.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skasuj punkt przerywania programu który ma indeks *arg* w :attr:`Breakpoint.bpbynumber`. Jeśli *arg* jest nie numeryczny lub poza zakresem, zwróć wiadomość o błędzie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete all breakpoints in *filename*.  If none were set, an error message is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skasuj wszystkie punkty przerywania programu w pliku *nazwa pliku* - z ang. *filename*. Jeśli żadne nie zostały ustawione, wiadomość o błędzie jest zwracana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete all existing breakpoints.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skasuj wszystkie istniejące punkty przerywania wykonania programu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check if there is a breakpoint for *lineno* of *filename*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdź czy jest punkt przerywania programu dla *lineno* - z ang. - *numeru linii* pliku *nazwa pliku*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return all breakpoints for *lineno* in *filename*, or an empty list if none are set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wszystkie punkty przerywania wykonania programu dla danego *lineno* w pliku *nazwa pliku* - z ang. - *filename* lub pustą listę jeśli żaden nie został ustawiony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return all breakpoints in *filename*, or an empty list if none are set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wszystkie punkty przerywania wykonania programu w *nazwie pliku*, lub pustą listę jeśli żaden nie został ustawiony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return all breakpoints that are set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wszystkie punkty przerywania wykonania programu które są ustawione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derived classes and clients can call the following methods to get a data structure representing a stack trace.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dziedziczące uogólnienia i klienci mogą wywoływać następujące sposoby postępowania aby uzyskać struktury danych reprezentujące ślad wywołań ze sterty wywołań.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get a list of records for a frame and all higher (calling) and lower frames, and the size of the higher part.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pobierz listę zapisów dla ramki i wszystkich powyżej (wywołań) i poniżej ramek, i rozmiar wyższej części.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a string with information about a stack entry, identified by a ``(frame, lineno)`` tuple:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć ciąg znaków z informacją o wpisie na stosie, identyfikowaną przez krotkę ``(ramka, lineno)`` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The canonical form of the filename which contains the frame.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kanoniczna postać nazwy pliku, który zawiera ramkę. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function name, or ``"&lt;lambda&gt;"``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nazwa zadania, lub ``"&lt;lambda&gt;"``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input arguments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametry wejściowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The return value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość zwracana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line of code (if it exists).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Linia kodu (jeśli istnieje).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following two methods can be called by clients to use a debugger to debug a :term:`statement`, given as a string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące dwa sposoby postępowania mogą być wywoływane przez klientów aby użyć odpluskwiania aby odpluskwić :term:`statement` - z ang. - :term:`stwierdzenie`, dane jako ciąg znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debug a statement executed via the :func:`exec` function.  *globals* defaults to :attr:`__main__.__dict__`, *locals* defaults to *globals*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpluskwiaj wyrażenie wykonywane przez zadanie :func:`exec`. *globals* domyślnie równa się :attr:`__main__.__dict__`, *locals* domyślnie równe jest *globals*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debug an expression executed via the :func:`eval` function.  *globals* and *locals* have the same meaning as in :meth:`run`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpluskwiaj wyrażenie wykonywane przez zadanie :func:`eval`. *globals* i *locals* mają to same znaczenie jak w sposobie postępowania :meth:`run`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For backwards compatibility.  Calls the :meth:`run` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla zgodności wstecznej. Wywołuje sposób postępowania :meth:`run`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debug a single function call, and return its result.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpluskwiaj pojedyncze wywołanie zadania, i zwróć jego wynik.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, the module defines the following functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ostatecznie moduł definiuje następujące zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check whether we should break here, depending on the way the breakpoint *b* was set.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdź czy powinniśmy przerwać tutaj, w zależności od sposobu w jaki punkt przerywania *b* został ustawiony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it was set via line number, it checks if ``b.line`` is the same as the one in the frame also passed as argument.  If the breakpoint was set via function name, we have to check we are in the right frame (the right function) and if we are in its first executable line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli został ustawiony przez numer linii, sprawdza czy ``b.line`` jest tożsame jak to w ramce także przekazywane jako parametr. Jeśli punkt przerywania wykonania programu został ustawiony przez nazwę zadania musimy sprawdzić czy jesteśmy we właściwej ramce (właściwym zadaniu) i czy jesteśmy w jego pierwszej wykonywalnej linii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Determine if there is an effective (active) breakpoint at this line of code. Return breakpoint number or 0 if none.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdź czy istnieje efektywny (aktywny) punkt przerywania wykonania programu w tej linii kodu. Zwróć punkt przerywania wykonania programu lub 0 jeśli żaden nie występuje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Called only if we know there is a breakpoint at this location.  Returns the breakpoint that was triggered and a flag that indicates if it is ok to delete a temporary breakpoint.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywoływane tylko jeśli wiemy, że jest punkt przerywania wykonania programu w tej lokalizacji. Zwróć punkt przerywania wykonania programu który został potrącony i flagę która wskazuje czy można skasować tymczasowy punkt przerywania wykonania programu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starts debugging with a :class:`Bdb` instance from caller's frame.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zaczyna odpluskwianie z przykładem uogólnienia :class:`Bdb` z ramki wywołującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`binascii` --- Convert between binary and ASCII</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`binascii` --- Zamień pomiędzy binary a kodem ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`binascii` module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like :mod:`uu`, :mod:`base64`, or :mod:`binhex` instead. The :mod:`binascii` module contains low-level functions written in C for greater speed that are used by the higher-level modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł :mod:`binascii` zawiera liczbę sposobów postępowania aby zamienić pomiędzy reprezentacją binarną a różnymi zakodowanymi-w-ASCII. Zwykle nie używasz tych zadań bezpośrednio ale używa modułów opakowania takich jak :mod:`uu`, :mod:`base64` lub :mod:`binhex` zamiast tego jednego. Moduł :mod:`binascii` zawiera nisko-poziomowe zadania napisane w C dla wyższych prędkości które są używane przez wyższego-poziomu moduły.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`binascii` module defines the following functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`binascii` definiuje następujące zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a single line of uuencoded data back to binary and return the binary data. Lines normally contain 45 (binary) bytes, except for the last line. Line data may be followed by whitespace.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień pojedynczą linię zakodowanych danych uu z powrotem do  postaci binarnej i zwróć binarne dane. Linie zwykle zawierają 45 (binarnych) bajtów, z wyjątkiem ostatniej linii. Po linii danych mogą następować białe znaki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert binary data to a line of ASCII characters, the return value is the converted line, including a newline char. The length of *data* should be at most 45.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień dane binarne na linię znaków ASCII, zwracana wartość jest konwertowaną linią, zawierając w tym znak nowego wiersza. Długość *danych* - z ang. - *data* powinna być najwięcej 45.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień blok danych base64 na binarne i zwróć dane binarne. Więcej niż jedna linia może być przekazywana na raz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert binary data to a line of ASCII characters in base64 coding. The return value is the converted line, including a newline char. The length of *data* should be at most 57 to adhere to the base64 standard.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień binarne dane do linii znaków ASCII w kodowaniu base64. Zwracana wartość jest zamienioną linią zawierając znak nowego wiersza. Długość *danych* - z ang. - *data* powinien być najdłużej 57 aby dostosować się do standardu base64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a block of quoted-printable data back to binary and return the binary data. More than one line may be passed at a time. If the optional argument *header* is present and true, underscores will be decoded as spaces.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień blok cytowanych-drukowalnych danych spowrotem do binarnych i zwróć dane binarne. Więcej niż jedna linia może być przekazywana na raz. Jeśli opcjonalny parametr *nagłówek* jest obecny i prawdziwy, podkreślenia będą zdekodowane jako odstępy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert binary data to a line(s) of ASCII characters in quoted-printable encoding.  The return value is the converted line(s). If the optional argument *quotetabs* is present and true, all tabs and spaces will be encoded.   If the optional argument *istext* is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument *header* is present and true, spaces will be encoded as underscores per RFC1522. If the optional argument *header* is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień dane binarne na linię znaków ASCII zakodowanych w cudzysłowach drukowalnych. Wartość zwracana jest zamienioną linią(ami). Jeśli opcjonalny parametr *quotetabs* jest obecny i prawdziwy, wszystkie tabulacje i odstępy zostaną zakodowane. Jeśli opcjonalny parametr *istext* jest obecny i prawdziwy, znaki nowego wiersza nie są kodowane ale kończące białe znaki zostaną zakodowane. Jeśli opcjonalny parametr *nagłówka* jest obecny i prawdziwy, odstępy będą zakodowane jako podkreślenia zgodne z RFC 1522. Jeśli opcjonalny parametr *nagłówka* - z ang. - *header* jest obecny i fałszywy, znaki nowego wiersza zostaną zakodowane także; w przeciwnym razie zamiana znaków nowego wiersza może popsuć binarny strumień danych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert binhex4 formatted ASCII data to binary, without doing RLE-decompression. The string should contain a complete number of binary bytes, or (in case of the last portion of the binhex4 data) have the remaining bits zero.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skonwertuj sformatowane binhex4 dane  ASCII do danych binarnych bez wykonywania dekompresji-RLE. Ciąg powinien zawierać pełną liczbę bajtów binarnych, lub (w przypadku ostatniej porcji danych binhex4) mieć pozostałe bity wyzerowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform RLE-decompression on the data, as per the binhex4 standard. The algorithm uses ``0x90`` after a byte as a repeat indicator, followed by a count. A count of ``0`` specifies a byte value of ``0x90``. The routine returns the decompressed data, unless data input data ends in an orphaned repeat indicator, in which case the :exc:`Incomplete` exception is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj dekompresję-RLE na danych, zgodnie ze standardem binhex4. Algorytm używa ``0x90`` po bajcie jako wskaźnik powtórzenia, po którym następuje zliczana liczba. Wartość zliczona ``0`` określa wartość bajtu ``0x90``. Zadanie zwraca rozpakowane dane, chyba że dane wejściowe kończą się osamotnionym wskazaniem powtórzenia, w którym to przypadku zgłaszany jest wyjątek :exc:`Niekompletny` - z ang. - :exc:`Incomplete`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform binhex4 style RLE-compression on *data* and return the result.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj kompresję RLE w stylu binhex4 na *danych* - z ang. - *data* i zwróć wynik.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perform hexbin4 binary-to-ASCII translation and return the resulting string. The argument should already be RLE-coded, and have a length divisible by 3 (except possibly the last fragment).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj tłumaczenie hexbin4 binarne-do-ASCII i zwróć wynikły ciąg znaków. Parametr powinien być już zakodowany kodem RLE, i mieć długość podzielną przez 3 (z wyjątkiem możliwie ostatniego fragmentu).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compute the binhex4 crc value of *data*, starting with an initial *crc* and returning the result.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oblicz wartość crc binhex4 *danych*, zaczynając z początkowym *crc* i zwracając wynik</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compute CRC-32, the 32-bit checksum of data, starting with an initial crc.  This is consistent with the ZIP file checksum.  Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm.  Use as follows::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Oblicz CRC-32, 32-bitową sumę kontrolną danych zaczynając z początkowym crc. To jest zgodne z sumą kontrolną plików ZIP. Od kiedy algorytm jest zaprojektowany dla użycia jako algorytm sprawdzania sumy kontrolnej, nie jest on odpowiedni dla użycia jako ogólny algorytm hash-owania. Używaj jak następuje::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>print(binascii.crc32(b"hello world")) # Or, in two pieces: crc = binascii.crc32(b"hello") crc = binascii.crc32(b" world", crc) &amp; 0xffffffff print('crc32 = {:#010x}'.format(crc))</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>print(binascii.crc32(b"witaj świecie)) # Lub, w dwóch kawałkach: crc = binascii.crc32(b"witaj") crc = binascii.crc32(b" świecie", crc) &amp; 0xffffffff print('crc32 = {:#010x}'.format(crc))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate the same numeric value across all Python versions and platforms use crc32(data) &amp; 0xffffffff.  If you are only using the checksum in packed binary format this is not necessary as the return value is the correct 32bit binary representation regardless of sign.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby wygenerować tą samą wartość numeryczną we wszystkich wersjach języka pytonowskiego i wszystkich maszynach/środowiskach używaj crc32(dane) &amp; 0xffffffff. Jeśli tylko używasz sumy kontrolnej w spakowanej binarnej postaci to nie jest konieczne jako że wartość zwracana jest poprawną 32bitową binarną reprezentacją niezależną od znaku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hexadecimal representation of the binary *data*.  Every byte of *data* is converted into the corresponding 2-digit hex representation.  The resulting string is therefore twice as long as the length of *data*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć heksadecymalną reprezentację *danych* binarnych. Każdy bajt *danych* jest konwertowany do odpowiadającego 2-cyfrowej reprezentacji heksadecymalnej. Wynikający ciąg znaków jest z tego też powodu dwukrotnie dłuższy od długości *danych*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the binary data represented by the hexadecimal string *hexstr*.  This function is the inverse of :func:`b2a_hex`. *hexstr* must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise a :exc:`TypeError` is raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć binarną reprezentację danych przez heksadecymalny ciąg znaków *hexstr*. To zadanie jest przeciwnym do :func:`b2a_hex`. *hexstr* musi zawierać parzystą liczbę heksadecymalnych cyfr (które mogą być dużymi lub małymi literami), w przeciwnym razie wyjątek :exc:`TypeError` jest zgłaszany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception raised on errors. These are usually programming errors.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyjątek zgłaszany przy błędach. Istnieją zwykle błędy programowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception raised on incomplete data. These are usually not programming errors, but may be handled by reading a little more data and trying again.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyjątek zgłaszany przy niekompletnych danych. Te nie są zwykle błędami programowania, ale mogą być obsługiwane przez wczytanie odrobiny więcej danych i próbując jeszcze raz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for base64 encoding used in MIME email messages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla kodowania base64 w wiadomościach email MIME.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for the binhex format used on the Macintosh.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla formatu binhex używanego na Macintoshu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for UU encoding used on Unix.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla kodowania UU używanego na Unixie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for quoted-printable encoding used in MIME email messages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wsparcie dla cytowanych-drukowalnych kodowań używanych w wiadomościach email typu MIME.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`binhex` --- Encode and decode binhex4 files</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`binhex` --- Koduj i dekoduj pliki binhex4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module encodes and decodes files in binhex4 format, a format allowing representation of Macintosh files in ASCII. Only the data fork is handled.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł koduje i dekoduje pliki w formacie binhex4, formacie pozwalającym reprezentację plików Macintosha w ASCII. Tylko rozwidlenie danych jest obsługiwane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`binhex` module defines the following functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>moduł :mod:`binhex` definiuje następujące zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a binary file with filename *input* to binhex file *output*. The *output* parameter can either be a filename or a file-like object (any object supporting a :meth:`write` and :meth:`close` method).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień plik binarny z nazwą pliku *input* do pliku binhex *output*. Parametr *output* może albo być nazwą pliku lub przedmiotem podobnym do pliku (dowolny przedmiot wspierający sposoby postępowania :meth:`write` - z ang. - :meth:`zapisz` i :meth:`close` - z ang. - :meth:`zamknij`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decode a binhex file *input*. *input* may be a filename or a file-like object supporting :meth:`read` and :meth:`close` methods. The resulting file is written to a file named *output*, unless the argument is ``None`` in which case the output filename is read from the binhex file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekoduj plik binhex *input*. *input* może być nazwą pliku lub przedmiotem podobnym do pliku wspierającym sposoby postępowania :meth:`read` i :meth:`close`. Wynikający plik jest zapisywany do pliku nazwanego *output*, chyba, że parametr jest ``None`` - z ang. - ``Żaden`` w którym przypadku nazwa pliku jest wczytywana z pliku binhex.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following exception is also defined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujący wyjątek jest także zdefiniowany:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception raised when something can't be encoded using the binhex format (for example, a filename is too long to fit in the filename field), or when input is not properly encoded binhex data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyjątek zgłaszany gdy coś nie może być zakodowane używając formatu binhex (dla przykładu, nazwa pliku jest za długa aby dopasować do pola nazwy pliku), lub gdy wejście nie jest poprawnie zakodowanymi danymi binhex.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwagi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an alternative, more powerful interface to the coder and decoder, see the source for details.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje alternatywny, bardziej silny sprzęg kodera i dekodera, zobacz źródło dla szczegółów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you code or decode textfiles on non-Macintosh platforms they will still use the old Macintosh newline convention (carriage-return as end of line).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli kodujesz lub dekodujesz pliki tekstowe na maszynie/środowisku nie-Macintoshu one będą wciąż używały starej konwencji znaków nowego wiersza z Macintosha (powrót-karetki jako końca linii).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As of this writing, :func:`hexbin` appears to not work in all cases.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W momencie pisania tego zadanie :func:`hexbin` sprawia wrażenie nie działającej we wszystkich przypadkach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`bisect` --- Array bisection algorithm</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`bisect` --- algorytm bisekcji tablicy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion.  For long lists of items with expensive comparison operations, this can be an improvement over the more common approach.  The module is called :mod:`bisect` because it uses a basic bisection algorithm to do its work.  The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza wsparcia dla utrzymywania listy w posortowanym porządku bez konieczności sortowania listy po każdym wstawieniu. Dla długich list przedmiotów o kosztownych operacjach porównania, to może być polepszenie względem bardziej typowego podejścia. Moduł jest zwany :mod:`bisect` ponieważ używa używa podstawowego algorytmu bisekcji aby wykonać swoją pracę. Kod źródłowy może być najbardziej użyteczny jako działający przykład algorytmu (warunki brzegowe są już od razu poprawne!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions are provided:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania są dostarczone:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Locate the proper insertion point for *x* in *a* to maintain sorted order. The parameters *lo* and *hi* may be used to specify a subset of the list which should be considered; by default the entire list is used.  If *x* is already present in *a*, the insertion point will be before (to the left of) any existing entries.  The return value is suitable for use as the first parameter to ``list.insert()``.  This assumes that *a* is already sorted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Znajdź poprawny punkt wstawienia dla *x* w *a* aby utrzymać posortowany porządek. Parametry *lo* i *hi* mogą być użyte do określenia podzbioru listy który powinien być brany pod uwagę; domyślnie cała lista jest używana. Jeśli *x* jest już obecne w *a* punkt wstawiania będzie przed (po lewej stronie) jakimikolwiek wpisami. Wartość zwracana jest dobra do użycia jako pierwszy parametr ``list.insert()``. To zakłada że *a* jest już posortowana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to :func:`bisect_left`, but returns an insertion point which comes after (to the right of) any existing entries of *x* in *a*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podobna do zadania :func:`bisect_left` ale zwraca punkt wstawiania który jest po (po prawej stronie od) jakichkolwiek wpisów *x* w *a*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert *x* in *a* in sorted order.  This is equivalent to ``a.insert(bisect.bisect_left(a, x, lo, hi), x)``.  This assumes that *a* is already sorted.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wstaw *x* w *a* w posortowany sposób. To jest równoważne do ``a.insert(bisect_left(a, x, lo, hi), x)``. To zakłada że *a* jest już posortowane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similar to :func:`insort_left`, but inserting *x* in *a* after any existing entries of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>podobne do zadania :func:`insort_left`, ale wstawiając *x* w *a* po jakichkolwiek wpisach *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :func:`bisect` function is generally useful for categorizing numeric data. This example uses :func:`bisect` to look up a letter grade for an exam total (say) based on a set of ordered numeric breakpoints: 85 and up is an 'A', 75..84 is a 'B', etc.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie :func:`bisect` jest ogólnie użyteczne dla kategoryzacji danych numerycznych. Ten przykład używa :func:`bisect` aby podejrzeć literową ocenę za sumę z egzaminu (powiedzmy) w oparciu o zbiór uporządkowanych numerycznych punktów przerwań: 85 i więcej dla 'A', 75..84 dla 'B', itd.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; grades = "FEDCBA" &gt;&gt;&gt; breakpoints = [30, 44, 66, 75, 85] &gt;&gt;&gt; from bisect import bisect &gt;&gt;&gt; def grade(total): ...           return grades[bisect(breakpoints, total)] ... &gt;&gt;&gt; grade(66) 'C' &gt;&gt;&gt; map(grade, [33, 99, 77, 44, 12, 88]) ['E', 'A', 'B', 'D', 'F', 'A']</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; grades = "FEDCBA" &gt;&gt;&gt; breakpoints = [30, 44, 66, 75, 85] &gt;&gt;&gt; from bisect import bisect &gt;&gt;&gt; def grade(total): ...           return grades[bisect(breakpoints, total)] ... &gt;&gt;&gt; grade(66) 'C' &gt;&gt;&gt; map(grade, [33, 99, 77, 44, 12, 88]) ['E', 'A', 'B', 'D', 'F', 'A']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the :func:`sorted` function, it does not make sense for the :func:`bisect` functions to have *key* or *reversed* arguments because that would lead to an inefficent design (successive calls to bisect functions would not "remember" all of the previous key lookups).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W przeciwieństwie do zadania :func:`sorted`, nie ma sensu dla zadań :func:`bisect` mieć *kluczowe* - z ang. - *key* lub *odwrócone* - z ang. - *reversed* parametry ponieważ to mogłoby prowadzić do nieefektywnego układu (kolejne wywołania zadań bisekcji nie "pamiętałyby" wszystkich poprzednich podejrzeń klucza).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead, it is better to search a list of precomputed keys to find the index of the record in question::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamiast tego, lepiej jest przeszukać listę uprzednio obliczonych wartości kluczowych aby odnaleźć indeks poszukiwanego zapisu:: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)] &gt;&gt;&gt; data.sort(key=lambda r: r[1]) &gt;&gt;&gt; keys = [r[1] for r in data]         # precomputed list of keys &gt;&gt;&gt; data[bisect_left(keys, 0)] ('black', 0) &gt;&gt;&gt; data[bisect_left(keys, 1)] ('blue', 1) &gt;&gt;&gt; data[bisect_left(keys, 5)] ('red', 5) &gt;&gt;&gt; data[bisect_left(keys, 8)] ('yellow', 8)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; data = [('czerwony', 5), ('niebieski', 1), ('żółty', 8), ('czarny', 0)] &gt;&gt;&gt; data.sort(key=lambda r: r[1]) &gt;&gt;&gt; keys = [r[1] for r in data]         # przeliczona uprzednio lista kluczy &gt;&gt;&gt; data[bisect_left(keys, 0)] ('czarny', 0) &gt;&gt;&gt; data[bisect_left(keys, 1)] ('niebieski', 1) &gt;&gt;&gt; data[bisect_left(keys, 5)] ('czerwony', 5) &gt;&gt;&gt; data[bisect_left(keys, 8)] ('żółty', 8)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`builtins` --- Built-in objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`builtins` --- przedmioty wbudowane</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides direct access to all 'built-in' identifiers of Python; for example, ``builtins.open`` is the full name for the built-in function :func:`open`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza bezpośredni dostęp do wszystkich 'wbudowanych' identyfikatorów języka pytonowskiego; dla przykładu ``builtins.open`` jest pełną nazwą dla wbudowanego zadania :func:`open`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module is not normally accessed explicitly by most applications, but can be useful in modules that provide objects with the same name as a built-in value, but in which the built-in of that name is also needed.  For example, in a module that wants to implement an :func:`open` function that wraps the built-in :func:`open`, this module can be used directly::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostęp do tego modułu nie jest zwykle otrzymywany jawnie przy większości aplikacji, ale może być użyteczny w modułach które dostarczają przedmiotów o tej samej nazwie jak wartość wbudowana, ale w których wbudowany przedmiot o tej nazwie jest także wymagany. Dla przykładu w module który chce wypełnić zadanie :func:`open` w szczególny sposób które opakowuje wbudowane zadanie :func:`open`, ten moduł może być używany bezpośrednio::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import builtins  def open(path):     f = builtins.open(path, 'r')     return UpperCaser(f)  class UpperCaser:     '''Wrapper around a file that converts output to upper-case.'''      def __init__(self, f):         self._f = f      def read(self, count=-1):         return self._f.read(count).upper()      # ...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import builtins  def open(path):     f = builtins.open(path, 'r')     return UpperCaser(f)  class UpperCaser:     '''Opakowanie wokół pliku które zamienia wyjście na wielkie litery.'''      def __init__(self, f):         self._f = f      def read(self, count=-1):         return self._f.read(count).upper()      # ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an implementation detail, most modules have the name ``__builtins__`` (note the ``'s'``) made available as part of their globals.  The value of ``__builtins__`` is normally either this module or the value of this modules's :attr:`__dict__` attribute.  Since this is an implementation detail, it may not be used by alternate implementations of Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jako szczegół wypełnienia, większość modułów ma nazwę ``__builtins__`` (zauważ ``'s'``) dostępną jako część ich przedmiotów globalnych - w znaczeniu nadrzędnych. Wartość ``__builtins__`` jest zwykle tym modułem lub wartością właściwości :attr:`__dict__` tego modułu. Ponieważ jest to szczegół wypełnienia, nie może to być wykorzystane przez odmienne wypełnienia języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`bz2` --- Compression compatible with :program:`bzip2`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`bz2` --- Kompresja odpowiadająca programowi :program:`bzip2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides a comprehensive interface for the bz2 compression library. It implements a complete file interface, one-shot (de)compression functions, and types for sequential (de)compression.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza zrozumiałego sprzęgu dla biblioteki kompresji bz2. Wypełnia całkowicie sprzęg pliku, jednorazowego-uruchomienia zadania (de)kompresji i typów dla (de)kompresji sekwencyjnej.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For other archive formats, see the :mod:`gzip`, :mod:`zipfile`, and :mod:`tarfile` modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla innych formatów archiwów, zobacz moduły :mod:`gzip`, :mod:`zipfile`, i :mod:`tarfile`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a summary of the features offered by the bz2 module:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tu jest podsumowanie właściwości oferowanych przez moduł bz2:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`BZ2File` class implements a complete file interface, including :meth:`~BZ2File.readline`, :meth:`~BZ2File.readlines`, :meth:`~BZ2File.writelines`, :meth:`~BZ2File.seek`, etc;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`BZ2File` wypełnia kompletny sprzęg pliku zawierając sposoby postępowania :meth:`~BZ2File.readline`, :meth:`~BZ2File.readlines`, :meth:`~BZ2File.writelines`, :meth:`~BZ2File.seek`, itd;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`BZ2File` class implements emulated :meth:`~BZ2File.seek` support;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`BZ2File` wypełnia emulowane wsparcie dla :meth:`~BZ2File.seek`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`BZ2File` class implements universal newline support;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`BZ2File` wypełnia wsparcie dla uniwersalnego nowego wiersza;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`BZ2File` class offers an optimized line iteration using the readahead algorithm borrowed from file objects;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`BZ2File` oferuje optymalizowaną iterację linii używając algorytmu wczytywania z wyprzedzeniem zapożyczonego od przedmiotów plików;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequential (de)compression supported by :class:`BZ2Compressor` and :class:`BZ2Decompressor` classes;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sekwencyjna (de)kompresja wspierana przez uogólnienia :class:`BZ2Compressor` i :class:`BZ2Decompressor`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One-shot (de)compression supported by :func:`compress` and :func:`decompress` functions;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"Jednego-strzału" (de)kompresja wspierana przez zadania :func:`compress` i :func:`decompress`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread safety uses individual locking mechanism.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bezpieczeństwo wątków używa indywidualnego mechanizmu blokowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(De)compression of files</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(De)kompresja plików</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling of compressed files is offered by the :class:`BZ2File` class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługa skompresowanych plików jest oferowana przez uogólnienie :class:`BZ2File`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a bz2 file. Mode can be either ``'r'`` or ``'w'``, for reading (default) or writing. When opened for writing, the file will be created if it doesn't exist, and truncated otherwise. If *buffering* is given, ``0`` means unbuffered, and larger numbers specify the buffer size; the default is ``0``. If *compresslevel* is given, it must be a number between ``1`` and ``9``; the default is ``9``. Add a ``'U'`` to mode to open the file for input with universal newline support. Any line ending in the input file will be seen as a ``'\n'`` in Python.  Also, a file so opened gains the attribute :attr:`newlines`; the value for this attribute is one of ``None`` (no newline read yet), ``'\r'``, ``'\n'``, ``'\r\n'`` or a tuple containing all the newline types seen. Universal newlines are available only when reading. Instances support iteration in the same way as normal :class:`file` instances.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Otwórz plik bz2. Tryb może być albo ``'r'`` albo ``'w'``, dla wczytywania (dmyślnego) lub zapisywania. Gdy otwarty na pisanie, plik zostanie utworzony jeśli nie istnieje, i obcięty w przeciwnym wypadku. Jeśli *przestrzeń wymiany* jest dana, ``0`` oznacza bez przestrzeni wymiany, zaś większe liczby określają rozmiar przestrzeni wymiany; domyślna wartość jest ``0``. Jeśli *compresslevel* - z ang. - poziom kompresji jest dany, musi być liczbą pomiędzy ``1`` i ``9``; domyślna jest ``9``. Dodaj ``'U'`` do trybu aby otworzyć plik dla wczytywania ze wsparciem dla uniwersalnego nowego wiersza. Dowolne linie kończące się w pliku wejściowym będą widziane jako ``'
'`` w języku pytonowskim. Także plik tak otwarty zyskuje właściwość :attr:`newlines`; wartość tej właściwości jest jedną z ``None`` (- nie wczytano jeszcze nowej linii), ``'&#13;'``, ``'
'``, ``'&#13;
'`` lub krotka zawierająca wszystkie typy nowego wiersza zaobserwowane. Uniwersalne nowe linie są dostępne tylko przy wczytywaniu. Przykłady wspierają iterację w ten sam sposób jak zwykłe przykłady :class:`file`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`BZ2File` supports the :keyword:`with` statement.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`BZ2File` wspiera wyrażenie :keyword:`with` - z ang. - :keyword:`z`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the file. Sets data attribute :attr:`closed` to true. A closed file cannot be used for further I/O operations. :meth:`close` may be called more than once without error.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamknij plik. Ustawia właściwość danych :attr:`closed` na prawdę. Zamknięty plik nie może być używany dla dalszych operacji I/O - wejścia/wyjścia. Sposób postępowania :meth:`close` może być wywoływany więcej niż raz bez błędu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read at most *size* uncompressed bytes, returned as a byte string. If the *size* argument is negative or omitted, read until EOF is reached.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj nie więcej niż *size* nieskompresowanych bajtów zwracanych jako ciąg bajtów. Jeśli parametr *size* jest ujemny bądź pominięty, wczytuj aż napotkasz znak końca pliku - z ang. - EOF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the next line from the file, as a byte string, retaining newline. A non-negative *size* argument limits the maximum number of bytes to return (an incomplete line may be returned then). Return an empty byte string at EOF.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć następną linię z pliku, jako ciąg bajtów zachowując znak nowego wiersza. Nieujemny parametr *size* ogranicza maksymalną liczbę bajtów do zwrócenia (niekompletna linia może być w ten sposób zwrócona). Zwróć pusty ciąg bajtów w momencie napotkania EOF.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a list of lines read. The optional *size* argument, if given, is an approximate bound on the total number of bytes in the lines returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć listę wczytanych linii. Opcjonalny parametr *size* jeśli dany jest przybliżoną granicą całkowitej liczby bajtów w zwróconych liniach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move to new file position. Argument *offset* is a byte count. Optional argument *whence* defaults to ``os.SEEK_SET`` or ``0`` (offset from start of file; offset should be ``&gt;= 0``); other values are ``os.SEEK_CUR`` or ``1`` (move relative to current position; offset can be positive or negative), and ``os.SEEK_END`` or ``2`` (move relative to end of file; offset is usually negative, although many platforms allow seeking beyond the end of a file).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przesuń do nowej pozycji pliku. Parametr *offset* jest liczbą bajtów. Opcjonalny parametr *whence* domyślnie równy jest ``os.SEEK_SET`` lub ``0`` (przesunięcie względem początku pliku; przesunięcie powinno być ``&gt;= 0``); inne wartości są ``os.SEEK_CUR`` lub ``1`` (przesuń względem obecnej pozycji; przesunięcie może być dodatnie lub ujemne), i ``os.SEEK_END`` lub ``2`` (przesuń względem końca pliku; przesunięcie jest zwykle ujemne, chociaż wiele maszyn/środowisk pozwala na przeszukiwanie poza końcem pliku).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that seeking of bz2 files is emulated, and depending on the parameters the operation may be extremely slow.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że przeszukiwanie pliku bz2 jest emulowane, i w zależności od parametrów operacja może być bardzo powolna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the current file position, an integer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć pozycję w obecnym pliku, liczbę całkowitą.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write the byte string *data* to file. Note that due to buffering, :meth:`close` may be needed before the file on disk reflects the data written.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz ciąg bajtów *data* do pliku. Zauważ, że z powodu przestrzeni wymiany, sposób postępowania :meth:`close` może być konieczny zanim plik na dysku będzie odzwierciedlał dane zapisane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write the sequence of byte strings to the file. Note that newlines are not added. The sequence can be any iterable object producing byte strings. This is equivalent to calling write() for each byte string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz sekwencję ciągów bajtów do pliku. Zauważ, że nowe linie nie są dodawane. Sekwencja może być dowolnym iterowalnym przedmiotem produkującym ciągi bajtów. To jest równoważne wywołaniu zapisu write() dla każdego ciągu bajtów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequential (de)compression</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sekwencyjna (de)kompresja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sequential compression and decompression is done using the classes :class:`BZ2Compressor` and :class:`BZ2Decompressor`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sekwencyjna kompresja i dekompresja jest wykonywana używając uogólnień :class:`BZ2Compressor` i :class:`BZ2Decompressor`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new compressor object. This object may be used to compress data sequentially. If you want to compress data in one shot, use the :func:`compress` function instead. The *compresslevel* parameter, if given, must be a number between ``1`` and ``9``; the default is ``9``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stwórz nowy przedmiot kompresora. Ten przedmiot może być użyty do kompresowania danych sekwencyjnie. Jeśli chcesz skompresować dane za jednym zamachem, użyj zadania :func:`compress` zamiast tego. Parametr *compresslevel* jeśli dany musi być liczbą pomiędzy ``1`` i ``9``; domyślnie jest ``9``.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide more data to the compressor object. It will return chunks of compressed data whenever possible. When you've finished providing data to compress, call the :meth:`flush` method to finish the compression process, and return what is left in internal buffers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcz więcej danych do przedmiotu kompresora. Zwróci kawałki skompresowanych danych gdzie jest to możliwe. Gdy skończysz dostarczać dane do skompresowania, wywołaj sposób postępowania :meth:`flush` do zakończenia procesu kompresowania i zwróć to co zostało w wewnętrznych przestrzeniach wymiany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finish the compression process and return what is left in internal buffers. You must not use the compressor object after calling this method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakończ proces kompresji i zwróć to co zostało w wewnętrznych przestrzeniach wymiany. Nie można używać więcej przedmiotu kompresora po wywołaniu tego sposobu postępowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new decompressor object. This object may be used to decompress data sequentially. If you want to decompress data in one shot, use the :func:`decompress` function instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz nowy przedmiot dekompresora. Ten przedmiot może być używany do dekompresji danych sekwencyjnie. Jeśli chcesz dekompresować dane za jednym zamachem, użyj zadania :func:`decompress` zamiast tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provide more data to the decompressor object. It will return chunks of decompressed data whenever possible. If you try to decompress data after the end of stream is found, :exc:`EOFError` will be raised. If any data was found after the end of stream, it'll be ignored and saved in :attr:`unused_data` attribute.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostarcz więcej danych do przedmiotu dekompresora. Zwróci kawałki dekompresowanych danych gdy to możliwe. Jeśli będziesz próbował dekompresować dane po napotkaniu końca strumienia, wyjątek :exc:`EOFError` zostanie zgłoszony. Jeśli jakiekolwiek dane zostaną napotkane po końcu strumienia, zostaną zignorowane i zapisane we właściwości :attr:`unused_data`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One-shot (de)compression</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedno-razowa (de)kompresja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One-shot compression and decompression is provided through the :func:`compress` and :func:`decompress` functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jedno-razowa kompresja i dekompresja jest dostarczona przez zadania :func:`compress` i :func:`decompress`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compress *data* in one shot. If you want to compress data sequentially, use an instance of :class:`BZ2Compressor` instead. The *compresslevel* parameter, if given, must be a number between ``1`` and ``9``; the default is ``9``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zkompresuj *dane* za jednym zamachem. Jeśli chcesz kompresować dane sekwencyjnie, użyj przykładu uogólnienia :class:`BZ2Compressor` zamiast tego. Parametr *compresslevel*, jeśli dany musi być liczbą pomiędzy ``1`` i ``9``; domyślnie jest to ``9``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decompress *data* in one shot. If you want to decompress data sequentially, use an instance of :class:`BZ2Decompressor` instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekompresuj *dane* za jednym zamachem. Jeśli chcesz dekompresować dane sekwencyjnie, użyj przykładu uogólnienia :class:`BZ2Decompressor` zamiast tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`calendar` --- General calendar-related functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`calendar` --- Ogólnie zadania związane z kalendarzem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module allows you to output calendars like the Unix :program:`cal` program, and provides additional useful functions related to the calendar. By default, these calendars have Monday as the first day of the week, and Sunday as the last (the European convention). Use :func:`setfirstweekday` to set the first day of the week to Sunday (6) or to any other weekday.  Parameters that specify dates are given as integers. For related functionality, see also the :mod:`datetime` and :mod:`time` modules.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł pozwala ci produkować kalendarze tak jak program Unix-a :program:`cal`, i dostarcza dodatkowych użytecznych zadań związanych z kalendarzem. Domyślnie te kalendarze mają poniedziałek jako pierwszy dzień tygodnia, i niedzielę jako ostatni (konwencja Europejska). Użyj zadania :func:`setfirstweekday` aby ustawić pierwszy dzień tygodnia na niedzielę (6) lub jakikolwiek inny dzień tygodnia. Parametry które określają daty podane są jako liczby całkowite. Dla powiązanej funkcjonalności zobacz moduły :mod:`datetime` i :mod:`time`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of these functions and classes rely on the :mod:`datetime` module which uses an idealized calendar, the current Gregorian calendar indefinitely extended in both directions.  This matches the definition of the "proleptic Gregorian" calendar in Dershowitz and Reingold's book "Calendrical Calculations", where it's the base calendar for all computations.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość z tych zadań i uogólnień opiera się na module :mod:`datetime`, który używa idealizowanego kalendarza, obecnego kalendarza Gregoriańskiego rozciągniętego bez ograniczeń w obu kierunkach. To odpowiada definicji proleptycznego kalendarza Gregoriańskiego w książce "Kalendarzowe obliczenia" Dershowitza i Reingold-a, gdzie jest on podstawowym kalendarzem dla wszystkich obliczeń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creates a :class:`Calendar` object. *firstweekday* is an integer specifying the first day of the week. ``0`` is Monday (the default), ``6`` is Sunday.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzy przedmiot :class:`Calendar`. *Pierwszy dzień tygodnia* - z ang. - *firstweekday* jest liczbą całkowitą określającą pierwszy dzień tygodnia. ``0`` jest Poniedziałkiem (domyślnie), ``6`` jest Niedzielą.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Calendar` object provides several methods that can be used for preparing the calendar data for formatting. This class doesn't do any formatting itself. This is the job of subclasses.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmiot uogólnienia :class:`Calendar` dostarcza kilkanaście metod, które mogą być używane dla przygotowania danych kalendarza dla formatowania. To uogólnienie nie robi żadnego formatowania samodzielnie. To jest zadaniem podrzędnych uogólnień.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Calendar` instances have the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przykłady :class:`Calendar` mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return an iterator for the week day numbers that will be used for one week.  The first value from the iterator will be the same as the value of the :attr:`firstweekday` property.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć przedmiot iterujący dla numerów dni tygodnia które będą użyte w jednym tygodniu. Pierwsza wartość z przedmiotu iterującego będzie taka sama jak wartość właściwości :attr:`firstweekday`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return an iterator for the month *month* (1-12) in the year *year*. This iterator will return all days (as :class:`datetime.date` objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć przedmiot iterujący dla miesiąca *month* (1-12) w roku *year*. Przedmiot iterujący będzie zwracał wszystkie dni (jako przedmioty :class:`datetime.date`) dla miesiąca i wszystkie dni przed początkiem miesiąca lub po końcu miesiąca które są wymagane aby otrzymać pełen tydzień.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return an iterator for the month *month* in the year *year* similar to :meth:`itermonthdates`. Days returned will be tuples consisting of a day number and a week day number.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć przedmiot iterujący dla *miesiąca* - z ang. - *month* w *roku* - z ang. - *year* podobnego do :meth:`itermonthdates`. Dni zwracane będą krotkami składającymi się z numeru dnia i numeru dnia tygodnia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return an iterator for the month *month* in the year *year* similar to :meth:`itermonthdates`. Days returned will simply be day numbers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć przedmiot iterujący dla *miesiąca* w *roku* - z ang. - *month* in the *year* podobnego do :meth:`itermonthdates`. Dni zwracane będą po prostu numerami dni.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a list of the weeks in the month *month* of the *year* as full weeks.  Weeks are lists of seven :class:`datetime.date` objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć listę tygodni w *miesiącach* - z ang. - *month* *roku* - z ang. - *year* jako pełnych tygodni. Tygodnie są listami siedmiu przedmiotów :class:`datetime.date`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a list of the weeks in the month *month* of the *year* as full weeks.  Weeks are lists of seven tuples of day numbers and weekday numbers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć listę tygodni w *miesiącu*, *roku* jako pełnych tygodni. Tygodnie są listami siedmiu krotek numerów dni i numerów dni tygodnia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a list of the weeks in the month *month* of the *year* as full weeks.  Weeks are lists of seven day numbers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć listę tygodni w *miesiącu*, *roku* jako pełnych tygodni. Tygodnie są listami siedmio-dniowych liczb.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to *width* months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1--7 days. Days are :class:`datetime.date` objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć dane dla określonego roku gotowe do formatowania. Wartość zwracana jest listą wierszy-miesięcy. Każdy wiersz miesięcy zawiera *szerokość* - z ang. - *width* miesięcy (domyślnie 3). Każdy miesiąc zawiera pomiędzy 4 a 6 tygodni a każdy tydzień zawiera między 1--7 dni. Dni są przedmiotami uogólnienia :class:`datetime.date`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the data for the specified year ready for formatting (similar to :meth:`yeardatescalendar`). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć dane dla określonego roku gotowe do formatowania (podobne do sposobu postępowania :meth:`yeardatescalendar`). Wpisy na listach tygodni są krotkami numerów dni i numerów dni tygodnia. Numery dni poza tym miesiącem są równe zero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the data for the specified year ready for formatting (similar to :meth:`yeardatescalendar`). Entries in the week lists are day numbers. Day numbers outside this month are zero.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć dane dla określonego roku gotowe do formatowania (podobne do sposobu postępowania :meth:`yeardatescalendar`). Wpisy na listach tygodni są numerami dni. Numery dni poza tym miesiącem są równe zero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class can be used to generate plain text calendars.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie może być używane do utworzenia kalendarzy czystym tekstem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`TextCalendar` instances have the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnienia :class:`TextCalendar` mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a month's calendar in a multi-line string. If *w* is provided, it specifies the width of the date columns, which are centered. If *l* is given, it specifies the number of lines that each week will use. Depends on the first weekday as specified in the constructor or set by the :meth:`setfirstweekday` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć kalendarz miesiąca w wielo-liniowym ciągu znaków. Jeśli *w* jest dostarczony, określa szerokość kolumn daty, które są wycentrowane. Jeśli *l* jest dane, określa liczbę linii, których każdy tydzień będzie używał. Zależy od pierwszego dnia tygodnia jak określono w konstruktorze lub ustawiono sposobem postępowania :meth:`setfirstweekday`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print a month's calendar as returned by :meth:`formatmonth`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydrukuj miesięczny kalendarz jak zwrócono przez sposób postępowania :meth:`formatmonth`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a *m*-column calendar for an entire year as a multi-line string. Optional parameters *w*, *l*, and *c* are for date column width, lines per week, and number of spaces between month columns, respectively. Depends on the first weekday as specified in the constructor or set by the :meth:`setfirstweekday` method.  The earliest year for which a calendar can be generated is platform-dependent.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć *m*-kolumnowy kalendarz dla całego roku jako wielo-liniowy ciąg znaków. Opcjonalne parametry *w*, *l*, i *c* służą szerokości kolumn dat, linii na tydzień i liczby odstępów pomiędzy kolumnami miesięcy, odpowiednio. Zależy od pierwszego dnia tygodnia jak określono w konstruktorze lub ustawiono sposobem postępowania :meth:`setfirstweekday`. Najwcześniejszy rok dla którego kalendarz może być wytworzony zależy od maszyny/środowiska.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print the calendar for an entire year as returned by :meth:`formatyear`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Drukuj kalendarz dla całego roku jak zwrócono ze sposobu postępowania :meth:`formatyear`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class can be used to generate HTML calendars.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie może być używane do wytworzenia kalendarzy HTML.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`HTMLCalendar` instances have the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnienia :class:`HTMLCalendar` mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a month's calendar as an HTML table. If *withyear* is true the year will be included in the header, otherwise just the month name will be used.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć miesięczny kalendarz jako tabelę HTML. Jeśli *withyear* jest prawdziwe rok zostanie załączony w nagłówku, w przeciwnym przypadku tylko nazwa miesiąca będzie użyta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a year's calendar as an HTML table. *width* (defaulting to 3) specifies the number of months per row.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć roczny kalendarz jako tabelę HTML. *szerokość* - z ang. - *width* (domyślnie równa 3) określa liczbę miesięcy na wiersz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a year's calendar as a complete HTML page. *width* (defaulting to 3) specifies the number of months per row. *css* is the name for the cascading style sheet to be used. :const:`None` can be passed if no style sheet should be used. *encoding* specifies the encoding to be used for the output (defaulting to the system default encoding).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć kalendarz roczny jako kompletną stronę HTML. *szerokość* - z ang. - *width* (domyślnie równa 3) określa liczbę miesięcy na wiersz. *css* jest nazwą kaskadowego arkusza stylów do użycia. :const:`None` może być przekazane jeśli żaden arkusz stylów nie ma być użyty. *kodowanie* - z ang. - *encoding* określa kodowanie do użycia dla wyjścia (domyślnie domyślnego kodowania systemowego).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This subclass of :class:`TextCalendar` can be passed a locale name in the constructor and will return month and weekday names in the specified locale. If this locale includes an encoding all strings containing month and weekday names will be returned as unicode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To podrzędne uogólnienie uogólnienia :class:`TextCalendar` może otrzymać przekazaną nazwę lokalizacji w konstruktorze i zwróci miesiąc i dzień tygodnia w określonej lokalizacji. Jeśli ta lokalizacja zawiera kodowanie, wszystkie ciągi znaków zawierające nazwy miesiąca i dni tygodnia będą zwrócone jako Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This subclass of :class:`HTMLCalendar` can be passed a locale name in the constructor and will return month and weekday names in the specified locale. If this locale includes an encoding all strings containing month and weekday names will be returned as unicode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To podrzędne uogólnienie uogólnienia :class:`HTMLCalendar` może otrzymać przekazaną nazwę lokalizacji w konstruktorze i zwróci nazwy miesiąca i dni tygodnia w określonej lokalizacji. Jeśli ta lokalizacja zawiera kodowanie, wszystkie ciągi znaków zawierające nazwy miesięcy i dni tygodnia będą zwrócone jako Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For simple text calendars this module provides the following functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla prostych kalendarzy tekstowych ten moduł dostarcza następujące zadania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sets the weekday (``0`` is Monday, ``6`` is Sunday) to start each week. The values :const:`MONDAY`, :const:`TUESDAY`, :const:`WEDNESDAY`, :const:`THURSDAY`, :const:`FRIDAY`, :const:`SATURDAY`, and :const:`SUNDAY` are provided for convenience. For example, to set the first weekday to Sunday::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustawia dzień tygodnia (``0`` jest poniedziałkiem, ``6`` jest niedzielą) jako początek każdego tygodnia. Wartości :const:`MONDAY`, :const:`TUESDAY`, :const:`WEDNESDAY`, :const:`THURSDAY`, :const:`FRIDAY`, :const:`SATURDAY` i :const:`SUNDAY` są dostarczone dla wygody. Dla przykładu, aby ustawić pierwszy dzień tygodnia na Niedzielę::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import calendar calendar.setfirstweekday(calendar.SUNDAY)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import calendar calendar.setfirstweekday(calendar.SUNDAY)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the current setting for the weekday to start each week.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca obecne ustawienie dla dnia tygodnia którym zaczyna się każdy tydzień.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns :const:`True` if *year* is a leap year, otherwise :const:`False`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca :const:`True` jeśli *rok* - z ang - *year* jest przestępny w przeciwnym razie :const:`False`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the number of leap years in the range from *y1* to *y2* (exclusive), where *y1* and *y2* are years.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca liczbę lat przestępnych w zakresie od *y1* do *y2* (wyłączając lata brzegowe) gdzie *y1* i *y2* są latami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function works for ranges spanning a century change.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie pracuje dla zakresów rozpinających zmianę stulecia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the day of the week (``0`` is Monday) for *year* (``1970``--...), *month* (``1``--``12``), *day* (``1``--``31``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca dzień tygodnia (``0`` to poniedziałek) dla *roku* - z ang. - *year* (``1970``--...), *miesiąca* - z ang. - *month* (``1``--``12``), *dnia* - z ang - *day* (``1``--``31``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a header containing abbreviated weekday names. *n* specifies the width in characters for one weekday.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć nagłówek zawierający skrócone nazwy dni tygodnia. *n* określa szerokość w znakach dla jednego dnia tygodnia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns weekday of first day of the month and number of days in month,  for the specified *year* and *month*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca dzień tygodnia pierwszego dnia miesiąca i liczbę dni w miesiącu, dla określonego *roku* i *miesiąca*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns a matrix representing a month's calendar.  Each row represents a week; days outside of the month a represented by zeros. Each week begins with Monday unless set by :func:`setfirstweekday`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca matrycę reprezentującą kalendarz miesięczny. Każdy wiersz reprezentuje tydzień; dni poza miesiącem są reprezentowane przez zera. Każdy tydzień zaczyna się od poniedziałku chyba że ustawiono inaczej za pomocą zadania :func:`setfirstweekday`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prints a month's calendar as returned by :func:`month`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisuje miesięczny kalendarz taki jak zwrócony przez zadanie :func:`month`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns a month's calendar in a multi-line string using the :meth:`formatmonth` of the :class:`TextCalendar` class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca miesięczny kalendarz w wielo-liniowym ciągu znaków używając sposobu postępowania :meth:`formatmonth` uogólnienia :class:`TextCalendar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prints the calendar for an entire year as returned by  :func:`calendar`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypisuje kalendarz dla całego roku jak zwrócony przez zadanie :func:`calendar`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns a 3-column calendar for an entire year as a multi-line string using the :meth:`formatyear` of the :class:`TextCalendar` class.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć 3-kolumnowy kalendarz dla całego roku jako wielo-liniowy ciąg znaków używając sposobu postępowania :meth:`formatyear` uogólnienia :class:`TextCalendar`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An unrelated but handy function that takes a time tuple such as returned by the :func:`gmtime` function in the :mod:`time` module, and returns the corresponding Unix timestamp value, assuming an epoch of 1970, and the POSIX encoding.  In fact, :func:`time.gmtime` and :func:`timegm` are each others' inverse.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niezwiązane ale użyteczne zadanie, które pobiera krotkę czasu taką jak zwracana przez zadanie :func:`gmtime` w module :mod:`time` i zwraca odpowiadającą wartość stempla czasowego Unix-a, przyjmując epokę 1970, i kodowanie POSIX. Faktycznie zadania :func:`time.gmtime` i :func:`timegm` są wzajemnymi przeciwieństwami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`calendar` module exports the following data attributes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`calendar` wystawia następujące właściwości danych:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An array that represents the days of the week in the current locale.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tabela która reprezentuje dni tygodnia w obecnej lokalizacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An array that represents the abbreviated days of the week in the current locale.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tabela która reprezentuje skrócone dni tygodnia w obecnej lokalizacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An array that represents the months of the year in the current locale.  This follows normal convention of January being month number 1, so it has a length of 13 and  ``month_name[0]`` is the empty string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tabela która reprezentuje miesiące w roku w obecnej lokalizacji. To jest w zgodzie z konwencją według której styczeń jest miesiącem numer 1, więc ma długość 13 i ``month_name[0]`` jest pustym ciągiem znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An array that represents the abbreviated months of the year in the current locale.  This follows normal convention of January being month number 1, so it has a length of 13 and  ``month_abbr[0]`` is the empty string.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tabela, która reprezentuje skrócone miesiące w roku w obecnej lokalizacji. To jest w zgodzie z konwencją, według której styczeń jest miesiącem numer 1, więc tabela ma długość 13 i ``month_abbr[0]`` jest pustym ciągiem znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object-oriented interface to dates and times with similar functionality to the :mod:`time` module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zorientowany na przedmioty sprzęg dla dat i czasów z podobnymi funkcjonalnościami dla modułu :mod:`time`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Low-level time related functions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niskiego-poziomu zadania związane z czasem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`cgi` --- Common Gateway Interface support</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`cgi` --- wsparcie dla wspólnego sprzęgu bramki - z ang. - Common Gateway Interface</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support module for Common Gateway Interface (CGI) scripts.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wspierający moduł dla skryptów sprzęgu wspólnej bramki (z ang. CGI).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module defines a number of utilities for use by CGI scripts written in Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł definiuje pewną liczbę użyteczności dla użycia przez skrypty CGI napisane w języku pytonowskim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wprowadzenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A CGI script is invoked by an HTTP server, usually to process user input submitted through an HTML ``&lt;FORM&gt;`` or ``&lt;ISINDEX&gt;`` element.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skrypt CGI jest wywoływany przez serwer HTTP, zwykle aby przetworzyć wejście użytkownika dostarczone przez HTML ``&lt;FORM&gt;`` lub element ``&lt;ISINDEX&gt;``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most often, CGI scripts live in the server's special :file:`cgi-bin` directory. The HTTP server places all sorts of information about the request (such as the client's hostname, the requested URL, the query string, and lots of other goodies) in the script's shell environment, executes the script, and sends the script's output back to the client.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Najczęściej, Skrypty CGI przebywają w katalogu specjalnym serwera :file:`cgi-bin`. Serwer HTTP umieszcza wszelkiego rodzaju informacje o zapytaniu (takie jak nazwa hosta klienta, oczekiwany adres URL, ciąg zapytania, i wiele innych dobrych rzeczy) w środowisku powłoki skryptu, wykonuje skrypt i wysyła wyjście skryptu z powrotem do klienta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The script's input is connected to the client too, and sometimes the form data is read this way; at other times the form data is passed via the "query string" part of the URL.  This module is intended to take care of the different cases and provide a simpler interface to the Python script.  It also provides a number of utilities that help in debugging scripts, and the latest addition is support for file uploads from a form (if your browser supports it).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wejście skryptu jest połączone z klientem także, i czasami dane formularza są wczytywane tą drogą także; innym razem dane formularza są przekazywane przez "ciąg zapytania" jako część adresu URL. Ten moduł jest przeznaczony do zajmowania się różnymi przypadkami i dostarczenia prostszego sprzęgu dla skryptu języka pytonowskiego. To także dostarcza pewną liczbę użyteczności które pomagają w odpluskwianiu skryptów zaś najnowszym dodatkiem jest wsparcie dla załadowywania plików przez formularz (jeśli twoja przeglądarka to wspomaga).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output of a CGI script should consist of two sections, separated by a blank line.  The first section contains a number of headers, telling the client what kind of data is following.  Python code to generate a minimal header section looks like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyjście skryptu CGI powinno składać się z dwóch sekcji, oddzielonych pustą linią. Pierwszy rozdział zawiera liczbę nagłówków, mówiąc klientowi jakiego rodzaju dane nastąpią potem. Kod języka pytonowskiego aby wytworzyć minimalny rozdział nagłówkowy wygląda następująco::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>print("Content-Type: text/html")    # HTML is following print()                             # blank line, end of headers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>print("Content-Type: text/html")    # HTML następuje print()                             # pusty wiersz, koniec nagłówków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second section is usually HTML, which allows the client software to display nicely formatted text with header, in-line images, etc. Here's Python code that prints a simple piece of HTML::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Drugi rozdziałem jest zwykle HTML, który pozwala oprogramowaniu klienta wyświetlić ładnie sformatowany tekst z nagłówkiem, obrazkami w-jednej-linii itp. Tu jest kod języka pytonowskiego który drukuje prosty kawałek HTML-a::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>print("&lt;TITLE&gt;CGI script output&lt;/TITLE&gt;") print("&lt;H1&gt;This is my first CGI script&lt;/H1&gt;") print("Hello, world!")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>print("&lt;TITLE&gt;Wyjście skryptu CGI&lt;/TITLE&gt;") print("&lt;H1&gt;To jest mój pierwszy skrypt CGI&lt;/H1&gt;") print("Witaj świecie!")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the cgi module</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Użycie modułu cgi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Begin by writing ``import cgi``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zacznij przez napisanie ``import cgi``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a new script, consider adding these lines::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy piszesz nowy skrypt, rozważ dodanie tych linii::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import cgitb cgitb.enable()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import cgitb cgitb.enable()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This activates a special exception handler that will display detailed reports in the Web browser if any errors occur.  If you'd rather not show the guts of your program to users of your script, you can have the reports saved to files instead, with code like this::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To aktywuje specjalną obsługę błędów, która będzie wyświetlać szczegółowe raporty o błędach w przeglądarce sieciowej jeśli nastąpią jakiekolwiek błędy. Jeśli wolisz raczej nie pokazywać wnętrzności swojego programu dla użytkowników twojego skryptu możesz mieć raporty zapisane do pliku zamiast tego, za pomocą kodu takiego jak ten::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import cgitb cgitb.enable(display=0, logdir="/tmp")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import cgitb cgitb.enable(display=0, logdir="/tmp")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's very helpful to use this feature during script development. The reports produced by :mod:`cgitb` provide information that can save you a lot of time in tracking down bugs.  You can always remove the ``cgitb`` line later when you have tested your script and are confident that it works correctly.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest bardzo przydatnym użycie tej właściwości w czasie rozwijania skryptu. Raporty produkowane przez :mod:`cgitb` dostarczają informację która może oszczędzić Ci wiele czasu w śledzeniu błędów. Możesz zawsze usunąć ``cgitb`` linię później gdy przetestowałeś swój skrypt i jesteś pewien że działa on prawidłowo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get at submitted form data, use the :class:`FieldStorage` class.  Instantiate it exactly once, without arguments.  This reads the form contents from standard input or the environment (depending on the value of various environment variables set according to the CGI standard).  Since it may consume standard input, it should be instantiated only once.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby dostać się do danych podanych przez formularz, użyj uogólnienia :class:`FieldStorage`. Daj przykład tego uogólnienia tylko raz, bez parametrów. To wczyta zawartość formularza ze standardowego wejścia środowiska (w zależności od wartości różnych zmiennych środowiskowych ustawionych zgodnie ze standardem CGI) Ponieważ może to pochłonąć standardowe wejście, powinno się dawać przykład tego uogólnienia tylko raz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`FieldStorage` instance can be indexed like a Python dictionary. It allows membership testing with the :keyword:`in` operator, and also supports the standard dictionary method :meth:`keys` and the built-in function :func:`len`.  Form fields containing empty strings are ignored and do not appear in the dictionary; to keep such values, provide a true value for the optional *keep_blank_values* keyword parameter when creating the :class:`FieldStorage` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład uogólnienia :class:`FieldStorage` może być indeksowany jak słownik języka pytonowskiego. Pozwala to na sprawdzanie członkostwa za pomocą operatora :keyword:`in`, a także wsparcie standardowego sposobu postępowania słownika :meth:`keys` i wbudowanego zadania :func:`len`. Pola formularza zawierające puste ciągi znaków są ignorowane i nie pojawiają się w słowniku; Aby trzymać takie wartości dostarcz prawdziwą wartość dla opcjonalnego parametru słowa kluczowego *keep_blank_values* gdy tworzony jest przykład uogólnienia :class:`FieldStorage`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, the following code (which assumes that the :mailheader:`Content-Type` header and blank line have already been printed) checks that the fields ``name`` and ``addr`` are both set to a non-empty string::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla przykładu, następujący kod (który zakłada, że nagłówek :mailheader:`Content-Type` i puste linie zostały już wydrukowane) sprawdza czy pola ``nazwa`` i ``addr`` zostały oba ustawione na nie-pusty ciąg znaków::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>form = cgi.FieldStorage() if "name" not in form or "addr" not in form:     print("&lt;H1&gt;Error&lt;/H1&gt;")     print("Please fill in the name and addr fields.")     return print("&lt;p&gt;name:", form["name"].value) print("&lt;p&gt;addr:", form["addr"].value) ...further form processing here...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>form = cgi.FieldStorage() if "name" not in form or "addr" not in form:     print("&lt;H1&gt;Błąd&lt;/H1&gt;")     print("Proszę wprowadź pola nazwa i adres.")     return print("&lt;p&gt;name:", form["name"].value) print("&lt;p&gt;addr:", form["addr"].value) ...dalsza obróbka formularza tutaj...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here the fields, accessed through ``form[key]``, are themselves instances of :class:`FieldStorage` (or :class:`MiniFieldStorage`, depending on the form encoding). The :attr:`value` attribute of the instance yields the string value of the field.  The :meth:`getvalue` method returns this string value directly; it also accepts an optional second argument as a default to return if the requested key is not present.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tutaj pola, dostępne przez odwołanie ``form[key]``, są same w sobie przykładami uogólnienia :class:`FieldStorage` (lub :class:`MiniFieldStorage`, w zależności od kodowania formularza). Właściwość :attr:`value` przykładu wydaje wartość ciągu znaków tego pola. Sposób postępowania :meth:`getvalue` zwraca tę wartość ciągu znaków bezpośrednio; akceptuje także opcjonalny drugi parametr jako domyślny do zwrócenia jeśli oczekiwany klucz nie jest obecny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the submitted form data contains more than one field with the same name, the object retrieved by ``form[key]`` is not a :class:`FieldStorage` or :class:`MiniFieldStorage` instance but a list of such instances.  Similarly, in this situation, ``form.getvalue(key)`` would return a list of strings. If you expect this possibility (when your HTML form contains multiple fields with the same name), use the :func:`getlist` function, which always returns a list of values (so that you do not need to special-case the single item case).  For example, this code concatenates any number of username fields, separated by commas::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli przekazane dane formularza zawierają więcej niż jedno pole o tej samej nazwie, przedmiot otrzymany przez wywołanie ``form[key]`` nie jest przykładem :class:`FieldStorage` lub :class:`MiniFieldStorage`  ale listą takich przykładów. Podobnie w tej sytuacji, ``form.getvalue(key)`` zwróciłoby listę ciągów znaków. Jeśli oczekujesz tej możliwości (kiedy twój formularz HTML zawiera wiele pól o tej samej nazwie) użyj zadania :func:`getlist`, które zawsze zwraca listę wartości (tak że nie potrzebujesz szczególnego przypadku dla przypadku pojedynczego elementu). Dla przykładu ten kod łączy dowolną liczbę pól nazwy użytkownika oddzielonych przez przecinki::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>value = form.getlist("username") usernames = ",".join(value)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>value = form.getlist("username") usernames = ",".join(value)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a field represents an uploaded file, accessing the value via the :attr:`value` attribute or the :func:`getvalue` method reads the entire file in memory as a string.  This may not be what you want. You can test for an uploaded file by testing either the :attr:`filename` attribute or the :attr:`!file` attribute.  You can then read the data at leisure from the :attr:`!file` attribute::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli pole reprezentuje załadowany plik, dostęp do wartości przez właściwość :attr:`value` lub sposób postępowania :func:`getvalue` wczytuje cały plik do pamięci jako ciąg znaków. To może nie być tym czego oczekujesz. Możesz sprawdzić załadowany plik przez przetestowanie albo właściwości :attr:`filename` albo właściwości :attr:`!file`. Możesz wtedy wczytać dane w czasie wolnym z właściwości :attr:`!file`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>fileitem = form["userfile"] if fileitem.file:     # It's an uploaded file; count lines     linecount = 0     while True:         line = fileitem.file.readline()         if not line: break         linecount = linecount + 1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>fileitem = form["userfile"] if fileitem.file:     # to załadowany plik; zlicz linie     linecount = 0     while True:         line = fileitem.file.readline()         if not line: break         linecount = linecount + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an error is encountered when obtaining the contents of an uploaded file (for example, when the user interrupts the form submission by clicking on a Back or Cancel button) the :attr:`done` attribute of the object for the field will be set to the value -1.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli napotkany zostanie błąd podczas otrzymywania zawartości załadowanego pliku (dla przykładu, gdy użytkownik przerwie działanie formularza przez kliknięcie  przycisku Wstecz lub Anuluj) właściwość :attr:`done` przedmiotu dla pola zostanie ustawiona na wartość -1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive :mimetype:`multipart/\*` encoding). When this occurs, the item will be a dictionary-like :class:`FieldStorage` item. This can be determined by testing its :attr:`!type` attribute, which should be :mimetype:`multipart/form-data` (or perhaps another MIME type matching :mimetype:`multipart/\*`).  In this case, it can be iterated over recursively just like the top-level form object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Standard ładowania pliku przewiduje możliwość załadowania wielu plików z jednego pola (używając rekursywnego kodowania :mimetype:`multipart/\*`). Gdy to się zdarzy, element będzie słowniko-podobnym elementem :class:`FieldStorage`. To może być określone przez sprawdzenie właściwości :attr:`!type`, która powinna być :mimetype:`multipart/form-data` (lub byćmoże inny typ MIME pasujący do :mimetype:`multipart/\*`). W tym przypadku może być on iterowany rekursywnie tak, jak przedmiot formularza nadrzędnego poziomu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a form is submitted in the "old" format (as the query string or as a single data part of type :mimetype:`application/x-www-form-urlencoded`), the items will actually be instances of the class :class:`MiniFieldStorage`.  In this case, the :attr:`!list`, :attr:`!file`, and :attr:`filename` attributes are always ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy formularz jest podawany w "starym" formacie (jako ciąg zapytania lub pojedyncza część danych typu :mimetype:`application/x-www-form-urlencoded`), wszystkie elementy właściwie będą przykładami uogólnienia :class:`MiniFieldStorage`. W tym przypadku, właściwości :attr:`!list`, :attr:`!file`, i :attr:`filename` są zawsze ``None``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A form submitted via POST that also has a query string will contain both :class:`FieldStorage` and :class:`MiniFieldStorage` items.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Formularz podany przez sposób postępowania POST który także zawiera ciąg zapytania będzie zawierał zarówno elementy :class:`FieldStorage` jak i :class:`MiniFieldStorage`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Higher Level Interface</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg Wyższego Poziomu (Higher Level Interface)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section explains how to read CGI form data using the :class:`FieldStorage` class.  This section describes a higher level interface which was added to this class to allow one to do it in a more readable and intuitive way.  The interface doesn't make the techniques described in previous sections obsolete --- they are still useful to process file uploads efficiently, for example.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Poprzednia sekcja wyjaśnia jak czytać dane z formularza CGI używając uogólnienia :class:`FieldStorage`. Ten rozdział opisuje sprzęg wyższego rzędu, który został dodany do tego uogólnienia aby pozwolić robić to w bardziej czytelny i intuicyjny sposób. Sprzęg nie powoduje że techniki opisane w poprzednich rozdziałach stają się zbędne --- one są wciąż użyteczne aby wykonywać ładowanie plików efektywnie, dla przykładu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interface consists of two simple methods. Using the methods you can process form data in a generic way, without the need to worry whether only one or more values were posted under one name.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprzęg składa się z dwóch prostych sposobów postępowania. Używając sposobów postępowania możesz przetwarzać dane w zastępczy sposób bez konieczności martwienia się czy tylko jedna czy więcej danych zostało opublikowanych pod daną nazwą.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous section, you learned to write following code anytime you expected a user to post more than one value under one name::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W poprzednim rozdziale, dowiedziałeś się jak pisać następujący kod za każdym razem gdy spodziewałeś się że użytkownik opublikuje więcej niż jedną wartość pod jedną nazwą::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item = form.getvalue("item") if isinstance(item, list):     # The user is requesting more than one item. else:     # The user is requesting only one item.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>item = form.getvalue("item") if isinstance(item, list): # Użytkownik oczekuje więcej niż jednej rzeczy. else: # Użytkownik oczekuje tylko jednej rzeczy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This situation is common for example when a form contains a group of multiple checkboxes with the same name::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ta sytuacja jest obecna dla przykładu gdy formularz zawiera grupę wielu pól zaznaczania o tej samej nazwie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;input type="checkbox" name="item" value="1" /&gt; &lt;input type="checkbox" name="item" value="2" /&gt;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&lt;input type="checkbox" name="item" value="1" /&gt; &lt;input type="checkbox" name="item" value="2" /&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most situations, however, there's only one form control with a particular name in a form and then you expect and need only one value associated with this name.  So you write a script containing for example this code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W większości przypadków, jednakże, istnieje tylko jedna urządzenie formularza o określonej nazwie w formularzu i wtedy oczekujesz i potrzebujesz tylko jednej wartości powiązanej z tą nazwą. Więc piszesz skrypt zawierający dla przykładu ten kod::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>user = form.getvalue("user").upper()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>user = form.getvalue("user").upper()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The problem with the code is that you should never expect that a client will provide valid input to your scripts.  For example, if a curious user appends another ``user=foo`` pair to the query string, then the script would crash, because in this situation the ``getvalue("user")`` method call returns a list instead of a string.  Calling the :meth:`~str.upper` method on a list is not valid (since lists do not have a method of this name) and results in an :exc:`AttributeError` exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Problem z kodem polega na tym, że nigdy nie powinieneś oczekiwać, że klient dostarczy właściwe wpisy do twoich skryptów. Dla przykładu, jeśli ciekawy użytkownik dołoży jeszcze jedną parę ``user=foo`` do ciągu zapytania, wtedy skrypt ulegnie wypadkowi, ponieważ w tej sytuacji wywołanie sposobu postępowania ``getvalue("user")`` zwróci listę zamiast ciągu znaków. Wywołanie sposobu postępowania :meth:`~str.upper` na liście nie jest prawidłowe (gdyż listy nie mają sposobów postępowania o tej nazwie) i kończy się wyjątkiem :exc:`AttributeError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, the appropriate way to read form data values was to always use the code which checks whether the obtained value is a single value or a list of values.  That's annoying and leads to less readable scripts.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zatem, właściwym sposobem aby wczytywać dane formularza było zawsze używanie kodu który sprawdza czy otrzymana wartość jest pojedynczą wartością czy listą wartości. To jest irytujące i prowadzi do mniej czytelnych skryptów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more convenient approach is to use the methods :meth:`getfirst` and :meth:`getlist` provided by this higher level interface.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bardziej użyteczne podejście polega na tym aby używać sposobów postępowania :meth:`getfirst` i :meth:`getlist` dostarczanych przez sprzęg wyższego poziomu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method always returns only one value associated with form field *name*. The method returns only the first value in case that more values were posted under such name.  Please note that the order in which the values are received may vary from browser to browser and should not be counted on. [#]_  If no such form field or value exists then the method returns the value specified by the optional parameter *default*.  This parameter defaults to ``None`` if not specified.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania zawsze zwraca tylko jedną wartość związaną z polem formularza *name*. Sposób postępowania zwraca tylko pierwszą wartość w przypadku gdy więcej wartości zostało opublikowanych pod taką nazwą. Proszę zauważ że kolejność w jakiej wartości są otrzymywane może różnić się między przeglądarkami i nie powinien liczyć się. [#]_ Jeśli żadne takie pole formularza ani wartość nie istnieje wtedy sposób postępowania zwraca wartość określoną przez opcjonalny parametr *domyślny* - z ang - *default*. Ten parametr domyślnie równy jest ``None`` jeśli nie jest określony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method always returns a list of values associated with form field *name*. The method returns an empty list if no such form field or value exists for *name*.  It returns a list consisting of one item if only one such value exists.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania zawsze zwraca listę wartości związaną z polem formularza *name*. Ten sposób postępowania zwraca pustą listę jeśli żadne pole ani wartość nie istnieje dla *nazwy* - z ang. - *name*. Zwraca listę składającą się z jednego elementu jeśli tylko jedna taka wartość istnieje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using these methods you can write nice compact code::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używając tych sposobów postępowania możesz napisać ładny zgrabny kod::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import cgi form = cgi.FieldStorage() user = form.getfirst("user", "").upper()    # This way it's safe. for item in form.getlist("item"):     do_something(item)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import cgi form = cgi.FieldStorage() user = form.getfirst("user", "").upper()    # Tym sposobem jest bezpiecznie. for item in form.getlist("item"):     do_something(item)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are useful if you want more control, or if you want to employ some of the algorithms implemented in this module in other circumstances.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te są użyteczne jeśli chcesz więcej kontrolować, lub jeśli chcesz zatrudnić niektóre z algorytmów wypełnionych w tym module w innych przypadkach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse a query in the environment or from a file (the file defaults to ``sys.stdin``).  The *keep_blank_values* and *strict_parsing* parameters are passed to :func:`urllib.parse.parse_qs` unchanged.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj zapytanie w środowisku lub z pliku (plik domyślnie równy jest ``sys.stdin``). Parametry *keep_blank_values* i *strict_parsing* są przekazywane dla zadania :func:`urllib.parse.parse_qs` bez zmian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is deprecated in this module. Use :func:`urllib.parse.parse_qs` instead. It is maintained here only for backward compatibility.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest przedawnione w tym module. Używaj zadania :func:`urllib.parse.parse_qs` zamiast tego. Jest ono utrzymywane tutaj tylko dla wstecznej zgodności.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse input of type :mimetype:`multipart/form-data` (for  file uploads). Arguments are *fp* for the input file and *pdict* for a dictionary containing other parameters in the :mailheader:`Content-Type` header.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj wejście typu :mimetype:`multipart/form-data` (dla ładowania plików). Parametrami są *fp* dla wejściowego pliku i *pdict* dla słownika zawierającego inne parametry w nagłówku :mailheader:`Content-Type`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns a dictionary just like :func:`urllib.parse.parse_qs` keys are the field names, each value is a list of values for that field.  This is easy to use but not much good if you are expecting megabytes to be uploaded --- in that case, use the :class:`FieldStorage` class instead which is much more flexible.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca słownik taki jak wtedy, gdy klucze :func:`urllib.parse.parse_qs` są nazwami pól, każda wartość jest listą wartości dla tego pola. To jest łatwe w użyciu ale nie bardzo dobre jeśli spodziewasz się megabajtów do załadowania --- w tym przypadku, użyj uogólnienia :class:`FieldStorage` zamiast tego i uzyskasz rozwiązanie o wiele bardziej elastyczne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this does not parse nested multipart parts --- use :class:`FieldStorage` for that.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że to nie wczytuje zagnieżdżonych wieloczęściowych części --- użyj uogólnienia :class:`FieldStorage` dla tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parse a MIME header (such as :mailheader:`Content-Type`) into a main value and a dictionary of parameters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj nagłówek MIME (taki, jak :mailheader:`Content-Type`) do głównej wartości i słownika parametrów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Robust test CGI script, usable as main program. Writes minimal HTTP headers and formats all information provided to the script in HTML form.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wydajny testowy skrypt CGI, użyteczny jako program główny. Zapisuje minimalne nagłówki HTTP i formatuje całą informację dostarczoną dla skryptu w formularzu HTML.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Format the shell environment in HTML.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Formatuje środowisko powłoki w HTML-u</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Format a form in HTML.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Formatuje formularz w HTML-u.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Format the current directory in HTML.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Formatuje obecny katalog w HTML-u.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print a list of useful (used by CGI) environment variables in HTML.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Drukuje listę użytecznych (używanych przez CGI) zmiennych środowiskowych w HTML-u.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert the characters ``'&amp;'``, ``'&lt;'`` and ``'&gt;'`` in string *s* to HTML-safe sequences.  Use this if you need to display text that might contain such characters in HTML.  If the optional flag *quote* is true, the quotation mark character (``'"'``) is also translated; this helps for inclusion in an HTML attribute value, as in ``&lt;A HREF="..."&gt;``.  If the value to be quoted might include single- or double-quote characters, or both, consider using the :func:`quoteattr` function in the :mod:`xml.sax.saxutils` module instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamienia znaki ``'&amp;'``, ``'&lt;'`` i ``'&gt;'`` w ciągu *s* do sekwencji bezpiecznych dla HTML-a. Użyj tego jeśli potrzebujesz wyświetlić tekst który może zawierać takie znaki w HTML-u. Jeśli opcjonalna flaga *cytatu* - z ang. - *quote* jest prawdziwa, wtedy znak cytowania (``'"'``) jest także tłumaczony; To pomaga w załączaniu w HTML-u wartości właściwości jak w ``&lt;A HREF="..."&gt;``. Jeśli wartość do cytowania może zawierać pojedyncze lub podwójne znaki cytowania, lub oba, weź pod uwagę użycie zadania :func:`quoteattr` z modułu :mod:`xml.sax.saxutils` zamiast tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caring about security</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Troska o bezpieczeństwo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's one important rule: if you invoke an external program (via the :func:`os.system` or :func:`os.popen` functions. or others with similar functionality), make very sure you don't pass arbitrary strings received from the client to the shell.  This is a well-known security hole whereby clever hackers anywhere on the Web can exploit a gullible CGI script to invoke arbitrary shell commands.  Even parts of the URL or field names cannot be trusted, since the request doesn't have to come from your form!</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje jedna istotna zasada: Jeśli wywołujesz zewnętrzny program (przez zadanie :func:`os.system` lub :func:`os.popen` lub inne o podobnym działaniu), upewnij się bardzo że nie przekazujesz dowolnych ciągów znaków otrzymanych od klienta do powłoki. To jest bardzo znana luka bezpieczeństwa gdzie sprytni hakerzy dowolnie w sieci mogą wykorzystać naiwny skrypt CGI aby wywołać dowolną komendę powłoki. Nawet częściom adresu URL lub nazwom pól nie można ufać, gdyż zapytanie może nie pochodzić z formularza!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be on the safe side, if you must pass a string gotten from a form to a shell command, you should make sure the string contains only alphanumeric characters, dashes, underscores, and periods.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby trzymać się bezpiecznej strony, jeśli przekazujesz ciąg znaków otrzymany z formularza do polecenia powłoki, powinieneś upewnić się, że ciąg znaków zawiera tylko znaki alfanumeryczne, ukośniki, podkreślenia i kropki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing your CGI script on a Unix system</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instalowanie twojego skryptu CGI na systemie Unix-owym</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read the documentation for your HTTP server and check with your local system administrator to find the directory where CGI scripts should be installed; usually this is in a directory :file:`cgi-bin` in the server tree.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przeczytaj dokumentację dla twojego serwera HTTP i sprawdź u swojego administratora systemu aby dowiedzieć się który katalog powinien być użyty dla instalowania skryptów CGI; zwykle to jest katalog :file:`cgi-bin` w drzewie serwera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure that your script is readable and executable by "others"; the Unix file mode should be ``0o755`` octal (use ``chmod 0755 filename``).  Make sure that the first line of the script contains ``#!`` starting in column 1 followed by the pathname of the Python interpreter, for instance::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Upewnij się że twój skrypt jest czytelny i wykonywalny przez "innych"; tryb pliku Unix-a powinien być ``0o755`` ósemkowo (użyj ``chmod 0755 nazwa-pliku``). Upewnij się, że pierwsza linia skryptu zawiera ``#!`` zaczynając w kolumnie 1 po której następuje ścieżka dostępu do pliku programu interpretującego polecenia języka pytonowskiego, dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#!/usr/local/bin/python</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>#!/usr/local/bin/python</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure the Python interpreter exists and is executable by "others".</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Upewnij się że program interpretujący polecenia języka pytonowskiego istnieje i jest wykonywalny przez "innych".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure that any files your script needs to read or write are readable or writable, respectively, by "others" --- their mode should be ``0o644`` for readable and ``0o666`` for writable.  This is because, for security reasons, the HTTP server executes your script as user "nobody", without any special privileges.  It can only read (write, execute) files that everybody can read (write, execute).  The current directory at execution time is also different (it is usually the server's cgi-bin directory) and the set of environment variables is also different from what you get when you log in.  In particular, don't count on the shell's search path for executables (:envvar:`PATH`) or the Python module search path (:envvar:`PYTHONPATH`) to be set to anything interesting.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Upewnij się, że jakiekolwiek pliki które twój skrypt chce odczytać lub zapisać są czytelne i możliwe do zapisania odpowiednio, przez "innych" --- ich tryb powinien być ``0o644`` dla czytelnych i 0o666`` dla możliwych do zapisania. To jest ponieważ z powodów bezpieczeństwa, serwer HTTP wykonuje twój skrypt jako użytkownik "nikt" - z ang. - "nobody" bez żadnych szczególnych przywilejów. Może tylko wczytywać (zapisywać, wykonywać) pliki które wszyscy mogą czytać (zapisać, wykonać). Bierzący katalog w czasie wykonania jest także inny (jest to zwykle katalog serwera cgi-bin) i ustawienie zmiennych środowiskowych jest także inne od tego które dostajesz gdy się zalogujesz. W szczególności, nie licz na ścieżkę przeszukiwania pod kątem plików wykonywalnych (:envvar:`PATH`) ani na ścieżkę przeszukiwania modułów języka pytonowskiego (:envvar:`PYTHONPATH`), że będą ustawione na cokolwiek interesującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to load modules from a directory which is not on Python's default module search path, you can change the path in your script, before importing other modules.  For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli potrzebujesz załadować moduły z katalogu który nie jest domyślną ścieżką przeszukiwania modułów języka pytonowskiego, możesz zmienić ścieżkę w twoim skrypcie, przez importowaniem innych modułów. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import sys sys.path.insert(0, "/usr/home/joe/lib/python") sys.path.insert(0, "/usr/local/lib/python")</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import sys sys.path.insert(0, "/usr/home/joe/lib/python") sys.path.insert(0, "/usr/local/lib/python")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(This way, the directory inserted last will be searched first!)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>(W ten sposób, katalog wstawiony jako ostatni będzie przeszukiwany jako pierwszy!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instructions for non-Unix systems will vary; check your HTTP server's documentation (it will usually have a section on CGI scripts).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Instrukcje dla nie-Unixowych systemów będą różne; Sprawdź dokumentację serwera HTTP (będzie zwykle miała sekcję o skryptach CGI).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing your CGI script</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdzanie twoich skryptów CGI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, a CGI script will generally not run when you try it from the command line, and a script that works perfectly from the command line may fail mysteriously when run from the server.  There's one reason why you should still test your script from the command line: if it contains a syntax error, the Python interpreter won't execute it at all, and the HTTP server will most likely send a cryptic error to the client.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niestety, skrypt CGI zwykle nie uruchomi się gdy spróbujesz go uruchomić z wiersza poleceń i skrypt który działa dobrze z wiersza polecenia może zawieźć nieoczekiwanie gdy uruchomiony z serwera. Jest jeden powód dla którego wciąż powinieneś testować swój skrypt z wiersza polecenia: jeśli zawiera błąd składniowy, program interpretujący polecenia języka pytonowskiego nie wykona go w ogóle, a serwer HTTP najprawdopodobniej wyśle tajemniczy komunikat o błędzie do klienta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assuming your script has no syntax errors, yet it does not work, you have no choice but to read the next section.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakładając, że twój skrypt nie ma błędów składniowych, a jednak wciąż nie działa, nie masz wyboru, tylko musisz czytać dalej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging CGI scripts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odpluskwianie skryptów CGI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, check for trivial installation errors --- reading the section above on installing your CGI script carefully can save you a lot of time.  If you wonder whether you have understood the installation procedure correctly, try installing a copy of this module file (:file:`cgi.py`) as a CGI script.  When invoked as a script, the file will dump its environment and the contents of the form in HTML form. Give it the right mode etc, and send it a request.  If it's installed in the standard :file:`cgi-bin` directory, it should be possible to send it a request by entering a URL into your browser of the form::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na początek, sprawdź najprostsze błędy instalacji --- czytanie powyższej sekcji o instalowaniu twojego skryptu CGI może zaoszczędzić ci wiele czasu. Jeśli zastanawiasz się czy zrozumiałeś procedurę instalacyjną prawidłowo, spróbuj zainstalować kopię pliku tego modułu (:file:`cgi.py`) jako skrypt CGI. Gdy wywołany jako skrypt, plik upuści swoje środowisko i zawartość formularza w postaci HTML. Daj mu właściwy tryb itp. i wyślij mu zapytanie. Jeśli jest zainstalowany w standardowym katalogu :file:`cgi-bin`, powinno być możliwe wysłanie zapytania przez wstawienie adresu URL do twojej przeglądarki w postaci::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&amp;addr=At+Home</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&amp;addr=At+Home</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this gives an error of type 404, the server cannot find the script -- perhaps you need to install it in a different directory.  If it gives another error, there's an installation problem that you should fix before trying to go any further.  If you get a nicely formatted listing of the environment and form content (in this example, the fields should be listed as "addr" with value "At Home" and "name" with value "Joe Blow"), the :file:`cgi.py` script has been installed correctly.  If you follow the same procedure for your own script, you should now be able to debug it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli zwróci błąd typu 404, wtedy serwer nie może znaleźć skryptu -- być może potrzebujesz zainstalować go w innych katalogu. Jeśli daje inny błąd, istnieje problem instalacji który powinieneś naprawić zanim spróbujesz iść dalej. Jeśli otrzymujesz ładnie sformatowany wypis środowiska i zawartości formularza (w tym przypadku, pola powinny być wypisane jako "addr" z wartością "At Home" i "name" z wartością "Joe Blow"), plik skryptu :file:`cgi.py` zostały zainstalowane poprawnie. Jeśli wykonasz tę samą procedurę dla twojego własnego skryptu, powinieneś móc go teraz odpluskwiać.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next step could be to call the :mod:`cgi` module's :func:`test` function from your script: replace its main code with the single statement ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następnym krokiem mogłoby być wezwanie zadania :func:`test` modułu :mod:`cgi` z twojego skryptu: zamiana jej głównego kodu na pojedyncze stwierdzenie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cgi.test()</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cgi.test()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This should produce the same results as those gotten from installing the :file:`cgi.py` file itself.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To powinno dać te same wyniki jak te otrzymane z zainstalowania samego pliku :file:`cgi.py`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an ordinary Python script raises an unhandled exception (for whatever reason: of a typo in a module name, a file that can't be opened, etc.), the Python interpreter prints a nice traceback and exits.  While the Python interpreter will still do this when your CGI script raises an exception, most likely the traceback will end up in one of the HTTP server's log files, or be discarded altogether.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy zwykły skrypt języka pytonowskiego zgłasza nieobsłużony wyjątek (dla jakiegokolwiek powodu: z powodu literówki w nazwie modułu, pliku który nie może być otwarty, itp.), program interpretujący polecenia języka pytonowskiego wypisuje ładny wypis i wychodzi. Podczas gdy program interpretujący polecenia języka pytonowskiego będzie wciąż to robił gdy twój skrypt CGI zgłosi wyjątek, najprawdopodobniej wypis skończy w jednym z plików logów serwera HTTP, lub zostanie odrzucony całkowicie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately, once you have managed to get your script to execute *some* code, you can easily send tracebacks to the Web browser using the :mod:`cgitb` module. If you haven't done so already, just add the lines::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Szczęśliwie, gdy już uda ci się wykonać *jakiś* kod za pomocą skryptu, możesz łatwo wysyłać wypisy do przeglądarki używając :mod:`cgitb`. Jeśli jeszcze nie zrobiłeś tego, po prostu dodaj linie::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to the top of your script.  Then try running it again; when a problem occurs, you should see a detailed report that will likely make apparent the cause of the crash.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>na górę twojego skryptu. Wtedy spróbuj uruchomić go jeszcze raz; gdy problem pojawi się znów, powinieneś zobaczyć szczegółowy raport, który prawdopodobnie uczyni jasnym powód wypadku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you suspect that there may be a problem in importing the :mod:`cgitb` module, you can use an even more robust approach (which only uses built-in modules)::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli podejrzewasz, że może być problem w importowaniu modułu :mod:`cgitb`, możesz użyć nawet jeszcze bardziej wydajnego podejścia (które używa tylko modułów wbudowanych)::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import sys sys.stderr = sys.stdout print("Content-Type: text/plain") print() ...your code here...</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>import sys sys.stderr = sys.stdout print("Content-Type: text/plain") print() ...twój kod tutaj...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This relies on the Python interpreter to print the traceback.  The content type of the output is set to plain text, which disables all HTML processing.  If your script works, the raw HTML will be displayed by your client.  If it raises an exception, most likely after the first two lines have been printed, a traceback will be displayed. Because no HTML interpretation is going on, the traceback will be readable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To opiera się na programie interpretującym polecenia języka pytonowskiego, że wydrukuje swój wypis. Typ treści wyjścia jest ustawiony na zwykły tekst, co wyklucza całą obsługę HTML. Jeśli twój skrypt działa, surowy HTML zostanie pokazany przez twojego klienta. Jeśli zgłasza wyjątek, najprawdopodobniej po tym jak pierwsze linie zostaną wypisane, wypis wsteczny zostanie wyświetlony. Ponieważ żadna interpretacja HTML-a nie miejsca, wypis wsteczny będzie czytelny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common problems and solutions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Typowe problemy i ich rozwiązania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most HTTP servers buffer the output from CGI scripts until the script is completed.  This means that it is not possible to display a progress report on the client's display while the script is running.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Większość serwerów HTTP przechowuje w przestrzeni wymiany wyjście ze skryptów CGI dopóki skrypt się nie zakończy. To oznacza, że nie jest możliwe wyświetlenie raportu postępu na wyświetlaczu klienta kiedy skrypt działa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the installation instructions above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdź instrukcje instalacyjne powyżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP server's log files.  (``tail -f logfile`` in a separate window may be useful!)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sprawdź pliki logu serwera HTTP. (``tail -f logfile`` w oddzielnym oknie może być użyteczne!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Always check a script for syntax errors first, by doing something like ``python script.py``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zawsze sprawdzaj skrypt dla błędów składniowych najpierw, przez wykonanie czegoś podobnego do ``python script.py``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your script does not have any syntax errors, try adding ``import cgitb; cgitb.enable()`` to the top of the script.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli twój skrypt nie ma żadnych błędów składniowych, spróbuj dodać ``import cgitb; cgitb.enable()`` na górze skryptu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When invoking external programs, make sure they can be found. Usually, this means using absolute path names --- :envvar:`PATH` is usually not set to a very useful value in a CGI script.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy wywoływane są zewnętrzne programy upewnij się że mogą być znalezione. Zwykle to oznacza, że używanie nazw ścieżek absolutnych --- :envvar:`PATH` nie jest zwykle ustawiana na użyteczną wartość skryptu CGI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When reading or writing external files, make sure they can be read or written by the userid under which your CGI script will be running: this is typically the userid under which the web server is running, or some explicitly specified userid for a web server's ``suexec`` feature.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy wczytujesz lub zapisujesz zewnętrzne pliki, upewnij się że mogą one być wczytane lub zapisane przez userid pod którym twój skrypt CGI będzie działał: to jest typowo userid pod którym serwer sieci działa, lub pewny jawnie określony userid dla właściwości sieciowego serwera ``suexec``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't try to give a CGI script a set-uid mode.  This doesn't work on most systems, and is a security liability as well.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nie próbuj nadawać skryptowi CGI trybu set-uid. To nie działa na większości systemów, i jest odpowiedzialnością za bezpieczeństwo także.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that some recent versions of the HTML specification do state what order the field values should be supplied in, but knowing whether a request was received from a conforming browser, or even from a browser at all, is tedious and error-prone.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że pewne niedawne wersje specyfikacji HTML-a określają w jakiej kolejności wartości pól powinny być dostarczone, ale wiedzieć czy zapytanie zostało otrzymane z odpowiadającej przeglądarki, czy też w ogóle z przeglądarki jest nużące i podatne na błędy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`cgitb` --- Traceback manager for CGI scripts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`cgitb` --- zarządca wypisów śledzenia dla skryptów CGI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`cgitb` module provides a special exception handler for Python scripts. (Its name is a bit misleading.  It was originally designed to display extensive traceback information in HTML for CGI scripts.  It was later generalized to also display this information in plain text.)  After this module is activated, if an uncaught exception occurs, a detailed, formatted report will be displayed.  The report includes a traceback showing excerpts of the source code for each level, as well as the values of the arguments and local variables to currently running functions, to help you debug the problem.  Optionally, you can save this information to a file instead of sending it to the browser.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`cgitb` dostarcza specjalnej obsługi wyjątków dla skryptów języka pytonowskiego. (Jego nazwa jest nieco myląca. Był on oryginalnie zaprojektowany do wyświetlania szerokich informacji wypisów śledzenia w HTML-u dla skryptów CGI. To zostało później uogólnione dla wyświetlania także informacji w czystym tekście.) Po tym jak ten moduł zostanie aktywowany, jeśli niezłapany wyjątek zdarzy się, szczegółowy sformatowany raport zostanie wyświetlony. Raport zawiera wypis śledzenia pokazujący fragmenty kodu źródłowego dla każdego poziomu, zarówno jak też wartości argumentów i zmiennych lokalnych dla aktualnie uruchomionych zadań, aby pomóc odpluskwić problem. Opcjonalnie, możesz zachować tą informację w pliku zamiast wysyłać ją do przeglądarki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this feature, simply add this to the top of your CGI script::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby umożliwić tą właściwość, po prostu dodaj to na górę twojego skryptu CGI::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The options to the :func:`enable` function control whether the report is displayed in the browser and whether the report is logged to a file for later analysis.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcje dla zadania :func:`enable` kontrolują czy raport jest wyświetlany w przeglądarce i czy raport jest logowany do pliku dla dalszej analizy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function causes the :mod:`cgitb` module to take over the interpreter's default handling for exceptions by setting the value of :attr:`sys.excepthook`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie powoduje że moduł :mod:`cgitb` przejmuje domyślną obsługę programu interpretującego dla wyjątków przez ustawianie wartości :attr:`sys.excepthook`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The optional argument *display* defaults to ``1`` and can be set to ``0`` to suppress sending the traceback to the browser. If the argument *logdir* is present, the traceback reports are written to files.  The value of *logdir* should be a directory where these files will be placed. The optional argument *context* is the number of lines of context to display around the current line of source code in the traceback; this defaults to ``5``. If the optional argument *format* is ``"html"``, the output is formatted as HTML.  Any other value forces plain text output.  The default value is ``"html"``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcjonalny parametr *display* domyślnie równy jest ``1`` i może być ustawiony na ``0`` aby wycofać wysyłanie wypisu wstecznego dla przeglądarki. Jeśli argument *logdir* jest obecny, raporty wypisów śledzenia są zapisywane do plików. Wartość *logdir* powinna być katalogiem gdzie te pliki będą umieszczone. Opcjonalny parametr *context* jest liczbą linii kontekstu do wyświetlenia na około obecnej linii kodu źródłowego w wypisie śledzenia; to domyślnie jest ``5``. Jeśli opcjonalny parametr *format* jest ``"html"``, wyjście będzie sformatowane jako HTML. Jakiekolwiek inne wartości zmuszają do wypisu czystym tekstem. Domyślna wartość jest ``"html"``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function handles an exception using the default settings (that is, show a report in the browser, but don't log to a file). This can be used when you've caught an exception and want to report it using :mod:`cgitb`.  The optional *info* argument should be a 3-tuple containing an exception type, exception value, and traceback object, exactly like the tuple returned by :func:`sys.exc_info`.  If the *info* argument is not supplied, the current exception is obtained from :func:`sys.exc_info`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie obsługuje wyjątek używając domyślnych ustawień (to jest, pokazuje raport w przeglądarce, ale nie loguje do pliku). To może być użyte gdy złapiesz wyjątek i chcesz złożyć raport o tym używając :mod:`cgitb`. Opcjonalny parametr *info* powinien być 3-krotką zawierającą typ wyjątku, wartość wyjątku i przedmiot wypisu śledzenia wstecz, dokładnie jak krotka zwrócona przez :func:`sys.exc_info`. Jeśli parametr *info* nie jest dostarczony, obecny wyjątek jest otrzymywany z zadania :func:`sys.exc_info`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`chunk` --- Read IFF chunked data</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`chunk` --- Wczytaj pokawałkowane dane IFF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module provides an interface for reading files that use EA IFF 85 chunks. [#]_  This format is used in at least the Audio Interchange File Format (AIFF/AIFF-C) and the Real Media File Format (RMFF).  The WAVE audio file format is closely related and can also be read using this module.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł dostarcza sprzęg dla wczytania pliku który używa kawałków EA IFF 85. [#]_ Ten format jest używany co najmniej w AIFF - Formacie Pliku Wymiany Dźwięku (AIFF/AIFF-C) i Formacie Pliku Real Media (RMFF). Format pliku dźwiękowego WAVE jest blisko związany i może także być wczytany używając tego modułu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A chunk has the following structure:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kawałek ma następującą strukturę:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Offset</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Offset</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Length</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Długość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contents</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zawartość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>0</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Chunk ID</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ID kawałka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Size of chunk in big-endian byte order, not including the header</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozmiar kawałka w porządku bajtów dużego-endian-u , nie zawierając nagłówka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*n*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*n*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data bytes, where *n* is the size given in the preceding field</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bajty danych, gdzie *n* jest rozmiarem danym w poprzednim polu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>8 + *n*</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>8 + *n*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>0 or 1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>0 lub 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pad byte needed if *n* is odd and chunk alignment is used</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bajt wyrównania potrzebny jeśli *n* jest nieparzysty i wyrównanie kawałka jest używane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ID is a 4-byte string which identifies the type of chunk.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Identyfikator ID jest 4-bajtowym ciągiem znaków który identyfikuje typ kawałka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The size field (a 32-bit value, encoded using big-endian byte order) gives the size of the chunk data, not including the 8-byte header.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pole rozmiaru (32-bitowa wartość, zakodowana używając porządku bajtów dużego-endian-a) daje rozmiar danych kawałka, nie zawierając 8-bajtowego nagłówka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually an IFF-type file consists of one or more chunks.  The proposed usage of the :class:`Chunk` class defined here is to instantiate an instance at the start of each chunk and read from the instance until it reaches the end, after which a new instance can be instantiated. At the end of the file, creating a new instance will fail with a :exc:`EOFError` exception.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwykle typ pliku-IFF składa się z jednego lub więcej kawałków. Proponowane użycie uogólnienia :class:`Chunk` określonego tutaj jest daniem przykładu na początku każdego kawałka i wczytanie z tego przykładu zanim dotrze on do końca, po którym nowy przykład może być dany. Na końcu pliku, utworzenie nowego przykładu zawiedzie z wyjątkiem :exc:`EOFError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class which represents a chunk.  The *file* argument is expected to be a file-like object.  An instance of this class is specifically allowed.  The only method that is needed is :meth:`read`.  If the methods :meth:`seek` and :meth:`tell` are present and don't raise an exception, they are also used. If these methods are present and raise an exception, they are expected to not have altered the object.  If the optional argument *align* is true, chunks are assumed to be aligned on 2-byte boundaries.  If *align* is false, no alignment is assumed.  The default value is true.  If the optional argument *bigendian* is false, the chunk size is assumed to be in little-endian order. This is needed for WAVE audio files. The default value is true.  If the optional argument *inclheader* is true, the size given in the chunk header includes the size of the header.  The default value is false.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie, które reprezentuje kawałek. Parametr *pliku* jest oczekiwany że będzie podobnym do pliku przedmiotem. Przykład tego uogólnienia jest szczególnie dozwolony. Jedyny sposób postępowania który jest wymagany jest :meth:`read`. Jeśli sposoby postępowania :meth:`seek` i :meth:`tell` są obecne i nie zwracają wyjątku, także są używane. Jeśli te sposoby postępowania są obecne i zgłaszają wyjątek, jest oczekiwane że nie zmienią przedmiotu. Jeśli opcjonalny parametr *align* jest prawdziwy, kawałki zakłada się że są ułożone na 2-bajtowych brzegach. Jeśli *align* jest fałszywy, żadne ułożenie nie jest przyjmowane. Domyślną wartością jest prawda. Jeśli opcjonalny parametr *bigendian* jest fałszywy rozmiar kawałka jest zakładany że jest w porządku małego-endian-a. To jest wymagane dla plików dźwiękowych WAVE. Domyślna wartość jest prawdziwa. Jeśli opcjonalny parametr *inclheader* jest prawdziwy, rozmiar dany w nagłówku kawałka zawiera rozmiar nagłówka, domyślną wartością jest fałsz. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Chunk` object supports the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmiot uogólnienia :class:`Chunk` wspiera następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the name (ID) of the chunk.  This is the first 4 bytes of the chunk.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca nazwę (IDentyfikator) kawałka. To jest pierwsze 4 bajty kawałka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the size of the chunk.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca rozmiar kawałka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close and skip to the end of the chunk.  This does not close the underlying file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamknij i przeskocz na koniec kawałka. To nie zamyka leżącego u podstaw pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The remaining methods will raise :exc:`IOError` if called after the :meth:`close` method has been called.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pozostałe sposoby postępowania zgłoszą :exc:`IOError` jeśli wywołany po tym, jak sposób postępowania :meth:`close` został wywołany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns ``False``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca ``fałsz``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the chunk's current position.  The *whence* argument is optional and defaults to ``0`` (absolute file positioning); other values are ``1`` (seek relative to the current position) and ``2`` (seek relative to the file's end).  There is no return value. If the underlying file does not allow seek, only forward seeks are allowed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw obecną pozycję kawałka. Parametr *whence* jest opcjonalny i domyślnie równy ``0`` (bezwzględna pozycja w pliku); inne wartości są ``1`` (wyszukaj w odniesieniu do obecnej pozycji w pliku) i ``2`` (wyszukaj w odniesieniu do końca pliku). Nie ma wartości zwracanej. Jeśli leżący u podstaw plik nie pozwala na wyszukiwanie, tylko wyszukiwanie w przód jest dozwolone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the current position into the chunk.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć obecną pozycję w kawałku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read at most *size* bytes from the chunk (less if the read hits the end of the chunk before obtaining *size* bytes).  If the *size* argument is negative or omitted, read all data until the end of the chunk.  The bytes are returned as a string object.  An empty string is returned when the end of the chunk is encountered immediately.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć co najwyżej *size* bajtów z kawałka (mniej jeśli wczytywanie napotka koniec kawałka przed otrzymaniem *size* bajtów). Jeśli parametr *size* jest ujemny lub pominięty, wczytaj wszystkie dane aż do końca kawałka. Bajty są zwracane jako przedmiot ciągu znaków. Pusty ciąg znaków jest zwracany gdy koniec kawałka jest napotykany natychmiast.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to the end of the chunk.  All further calls to :meth:`read` for the chunk will return ``''``.  If you are not interested in the contents of the chunk, this method should be called so that the file points to the start of the next chunk.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przeskocz do końca kawałka. Wszystkie przyszłe wywołania sposobu postępowania :meth:`read` dla kawałka zwrócą ``"``. Jeśli nie jesteś zainteresowany zawartością kawałka, ten sposób postępowania powinien być wywoływany tak aby plik wskazywał początek następnego kawałka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"EA IFF 85" Standard for Interchange Format Files, Jerry Morrison, Electronic Arts, January 1985.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>"EA IFF 85" Standard dla formatu plików wzajemnej wymiany, Jerry Morrison, Electronic Arts, styczeń 1985.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`cmath` --- Mathematical functions for complex numbers</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`cmath` --- zadania matematyczne dla liczb zespolonych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module is always available.  It provides access to mathematical functions for complex numbers.  The functions in this module accept integers, floating-point numbers or complex numbers as arguments. They will also accept any Python object that has either a :meth:`__complex__` or a :meth:`__float__` method: these methods are used to convert the object to a complex or floating-point number, respectively, and the function is then applied to the result of the conversion.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł jest zawsze dostępny. Dostarcza on dostęp do zadań matematycznych dla liczb zespolonych. Zadania w tym module akceptują liczby całkowite, liczby zmiennoprzecinkowe lub liczby zespolone jako parametry. Będą one także akceptować dowolne przedmioty języka pytonowskiego które mają sposoby postępowania albo :meth:`__complex__` lub :meth:`__float__`: te sposoby postępowania są używane aby zamienić przedmiot na liczbę zespoloną lub zmiennoprzecinkową, odpowiednio, i zadanie jest wtedy stosowane dla rezultatu przekształcenia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On platforms with hardware and system-level support for signed zeros, functions involving branch cuts are continuous on *both* sides of the branch cut: the sign of the zero distinguishes one side of the branch cut from the other.  On platforms that do not support signed zeros the continuity is as specified below.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Na maszynach/środowiskach ze wsparciem sprzętowym lub poziomu-systemu dla oznaczonych zer, zadania biorące pod uwagę cięcia rozgałęzień są ciągłe po obu stronach cięcia odgałęzienia: znak zera rozróżnia jedną stronę cięcia odgałęzienia od drugiej. Na maszynach/środowiskach, które nie wspierają znaczonych zer ciągłość jest określona poniżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversions to and from polar coordinates</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamiany z i do współrzędnych polowych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Python complex number ``z`` is stored internally using *rectangular* or *Cartesian* coordinates.  It is completely determined by its *real part* ``z.real`` and its *imaginary part* ``z.imag``.  In other words::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczba zespolona ``z`` jest zachowana wewnętrznie używając współrzędnych *prostokątnych* lub *Kartezjańskich*. Jest to kompletnie zdeterminowane przez *część rzeczywistą* - ``z.real`` i *część urojoną* ``z.imag``. Innymi słowy::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>z == z.real + z.imag*1j</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>z == z.real + z.imag*1j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Polar coordinates* give an alternative way to represent a complex number.  In polar coordinates, a complex number *z* is defined by the modulus *r* and the phase angle *phi*. The modulus *r* is the distance from *z* to the origin, while the phase *phi* is the counterclockwise angle, measured in radians, from the positive x-axis to the line segment that joins the origin to *z*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*Współrzędne polarne* dają alternatywny sposób aby reprezentować liczby zespolone. W polarnych współrzędnych, liczba zespolona *z* jest zdefiniowana przez moduł *r* i kąta fazowego *phi* - z ang. - *fi*. Moduł *r* jest odległością od *z* do początku, podczas gdy faza *phi* jest kątem przeciwnym dla ruchu wskazówek zegara, mierzonym w radianach, od pozytywnej osi-x do segmentu linii łączącej początek układu współrzędnych z *z*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following functions can be used to convert from the native rectangular coordinates to polar coordinates and back.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następujące zadania mogą być używane do skonwertowania z natywnych prostokątnych współrzędnych do współrzędnych kołowych i z powrotem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the phase of *x* (also known as the *argument* of *x*), as a float.  ``phase(x)`` is equivalent to ``math.atan2(x.imag, x.real)``.  The result lies in the range [-π, π], and the branch cut for this operation lies along the negative real axis, continuous from above.  On systems with support for signed zeros (which includes most systems in current use), this means that the sign of the result is the same as the sign of ``x.imag``, even when ``x.imag`` is zero::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć fazę *x* (znaną także jako *argument* *x*), jako liczbę zmiennoprzecinkową. ``phase(x)`` jest równoważne ``math.atan2(x.imag, x.real)``. Wynik leży w przedziale [-π, π], i przecięcie odgałęzienia dla tej operacji leży wzdłuż ujemnej rzeczywistej osi, ciągłej z góry. W maszynach/środowiskach które wspierają oznaczone zera (co zawiera większość maszyn/środowisk w obecnym użyciu), to oznacza że znak wyniku jest ten sam jak znak ``x.imag``, nawet gdy ``x.imag`` jest zero::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; phase(complex(-1.0, 0.0)) 3.141592653589793 &gt;&gt;&gt; phase(complex(-1.0, -0.0)) -3.141592653589793</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; phase(complex(-1.0, 0.0)) 3.141592653589793 &gt;&gt;&gt; phase(complex(-1.0, -0.0)) -3.141592653589793</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The modulus (absolute value) of a complex number *x* can be computed using the built-in :func:`abs` function.  There is no separate :mod:`cmath` module function for this operation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł (wartość bezwzględna) zespolonej liczby *x* może być obliczony używając wbudowanego zadania :func:`abs`. Nie ma oddzielnego zadania modułu :mod:`cmath` dla tej operacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the representation of *x* in polar coordinates.  Returns a pair ``(r, phi)`` where *r* is the modulus of *x* and phi is the phase of *x*.  ``polar(x)`` is equivalent to ``(abs(x), phase(x))``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć reprezentację *x* w kołowych współrzędnych. Zwróć parę ``(r, phi)`` gdzie *r* jest modułem *x* a phi jest fazą *x*. ``polar(x)`` jest równoważne ``(abs(x), phase(x))``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the complex number *x* with polar coordinates *r* and *phi*. Equivalent to ``r * (math.cos(phi) + math.sin(phi)*1j)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć liczbę zespoloną *x* z kołowymi współrzędnymi *r* i *phi*. Równoważne ``r * (math.cos(phi) + math.sin(phi)*1j)``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Power and logarithmic functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania potęgowania i logarytmiczne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the exponential value ``e**x``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć potęgową wartość ``e**x``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the logarithm of *x* to the given *base*. If the *base* is not specified, returns the natural logarithm of *x*. There is one branch cut, from 0 along the negative real axis to -∞, continuous from above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć logarytm *x* dla danej *podstawy* - z ang. - *base*. Jeśli *podstawa* - z ang. - *base* nie jest określona, zwróć logarytm naturalny *x*. Jest jedno odgałęzienie ucięte, od 0 wzdłuż ujemnej osi rzeczywistej do -∞, ciągłej od góry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the base-10 logarithm of *x*. This has the same branch cut as :func:`log`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć logarytm o podstawie dziesiętnej z *x*. To ma tą samą gałąź uciętą jak :func:`log`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the square root of *x*. This has the same branch cut as :func:`log`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć pierwiastek kwadratowy z *x*. To ma tą samą uciętą gałąź jak :func:`log`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Trigonometric functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Funkcje trygonometryczne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the arc cosine of *x*. There are two branch cuts: One extends right from 1 along the real axis to ∞, continuous from below. The other extends left from -1 along the real axis to -∞, continuous from above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć arcus cosinus *x*. Są dwa odgałęzienia ucięte: jedna biegnie od 1 wzdłuż rzeczywistej osi do ∞, ciągła od dołu. Druga biegnie od -1 wzdłuż rzeczywistej osi do -∞, ciągła od góry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the arc sine of *x*. This has the same branch cuts as :func:`acos`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć arcus sinus *x* To ma te same odgałęzienia cięte jak :func:`acos`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the arc tangent of *x*. There are two branch cuts: One extends from ``1j`` along the imaginary axis to ``∞j``, continuous from the right. The other extends from ``-1j`` along the imaginary axis to ``-∞j``, continuous from the left.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć arcus tangens *x*. Są dwa odgałęzienia ucięte: Jedno rozciąga się od ``1j`` wzdłuż osi urojonej do ``∞j``, ciągłe od prawej strony. Druga rozciąga się od ``-1j`` wzdłuż osi urojonej do ``-∞j``, ciągłej od lewej strony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the cosine of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć cosinus *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the sine of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć sinus *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the tangent of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć tangens *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hyperbolic functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Funkcje hiperboliczne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hyperbolic arc cosine of *x*. There is one branch cut, extending left from 1 along the real axis to -∞, continuous from above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć hiperboliczny arcus cosinus *x*. Istnieje jedno odgałęzienie, rozciągające się z lewej strony od 1 wzdłuż osi rzeczywistej do -∞, ciągłej od góry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hyperbolic arc sine of *x*. There are two branch cuts: One extends from ``1j`` along the imaginary axis to ``∞j``, continuous from the right.  The other extends from ``-1j`` along the imaginary axis to ``-∞j``, continuous from the left.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć hiperboliczny arcus sinus *x*. Istnieją dwa odgałęzienia ucięte, jedno rozciąga się od ``1j`` wzdłuż urojonej osi do ``∞j``, ciągłej od prawej strony. Druga rozciąga się od ``-1j`` wzdłuż urojonej osi do ``-∞j``, ciągłej od lewej strony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hyperbolic arc tangent of *x*. There are two branch cuts: One extends from ``1`` along the real axis to ``∞``, continuous from below. The other extends from ``-1`` along the real axis to ``-∞``, continuous from above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć hiperboliczny arcus tangens *x*. Istnieją dwie gałęzie: jedna rozciąga się od ``1`` wzdłuż rzeczywistej osi do ``∞``, ciągłej od dołu. Drugi rozciąga się od ``-1`` wzdłuż osi rzeczywistej do ``-∞``, ciągłej od góry.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hyperbolic cosine of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć hiperboliczny cosinus *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hyperbolic sine of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć hiperboliczny sinus *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the hyperbolic tangent of *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć hiperboliczny tangens *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classification functions</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Funkcje klasyfikacyjne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return *True* if the real or the imaginary part of x is positive or negative infinity.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć *prawdę* - z ang. - *True* jeśli rzeczywista lub urojona część x jest dodatnią lub ujemną nieskończonością.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return *True* if the real or imaginary part of x is not a number (NaN).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć *prawdę* - z ang. - *True* jeśli rzeczywista lub urojona część x nie jest liczbą (NaN - z ang. not a number)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constants</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stałe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mathematical constant *π*, as a float.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Stała matematyczna *π* jako liczba zmiennoprzecinkowa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mathematical constant *e*, as a float.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Matematyczna stała *e* jako liczba zmiennoprzecinkowa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the selection of functions is similar, but not identical, to that in module :mod:`math`.  The reason for having two modules is that some users aren't interested in complex numbers, and perhaps don't even know what they are.  They would rather have ``math.sqrt(-1)`` raise an exception than return a complex number. Also note that the functions defined in :mod:`cmath` always return a complex number, even if the answer can be expressed as a real number (in which case the complex number has an imaginary part of zero).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ, że wybór zadań jest podobny ale nie identyczny do tej w module :mod:`math`. Powódem posiadania dwóch modułów jest to, że niektórzy użytkownicy nie są zainteresowani liczbami zespolonymi, i być może nie wiedzą nawet że istnieją. Woleliby żeby ``math.sqrt(-1)`` zgłosił wyjątek niż zwróciło liczbę urojoną. Zauważ też że zadania określone w module :mod:`cmath` zawsze zwraca liczbę zespoloną, nawet jeśli odpowiedź może być wyrażona jako liczba rzeczywista (w którym to przypadku liczba zespolona ma część urojoną równą zero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A note on branch cuts: They are curves along which the given function fails to be continuous.  They are a necessary feature of many complex functions.  It is assumed that if you need to compute with complex functions, you will understand about branch cuts.  Consult almost any (not too elementary) book on complex variables for enlightenment.  For information of the proper choice of branch cuts for numerical purposes, a good reference should be the following:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwaga o cięciach gałęzi: Są to krzywe wzdłuż których dana funkcja nie jest ciągła. Są one konieczną właściwością wielu zespolonych funkcji. Jest zakładane że jeśli potrzebujesz obliczeń z liczbami zespolonymi, to zrozumiałe są cięcia gałęzi. Skonsultuj się prawie z każdą (nie tak podstawową) książką o liczbach zespolonych dla oświecenia. Dla informacji o właściwym wyborze cięć gałęzi dla potrzeb numerycznych, dobrym odniesieniem powinno być następujące:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kahan, W:  Branch cuts for complex elementary functions; or, Much ado about nothing's sign bit.  In Iserles, A., and Powell, M. (eds.), The state of the art in numerical analysis. Clarendon Press (1987) pp165-211.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kahan, W: "Branch cuts for complex elementary functions"; lub, Much ado about nothing's sign bit. w Iserles, A. i Powell, M. (eds.), Stan dzieła sztuki w numerycznej analizie. Clarendon Press (1987) pp165-211.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`cmd` --- Support for line-oriented command interpreters</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`cmd` --- Wsparcie dla zorientowanych-na-linię interpreterów poleceń</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Cmd` class provides a simple framework for writing line-oriented command interpreters.  These are often useful for test harnesses, administrative tools, and prototypes that will later be wrapped in a more sophisticated interface.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Cmd` dostarcza prostych ram dla pisania zorientowanych-na-linię interpretatorów poleceń. Te są często użyteczne dla testów, narzędzi administracyjnych i prototypów, które będą później zapakowane w bardziej zaawansowany sprzęg.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Cmd` instance or subclass instance is a line-oriented interpreter framework.  There is no good reason to instantiate :class:`Cmd` itself; rather, it's useful as a superclass of an interpreter class you define yourself in order to inherit :class:`Cmd`'s methods and encapsulate action methods.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład :class:`Cmd` lub przykład podrzędnego uogólnienia jest zorientowaną na linię ramą programu interpretującego polecenia. Nie ma dobrego powodu aby dawać przykład :class:`Cmd` sam w sobie; raczej jest użyteczne jako nadrzędne uogólnienie uogólnienia programu interpretującego polecenia który definiujesz sam w celu odziedziczenia sposobów postępowania :class:`Cmd` i kapsułkowania sposobów postępowania akcji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The optional argument *completekey* is the :mod:`readline` name of a completion key; it defaults to :kbd:`Tab`. If *completekey* is not :const:`None` and :mod:`readline` is available, command completion is done automatically.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcjonalny parametr *completekey* jest nazwą przycisku do kompletowania z modułu :mod:`readline`; domyślnie jest :kbd:`Tab`. Jeśli *completekey* nie jest :const:`None` i :mod:`readline` jest dostępne, kompletowanie poleceń jest dokonywane automatycznie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The optional arguments *stdin* and *stdout* specify the  input and output file objects that the Cmd instance or subclass  instance will use for input and output. If not specified, they will default to :data:`sys.stdin` and :data:`sys.stdout`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcjonalne parametry *stdin* i *stdout* określa wejściowe i wyjściowe przedmiotów plików których przykłady Cmd lub podrzędnych uogólnień będą używane dla wejścia i wyjścia. Jeśli nie określono, będą one domyślnie równe :data:`sys.stdin` i :data:`sys.stdout`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a given *stdin* to be used, make sure to set the instance's :attr:`use_rawinput` attribute to ``False``, otherwise *stdin* will be ignored.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli chcesz aby dane *stdin* było używane, upewnij się że ustawisz właściwość :attr:`use_rawinput` na ``False`` - z ang. - ``Fałsz`` w przeciwnym razie *stdin* zostanie zignorowany.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cmd Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Cmd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Cmd` instance has the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady :class:`Cmd` mają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeatedly issue a prompt, accept input, parse an initial prefix off the received input, and dispatch to action methods, passing them the remainder of the line as argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Powtarzając wysyłaj zapytanie, akceptuj wpisy wejściowe, wczytuj początkowe przedrostki otrzymanego wejścia i rozkładaj do sposobów postępowania akcji, przekazując im pozostałą część linii jako parametr.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The optional argument is a banner or intro string to be issued before the first prompt (this overrides the :attr:`intro` class member).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opcjonalny parametr jest bannerem lub ciągiem znaków wprowadzającym do wystosowania przed pierwszym zapytaniem o polecenie (to obchodzi właściwość :attr:`intro` - członka uogólnienia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the :mod:`readline` module is loaded, input will automatically inherit :program:`bash`\ -like history-list editing (e.g. :kbd:`Control-P` scrolls back to the last command, :kbd:`Control-N` forward to the next one, :kbd:`Control-F` moves the cursor to the right non-destructively, :kbd:`Control-B` moves the cursor to the left non-destructively, etc.).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli moduł :mod:`readline` jest załadowany, wejście automatycznie odziedziczy podobny do :program:`bash`\-a sposób edycji list-historii (np. :kbd:`Control-P` przewija wstecz do ostatniej komendy, :kbd:`Control-N` przejście wprzód do następnego, :kbd:`Control-F` przesunięcie kursora do prawej strony nie-destrukcyjnie, :kbd:`Control-B` przesunięcie kursora do lewej strony nie-destrukcyjnie, itd.).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An end-of-file on input is passed back as the string ``'EOF'``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Koniec-pliku na wejściu jest przekazywany jako ciąg ``'EOF'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interpreter instance will recognize a command name ``foo`` if and only if it has a method :meth:`do_foo`.  As a special case, a line beginning with the character ``'?'`` is dispatched to the method :meth:`do_help`.  As another special case, a line beginning with the character ``'!'`` is dispatched to the method :meth:`do_shell` (if such a method is defined).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład programu interpretującego będzie rozpoznawał nazwę komendy ``foo`` wtedy i tylko wtedy gdy ma on sposób postępowania :meth:`do_foo`. Jako szczególny przypadek, początek wiersza ze znakiem ``'?'`` jest przesyłany do sposobu postępowania :meth:`do_help`. Jako następny szczególny przypadek, początek linii ze znakiem ``'!'`` jest przesyłany do sposobu postępowania :meth:`do_shell` (jeśli taki sposób postępowania jest zdefiniowany).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method will return when the :meth:`postcmd` method returns a true value. The *stop* argument to :meth:`postcmd` is the return value from the command's corresponding :meth:`do_\*` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania będzie powracał gdy sposób postępowania :meth:`postcmd` zwróci wartość prawdy. Parametr *stop* dla sposobu postępowania :meth:`postcmd` jest wartością zwracaną z odpowiadającego sposobu postępowania :meth:`do_\*`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If completion is enabled, completing commands will be done automatically, and completing of commands args is done by calling :meth:`complete_foo` with arguments *text*, *line*, *begidx*, and *endidx*.  *text* is the string prefix we are attempting to match: all returned matches must begin with it. *line* is the current input line with leading whitespace removed, *begidx* and *endidx* are the beginning and ending indexes of the prefix text, which could be used to provide different completion depending upon which position the argument is in.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli kompletowanie jest włączone kompletowanie komend będzie wykonywane automatycznie i kompletowanie parametrów komend jest dokonywane przez wywołanie :meth:`complete_foo` z parametrami *text*, *line*, *begidx*, i *endidx*. *text* jest ciągiem przedrostka który mamy zamiar dopasować: wszystkie zwracane dopasowania muszą zaczynać się od niego. *line* jest obecną linią wprowadzaną ze zdjętymi prowadzącymi białymi znakami, *begidx* i *endidx* są początkowymi i końcowymi indeksami tekstu przedrostka, które mogą być użyte do zapewnienia różnych uzupełnień w zależności od tego w której pozycji parametr się znalazł.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All subclasses of :class:`Cmd` inherit a predefined :meth:`do_help`. This method, called with an argument ``'bar'``, invokes the corresponding method :meth:`help_bar`.  With no argument, :meth:`do_help` lists all available help topics (that is, all commands with corresponding :meth:`help_\*` methods), and also lists any undocumented commands.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie podrzędne uogólnienia :class:`Cmd` dziedziczą uprzednio zdefiniowany sposób postępowania :meth:`do_help`. Ten sposób postępowania wywołany z parametrem ``'bar'``, wywołuje odpowiadający sposób postępowania :meth:`help_bar`. Bez parametru :meth:`do_help` wypisuje wszystkie dostępne tematy pomocy (to jest, wszystkie polecenia z odpowiadającymi sposobami postępowania :meth:`help_\*`), a także wypisuje wszystkie nieudokumentowane polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interpret the argument as though it had been typed in response to the prompt. This may be overridden, but should not normally need to be; see the :meth:`precmd` and :meth:`postcmd` methods for useful execution hooks.  The return value is a flag indicating whether interpretation of commands by the interpreter should stop.  If there is a :meth:`do_\*` method for the command *str*, the return value of that method is returned, otherwise the return value from the :meth:`default` method is returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Interpretuj parametr tak jakby został wprowadzony w odpowiedzi na zapytanie. To może być przesłonięte, ale nie powinno normalnie być; zobacz sposoby postępowania :meth:`precmd` i :meth:`postcmd` dla użytecznych haczyków wykonania. Wartość zwracana jest flagą wskazującą czy interpretacja poleceń przez program interpretujący powinna się zakończyć. Jeśli istnieje sposób postępowania :meth:`do_\*` dla polecenia *str*, wartość zwracana z tego sposobu postępowania jest zwracana, w przeciwnym przypadku wartość zwracana ze sposobu postępowania :meth:`default` jest zwracana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when an empty line is entered in response to the prompt. If this method is not overridden, it repeats the last nonempty command entered.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania wywoływany wtedy gdy pusty wiersz jest wprowadzany w odpowiedzi na zapytanie. Jeśli ten sposób postępowania nie jest przesłonięty, powtarza on ostatnią niepustą komendę wprowadzoną.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called on an input line when the command prefix is not recognized. If this method is not overridden, it prints an error message and returns.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania wywoływany na linii wprowadzanej gdy przedrostek polecenia jest nierozpoznany. Jeśli ten sposób postępowania nie jest przesłonięty, drukuje on wiadomość o błędzie i powraca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called to complete an input line when no command-specific :meth:`complete_\*` method is available.  By default, it returns an empty list.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób wywoływany w celu uzupełnienia linii wejściowej gdy żadne szczególne-dla-polecenia sposoby postępowania :meth:`complete\*` nie są dostępne. Domyślnie, zwraca pustą listę. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hook method executed just before the command line *line* is interpreted, but after the input prompt is generated and issued.  This method is a stub in :class:`Cmd`; it exists to be overridden by subclasses.  The return value is used as the command which will be executed by the :meth:`onecmd` method; the :meth:`precmd` implementation may re-write the command or simply return *line* unchanged.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania - hak - wykonywany dokładnie przed tym, jak wiersz poleceń *linia* jest interpretowany, ale po tym jak zapytanie wejściowe jest wygenerowane i przekazane. Ten sposób postępowania jest zrębem w :class:`Cmd`; istnieje po to aby być przesłanianym przez podrzędne uogólnienia. Wartość zwracana jest używana jako polecenie, które będzie wykonane przez sposób postępowania :meth:`onecmd`; wypełnienie sposobu postępowania :meth:`precmd` może ponownie zapisywać polecenie lub po prostu zwracać *linię* bez zmian.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hook method executed just after a command dispatch is finished.  This method is a stub in :class:`Cmd`; it exists to be overridden by subclasses.  *line* is the command line which was executed, and *stop* is a flag which indicates whether execution will be terminated after the call to :meth:`postcmd`; this will be the return value of the :meth:`onecmd` method.  The return value of this method will be used as the new value for the internal flag which corresponds to *stop*; returning false will cause interpretation to continue.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania - hak - wykonywany tuż po tym jak wydawanie polecenia jest zakończone. Ten sposób postępowania jest zrębem w uogólnieniu :class:`Cmd`; istnieje aby być przesłanianym przez podrzędne uogólnienia. *Linia* jest poleceniem które zostało wykonane, i *stop* jest flagą która wskazuje czy wykonanie zostanie zakończone po wywołaniu sposobu postępowania :meth:`postcmd`; to będzie wartość zwracana sposobu postępowania :meth:`onecmd`. Wartość zwracana tego sposobu postępowania będzie używana jako nowa wartość dla wewnętrznej flagi która odpowiada *stop*; zwracanie fałszu będzie powodowało, że interpretacja pójdzie naprzód.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hook method executed once when :meth:`cmdloop` is called.  This method is a stub in :class:`Cmd`; it exists to be overridden by subclasses.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania hak wykonywany raz gdy :meth:`cmdloop` jest wywoływany. Ten sposób postępowania jest zrębem w uogólnieniu :class;`Cmd`; istnieje aby być przesłaniany przez podrzędne uogólnienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hook method executed once when :meth:`cmdloop` is about to return. This method is a stub in :class:`Cmd`; it exists to be overridden by subclasses.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania - hak - wykonywany raz gdy sposób postępowania :meth:`cmdloop` jest gotowa do powrotu. Ten sposób postępowania jest zrębem w uogólnieniu :class:`Cmd`; istnieje aby być przesłanianym przez podrzędne uogólnienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of :class:`Cmd` subclasses have some public instance variables:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady uogólnienia podrzędnego względem uogólnienia :class:`Cmd` mają pewne publiczne zmienne przykładu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prompt issued to solicit input.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapytanie wypuszczone aby pobrać wejście.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The string of characters accepted for the command prefix.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ciąg znaków akceptowany za przedrostek polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last nonempty command prefix seen.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Niepusty przedrostek polecenia widziany ostatnio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A string to issue as an intro or banner.  May be overridden by giving the :meth:`cmdloop` method an argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ciąg znaków do przekazania jako ciąg wprowadzający lub banner. Może być przesłonięty przez podanie parametru dla sposobu postępowania :meth:`cmdloop`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The header to issue if the help output has a section for documented commands.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nagłówek do przekazania jeśli wyjście pomocy ma rozdział dla udokumentowanych poleceń.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The header to issue if the help output has a section for miscellaneous  help topics (that is, there are :meth:`help_\*` methods without corresponding :meth:`do_\*` methods).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nagłówek do przekazania jeśli wyjście pomocy ma rozdział dla szczególnych treści pomocy (to jest, istnieją sposoby postępowania :meth:`help_\*`, bez odpowiadających sposobów postępowania :meth:`do_\*`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The header to issue if the help output has a section for undocumented  commands (that is, there are :meth:`do_\*` methods without corresponding :meth:`help_\*` methods).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Nagłówek do przekazania jeśli wyjście pomocy ma rozdział dla nieudokumentowanych poleceń (to jest, istnieją sposoby postępowania :meth:`do_\*` bez odpowiadających sposobów postępowania :meth:`help_\*`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The character used to draw separator lines under the help-message headers.  If empty, no ruler line is drawn.  It defaults to ``'='``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Znak używany aby rysować linie separatora pod nagłówkami wiadomości-pomocy. Jeśli pusty żadna linia oddzielająca nie jest rysowana. Domyślnie równa jest ``'='``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A flag, defaulting to true.  If true, :meth:`cmdloop` uses :func:`input` to display a prompt and read the next command; if false, :meth:`sys.stdout.write` and :meth:`sys.stdin.readline` are used. (This means that by importing :mod:`readline`, on systems that support it, the interpreter will automatically support :program:`Emacs`\ -like line editing  and command-history keystrokes.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Flaga domyślnie równa prawdzie. Jeśli prawdziwa sposób postępowania :meth:`cmdloop` używa zadania :func:`input` aby wyświetlić zapytanie i wczytać następne polecenie; jeśli fałszywa sposoby postępowania :meth:`sys.stdout.write` i :meth:`sys.stdin.readline` są używane. (To oznacza że przez importowanie :mod;`readline`, na systemach które wspierają go, interpreter automatycznie wspiera :program:`Emacs`\ -o-podobne edycje linii i naciśnięcia przycisków historii-poleceń.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`code` --- Interpreter base classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`code` --- uogólnienia bazowe interpretera poleceń</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ``code`` module provides facilities to implement read-eval-print loops in Python.  Two classes and convenience functions are included which can be used to build applications which provide an interactive interpreter prompt.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł ``code`` dostarcza urządzeń do wypełnienia pętli read-eval-print - wczytaj-oblicz-drukuj w języku pytonowskim. Dwa uogólnienia i zadania użytkowe są zawarte, które mogą być użyte do budowania aplikacji które dostarczają współdziałający z użytkownikiem program interpretujący polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class deals with parsing and interpreter state (the user's namespace); it does not deal with input buffering or prompting or input file naming (the filename is always passed in explicitly). The optional *locals* argument specifies the dictionary in which code will be executed; it defaults to a newly created dictionary with key ``'__name__'`` set to ``'__console__'`` and key ``'__doc__'`` set to ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To uogólnienie zajmuje się wczytywaniem i stanem programu interpretującego (przestrzeni nazw użytkownika); nie zajmuje się ono przestrzenią wymiany wejścia czy zapytywaniem czy też nazywaniem pliku wejściowego (nazwa pliku zawsze przekazywana jest jawnie). Opcjonalny parametr *locals* określa słownik w którym kod będzie wykonywany; Domyślnie równe jest nowo utworzonemu słownikowi z kluczem ``'__name__'`` ustawionym na ``'__console__'`` i kluczem ``'__doc__'`` ustawionym na ``None``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Closely emulate the behavior of the interactive Python interpreter. This class builds on :class:`InteractiveInterpreter` and adds prompting using the familiar ``sys.ps1`` and ``sys.ps2``, and input buffering.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Blisko emuluj zachowanie współdziałającego z użytkownikiem programu interpretującego polecenia języka pytonowskiego. To uogólnienie buduje na uogólnieniu :class:`InteractiveInterpreter` i dodaje zapytania używając znajomego ``sys.ps1`` i ``sys.ps2``, i przestrzeni wymiany wejścia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convenience function to run a read-eval-print loop.  This creates a new instance of :class:`InteractiveConsole` and sets *readfunc* to be used as the :meth:`raw_input` method, if provided.  If *local* is provided, it is passed to the :class:`InteractiveConsole` constructor for use as the default namespace for the interpreter loop.  The :meth:`interact` method of the instance is then run with *banner* passed as the banner to use, if provided.  The console object is discarded after use.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadanie - udogodnienie - do uruchamiania pętli wczytaj-oblicz-drukuj. To tworzy nowy przykład uogólnienia :class:`InteractiveConsole` i ustawia *readfunc* aby było użyte przez sposób postępowania :meth:`raw_input`, jeśli dostarczono. Jeśli *local* jest dostarczony, jest przekazywany do konstruktora uogólnienia :class:`InteractiveConsole` dla użycia jako domyślna przestrzeń nazw dla pętli programu interpretującego polecenia. Sposób postępowania :meth:`interact` dla przykładu jest wtedy uruchamiany z *bannerem* przekazywanym jako banner do użycia, jeśli dostarczono. Przedmiot konsoli jest odrzucany po użyciu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This function is useful for programs that want to emulate Python's interpreter main loop (a.k.a. the read-eval-print loop).  The tricky part is to determine when the user has entered an incomplete command that can be completed by entering more text (as opposed to a complete command or a syntax error).  This function *almost* always makes the same decision as the real interpreter main loop.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>To zadanie jest użyteczne dla programów, które chcą emulować główną pętlę interpretatora poleceń języka pytonowskiego (inaczej znanego jako pętla wczytaj-oblicz-drukuj). Trudną częścią jest określenie gdy użytkownik wprowadził niepełne polecenie, które może być uzupełnione przez wpisanie większej ilości tekstu (w przeciwieństwie do kompletnego polecenia lub błędu składniowego). To zadanie *prawie* zawsze wykonuje te same decyzje jako pętla główna prawdziwego programu interpretującego polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*source* is the source string; *filename* is the optional filename from which source was read, defaulting to ``'&lt;input&gt;'``; and *symbol* is the optional grammar start symbol, which should be either ``'single'`` (the default) or ``'eval'``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*źródło* - z ang. - *source* jest ciągiem źródła; *filename* - z ang. - *nazwa pliku* jest opcjonalną nazwą pliku z którego źródło zostało wczytane, domyślnie równe ``'&lt;input&gt;'``; i *symbol* jest opcjonalnym gramatycznym symbolem początkowym, który powinien być albo ``'pojedynczym'`` - z ang. - ``'single'`` (domyślnie) albo ``'eval'`` - z ang. - ``'obliczonym'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns a code object (the same as ``compile(source, filename, symbol)``) if the command is complete and valid; ``None`` if the command is incomplete; raises :exc:`SyntaxError` if the command is complete and contains a syntax error, or raises :exc:`OverflowError` or :exc:`ValueError` if the command contains an invalid literal.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca przedmiot kodu (ten sam jak ``compile(source, filename, symbol)``) jeśli polecenie jest kompletne i poprawne; ``None`` jeśli polecenie jest niekompletne; zgłasza :exc:`SyntaxError` jeśli polecenie jest kompletne i zawiera błąd składniowy, lub zgłasza :exc:`OverflowError` lub :exc:`ValueError` jeśli polecenie zawiera niewłaściwą wartość.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interactive Interpreter Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty współdziałającego z użytkownikiem programu interpreteującego polecenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compile and run some source in the interpreter. Arguments are the same as for :func:`compile_command`; the default for *filename* is ``'&lt;input&gt;'``, and for *symbol* is ``'single'``.  One several things can happen:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Skompiluj i uruchom pewne źródło w programie interpretującym. Parametry są te same co dla zadania :func:`compile_command`; domyślnie dla *nazwy pliku* - z ang. - *filename* jest ``'&lt;input&gt;'``, i dla *symbolu* jest ``'single'``. Jedno z kilku rzeczy może się zdarzyć:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input is incorrect; :func:`compile_command` raised an exception (:exc:`SyntaxError` or :exc:`OverflowError`).  A syntax traceback will be printed by calling the :meth:`showsyntaxerror` method.  :meth:`runsource` returns ``False``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wejście jest nieprawidłowe; :func:`compile_command` zgłosiła wyjątek (:exc:`SyntaxError` lub :exc:`OverflowError`). Składniowy wypis śledzenia zostanie wydrukowany przez wywołanie sposobu postępowania :meth:`showsyntaxerror`. Sposób postępowania :meth:`runsource` zwraca ``Fałsz``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input is incomplete, and more input is required; :func:`compile_command` returned ``None``. :meth:`runsource` returns ``True``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wejście jest niekompletne, więcej wpisów wejścia jest oczekiwane; zadanie :func:`compile_command` zwraca ``None``. :meth:`runsource` zwraca ``Prawdę`` - z ang. - ``True``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input is complete; :func:`compile_command` returned a code object.  The code is executed by calling the :meth:`runcode` (which also handles run-time exceptions, except for :exc:`SystemExit`). :meth:`runsource` returns ``False``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wejście jest kompletne; :func:`compile_command` zwróciło przedmiot kodu. Kod jest wykonywany przez uruchomienie sposobu postępowania :meth:`runcode` (co także obsługuje wyjątki czasu-wykonania, z wyjątkiem dla :exc:`SystemExit`). Sposób postępowania :meth:`runsource` zwraca ``Fałsz``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The return value can be used to decide whether to use ``sys.ps1`` or ``sys.ps2`` to prompt the next line.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość zwracana może być użyta dla zdecydowania czy używać ``sys.ps1`` lub ``sys.ps2`` aby zapytać o następną linię.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execute a code object. When an exception occurs, :meth:`showtraceback` is called to display a traceback.  All exceptions are caught except :exc:`SystemExit`, which is allowed to propagate.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wykonaj przedmiot kodu. Gdy wyjątek nastąpi, :meth:`showtraceback` jest wywoływane aby wyświetlić wypis śladu. Wszystkie wyjątki są łapane z oprócz :exc:`SystemExit`, który ma pozwolenie na propagację.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A note about :exc:`KeyboardInterrupt`: this exception may occur elsewhere in this code, and may not always be caught.  The caller should be prepared to deal with it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ o :exc:`KeyboardInterrupt`: ten wyjątek może nastąpić gdziekolwiek indziej w tym kodzie i może nie zawsze być złapany. Wywołujący powinien być przygotowany aby sobie z tym radzić.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Display the syntax error that just occurred.  This does not display a stack trace because there isn't one for syntax errors. If *filename* is given, it is stuffed into the exception instead of the default filename provided by Python's parser, because it always uses ``'&lt;string&gt;'`` when reading from a string. The output is written by the :meth:`write` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyświetl błąd który właśnie nastąpił. To nie wyświetla wypisu śladu ze sterty ponieważ nie istnieje taki dla błędu składniowego. Jeśli *nazwa pliku* jest dana, jest ona wepchnięta w wyjątek zamiast domyślnej nazwy pliku dostarczonej przez czytnik języka Pytonowskiego, ponieważ to zawsze używa ``'&lt;string&gt;'`` gdy czytane jest z ciągu znaków. Wyjście jest zapisywane przez sposób postępowania :meth:`write`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Display the exception that just occurred.  We remove the first stack item because it is within the interpreter object implementation. The output is written by the :meth:`write` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wyświetl wyjątek który właśnie nastąpił. Zdejmujemy pierwszy element sterty ponieważ jest on wewnątrz wypełnienia przedmiotu interpretatora. Wyjście jest zapisywane przez sposób postępowania :meth:`write`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a string to the standard error stream (``sys.stderr``). Derived classes should override this to provide the appropriate output handling as needed.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz ciąg znaków do standardowego strumienia błędów (``sys.stderr``). Pochodne uogólnienia powinny przesłaniać to dla dostarczenia odpowiedniej obsługi wyjścia, jak potrzeba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interactive Console Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty współdziałającej z użytkownikiem konsoli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`InteractiveConsole` class is a subclass of :class:`InteractiveInterpreter`, and so offers all the methods of the interpreter objects as well as the following additions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`InteractiveConsole` jest podrzędnym uogólnieniem względem :class:`InteractiveInterpreter`, i tak oferuje wszystkie sposoby postępowania przedmiotów interpretera zarówno jak też następujące dodatki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Closely emulate the interactive Python console. The optional banner argument specify the banner to print before the first interaction; by default it prints a banner similar to the one printed by the standard Python interpreter, followed by the class name of the console object in parentheses (so as not to confuse this with the real interpreter -- since it's so close!).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Blisko emuluj współdziałającą z użytkownikiem  konsolę języka Pytonowskiego. Opcjonalny parametr banner określa banner do wydrukowania przed pierwszym współdziałaniem z użytkownikiem; domyślnie drukuje to banner podobny do jednego drukowanego przez standardowy interpreter języka pytonowskiego, po którym następuje nazwa przedmiotu konsoli w nawiasach (tak aby nie pomylić tego z rzeczywistym interpreterem -- gdyż jest on tak bliski!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Push a line of source text to the interpreter. The line should not have a trailing newline; it may have internal newlines.  The line is appended to a buffer and the interpreter's :meth:`runsource` method is called with the concatenated contents of the buffer as source.  If this indicates that the command was executed or invalid, the buffer is reset; otherwise, the command is incomplete, and the buffer is left as it was after the line was appended.  The return value is ``True`` if more input is required, ``False`` if the line was dealt with in some way (this is the same as :meth:`runsource`).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Popchnij linię tekstu źródłowego dla interpretatora. Linia nie powinna mieć kończącego znaku nowego wiersza. Linia jest dopisywana do przestrzeni wymiany, a sposób postępowania :meth:`runsource` programu interpretującego polecenia języka pytonowskiego jest wywoływany z połączonych zawartości z przestrzeni wymiany jako źródło. Jeśli to wskazuje, że komenda została wykonana lub niewłaściwa, przestrzeń wymiany jest resetowana; w przeciwnym razie, polecenie jest niekompletne, a przestrzeń wymiany jest pozostawiana tak jak była po tym jak linia została dopisana. Wartość zwracana jest ``Prawdziwa`` jeśli więcej wejścia jest wymagane, ``Fałszywa`` jeśli linia została obsłużona w pewien sposób (to jest tym samym jak :meth:`runsource`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove any unhandled source text from the input buffer.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdejmij dowolne nieobsłużone teksty źródłowe z przestrzeni wymiany wprowadzania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a prompt and read a line.  The returned line does not include the trailing newline.  When the user enters the EOF key sequence, :exc:`EOFError` is raised. The base implementation reads from ``sys.stdin``; a subclass may replace this with a different implementation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisz zapytanie i wczytaj linię. Zwracana linia nie zawiera kończącego znaku nowej linii. Gdy użytkownik wprowadzi sekwencję znaków EOF, :exc:`EOFError` jest zgłaszany. Bazowe wypełnienie wczytuje z ``sys.stdin``; podrzędne uogólnienie może zastąpić to innym wypełnieniem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`codecs` --- Codec registry and base classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`codecs` --- rejestr kodeków i uogólnień podstawowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module defines base classes for standard Python codecs (encoders and decoders) and provides access to the internal Python codec registry which manages the codec and error handling lookup process.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł określa uogólnienia podstawowe dla standardowych kodeków języka Pytonowskiego (koderów i dekoderów) i dostarcza dostęp do wewnętrznego rejestru kodeków który zarządza kodekami i procesem podglądania obsługi błędów. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It defines the following functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Definiuje to następujące zadania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register a codec search function. Search functions are expected to take one argument, the encoding name in all lower case letters, and return a :class:`CodecInfo` object having the following attributes:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rejestruje zadanie szukania kodeków. Zadania poszukiwania kodeku oczekuje się że pobiorą jeden parametr, nazwę kodowania małymi literami, i zwróci przedmiot :class:`CodecInfo` posiadający następujące właściwości:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``name`` The name of the encoding;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``name`` Nazwa kodowania;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``encode`` The stateless encoding function;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``encode`` Bezstanowe zadanie kodowania;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``decode`` The stateless decoding function;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``decode`` Bezstanowe zadanie dekodowania;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``incrementalencoder`` An incremental encoder class or factory function;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``incrementalencoder`` zwiększające uogólnienie kodowania lub zadanie fabrykujące;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``incrementaldecoder`` An incremental decoder class or factory function;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``incrementaldecoder`` zwiększające uogólnienie dekodowania lub zadanie fabrykujące;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``streamwriter`` A stream writer class or factory function;</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``streamwriter`` zapisujące strumień uogólnienie lub zadanie fabrykujące;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``streamreader`` A stream reader class or factory function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``streamreader`` odczytujące strumień uogólnienie lub zadanie fabrykujące;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The various functions or classes take the following arguments:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Różne zadania i uogólnienia pobierają następujące parametry:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*encode* and *decode*: These must be functions or methods which have the same interface as the :meth:`encode`/:meth:`decode` methods of Codec instances (see Codec Interface). The functions/methods are expected to work in a stateless mode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*koduj* i *dekoduj - z ang. - *encode* and *decode*: Te muszą być zadaniami lub sposobami postępowania, które mają ten sam sprzęg jak sposoby postępowania :meth:`encode`/:meth:`decode` przykładów kodeków (zobacz sprzęg kodeków). Zadania/ sposoby postępowania oczekuje się, że będą działać w trybie bezstanowym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*incrementalencoder* and *incrementaldecoder*: These have to be factory functions providing the following interface:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*incrementalencoder* i *incrementaldecoder*: Te muszą być zadaniami fabrykującymi dostarczającymi następujący sprzęg:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``factory(errors='strict')``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``factory(errors='strict')``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The factory functions must return objects providing the interfaces defined by the base classes :class:`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. Incremental codecs can maintain state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania fabrykujące muszą zwracać przedmioty dostarczające sprzęgi określone przez uogólnienia podstawowe :class:`IncrementalEncoder` i :class:`IncrementalDecoder`, odpowiednio. Zwiększające kodeki mogą zachowywać stan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*streamreader* and *streamwriter*: These have to be factory functions providing the following interface:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*streamreader* i *streamwriter*: Te muszą być zadaniami fabrykującymi dostarczającymi następujący sprzęg:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``factory(stream, errors='strict')``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``factory(stream, errors='strict')``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The factory functions must return objects providing the interfaces defined by the base classes :class:`StreamWriter` and :class:`StreamReader`, respectively. Stream codecs can maintain state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zadania fabrykujące muszą zwracać przedmioty dostarczające sprzęgi określone przez uogólnienie podstawowe :class:`StreamWriter` i :class:`StreamReader` odpowiednio. Kodeki strumieniowe mogą zachowywać stan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Possible values for errors are</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możliwe wartości dla błędów są:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'strict'``: raise an exception in case of an encoding error</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'strict'``: zgłoś wyjątek w przypadku błędu kodowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'replace'``: replace malformed data with a suitable replacement marker, such as ``'?'`` or ``'\ufffd'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'replace'``: zamień dane z odpowiednim markerem zamiany, takim jak ``'?'`` lub ``'\ufffd'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'ignore'``: ignore malformed data and continue without further notice</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'ignore'``: ignoruj źle uformowane dane i kontynuuj bez dalszych powiadomień</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'xmlcharrefreplace'``: replace with the appropriate XML character reference (for encoding only)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'xmlcharrefreplace'``: zamień na odpowiedni znak odniesienia XML (tylko dla kodowania)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'backslashreplace'``: replace with backslashed escape sequences (for encoding only)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'backslashreplace'``: zamień na skośnikowane sekwencje ucieczkowe (jedynie dla kodowania) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'surrogateescape'``: replace with surrogate U+DCxx, see :pep:`383`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'surrogateescape'``: zamień na surogatową U+DCxx, zobacz :pep:`383`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>as well as any other error handling name defined via :func:`register_error`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zarówno jak też dowolne inne nazwy obsługi błędów zdefiniowanych przez :func:`register_error`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case a search function cannot find a given encoding, it should return ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W przypadku gdy zadanie poszukiwania nie może znaleźć danego kodowania, powinno ono zwrócić ``None``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks up the codec info in the Python codec registry and returns a :class:`CodecInfo` object as defined above.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podgląda informację o kodeku w rejestrze kodeków języka pytonowskiego i zwraca przedmiot :class:`CodecInfo` jak określono powyżej.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encodings are first looked up in the registry's cache. If not found, the list of registered search functions is scanned. If no :class:`CodecInfo` object is found, a :exc:`LookupError` is raised. Otherwise, the :class:`CodecInfo` object is stored in the cache and returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodowania są najpierw podglądane w kieszeni rejestru. Jeśli nie znaleziono, lista zadań poszukiwania jest skanowana. Jeśli żadne przedmioty :class:`CodecInfo` nie są znajdowane, wyjątek :exc:`LookupError` jest zgłaszany. W przeciwnym przypadku przedmiot :class:`CodecInfo` jest przechowywany w kieszeni i zwracany do wywołującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To simplify access to the various codecs, the module provides these additional functions which use :func:`lookup` for the codec lookup:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby uprościć dostęp do różnych kodeków, moduł dostarcza te dodatkowe zadania które używają zadania :func:`lookup` dla podglądu kodeków:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look up the codec for the given encoding and return its encoder function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejrzyj kodek dla danego kodowania i zwróć jego zadanie kodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises a :exc:`LookupError` in case the encoding cannot be found.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza :exc:`LookupError` w przypadku gdy kodowanie nie może być znalezione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look up the codec for the given encoding and return its decoder function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejrzyj kodek dla danego kodowania i zwróć jego zadanie dekodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look up the codec for the given encoding and return its incremental encoder class or factory function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejrzyj kodek dla danego kodowania i zwróć jego uogólnienie zwiększające koder lub zadanie fabrykujące. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises a :exc:`LookupError` in case the encoding cannot be found or the codec doesn't support an incremental encoder.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłoś :exc:`LookupError` w przypadku gdy kodowanie nie może być znalezione lub gdy kodek nie wspiera zwiększającego się kodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look up the codec for the given encoding and return its incremental decoder class or factory function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejrzyj kodek dla danego kodowania i zwróć jego uogólnienie zwiększającego dekodera lub zadania fabrykującego. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises a :exc:`LookupError` in case the encoding cannot be found or the codec doesn't support an incremental decoder.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza wyjątek :exc:`LookupError` w przypadku gdy kodowanie nie może znaleźć kodowania lub kodek nie wspiera zwiększającego się dekodera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look up the codec for the given encoding and return its StreamReader class or factory function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejrzyj kodek dla danego kodowania i zwróć jego uogólnienie StreamReader lub zadanie fabrykujące.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look up the codec for the given encoding and return its StreamWriter class or factory function.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Podejrzyj kodek dla danego kodowania i zwróć jego uogólnienie StreamWriter lub zadania fabrykującego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Register the error handling function *error_handler* under the name *name*. *error_handler* will be called during encoding and decoding in case of an error, when *name* is specified as the errors parameter.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć zadanie obsługi błędu *error_handler* pod nazwą *name*. *error_handler* będzie wywołany w czasie kodowania i dekodowania w przypadku błędu, gdy *nazwa* - z ang. - *name* jest określone dla parametrów błędów.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For encoding *error_handler* will be called with a :exc:`UnicodeEncodeError` instance, which contains information about the location of the error. The error handler must either raise this or a different exception or return a tuple with a replacement for the unencodable part of the input and a position where encoding should continue. The encoder will encode the replacement and continue encoding the original input at the specified position. Negative position values will be treated as being relative to the end of the input string. If the resulting position is out of bound an :exc:`IndexError` will be raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla kodowania *error_handler* będzie wywołane z przykładem :exc:`UnicodeEncodeError` który zawiera informacje o położeniu błędu. Obsługa błędu musi albo zgłosić ten lub inny wyjątek lub zwrócić krotkę z zamiennikiem dla niedekodowalną część wejścia i pozycję gdzie kodowanie powinno kontynuować. Kodowanie będzie kodować zamiennik i kontynuować kodowanie oryginalnego wejścia w określonej pozycji. Ujemne wartości pozycji zostaną potraktowane jako będące odniesieniem do końca ciągu wejściowego. Jeśli powstała pozycja jest poza zakresem wyjątek :exc:`IndexError` zostanie zgłoszony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decoding and translating works similar, except :exc:`UnicodeDecodeError` or :exc:`UnicodeTranslateError` will be passed to the handler and that the replacement from the error handler will be put into the output directly.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekodowanie i zamiana nazw pracują podobnie z wyjątkiem :exc:`UnicodeDecodeError` lub :exc:`UnicodeTranslateError` zostaną przekazane do obsługi i że zamiennik dla obsługi błędu zostanie włożona do wyjściowego katalogu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the error handler previously registered under the name *name*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć obsługę błędu poprzednio zarejestrowanym pod nazwą *name*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raises a :exc:`LookupError` in case the handler cannot be found.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłasza wyjątek :exc:`LookupError` w przypadku gdy obsługa nie może być znaleziona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements the ``strict`` error handling: each encoding or decoding error raises a :exc:`UnicodeError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia ``strict`` - z ang - ścisłą obsługę błędu: każde błędy kodowania lub dekodowania zgłaszają :exc:`UnicodeError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements the ``replace`` error handling: malformed data is replaced with a suitable replacement character such as ``'?'`` in bytestrings and ``'\ufffd'`` in Unicode strings.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia obsługę błędu ``replace``: nieuformowane dane są zamieniane na odpowiedni znak zamienny taki jak ``'?'`` w ciągach bajtów i ``'ufffd'`` w ciągu Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements the ``ignore`` error handling: malformed data is ignored and encoding or decoding is continued without further notice.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia obsługę błędu ``ignoruj``: nieuformowane dane są ignorowane, a kodowanie lub dekodowanie jest kontynuowane bez dalszego powiadamiania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements the ``xmlcharrefreplace`` error handling (for encoding only): the unencodable character is replaced by an appropriate XML character reference.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia ``xmlcharrefreplace`` obsługę błędu (jedynie dla kodowania): niekodowalny znak jest zamieniany przez odpowiednie odniesienie znakowe XML.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements the ``backslashreplace`` error handling (for encoding only): the unencodable character is replaced by a backslashed escape sequence.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia obsługę błędu ``backslashreplace`` (jedynie dla kodowania): niekodowalny znak jest zamieniany przez skośnikowaną sekwencję ucieczkową.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To simplify working with encoded files or stream, the module also defines these utility functions:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby uprościć pracę z zakodowanymi plikami lub strumieniami, moduł także definiuje te zadania użytkowe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open an encoded file using the given *mode* and return a wrapped version providing transparent encoding/decoding.  The default file mode is ``'r'`` meaning to open the file in read mode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Otwórz zakodowany plik używając danego *trybu* i zwróć zapakowaną wersję dostarczającą przezroczyste kodowanie/dekodowanie. Domyślny tryb pliku jest ``'r'`` w znaczeniu otwarcia pliku w trybie odczytu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The wrapped version's methods will accept and return strings only.  Bytes arguments will be rejected.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapakowane sposoby postępowania wersji będą akceptować i zwracać tylko ciągi znaków. Parametry bajtowe zostaną odrzucone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Files are always opened in binary mode, even if no binary mode was specified.  This is done to avoid data loss due to encodings using 8-bit values.  This means that no automatic conversion of ``b'\n'`` is done on reading and writing.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pliki są zawsze otwierane w trybie binarnym, nawet jeśli żadne tryby binarne nie były określone. To jest robione po to aby uniknąć utraty danych z powodu kodowania 8-bitowych wartości. To oznacza że żadne automatyczne konwertowanie ``b'
'`` nie jest wykonywane przy wczytywaniu i zapisywaniu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*encoding* specifies the encoding which is to be used for the file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*kodowanie* określa kodowanie które będzie użyte dla pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*errors* may be given to define the error handling. It defaults to ``'strict'`` which causes a :exc:`ValueError` to be raised in case an encoding error occurs.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*błędy* mogą być dane do zdefiniowania obsługi błędu. To domyślnie równe jest ``'strict'`` co powoduje że :exc:`ValueError` jest zgłaszany w przypadku błędu kodowania. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*buffering* has the same meaning as for the built-in :func:`open` function.  It defaults to line buffered.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*buforowanie* ma te same znaczenie jak dla wbudowane zadanie :func:`open`. Domyślnie równe jest buforowaniu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a wrapped version of file which provides transparent encoding translation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć zapakowaną wersję pliku, który dostarcza przezroczystego tłumaczenia kodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bytes written to the wrapped file are interpreted according to the given *data_encoding* and then written to the original file as bytes using the *file_encoding*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bajty zapisane do zapakowanego pliku są interpretowane zgodnie z danym kodowaniem *data_encoding* i wtedy zapisane do oryginalnego pliku jako bajty używając *file_encoding*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *file_encoding* is not given, it defaults to *data_encoding*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *file_encoding* nie jest dane, domyślnie równe jest *data_encoding*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*errors* may be given to define the error handling. It defaults to ``'strict'``, which causes :exc:`ValueError` to be raised in case an encoding error occurs.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*errors* błędy mogą być dane do zdefiniowania obsługi błędów. Domyślnie równe jest ``'strict'``, co powoduje, że :exc:`ValueError` będzie zgłaszany w przypadku gdy błąd kodowania nastąpi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uses an incremental encoder to iteratively encode the input provided by *iterator*. This function is a :term:`generator`.  *errors* (as well as any other keyword argument) is passed through to the incremental encoder.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używa zwiększającego kodera do iteracyjnego zakodowania wejścia dostarczonego przez *iterator*. To zadanie jest :term:`generatorem`. *błędy* - z ang. - *errors* (zarówno jak inne parametry słów kluczowych) jest przekazywane dalej do przyrostowego kodera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uses an incremental decoder to iteratively decode the input provided by *iterator*. This function is a :term:`generator`.  *errors* (as well as any other keyword argument) is passed through to the incremental decoder.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Używa przyrostowego dekodera do iteracyjnego dekodowania wejścia dostarczonego przez *iterator*. To zadanie jest :term:`generatorem`. *błędy* - z ang. - *errors* (zarówno jak inne parametry słów kluczowych) są przekazywane dalej do przyrostowego dekodera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module also provides the following constants which are useful for reading and writing to platform dependent files:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł także dostarcza następujące stałe które są użyteczne dla wczytywania i zapisywania plików zależnych od maszyny/środowiska:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These constants define various encodings of the Unicode byte order mark (BOM) used in UTF-16 and UTF-32 data streams to indicate the byte order used in the stream or file and in UTF-8 as a Unicode signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others represent the BOM in UTF-8 and UTF-32 encodings.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te stałe określają różne kodowania Unikodowych znaków porządku bajtów (BOM - z ang. - byte order mark) używanych w ciągach danych UTF-16 i UTF-32 do wskazywania porządku bajtów używanych w strumieniu lub pliku i w UTF-8 jako sygnatury Unicode. :const:`BOM_UTF16` jest albo :const:`BOM_UTF16_BE` lub :const:`BOM_UTF16_LE` w zależności od natywnego porządku bajtów maszyny/środowiska, :const:`BOM` jest synonimem dla :const:`BOM_UTF16`, :const:`BOM_LE` dla :const:`BOM_UTF16_LE` i :const`BOM_BE` dla :const:`BOM_UTF16_BE`. Inne reprezentują BOM w kodowaniach UTF-8 i UTF-32.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codec Base Classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienia podstawowe kodeków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`codecs` module defines a set of base classes which define the interface and can also be used to easily write your own codecs for use in Python.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`codecs` definiuje zestaw uogólnień podstawowych które definiują sprzęg i może także być używany do łatwego pisania twoich własnych kodeków dla użycia w języku pytonowskim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each codec has to define four interfaces to make it usable as codec in Python: stateless encoder, stateless decoder, stream reader and stream writer. The stream reader and writers typically reuse the stateless encoder/decoder to implement the file protocols.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Każdy kodek musi definiować cztery sprzęgi aby spowodować że będzie użyteczny jako kodek w języku pytonowskim: bezstanowy koder, bezstanowy dekoder, strumieniowy czytnik i strumieniowy zapis. Strumieniowe czytanie i pisanie typowo ponownie używają bezstanowy koder/dekoder aby wypełnić protokoły plikowe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Codec` class defines the interface for stateless encoders/decoders.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Codec` definiuje sprzęg dla bezstanowego kodera/dekodera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To simplify and standardize error handling, the :meth:`encode` and :meth:`decode` methods may implement different error handling schemes by providing the *errors* string argument.  The following string values are defined and implemented by all standard Python codecs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby uprościć i standaryzować obsługę błędu, sposoby postępowania :meth:`encode` i :meth:`decode` mogą wypełniać inne błędne schematy obsługi przez dostarczenie *błędów* - z ang. - *error* parametrów ciągów znaków. Następujące ciągi znaków są definiowane i wypełniane przez wszystkie standardowe kodeki języka pytonowskiego: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wartość</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Meaning</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Znaczenie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'strict'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'ściśle'`` - z ang. - ``'strict'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raise :exc:`UnicodeError` (or a subclass); this is the default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłoś :exc:`UnicodeError` (lub podrzędne uogólnienie); to jest domyślnie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'ignore'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'ignoruj'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ignore the character and continue with the next.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ignoruje znak i kontynuuj z następnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'replace'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'zamień'`` - z ang. - ``'replace'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace with a suitable replacement character; Python will use the official U+FFFD REPLACEMENT CHARACTER for the built-in Unicode codecs on decoding and '?' on encoding.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień na odpowiedni znak zastępczy; Język pytonowski będzie używał oficjalnego ZNAKU ZASTĘPCZEGO U+FFFD dla wbudowanych kodeków Unicode na dekodowanie i '?' na kodowanie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'xmlcharrefreplace'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'xmlcharrefreplace'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace with the appropriate XML character reference (only for encoding).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień na odpowiedni znak XML - znak odniesienia (tylko dla kodowania).  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'backslashreplace'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'backslashreplace'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace with backslashed escape sequences (only for encoding).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień na sekwencję skośnikowaną ucieczkową (tylko dla kodowania).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'surrogateescape'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'surrogateescape'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace byte with surrogate U+DCxx, as defined in :pep:`383`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień na surogat U+DCxx, jak opisano w :pep:`383`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the following error handlers are specific to a single codec:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W dodatku następujące obsługi błędów są szczególne dla pojedynczego kodeka:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codec</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'surrogatepass'``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'surrogatepass'``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf-8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf-8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Allow encoding and decoding of surrogate codes in UTF-8.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Pozwala na kodowanie i dekodowanie kodów surogatów w UTF-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The set of allowed values can be extended via :meth:`register_error`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zestaw dozwolonych wartości może być rozszerzony przez :meth:`register_error`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codec Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty kodeków</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Codec` class defines these methods which also define the function interfaces of the stateless encoder and decoder:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Codec` definiuje te metody które mogą także definiować sprzęgi zadań bezstanowego kodera i dekodera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encodes the object *input* and returns a tuple (output object, length consumed). Encoding converts a string object to a bytes object using a particular character set encoding (e.g., ``cp1252`` or ``iso-8859-1``).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Koduje przedmiot *input* i zwraca krotkę (wyjściowy przedmiot, długość skonsumowana). Kodowanie konwertuje przedmiot ciągu do przedmiotu bajtów używając szczególnego zestawu znaków kodowania (np., ``cp1252`` lub ``iso-8859-1``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*errors* defines the error handling to apply. It defaults to ``'strict'`` handling.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*errors* definiuje obsługę błędów do zastosowania. Domyślnie jest to ``'ścisła'`` ( - z ang. ``'strict'`` ) obsługa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method may not store state in the :class:`Codec` instance. Use :class:`StreamCodec` for codecs which have to keep state in order to make encoding/decoding efficient.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania może nie zachowywać stanu w przykładzie :class:`Codec`. Użyj :class:`StreamCodec` dla kodeków które muszą utrzymywać stan w celu uczynienia kodowania/dekodowania efektywnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encoder must be able to handle zero length input and return an empty object of the output object type in this situation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Koder musi być w stanie obsłużyć wejście o długości zerowej i zwrócić pusty przedmiot wyjściowego typu przedmiotu w tej sytuacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decodes the object *input* and returns a tuple (output object, length consumed).  Decoding converts a bytes object encoded using a particular character set encoding to a string object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekoduje przedmiot wejściowy *input* i zwróć krotkę (wyjściowy przedmiot, długość skonsumowana). Dekodowanie zamienia przedmiot bajtów zakodowany używając szczególnego zestawu znaków kodowania do przedmiotu ciągu znaków.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*input* must be a bytes object or one which provides the read-only character buffer interface -- for example, buffer objects and memory mapped files.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*wejście* musi być przedmiotem bajtów lub takiego który dostarcza sprzęg przestrzeni wymiany znaków tylko do odczytu -- dla przykładu, przedmiot przestrzeni wymiany i plików mapowanych w pamięci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The decoder must be able to handle zero length input and return an empty object of the output object type in this situation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekoder musi być zdolny aby obsłużyć zerowej długości i zwrócić pusty przedmiot wyjściowego rodzaju przedmiotu w tej sytuacji.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes provide the basic interface for incremental encoding and decoding. Encoding/decoding the input isn't done with one call to the stateless encoder/decoder function, but with multiple calls to the :meth:`encode`/:meth:`decode` method of the incremental encoder/decoder. The incremental encoder/decoder keeps track of the encoding/decoding process during method calls.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>uogólnienia :class:`IncrementalEncoder` i :class:`IncrementalDecoder` dostarczają podstawowy sprzęg do zwiększającego się kodowania i dekodowania. Kodowanie/dekodowanie wejścia nie jest dokonywana za pomocą jednego wywołania zadania bezstanowego kodera/dekodera, ale za pomocą wielokrotnych odwołań do sposobu postępowania :meth:`encode`/:meth:`decode` zwiększającego się kodera/dekodera. Zwiększający koder/dekoder pilnuje procesu kodowania/dekodowania w czasie wywołania sposobów postępowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The joined output of calls to the :meth:`encode`/:meth:`decode` method is the same as if all the single inputs were joined into one, and this input was encoded/decoded with the stateless encoder/decoder.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Połączone wyjście wywołania sposobów postępowania :meth:`encode`/:meth:`decode` jest to samo co jeśli wszystkie pojedyncze wejścia byłyby połączone w jedno, i to wejście było zakodowane/zdekodowane bezstanowym koderem/dekoderem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IncrementalEncoder Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty IncrementalEncodera</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`IncrementalEncoder` class is used for encoding an input in multiple steps. It defines the following methods which every incremental encoder must define in order to be compatible with the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`IncrementalEncoder` jest używane dla kodowania wejścia w wielu krokach. Określa ona następujące sposoby postępowania które każdy zwiększający się koder musi definiować w celu aby być kompatybilnym z rejestrem kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constructor for an :class:`IncrementalEncoder` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor dla przykładu uogólnienia :class:`IncrementalEncoder`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All incremental encoders must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie zwiększające kodery muszą dostarczać ten sprzęg konstruktora. Wolno im dodawać dodatkowe parametry słów kluczowych, ale tylko te zdefiniowane tutaj są używane przez rejestr kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`IncrementalEncoder` may implement different error handling schemes by providing the *errors* keyword argument. These parameters are predefined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`IncrementalEncoder` może wypełniać różne schematy obsługi błędów przez dostarczanie parametru słowa kluczowego *errors*. Te parametry są zdefiniowane na stałe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'strict'`` - z ang. - ``'ścisłe'`` Zgłoś :exc:`ValueError` (lub podrzędne uogólnienia); to jest domyślne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'ignore'`` Ignore the character and continue with the next.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'ignore'`` Ignoruj znak i kontynuuj z następnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'replace'`` Replace with a suitable replacement character</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'zamień'`` Zamień na odpowiedni znak zamiany</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'xmlcharrefreplace'`` Replace with the appropriate XML character reference</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'xmlcharrefreplace'`` Zamień na odpowiedni XML znak odniesienia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'backslashreplace'`` Replace with backslashed escape sequences.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'backslashreplace'`` Zamień na sekwencję ucieczkową skośnikowaną.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *errors* argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the :class:`IncrementalEncoder` object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *errors* zostanie przypisany do właściwości o tej samej nazwie. Przypisywanie do tej właściwości umożliwia zamianę pomiędzy różnymi strategiami obsługi w czasie życia przedmiotu :class:`IncrementalEncoder`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The set of allowed values for the *errors* argument can be extended with :func:`register_error`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zbiór dozwolonych wartości parametru *errors* może być rozszerzany za pomocą zadania :func:`register_error`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encodes *object* (taking the current state of the encoder into account) and returns the resulting encoded object. If this is the last call to :meth:`encode` *final* must be true (the default is false).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*Przedmiot* Koderów (wliczający obecny stan kodera) i zwraca wynikający przedmiot kodowania. Jeśli to jest ostatnie wywołanie sposobu postępowania :meth:`encode` *final* musi być prawdziwe (domyślnie jest fałsz).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reset the encoder to the initial state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Resetuj koder do stanu początkowego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the current state of the encoder which must be an integer. The implementation should make sure that ``0`` is the most common state. (States that are more complicated than integers can be converted into an integer by marshaling/pickling the state and encoding the bytes of the resulting string into an integer).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć obecny stan kodera który musi być liczbą całkowitą. Wypełnienie powinno upewnić się że ``0`` jest najczęstszym stanem. (Stany, które są bardziej skomplikowane niż liczby całkowite mogą być zamienione na liczbę całkowitą, przez maszerowanie/peklowanie stanu i kodowanie bajtów wynikłych ciągów znaków do liczby całkowitej).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the state of the encoder to *state*. *state* must be an encoder state returned by :meth:`getstate`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw stan kodera na *stan*. *stan* musi być stanem kodera zwracanym przez :meth:`getstate`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IncrementalDecoder Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty IncrementalDecoder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`IncrementalDecoder` class is used for decoding an input in multiple steps. It defines the following methods which every incremental decoder must define in order to be compatible with the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`IncrementalDecoder` jest używany dla dekodowania wejścia w kilku krokach. Określa on następujące sposoby postępowania, które każdy przyrostowy dekoder musi określać w celu pozostania kompatybilnym z rejestrem kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constructor for an :class:`IncrementalDecoder` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor dla przykładu uogólnienia przyrostowego dekodera :class:`IncrementalDecoder`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All incremental decoders must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie przyrostowe dekodery muszą dostarczać ten sprzęg konstruktora. Wolno im dodawać dodatkowe parametry kluczowe, ale tylko te zdefiniowane tutaj są używane przez rejestr kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`IncrementalDecoder` may implement different error handling schemes by providing the *errors* keyword argument. These parameters are predefined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`IncrementalDecoder` może wypełniać różne schematy obsługi błędów przez dostarczenie parametru słowa kluczowego *errors*. Te parametry są uprzednio zdefiniowane:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``'replace'`` Replace with a suitable replacement character.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``'replace'`` Zamień na odpowiedni znak zastępczy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *errors* argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the :class:`IncrementalDecoder` object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *errors* zostanie przypisany do właściwości o tej samej nazwie. Przypisanie do tej właściwości umożliwia zamianę pomiędzy różnymi strategiami obsługi błędów w czasie bytności przedmiotu :class:`IncrementalDecoder`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decodes *object* (taking the current state of the decoder into account) and returns the resulting decoded object. If this is the last call to :meth:`decode` *final* must be true (the default is false). If *final* is true the decoder must decode the input completely and must flush all buffers. If this isn't possible (e.g. because of incomplete byte sequences at the end of the input) it must initiate error handling just like in the stateless case (which might raise an exception).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekoduje *przedmiot* (biorąc aktualny stan dekodera pod uwagę) i zwraca wynikły przedmiot dekodera. Jeśli to jest ostatnie wywołanie :meth:`decode` *final* musi być prawdziwe (domyślnie jest fałszywe). Jeśli *final* jest prawdziwe dekoder musi dekodować wejście kompletnie i musi opróżnić wszystkie przestrzenie wymiany. Jeśli to jest niemożliwe (np. z powodu niekompletnych sekwencji bajtów na koniec wejścia) to musi inicjować obsługę błędów tak jak w przypadku bezstanowym (co może zgłaszać wyjątek).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reset the decoder to the initial state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Resetuj dekoder do stanu początkowego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the current state of the decoder. This must be a tuple with two items, the first must be the buffer containing the still undecoded input. The second must be an integer and can be additional state info. (The implementation should make sure that ``0`` is the most common additional state info.) If this additional state info is ``0`` it must be possible to set the decoder to the state which has no input buffered and ``0`` as the additional state info, so that feeding the previously buffered input to the decoder returns it to the previous state without producing any output. (Additional state info that is more complicated than integers can be converted into an integer by marshaling/pickling the info and encoding the bytes of the resulting string into an integer.)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć stan obecny dekodera. To musi być krotka z dwoma elementami, pierwszy musi być przestrzenią wymiany zawierającą wciąż niezdekodowane wejście. Drugi musi być liczbą całkowitą i może być informacją dodatkową o stanie. (Wypełnienie powinno upewniać się, że ``0`` jest najczęściej spotykaną dodatkową informacją o stanie.) Jeśli ten dodatkowy stan jest ``0`` musi być możliwe ustawienie dekodera na stan który nie ma wejścia w przestrzeni wymiany i ``0`` jako dodatkową wiadomość o stanie, tak że przekazanie poprzednio buforowanego  wejścia dla dekodera zwraca go do poprzedniego stanu bez wytwarzania żadnego wyjścia. (Dodatkowe informacje o stanie które są bardziej skomplikowane niż liczby całkowite mogą być zamienione na liczbę całkowitą przez przemaszerowanie/peklowanie informacji i kodujących bajtów wynikłego ciągu znaków do liczby całkowitej.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the state of the encoder to *state*. *state* must be a decoder state returned by :meth:`getstate`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustaw stan kodera na *stan* - z ang. - *state*. *stan* musi być stanem dekodera zwróconym przez :meth:`getstate`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamWriter` and :class:`StreamReader` classes provide generic working interfaces which can be used to implement new encoding submodules very easily. See :mod:`encodings.utf_8` for an example of how this is done.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienia :class:`StreamWriter` i :class:`StreamReader` dostarczają zastępczych sprzęgów pracujących, które mogą być użyte do wypełnienia nowych podmodułów kodowania bardzo łatwo. Zobacz moduł :mod:`encodings.uft_8` dla przykładu jak to się robi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StreamWriter Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty StreamWriter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines the following methods which every stream writer must define in order to be compatible with the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`StreamWriter jest podrzędnym uogólnieniem uogólnienia :class:`Codec` i definiuje następujące sposoby postępowania które każdy piszący do strumienia musi definiować w celu pozostania zgodnym z rejestrem kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constructor for a :class:`StreamWriter` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor dla przykładu uogólnienia :class:`StreamWriter`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All stream writers must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie przedmioty piszące do strumienia muszą dostarczać ten sprzęg konstruktora. Mogą dodawać dodatkowe parametry słów kluczowych, ale tylko te zdefiniowane tutaj są użyte przez rejestr kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*stream* must be a file-like object open for writing binary data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*stream* musi być przedmiotem podobnym-do-pliku otwartym na zapis danych binarnych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamWriter` may implement different error handling schemes by providing the *errors* keyword argument. These parameters are predefined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`StreamWriter` może wypełniać różne schematy obsługi błędów przez dostarczanie parametru słowa kluczowego *errors*. Te parametry są zdefiniowane uprzednio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *errors* argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the :class:`StreamWriter` object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *errors* zostanie przypisany do właściwości o tej samej nazwie. Przypisanie do tej właściwości powoduje że możliwa jest zamiana pomiędzy rożnymi strategiami obsługi błędów w czasie bytowania przedmiotu :class:`StreamWriter`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writes the object's contents encoded to the stream.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisuje zawartość przedmiotu zakodowanego do strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writes the concatenated list of strings to the stream (possibly by reusing the :meth:`write` method).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapisuje połączona listę ciągów znaków do strumienia (możliwie przez ponowne użycie sposobu postępowania :meth:`write`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flushes and resets the codec buffers used for keeping state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Opróżnia i resetuje przestrzenie wymiany kodeka używane dla utrzymania stanu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling this method should ensure that the data on the output is put into a clean state that allows appending of new fresh data without having to rescan the whole stream to recover state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wywołanie tego sposobu postępowania powinno pozwalać na to by dane na wyjściu były włożone do czystego stanu który pozwala na dopisywanie nowych świeżych danych bez konieczności ponownego skanowania całego strumienia dla przywrócenia stanu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the above methods, the :class:`StreamWriter` must also inherit all other methods and attributes from the underlying stream.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W dodatku do powyższych sposobów postępowania, uogólnienie :class:`StreamWriter` musi także dziedziczyć wszystkie inne sposoby postępowania i właściwości z leżącego u podstaw strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StreamReader Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty StreamReader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamReader` class is a subclass of :class:`Codec` and defines the following methods which every stream reader must define in order to be compatible with the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`StreamReader` jest podrzędnym uogólnieniem uogólnienia :class:`Codec` i definiuje następujące sposoby postępowania które każdy czytający ze strumienia musi określać w celu aby zachować zgodność z rejestrem kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constructor for a :class:`StreamReader` instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Konstruktor dla przykładu uogólnienia :class:`StreamReader`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All stream readers must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie czytniki strumienia muszą dostarczać ten sprzęg konstruktora. Mogą dodawać dodatkowe parametry słów kluczowych, ale tylko te zdefiniowane tutaj są używane przez rejestr kodeków języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*stream* must be a file-like object open for reading (binary) data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*stream* musi być pliko-podobnym przedmiotem otwartym dla wczytywania (binarnych) danych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamReader` may implement different error handling schemes by providing the *errors* keyword argument. These parameters are defined:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`StreamReader` może wypełniać różne schematy obsługi błędów przez dostarczenie parametru słowa kluczowego *errors*. Te parametry są określone:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *errors* argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the :class:`StreamReader` object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *errors* zostanie przypisany do właściwości o tej samej nazwie. Przypisanie do właściwości umożliwia zamianę pomiędzy różnymi strategiami obsługi błędów w czasie życia przedmiotu :class:`StreamReader`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decodes data from the stream and returns the resulting object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dekoduje dane ze strumienia i zwraca wynikły przedmiot.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*chars* indicates the number of characters to read from the stream. :func:`read` will never return more than *chars* characters, but it might return less, if there are not enough characters available.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*chars* wskazuje liczbę znaków do wczytania ze strumienia. :func:`read` nigdy nie zwróci więcej znaków niż *chars*, ale może zwrócić mniej, jeśli nie ma dość znaków dostępnych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*size* indicates the approximate maximum number of bytes to read from the stream for decoding purposes. The decoder can modify this setting as appropriate. The default value -1 indicates to read and decode as much as possible.  *size* is intended to prevent having to decode huge files in one step.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*size* wskazuje przybliżoną maksymalną ilość bajtów wczytywanych ze strumienia do celów dekodowania. Dekoder może zmienić to ustawienie jak uważa za stosowne. Domyślna wartość -1 wskazuje wczytywanie i dekodowanie tak dużo jak to tylko możliwe. *size* jest pomyślany aby zapobiec konieczności dekodowania dużych plików w jednym kroku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*firstline* indicates that it would be sufficient to only return the first line, if there are decoding errors on later lines.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*firstline* wskazuje, że to byłoby wystarczające zwrócić tylko pierwszą linię, jeśli wystąpią błędy dekodowania w późniejszych liniach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method should use a greedy read strategy meaning that it should read as much data as is allowed within the definition of the encoding and the given size, e.g.  if optional encoding endings or state markers are available on the stream, these should be read too.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania powinien użyć zachłannej strategii wczytywania w znaczeniu że powinien wczytać tak dużo danych jak to jest dozwolone w definicji kodowania i danym rozmiarze, np. jeśli opcjonalne zakończenia kodowań lub znaczniki stanu są dostępne w strumieniu, wtedy te powinny być także wczytane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read one line from the input stream and return the decoded data.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj jedną linię ze strumienia wejściowego i zwróć zdekodowane dane.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*size*, if given, is passed as size argument to the stream's :meth:`readline` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*size*, jeśli dany jest przykazywany jako parametr rozmiaru do sposobu postępowania :meth:`readline` dla strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *keepends* is false line-endings will be stripped from the lines returned.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *keepends* jest fałszywe zakończenia linii będą zdjęte ze zwróconych linii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read all lines available on the input stream and return them as a list of lines.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wczytaj wszystkie linie dostępne w strumieniu wejściowym i zwróć je jako listę linii.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Line-endings are implemented using the codec's decoder method and are included in the list entries if *keepends* is true.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakończenia-linii są wypełnione używając sposobu postępowania dekodera należącego do kodeka i są zawarte w liście wpisów jeśli *keepends* jest prawdziwe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*sizehint*, if given, is passed as the *size* argument to the stream's :meth:`read` method.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*sizehint*, jeśli dany jest przekazywany jako parametr *size* dla sposobu postępowania  :meth:`read` należącego do strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resets the codec buffers used for keeping state.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Resetuje przestrzenie wymiany kodeków używanych dla utrzymywania stanu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that no stream repositioning should take place.  This method is primarily intended to be able to recover from decoding errors.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zauważ że żadne powtórne pozycjonowanie strumienia nie powinno mieć miejsca. Ten sposób postępowania jest przede wszystkim przeznaczony do umożliwienia podniesienia się z błędów dekodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the above methods, the :class:`StreamReader` must also inherit all other methods and attributes from the underlying stream.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W dodatku do powyższych sposobów postępowania, uogólnienie :class:`StreamReader` musi także dziedziczyć wszystkie inne sposoby postępowania i właściwości z leżącego u podstaw strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next two base classes are included for convenience. They are not needed by the codec registry, but may provide useful in practice.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Następne dwa uogólnienia podstawowe są załączone dla udogodnienia. Nie są konieczne dla rejestru kodeków, ale mogą okazać się użyteczne w praktyce.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StreamReaderWriter Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty StreamReaderWriter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamReaderWriter` allows wrapping streams which work in both read and write modes.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`StreamReaderWriter` pozwala opakowywać strumienie które pracują w trybach zarówno odczytu jak i zapisu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The design is such that one can use the factory functions returned by the :func:`lookup` function to construct the instance.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Plan pozwala na to by użyć zadania fabrykującego zwracanego przez zadanie :func:`lookup` aby skonstruować przykład.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like object. *Reader* and *Writer* must be factory functions or classes providing the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error handling is done in the same way as defined for the stream readers and writers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzy przykład uogólnienia :class:`StreamReaderWriter`. *strumień* - z ang. - *stream* musi być pliko-podobnym przedmiotem. *Czytnik* i *Pisak* - z ang. - *Reader* i *Writer* muszą być zadaniami fabrykującymi lub uogólnieniami dostarczającymi sprzęgi :class:`StreamReader` i :class:`StreamWriter` odpowiednio. Obsługa błędów jest wykonywana w ten sam sposób jak określono dla czytnika i piszącego z/do strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`StreamReaderWriter` instances define the combined interfaces of :class:`StreamReader` and :class:`StreamWriter` classes. They inherit all other methods and attributes from the underlying stream.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przykłady :class:`StreamReaderWriter` określają połączone sprzęgi uogólnień :class:`StreamReader` i :class:`StreamWriter`. One dziedziczą wszystkie pozostałe sposoby postępowania i właściwości z leżącego u podstaw strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StreamRecoder Objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty StreamRecoder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`StreamRecoder` provide a frontend - backend view of encoding data which is sometimes useful when dealing with different encoding environments.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`StreamRecorder` dostarcza widok przedni i tylni zakodowania danych który jest czasami użyteczny gdy mamy do czynienia z różnymi środowiskami kodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creates a :class:`StreamRecoder` instance which implements a two-way conversion: *encode* and *decode* work on the frontend (the input to :meth:`read` and output of :meth:`write`) while *Reader* and *Writer* work on the backend (reading and writing to the stream).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tworzy przykład :class:`StreamRecoder` który wypełnia dwu-kierunkową konwersję: *encode* i *decode* pracują na przednim końcu (wejściu do :meth:`read` i wyjściu ze sposobu postępowania :meth:`write`) podczas gdy *Reader* i *Writer* pracują z tyłu (wczytując i zapisując z/do strumienia).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use these objects to do transparent direct recodings from e.g. Latin-1 to UTF-8 and back.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Możesz używać tych przedmiotów aby wykonywać przezroczyste bezpośrednie powtórne kodowania z np. Latin-1 do UTF-8 i z powrotem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*stream* must be a file-like object.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*stream* musi być pliko-podobnym przedmiotem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*encode*, *decode* must adhere to the :class:`Codec` interface. *Reader*, *Writer* must be factory functions or classes providing objects of the :class:`StreamReader` and :class:`StreamWriter` interface respectively.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*encode*, *decode* musi stosować się do sprzęgu :class:`Codec`. *Reader* i *Writer* muszą być zdaniami fabrykującymi lub uogólnieniami dostarczającymi przedmiotów sprzęgów uogólnienia :class:`StreamReader` i :class:`StreamWriter` odpowiednio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*encode* and *decode* are needed for the frontend translation, *Reader* and *Writer* for the backend translation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>*encode* i *decode* - z ang. - *koduj* i *dekoduj* są potrzebne dla tłumaczenia przedniego, *Reader* i *Writer* dla tłumaczenia tylniego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error handling is done in the same way as defined for the stream readers and writers.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obsługa błędów jest wykonywana w ten sam sposób jak określono dla czytników i piszących do i ze strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`StreamRecoder` instances define the combined interfaces of :class:`StreamReader` and :class:`StreamWriter` classes. They inherit all other methods and attributes from the underlying stream.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przykłady :class:`StreamRecoder` definiują połączone sprzęgi uogólnień :class:`StreamReader` i :class:`StreamWriter`. One dziedziczą wszystkie inne sposoby postępowania i właściwości z leżącego u podstaw strumienia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encodings and Unicode</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodowania i kod Unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings are stored internally as sequences of codepoints (to be precise as :ctype:`Py_UNICODE` arrays). Depending on the way Python is compiled (either via :option:`--without-wide-unicode` or :option:`--with-wide-unicode`, with the former being the default) :ctype:`Py_UNICODE` is either a 16-bit or 32-bit data type. Once a string object is used outside of CPU and memory, CPU endianness and how these arrays are stored as bytes become an issue.  Transforming a string object into a sequence of bytes is called encoding and recreating the string object from the sequence of bytes is known as decoding.  There are many different methods for how this transformation can be done (these methods are also called encodings). The simplest method is to map the codepoints 0-255 to the bytes ``0x0``-``0xff``. This means that a string object that contains codepoints above ``U+00FF`` can't be encoded with this method (which is called ``'latin-1'`` or ``'iso-8859-1'``). :func:`str.encode` will raise a :exc:`UnicodeEncodeError` that looks like this: ``UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ciągi są zachowywane wewnętrznie jako sekwencje punktów kodowych (dla ścisłości jako tablice :ctype:`Py_UNICODE`). W zależności od sposobu w jaki język pytonowski jest kompilowany (albo przez :option:`--without-wide-unicode` lub :option:`--with-wide-unicode`, z tym pierwszym będącym domyślnym) :ctype:`Py_UNICODE` jest albo 16-bitowym albo 32-bitowym typem danych. Gdy ciąg znaków jest używany poza CPU i pamiecią, endianowość CPU i to jak te tabele są zachowywane jako bajty zaczyna być problemem. Transformowanie przedmiotu ciągu znaków do sekwencji bajtów jest zwane kodowaniem a odtwarzanie przedmiotu ciągu znaków z sekwencji bajtów jest znane jako dekodowanie. Istnieje wiele różnych metod na to jak ta transformacja może być dokonywana (te sposoby postępowania są także zwane kodowaniami) Najprostszym sposobem postępowania jest mapowanie punktów kodu 0-255 na bajty ``0x0`` - ``0xff``. To oznacza, że przedmiot ciągu znaków który zawiera punkty kodowe powyżej ``U+00FF`` nie może być zakodowany tą metodą (która znana jest pod nazwą ``'latin-1'`` lub ``'iso-8859-1'``). :func:`str.encode` będzie zgłaszało wyjątek :exc:`UnicodeEncodeError` który wygląda następująco: ``UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's another group of encodings (the so called charmap encodings) that choose a different subset of all Unicode code points and how these codepoints are mapped to the bytes ``0x0``-``0xff``. To see how this is done simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is used primarily on Windows). There's a string constant with 256 characters that shows you which character is mapped to which byte value.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje inna grupa kodowań (tak zwanych kodowań mapy znaków) które wybrały inny podzbiór wszystkich punktów kodowych Unicode i to jak te punkty kodowe są mapowane na bajty ``0x0`` - ``0xff``. Aby zobaczyć jak to się robi po prostu otwórz np. :file:`encodings/cp1252.py` (które jest kodowaniem, które jest używane głównie na Windows). Istnieje stała ciągu znaków z 256 znakami które pokazują ci, który znak jest przyporządkowany do której wartości bajtu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All of these encodings can only encode 256 of the 65536 (or 1114111) codepoints defined in Unicode. A simple and straightforward way that can store each Unicode code point, is to store each codepoint as two consecutive bytes. There are two possibilities: Store the bytes in big endian or in little endian order. These two encodings are called UTF-16-BE and UTF-16-LE respectively. Their disadvantage is that if e.g. you use UTF-16-BE on a little endian machine you will always have to swap bytes on encoding and decoding. UTF-16 avoids this problem: Bytes will always be in natural endianness. When these bytes are read by a CPU with a different endianness, then bytes have to be swapped though. To be able to detect the endianness of a UTF-16 byte sequence, there's the so called BOM (the "Byte Order Mark"). This is the Unicode character ``U+FEFF``. This character will be prepended to every UTF-16 byte sequence. The byte swapped version of this character (``0xFFFE``) is an illegal character that may not appear in a Unicode text. So when the first character in an UTF-16 byte sequence appears to be a ``U+FFFE`` the bytes have to be swapped on decoding. Unfortunately upto Unicode 4.0 the character ``U+FEFF`` had a second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: A character that has no width and doesn't allow a word to be split. It can e.g. be used to give hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD JOINER``) assuming this role). Nevertheless Unicode software still must be able to handle ``U+FEFF`` in both roles: As a BOM it's a device to determine the storage layout of the encoded bytes, and vanishes once the byte sequence has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a normal character that will be decoded like any other.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wszystkie te kodowania mogą zakodować tylko 256 z 65536 (lub 1114111) punktów kodowych zdefiniowanych w Unikodzie. Prosta i bezpośrednia droga, która może zachować każdy punkt kodowy Unicode, polega na tym aby zachować każdy punkt kodowy jak dwa następujące po sobie bajty. Istnieją dwie możliwości: Zachować bajty w porządku dużego endiana lub małego endiana. Te dwa kodowania są zwane UTF-16-BE i UTF-16-LE odpowiednio. Ich wadą jest to że jeżeli np. użyjesz UTF-16-BE na maszynie z małym endianem będziesz zawsze musiał zamieniać bajty przy kodowaniu i dekodowaniu. UTF-16 omija ten problem: Bajty zawsze będą w naturalnej endianności. Gdy te bajty są wczytane przez CPU z inną endiannością, wtedy bajty muszą jednak być zamienione miejscami. Aby móc wykryć endianność sekwencji bajtów UTF-16, istnieje tak zwany BOM("Byte Order Mark" - z ang. - znak porządku bajtów). To jest znak Unicode ``U+FEFF``. Ten znak doczepiony z przodu do każdej sekwencji UTF-16. Wersja z zamienionymi bajtami tego znaku (``0xFFFE``) jest nielegalnym znakiem który nie może pojawić się w tekście Unicode. Więc gdy pierwszy znak w sekwencji UTF-16 okaże się być ``U+FFFE`` bajty muszą być zamienione podczas dekodowania. Niestety aż do Unicode 4.0 znak ``U+FEFF`` miał drugi sens istnienia jako ``ZEROWEJ DŁUGOŚCI NIEŁAMANA SPACJA``: Znak który nie ma długości i nie pozwala słowom na rozdzielenie. Może np. być używany aby dać podpowiedzi dla algorytmu ligaturowego. Wraz z Unicode-m w wersji 4.0 użycie ``U+FEFF`` jako ``ZEROWEJ DŁUGOŚCI NIEŁAMANA SPACJA`` stało się przestarzałe (z ``U+2060`` (``ŁĄCZNIKIEM SŁÓW``) przejmującym jego rolę). Mimo to, oprogramowanie Unicode wciąż musi być w stanie obsłużyć ``U+FEFF`` w obu znaczeniach: Jako BOM jest to narzędzie do określania układu przechowywania dla zakodowanych bajtów, i znika gdy sekwencja bajtów zostanie zdekodowana w ciąg znaków; jako ``ZEROWEJ DŁUGOŚCI NIEŁAMANA SPACJA jest to normalny znak który będzie dekodowany jak każdy inny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's another encoding that is able to encoding the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: Marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to six 1 bits followed by a 0 bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieje inne kodowanie które jest w stanie zakodować pełen zakres znaków Unicode: UTF-8. UTF-8 jest kodowaniem 8-bitowym co oznacza że nie ma problemów z kolejnością bajtów w UTF-8. Każdy bajt w sekwencji bajtów UTF-8 składa się z dwóch części: Bitów znacznika (najbardziej znaczące bity) i bity ładowności. Bity znacznika są sekwencją od zera do sześciu bitów 1 po których następuje bit 0. Znaki Unicode-u są zakodowane tak, jak (z x będącym bitami ładowności które gdy sklejone dają znak Unicode):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Range</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encoding</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodowanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``U-00000000`` ... ``U-0000007F``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``U-00000000`` ... ``U-0000007F``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>0xxxxxxx</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>0xxxxxxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``U-00000080`` ... ``U-000007FF``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``U-00000080`` ... ``U-000007FF``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>110xxxxx 10xxxxxx</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>110xxxxx 10xxxxxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``U-00000800`` ... ``U-0000FFFF``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``U-00000800`` ... ``U-0000FFFF``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1110xxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>1110xxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``U-00010000`` ... ``U-001FFFFF``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``U-00010000`` ... ``U-001FFFFF``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``U-00200000`` ... ``U-03FFFFFF``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``U-00200000`` ... ``U-03FFFFFF``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``U-04000000`` ... ``U-7FFFFFFF``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``U-04000000`` ... ``U-7FFFFFFF``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The least significant bit of the Unicode character is the rightmost x bit.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Najmniej ważny bit znaku Unicode jest najbardziej wysuniętym na prawo bitem x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` character in the decoded string (even if it's the first character) is treated as a ``ZERO WIDTH NO-BREAK SPACE``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jako że UTF-8 jest 8-bitowym kodowaniem żadne BOM nie jest wymagane i każdy znak ``U+FEFF`` w zdekodowanym ciągu znaków (nawet gdy jest to pierwszy znak) jest traktowany jako ``ZEROWEJ DŁUGOŚCI NIEŁAMANA SPACJA``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without external information it's impossible to reliably determine which encoding was used for encoding a string. Each charmap encoding can decode any random byte sequence. However that's not possible with UTF-8, as UTF-8 byte sequences have a structure that doesn't allow arbitrary byte sequences. To increase the reliability with which a UTF-8 encoding can be detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls ``"utf-8-sig"``) for its Notepad program: Before any of the Unicode characters is written to the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: ``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any charmap encoded file starts with these byte values (which would e.g. map to</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bez zewnętrznej informacji nie możliwe jest określenie które kodowanie zostało użyte dla zakodowania ciągu znaków. Każde kodowanie mapy znaków może dekodować dowolną przypadkową sekwencję bajtów. Jednakże to nie jest możliwe z UTF-8, jako że sekwencje bajtów UTF-8 mają strukturę która nie pozwala na dowolną kolejność bajtów. Aby zwiększyć wiarygodność z którą kodowanie UTF-8 może być wykryte, Microsoft stworzył wartiant UTF-8 (które Pyton 2.5 nazywa ``"utf-8-sig"``) dla swojego programu notatnika: Zanim jakiekolwiek znaki unikodu są zapisywane do pliku Zakodowany w UTF-8 BOM (który wygląda następująco jako sekwencja bajtów: ``0xef``, ``0xbb``, ``0xbf``) jest zapisywany. Jako że jest raczej mało prawdopodobne że dowolny zakodowany mapą znaków plik zaczyna się od tych wartości bajtów (które byłyby mapowały na przykład do:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LATIN SMALL LETTER I WITH DIAERESIS</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ŁACIŃSKA MAŁA LITERA I Z DIAEREZĄ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W PRAWO-SKIEROWANY PODWÓJNEGO KĄTA ZNAK CYTATU</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>INVERTED QUESTION MARK</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ODWRÓCONY ZNAK ZAPYTANIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in iso-8859-1), this increases the probability that a utf-8-sig encoding can be correctly guessed from the byte sequence. So here the BOM is not used to be able to determine the byte order used for generating the byte sequence, but as a signature that helps in guessing the encoding. On encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the first three bytes to the file. On decoding utf-8-sig will skip those three bytes if they appear as the first three bytes in the file.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>w iso-8859-1), to zwiększa prawdopodobieństwo że kodowanie utf-8-sig może być właściwie zgadnięte z sekwencji bajtów. Tutaj więc BOM nie jest użytwany aby móc określić kolejność bajtów używanych do generowania sekwencji bajtów, ale jako sygnatura która pomaga w zgadnięciu kodowania. Przy kodowaniu utf-8-sig kodek napisze ``0xef``, ``0xbb``, ``0xbf`` jako pierwsze trzy bajty pliku. Przy dekodowaniu utf-8-sig ominie te trzy bajty jeśli pojawią się jako pierwsze trzy bajty w pliku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standard Encodings</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Standardowe kodowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python comes with a number of codecs built-in, either implemented as C functions or with dictionaries as mapping tables. The following table lists the codecs by name, together with a few common aliases, and the languages for which the encoding is likely used. Neither the list of aliases nor the list of languages is meant to be exhaustive. Notice that spelling alternatives that only differ in case or use a hyphen instead of an underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid alias for the ``'utf_8'`` codec.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski dostarczany jest z pewną liczbą kodeków wbudowanych, albo wypełnianych jako zadania C albo ze słownikami jako tabelami mapowania. Następująca tabela wypisuje kodeki po nazwie razem z kilkoma typowymi synonimami, i językami dla których kodowanie jest prawdopodobnie używane. Ani lista synonimów ani lista języków nie są przeznaczone aby były wyczerpujące. Zauważ alternatywne pisownie które tylko różnią się wielkością znaków lub używają myślnika zamiast podkreślenia są także poprawnymi synonimami; dlatego też np. ``'utf-8'`` jest poprawnym synonimem dla kodeka ``'utf_8'``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many of the character sets support the same languages. They vary in individual characters (e.g. whether the EURO SIGN is supported or not), and in the assignment of characters to code positions. For the European languages in particular, the following variants typically exist:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wiele zbiorów znaków wspiera te same języki.  Różnią się pojedynczymi znakami (np. czy ZNAK EURO jest wspierany czy nie), i przypisanie znaków do pozycji kodów. Dla języków europejskich w szczególności, następujące warianty typowo istnieją:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an ISO 8859 codeset</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>zestaw kodów ISO 8859</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a Microsoft Windows code page, which is typically derived from a 8859 codeset, but replaces control characters with additional graphic characters</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Strona kodowa Microsoft Windows która jest typowo odziedziczona po zestawie kodów 8859, ale zamienia znaki kierunków na dodatkowe znaki graficzne</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IBM EBCDIC code page</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Strona kodowa IBM EBCDIC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IBM PC code page, which is ASCII compatible</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Strona kodowa IBM PC, która jest zgodna z ASCII</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aliases</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Synonimy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Languages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Języki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ascii</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ascii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>646, us-ascii</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>646, us-ascii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>English</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Angielski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>big5</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>big5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>big5-tw, csbig5</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>big5-tw, csbig5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional Chinese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tradycyjny Chiński</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>big5hkscs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>big5hkscs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>big5-hkscs, hkscs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>big5-hkscs, hkscs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp037</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp037</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IBM037, IBM039</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>IBM037, IBM039</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp424</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp424</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>EBCDIC-CP-HE, IBM424</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>EBCDIC-CP-HE, IBM424</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hebrew</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Hebrajski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp437</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp437</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>437, IBM437</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>437, IBM437</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp500</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp500</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Western Europe</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zachodnio Europejski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp720</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp720</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Arabic</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Arabski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp737</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp737</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Greek</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Grecki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp775</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp775</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IBM775</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>IBM775</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Baltic languages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Języki bałtyckie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp850</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp850</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>850, IBM850</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>850, IBM850</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp852</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp852</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>852, IBM852</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>852, IBM852</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Central and Eastern Europe</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Europa centralna i wschodnia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp855</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp855</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>855, IBM855</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>855, IBM855</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bulgarian, Byelorussian, Macedonian, Russian, Serbian</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bułgarski, Białoruski, Macedoński, Rosyjski i Serbski.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp856</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp856</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp857</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp857</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>857, IBM857</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>857, IBM857</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Turkish</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Turecki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp858</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp858</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>858, IBM858</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>858, IBM858</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp860</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp860</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>860, IBM860</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>860, IBM860</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Portuguese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Portugalski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp861</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp861</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>861, CP-IS, IBM861</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>861, CP-IS, IBM861</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Icelandic</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Islandzki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp862</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp862</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>862, IBM862</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>862, IBM862</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp863</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp863</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>863, IBM863</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>863, IBM863</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Canadian</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kanadyjski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp864</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp864</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IBM864</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>IBM864</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp865</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp865</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>865, IBM865</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>865, IBM865</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Danish, Norwegian</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Duński, Norweski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp866</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp866</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>866, IBM866</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>866, IBM866</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Russian</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rosyjski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp869</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp869</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>869, CP-GR, IBM869</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>869, CP-GR, IBM869</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp874</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp874</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thai</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tajski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp875</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp875</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp932</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp932</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>932, ms932, mskanji, ms-kanji</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>932, ms932, mskanji, ms-kanji</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Japanese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Japoński</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp949</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp949</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>949, ms949, uhc</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>949, ms949, uhc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Korean</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Koreański</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp950</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp950</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>950, ms950</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>950, ms950</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1006</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Urdu</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Urdu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1026</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1026</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ibm1026</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ibm1026</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1140</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1140</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ibm1140</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ibm1140</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1250</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1250</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1250</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1250</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1251</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1251</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1251</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1251</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1252</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1252</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1252</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1252</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1253</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1253</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1253</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1253</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1254</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1254</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1254</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1254</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1255</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1255</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1256</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1256</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1256</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1256</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1257</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1257</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1257</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1257</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1258</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1258</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>windows-1258</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>windows-1258</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vietnamese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wietnamski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>euc_jp</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>euc_jp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>eucjp, ujis, u-jis</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>eucjp, ujis, u-jis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>euc_jis_2004</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>euc_jis_2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jisx0213, eucjis2004</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>jisx0213, eucjis2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>euc_jisx0213</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>euc_jisx0213</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>eucjisx0213</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>eucjisx0213</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>euc_kr</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>euc_kr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>euckr, koreański, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gb2312</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gb2312</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>chinese, csiso58gb231280, euc- cn, euccn, eucgb2312-cn, gb2312-1980, gb2312-80, iso- ir-58</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>chiński, csiso58gb231280, euc- cn, euccn, eucgb2312-cn, gb2312-1980, gb2312-80, iso- ir-58</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Chinese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uproszczony Chiński</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gbk</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gbk</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>936, cp936, ms936</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>936, cp936, ms936</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unified Chinese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zunifikowany Chiński</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gb18030</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gb18030</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gb18030-2000</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>gb18030-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hz</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>hz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hzgb, hz-gb, hz-gb-2312</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>hzgb, hz-gb, hz-gb-2312</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_jp</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_jp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>csiso2022jp, iso2022jp, iso-2022-jp</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>csiso2022jp, iso2022jp, iso-2022-jp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_jp_1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_jp_1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022jp-1, iso-2022-jp-1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022jp-1, iso-2022-jp-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_jp_2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_jp_2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022jp-2, iso-2022-jp-2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022jp-2, iso-2022-jp-2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Japanese, Korean, Simplified Chinese, Western Europe, Greek</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Japoński, Koreański, Uproszczony Chiński, Zachodnio-Europejski, Grecki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_jp_2004</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_jp_2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022jp-2004, iso-2022-jp-2004</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022jp-2004, iso-2022-jp-2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_jp_3</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_jp_3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022jp-3, iso-2022-jp-3</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022jp-3, iso-2022-jp-3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_jp_ext</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_jp_ext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022jp-ext, iso-2022-jp-ext</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022jp-ext, iso-2022-jp-ext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso2022_kr</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso2022_kr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>csiso2022kr, iso2022kr, iso-2022-kr</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>csiso2022kr, iso2022kr, iso-2022-kr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>latin_1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>latin_1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-1, iso8859-1, 8859, cp819, łacina, latin1, L1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>West Europe</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zachodnio europejski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-2, latin2, L2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-2, latin2, L2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_3</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-3, latin3, L3</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-3, latin3, L3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Esperanto, Maltese</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Esperanto, Maltański</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_4</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-4, latin4, L4</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-4, latin4, L4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_5</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-5, cyrillic</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-5, cyrylica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_6</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-6, arabic</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-6, arabski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_7</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-7, greek, greek8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-7, grecki, greek8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-8, hebrew</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-8, hebrajski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_9</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-9, latin5, L5</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-9, latin5, L5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_10</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-10, latin6, L6</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-10, latin6, L6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nordic languages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Języki nordyckie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_13</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-13, latin7, L7</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-13, latin7, L7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_14</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-14, latin8, L8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-14, latin8, L8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Celtic languages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Języki Celtyckie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_15</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-15, latin9, L9</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-15, latin9, L9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso8859_16</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso8859_16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iso-8859-16, latin10, L10</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>iso-8859-16, latin10, L10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>South-Eastern Europe</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Południowo-Wschodnia Europa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>johab</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>johab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cp1361, ms1361</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>cp1361, ms1361</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>koi8_r</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>koi8_r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>koi8_u</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>koi8_u</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ukrainian</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ukraiński</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mac_cyrillic</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mac_cyrillic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>maccyrillic</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>maccyrillic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mac_greek</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mac_greek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>macgreek</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>macgreek</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mac_iceland</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mac_iceland</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>maciceland</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>maciceland</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mac_latin2</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mac_latin2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>maclatin2, maccentraleurope</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>maclatin2, maccentraleurope</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mac_roman</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mac_roman</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>macroman</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>macroman</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mac_turkish</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mac_turkish</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>macturkish</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>macturkish</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ptcp154</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ptcp154</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>csptcp154, pt154, cp154, cyrillic-asian</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>csptcp154, pt154, cp154, cyrillic-asian</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kazakh</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kazachski</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>shift_jis</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>shift_jis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>csshiftjis, shiftjis, sjis, s_jis</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>csshiftjis, shiftjis, sjis, s_jis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>shift_jis_2004</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>shift_jis_2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>shiftjis2004, sjis_2004, sjis2004</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>shiftjis2004, sjis_2004, sjis2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>shift_jisx0213</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>shift_jisx0213</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>shiftjisx0213, sjisx0213, s_jisx0213</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>shiftjisx0213, sjisx0213, s_jisx0213</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_32</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>U32, utf32</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>U32, utf32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all languages</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie języki</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_32_be</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_32_be</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-32BE</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>UTF-32BE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_32_le</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_32_le</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-32LE</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>UTF-32LE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_16</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>U16, utf16</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>U16, utf16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_16_be</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_16_be</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-16BE</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>UTF-16BE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all languages (BMP only)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wszystkie języki (tylko BMP)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_16_le</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_16_le</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UTF-16LE</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>UTF-16LE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_7</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>U7, unicode-1-1-utf-7</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>U7, unicode-1-1-utf-7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>U8, UTF, utf8</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>U8, UTF, utf8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>utf_8_sig</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>utf_8_sig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Purpose</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Cel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>idna</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>idna</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements :rfc:`3490`, see also :mod:`encodings.idna`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia :rfc:`3490`, zobacz także :mod:`encodings.idna`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mbcs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>mbcs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dbcs</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>dbcs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Windows only: Encode operand according to the ANSI codepage (CP_ACP)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Tylko Windows: Zakoduj operand zgodnie ze stroną kodową ANSI (CP_ACP)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>palmos</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>palmos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encoding of PalmOS 3.5</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kodowanie PalmOS 3.5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>punycode</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>punycode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implements :rfc:`3492`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wypełnia :rfc:`3492`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>raw_unicode_escape</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>surowe_ucieczkowe_unicode - z ang. - raw_unicode_escape</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Produce a string that is suitable as raw Unicode literal in Python source code</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wytwórz ciąg znaków który jest odpowiedni jako surowy literał Unicode w kodzie źródłowym języka pytonowskiego</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>undefined</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>nie zdefiniowane</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Raise an exception for all conversions. Can be used as the system encoding if no automatic coercion between byte and Unicode strings is desired.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zgłoś wyjątek dla wszystkich zamian. Może być używane jako kodowanie systemu jeśli nie jest oczekiwane żadne automatyczne przymuszanie pomiędzy bajtem a ciągiem znaków Unicode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unicode_escape</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>unicode_escape - ucieczkowe_unicode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Produce a string that is suitable as Unicode literal in Python source code</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Utwórz ciąg znaków który jest odpowiedni jako literał Unicode w kodzie źródłowym języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unicode_internal</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>wewnętrzny_unicode - z ang. - unicode_internal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the internal representation of the operand</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć wewnętrzną reprezentację operandu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`encodings.idna` --- Internationalized Domain Names in Applications</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`encodings.idna` --- Umiędzynarodowione nazwy domen w aplikacjach</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module implements :rfc:`3490` (Internationalized Domain Names in Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)). It builds upon the ``punycode`` encoding and :mod:`stringprep`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł wypełnia :rfc:`3490` (umiędzynarodowione nazwy domen w aplikacjach) i :rfc:`3492` (Nameprep: Profil Stringprep dla umiędzynarodowionych nazw domen (IDN - internationalized Domain Names)). Buduje nad kodowaniem ``punycode`` i :mod:`stringprep`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These RFCs together define a protocol to support non-ASCII characters in domain names. A domain name containing non-ASCII characters (such as ``www.Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain name is then used in all places where arbitrary characters are not allowed by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so on. This conversion is carried out in the application; if possible invisible to the user: The application should transparently convert Unicode domain labels to IDNA on the wire, and convert back ACE labels to Unicode before presenting them to the user.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te RFC razem definiują protokół aby wspierać znaki nie-ASCII w nazwach domen. Nazwy domen zawierające znaki nie-ASCII (takie jak: ``www.Alliancefrançaise.nu``) jest konwertowane do kodowania zgodnego z ASCII: (ACE, takiego jak ``www.xn--alliancefranaise-npb.nu``). Forma ACE nazwy domeny jest wtedy używana we wszystkich miejscach gdzie dowolne znaki nie są dozwolone przez protokół, takie jak zapytania DNS, pola :mailheader:`Host` HTTP, itd. Ta zamiana jest wykonywana w aplikacji; jeśli możliwe niewidoczne dla użytkownika: Aplikacja powinna w przezroczysty sposób zamieniać nazwy domen Unicode do IDNA na linii, i zamieniać wstecz nazwy ACE do Unicode przed zaprezentowaniem ich do użytkownika.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Python supports this conversion in several ways: The ``idna`` codec allows to convert between Unicode and the ACE. Furthermore, the :mod:`socket` module transparently converts Unicode host names to ACE, so that applications need not be concerned about converting host names themselves when they pass them to the socket module. On top of that, modules that have host names as function parameters, such as :mod:`http.client` and :mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also transparently sends an IDNA hostname in the :mailheader:`Host` field if it sends that field at all).</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Język pytonowski wspiera tą zamianę w na różne sposoby: kodek ``idna`` pozwala konwertować pomiędzy Unicode i ACE. Dalej moduł :mod:`socket` przezroczyście zamienia nazwy hosta Unicode na ACE, tak że aplikacje nie muszą się martwić o zamianę nazw hosta własnoręcznie gdy przekazują je do modułu gniazda. Na domiar tego, moduły które mają nazwy hosta jako parametry zadań, takie jak :mod:`http.client` i :mod:`ftplib` akceptują nazwy hosta Unicode (:mod:`http.client` wtedy także przezroczyście wysyłają nazwę hosta IDNA w nagłówku :mailheader:`Host` jeśli wysyła to pole w ogóle).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When receiving host names from the wire (such as in reverse name lookup), no automatic conversion to Unicode is performed: Applications wishing to present such host names to the user should decode them to Unicode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Gdy otrzymuje się nazwy hosta z linii (tak, jak w odwróconym podglądzie nazwy), żadna automatyczna konwersja Unicode nie jest wykonywana: Aplikacje które chciałyby prezentować takie nazwy hosta do użytkownika powinny dekodować je do Unikodu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The module :mod:`encodings.idna` also implements the nameprep procedure, which performs certain normalizations on host names, to achieve case-insensitivity of international domain names, and to unify similar characters. The nameprep functions can be used directly if desired.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`encodings.idna` wypełnia także procedurę nameprep, która wytwarza określone normalizacje na nazwach hosta, aby osiągnąć niewrażliwość na wielkość liter umiędzynarodowionych nazw domen, i aby zunifikować podobne znaki. Zadania nameprep  mogą być używane bezpośrednio jeśli jest taka potrzeba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return the nameprepped version of *label*. The implementation currently assumes query strings, so ``AllowUnassigned`` is true.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć z przygotowaną nazwą wersję *fiszki*. To wypełnienie obecnie zajmuje ciągi zapytań, więc ``AllowUnassigned`` jest prawdziwe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` is assumed to be false.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień fiszkę na ASCII, jak określono w :rfc:`3490`. ``UseSTD3ASCIIRules`` jest zakładane że będzie fałszywe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Convert a label to Unicode, as specified in :rfc:`3490`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zamień nazwę na Unicode, jak określono w :rfc:`3490`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`encodings.mbcs` --- Windows ANSI codepage</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`encodings.mbcs` --- strona kodowa Windows ANSI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Encode operand according to the ANSI codepage (CP_ACP). This codec only supports ``'strict'`` and ``'replace'`` error handlers to encode, and ``'strict'`` and ``'ignore'`` error handlers to decode.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zakoduj operand w zgodzie ze stroną kodową ANSI (CP_ACP). Ten kodek wspiera tylko obsługę błędów ``'strict'`` i ``'replace'`` dla kodowania i obsługę błędów ``'strict'`` i ``'ignore'`` dla dekodowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Availability: Windows only.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dostępność: tylko w Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`encodings.utf_8_sig` --- kodek UTF-8 z sygnaturą BOM </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module implements a variant of the UTF-8 codec: On encoding a UTF-8 encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful encoder this is only done once (on the first write to the byte stream).  For decoding an optional UTF-8 encoded BOM at the start of the data will be skipped.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł wypełnia wariant kodeka UTF-8: Na kodowaniu UTF-8 zakodowany BOM (Znacznik Porządku Bajtów) zostanie doklejony z przodu do zakodowanych bajtów w UTF-8. Dla kodera pełnego stanu to jest wykonywane tylko raz (podczas pierwszego zapisu do strumienia bajtów). Dla dekodowania opcjonalnie zakodowany BOM na początku danych zostanie ominięty. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`codeop` --- Compile Python code</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`codeop` --- Kompiluje kod języka pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`codeop` module provides utilities upon which the Python read-eval-print loop can be emulated, as is done in the :mod:`code` module.  As a result, you probably don't want to use the module directly; if you want to include such a loop in your program you probably want to use the :mod:`code` module instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`codeop` dostarcza użyteczności na której pętla języka pytonowskiego wczytaj-oblicz-wydrukuj może być emulowana, tak jak jest to dokonywane w module :mod:`code`. Jako wynik prawdopodobnie nie będziesz chciał używać tego modułu bezpośrednio; jeśli chcesz zawrzeć taką pętlę w swoim programie pewnie będziesz chciał użyć modułu :mod:`code` zamiast tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two parts to this job:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Istnieją dwie części dotyczące tej pracy:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being able to tell if a line of input completes a Python  statement: in short, telling whether to print '``&gt;&gt;&gt;``' or '``...``' next.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Bycie w stanie powiedzieć czy linia wejściowa uzupełnia wyrażenie języka pytonowskiego: w skrócie powiedzenie czy wydrukować '``&gt;&gt;&gt;``' czy '``...``' w następnej kolejności.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remembering which future statements the user has entered, so  subsequent input can be compiled with these in effect.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zapamiętanie które przyszłe wyrażenia użytkownik wpisał, więc następne wejście może być skompilowane z tym w efekcie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :mod:`codeop` module provides a way of doing each of these things, and a way of doing them both.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł :mod:`codeop` dostarcza sposób robienia każdej z tych rzeczy i sposób robienia ich obojga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do just the former:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby wykonać tylko to pierwsze:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tries to compile *source*, which should be a string of Python code and return a code object if *source* is valid Python code. In that case, the filename attribute of the code object will be *filename*, which defaults to ``'&lt;input&gt;'``. Returns ``None`` if *source* is *not* valid Python code, but is a prefix of valid Python code.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Próbuje skompilować *źródło*, które powinno być ciągiem znaków kodu języka pytonowskiego i zwrócić przedmiot kodu jeśli *źródło* jest poprawnym kodem języka pytonowskiego. W tym przypadku właściwość przedmiotu kodu *nazwą pliku* która domyślnie równa jest ``'&lt;input&gt;'``. Zwraca ``None`` jeśli *źródło* nie jest właściwym kodem języka pytonowskiego, ale jest przedrostkiem właściwego kodu języka Pytonowskiego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is a problem with *source*, an exception will be raised. :exc:`SyntaxError` is raised if there is invalid Python syntax, and :exc:`OverflowError` or :exc:`ValueError` if there is an invalid literal.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli istnieje problem ze *źródłem* wyjątek zostanie zgłoszony. :exc:`SyntaxError` jest zgłaszany jeśli istnieje nieprawidłowa składnia języka pytonowskiego i :exc:`OverflowError` lub :exc:`ValueError` jeśli jest nieprawidłowy literał.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *symbol* argument determines whether *source* is compiled as a statement (``'single'``, the default) or as an :term:`expression` (``'eval'``).  Any other value will cause :exc:`ValueError` to  be raised.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Parametr *symbol* określa czy *źródło* jest kompilowane jako wyrażenie (``'single'``, domyślnie) lub jako wyrażenie - z ang. - :term:`expression` (``'eval'``). Jakakolwiek inna wartość spowoduje, że :exc:`ValueError`  zostanie zgłoszony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible (but not likely) that the parser stops parsing with a successful outcome before reaching the end of the source; in this case, trailing symbols may be ignored instead of causing an error.  For example, a backslash followed by two newlines may be followed by arbitrary garbage. This will be fixed once the API for the parser is better.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jest możliwe (ale mało prawdopodobne) że czytnik przestanie czytać wraz z udanym wynikiem przed dotarciem do końca źródła; w takim przypadku, kończące symbole mogą zostać zignorowane zamiast powodować błąd. Dla przykładu skośnik, po którym następują dwa znaki nowego wiersza może poprzedzać dowolne śmiecie. To zostanie naprawione gdy sprzęg programowania dla czytnika zostanie ulepszony.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of this class have :meth:`__call__` methods identical in signature to the built-in function :func:`compile`, but with the difference that if the instance compiles program text containing a :mod:`__future__` statement, the instance 'remembers' and compiles all subsequent program texts with the statement in force.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady tego uogólnienia mają sposób postępowania :meth:`__call__` identyczny z sygnaturą do wbudowanego zadania :func:`compile`, ale z tą różnicą, że jeśli przykład kompiluje tekst programu zawierający wyrażenia :mod:`__future__`, przykład 'zapamiętuje' i kompiluje wszystkie następujące potem teksty programu z tym wyrażeniem w mocy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of this class have :meth:`__call__` methods identical in signature to :func:`compile_command`; the difference is that if the instance compiles program text containing a ``__future__`` statement, the instance 'remembers' and compiles all subsequent program texts with the statement in force.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykłady tego uogólnienia mają sposoby postępowania :meth:`__call__` identyczne z sygnaturą dla :func:`compile_command`; Różnica polega na tym, że jeśli przykład kompiluje tekst programu zawierający wyrażenie ``__future__``, przykład 'pamięta' i kompiluje wszystkie następujące później teksty programu z wyrażeniem w mocy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mod:`collections` --- Container datatypes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:mod:`collections` --- typy danych kontenerów</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This module implements high-performance container datatypes.  Currently, there are four datatypes, :class:`Counter`, :class:`deque`, :class:`OrderedDict` and :class:`defaultdict`, and one datatype factory function, :func:`namedtuple`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten moduł wypełnia wysokiej-wydajności typy danych kontenerów. Obecnie są cztery typy danych. :class:`Counter`, :class:`deque`, :class:`OrderedDict` i :class:`defaultdict`, i jeden typ danych zadania fabrykującego, :func:`namedtuple`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The specialized containers provided in this module provide alternatives to Python's general purpose built-in containers, :class:`dict`, :class:`list`, :class:`set`, and :class:`tuple`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Specjalizowane kontenery dostarczane w tym module dostarczają alternatywy dla kontenerów ogólnego zastosowania języka pytonowskiego, :class:`dict`, :class:`list`, :class:`set` i :class:`tuple`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to containers, the collections module provides some ABCs (abstract base classes) that can be used to test whether a class provides a particular interface, for example, whether it is hashable or a mapping.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W dodatku względem kontenerów, moduł kolekcji dostarcza pewnych ABCów (abstrakcyjnych uogólnień podstawowych) które mogą być użyte do przetestowania czy uogólnienie dostarcza konkretny sprzęg, dla przykładu, czy jest to typ haszowalny czy mapowalny.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ABCs - abstract base classes</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ABCe - abstrakcyjne uogólnienia podstawowe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The collections module offers the following ABCs:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Moduł kolekcji oferuje następujące abstrakcyjne uogólnienia podstawowe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ABC</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>ABC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inherits</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dziedziczy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abstract Methods</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Abstrakcyjne sposoby postępowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixin Methods</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domieszkowe sposoby postępowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Container`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Container` - kontener</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__contains__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__contains__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Hashable`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Hashable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__hash__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__hash__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Iterable`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Iterable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__iter__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__iter__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Iterator`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Iterator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__next__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__next__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Sized`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Sized`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__len__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__len__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Callable`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Callable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__call__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__call__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Sequence`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Sequence`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Sized`, :class:`Iterable`, :class:`Container`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Sized`, :class:`Iterable`, :class:`Container`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__getitem__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__getitem__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__contains__``. ``__iter__``, ``__reversed__``. ``index``, and ``count``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__contains__``. ``__iter__``, ``__reversed__``. ``index``, i ``count``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`MutableSequence`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`MutableSequence`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__setitem__`` ``__delitem__``, and ``insert``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__setitem__`` ``__delitem__``, and ``insert``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inherited Sequence methods and ``append``, ``reverse``, ``extend``, ``pop``, ``remove``, and ``__iadd__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odziedziczone sposoby postępowania sekwencji ``append``, ``reverse``, ``extend``, ``pop``, ``remove``, i ``__iadd__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Set`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Set`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, ``__and__``, ``__or__`` ``__sub__``, ``__xor__``, and ``isdisjoint``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, ``__and__``, ``__or__`` ``__sub__``, ``__xor__``, i ``isdisjoint``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`MutableSet`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`MutableSet` - mutowalny zbiór</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``add`` and ``discard``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``dodaj`` i ``odrzuć`` - z ang. - ``add`` i ``discard``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inherited Set methods and ``clear``, ``pop``, ``remove``, ``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odziedziczone sposoby postępowania Zbioru i ``clear``, ``pop``, ``remove``, ``__ior__``, ``__iand__``,  ``__ixor__``, i ``__isub__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Mapping`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`Mapping` - z ang. - Mapowanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and ``__ne__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, i ``__ne__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`MutableMapping`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`MutableMapping` - mutowalne mapowanie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__setitem__`` and ``__delitem__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__setitem__`` i ``__delitem__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inherited Mapping methods and ``pop``, ``popitem``, ``clear``, ``update``, and ``setdefault``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odziedziczone sposoby postępowania Mapowania i ``pop``, ``popitem``, ``clear``, ``update``, i ``setdefault``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`MappingView`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`MappingView` - Widok mapowania</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`KeysView`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`KeysView`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`MappingView`, :class:`Set`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`MappingView`, :class:`Set`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``__contains__``, ``__iter__``</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>``__contains__``, ``__iter__``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`ItemsView`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`ItemsView`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`ValuesView`</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>:class:`ValuesView`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These ABCs allow us to ask classes or instances if they provide particular functionality, for example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Te ABC-e - abstrakcyjne uogólnienia podstawowe pozwalają nam zapytać uogólnienia lub ich przykłady czy dostarczają konkretnej funkcjonalności, na przykład::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>size = None if isinstance(myvar, collections.Sized):     size = len(myvar)</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>size = None if isinstance(myvar, collections.Sized):     size = len(myvar)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs.  For example, to write a class supporting the full :class:`Set` API, it only necessary to supply the three underlying abstract methods: :meth:`__contains__`, :meth:`__iter__`, and :meth:`__len__`. The ABC supplies the remaining methods such as :meth:`__and__` and :meth:`isdisjoint` ::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kilka z ABC-ów są także użyteczne jako domieszki które ułatwiają rozwijanie uogólnień wspierających sprzęgi programowania kontenerów (z ang. - APIs). Dla przykładu aby zapisać uogólnienie wspierające w pełni sprzęg :class:`Set` - z ang. - zbioru, jest tylko konieczne dostarczenie trzech leżących u podstaw abstrakcyjnych sposobów postępowania: :meth:`__contains__`, :meth:`__iter__`, i :meth:`__len__`. ABCe dostarczają pozostałe metody takie jak :meth:`__and__` i :meth:`isdisjoint`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class ListBasedSet(collections.Set):      ''' Alternate set implementation favoring space over speed          and not requiring the set elements to be hashable. '''      def __init__(self, iterable):          self.elements = lst = []          for value in iterable:              if value not in lst:                  lst.append(value)      def __iter__(self):          return iter(self.elements)      def __contains__(self, value):          return value in self.elements      def __len__(self):          return len(self.elements)  s1 = ListBasedSet('abcdef') s2 = ListBasedSet('defghi') overlap = s1 &amp; s2            # The __and__() method is supported automatically</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>class ListBasedSet(collections.Set): ''' Alternatywne wypełnienie zbiorów preferujące rozmiar ponad prędkością działania i nie wymagające od elementów zbioru aby były hashowalne. ''' def __init__(self, iterable): self.elements = lst = [] for value in iterable: if value not in lst: lst.append(value) def __iter__(self): return iter(self.elements) def __contains__(self, value): return value in self.ements def __len__(self): return len(self.elements) s1 = ListBasedSet('abcdef') s2 = ListBasedSet('defghi') overlap = s1 &amp; s2 # Sposób postępowania __and__() jest wspierany automatycznie</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notes on using :class:`Set` and :class:`MutableSet` as a mixin:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uwagi o używaniu :class:`Set` i :class:`MutableSet` jako domieszki:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since some set operations create new sets, the default mixin methods need a way to create new instances from an iterable. The class constructor is assumed to have a signature in the form ``ClassName(iterable)``. That assumption is factored-out to an internal classmethod called :meth:`_from_iterable` which calls ``cls(iterable)`` to produce a new set. If the :class:`Set` mixin is being used in a class with a different constructor signature, you will need to override :meth:`from_iterable` with a classmethod that can construct new instances from an iterable argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Od kiedy niektóre operacje zbiorów tworzą nowe zbiory, domyślne sposoby postępowania domieszek potrzebują sposobu aby tworzyć nowe przykłady z iterowalnego. Konstruktor uogólnienia jest przyjmowany że ma sygnaturę w postaci ``ClassName(iterable)``. To założenie jest wyciągnięte na zewnątrz do wewnętrznego sposobu postępowania uogólnienia zwanego  :meth:`_from_iterable` które wywołuje ``cls(iterable)`` aby wytworzyć nowy zbiór. Jeśli domieszka uogólnienie zbioru :class:`Set` jest używana w uogólnieniu z różną sygnaturą konstruktora, będziesz potrzebował przesłonić :meth:`from_iterable` za pomocą sposobu postępowania uogólnienia, który może skonstruować nowe przykłady z iterowalnego parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To override the comparisons (presumably for speed, as the semantics are fixed), redefine :meth:`__le__` and then the other operations will automatically follow suit.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby przesłonić porównania (zakładając dla prędkości, jako że składnia jest poprawiona), ponownie zdefiniuj :meth:`__le__` i wtedy inne operacje automatycznie postąpią za nią.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Set` mixin provides a :meth:`_hash` method to compute a hash value for the set; however, :meth:`__hash__` is not defined because not all sets are hashable or immutable.  To add set hashabilty using mixins, inherit from both :meth:`Set` and :meth:`Hashable`, then define ``__hash__ = Set._hash``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Domieszka :class:`Set` dostarcza sposób postępowania :meth:`_hash` aby obliczyć wartość hash dla zbioru; jednakże :meth:`__hash__` nie jest zdefiniowana ponieważ nie wszystkie zbiory są hashowalne lub niemutowalne. Aby dodać hashowalność używając domieszek, odziedzicz z obydwu :meth:`Set` i :meth:`Hashable`, i zdefiniuj ``__hash__ = Set._hash``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`OrderedSet recipe &lt;http://code.activestate.com/recipes/576694/&gt;`_ for an example built on :class:`MutableSet`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>`OrderedSet przepis &lt;http://code.activestate.com/recipes/576694/&gt;`_ dla przykładu zbudowany na :class:`MutableSet`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more about ABCs, see the :mod:`abc` module and :pep:`3119`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Po więcej o ABC-ach, sięgnij do modułu :mod:`abc` i :pep:`3119`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`Counter` objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmioty :class`Counter`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A counter tool is provided to support convenient and rapid tallies. For example::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>narzędzie licznika jest dostarczone dla wsparcia wygodnych i szybkich rejestrów. Dla przykładu::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; # Tally occurrences of words in a list &gt;&gt;&gt; cnt = Counter() &gt;&gt;&gt; for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']: ...     cnt[word] += 1 &gt;&gt;&gt; cnt Counter({'blue': 3, 'red': 2, 'green': 1})  &gt;&gt;&gt; # Find the ten most common words in Hamlet &gt;&gt;&gt; import re &gt;&gt;&gt; words = re.findall('\w+', open('hamlet.txt').read().lower()) &gt;&gt;&gt; Counter(words).most_common(10) [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),  ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; # Rejestr wystąpień słowa w liście &gt;&gt;&gt; cnt = Counter() &gt;&gt;&gt; for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']: ...     cnt[word] += 1 &gt;&gt;&gt; cnt Counter({'blue': 3, 'red': 2, 'green': 1})  &gt;&gt;&gt; # Znajdź dziesięć najpopularniejszych słów w Hamlecie &gt;&gt;&gt; import re &gt;&gt;&gt; words = re.findall('\w+', open('hamlet.txt').read().lower()) &gt;&gt;&gt; Counter(words).most_common(10) [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),  ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A :class:`Counter` is a :class:`dict` subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values.  Counts are allowed to be any integer value including zero or negative counts.  The :class:`Counter` class is similar to bags or multisets in other languages.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Counter` jest podrzędnym uogólnieniem uogólnienia :class:`dict` do zliczania przedmiotów hashowalnych. Jest to nieuporządkowana kolekcja gdzie elementy są zachowane jako klucze słownika a ich liczby powtórzeń są przechowywane jako wartości słownika. Zliczone wartości mogą być wartościami całkowitymi zawierającymi zero i wartości ujemne. Uogólnienie :class:`Counter` jest podobne do torebek lub wielozbiorów w innych językach. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elements are counted from an *iterable* or initialized from another *mapping* (or counter):</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Elementy są zliczane z *iterowalnego* lub inicjowane z innego *mapowania* (lub zliczania):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; c = Counter()                           # a new, empty counter &gt;&gt;&gt; c = Counter('gallahad')                 # a new counter from an iterable &gt;&gt;&gt; c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping &gt;&gt;&gt; c = Counter(cats=4, dogs=8)             # a new counter from keyword args</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; c = Counter()                           # nowy, pusty licznik &gt;&gt;&gt; c = Counter('gallahad')                 # nowy licznik z iterowalnego &gt;&gt;&gt; c = Counter({'red': 4, 'blue': 2})      # nowy licznik z mapowania &gt;&gt;&gt; c = Counter(cats=4, dogs=8)             # nowy licznik z parametrów słów kluczowych</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counter objects have a dictionary interface except that they return a zero count for missing items instead of raising a :exc:`KeyError`:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty Licznika mają sprzęg słownika z wyjątkiem że mogą zwracać liczbę zero dla brakujących elementów zamiast zgłaszania błędu :exc:`KeyError`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; c = Counter(['eggs', 'ham']) &gt;&gt;&gt; c['bacon']                              # count of a missing element is zero 0</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; c = Counter(['eggs', 'ham']) &gt;&gt;&gt; c['bacon']                              # liczba dla brakującego elementu jest zero 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting a count to zero does not remove an element from a counter. Use ``del`` to remove it entirely:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ustawienie liczby zliczonej na zero nie usuwa elementu z licznika. Użyj ``del`` aby usunąć je całkowicie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; c['sausage'] = 0                        # counter entry with a zero count &gt;&gt;&gt; del c['sausage']                        # del actually removes the entry</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; c['sausage'] = 0 # wpis licznika z liczbą zero &gt;&gt;&gt; del c['sausage'] # del właściwie usuwa wpis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counter objects support three methods beyond those available for all dictionaries:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty licznika wspierają trzy sposoby postępowania poza tymi dostępnymi dla wszystkich słowników:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return an iterator over elements repeating each as many times as its count.  Elements are returned in arbitrary order.  If an element's count is less than one, :meth:`elements` will ignore it.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć iterator ponad elementami powtarzając każdy tyle razy jak jego liczba. Elementy są zwracane w dowolny sposób. Jeśli liczba elementu jest mniejsza niż jeden sposób postępowania :meth:`elements` zignoruje ją.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2) &gt;&gt;&gt; list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2) &gt;&gt;&gt; list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return a list of the *n* most common elements and their counts from the most common to the least.  If *n* is not specified, :func:`most_common` returns *all* elements in the counter.  Elements with equal counts are ordered arbitrarily:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwróć listę *n* najczęstszych elementów i ich liczb od najczęstszego do najmniej częstego. Jeśli *n* nie jest określony, :func:`most_common` zwraca *all* - z ang. - *wszystkie* elementy w liczniku. Elementy z równymi liczbami są uszeregowane dowolnie:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; Counter('abracadabra').most_common(3) [('a', 5), ('r', 2), ('b', 2)]</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; Counter('abracadabra').most_common(3) [('a', 5), ('r', 2), ('b', 2)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elements are subtracted from an *iterable* or from another *mapping* (or counter).  Like :meth:`dict.update` but subtracts counts instead of replacing them.  Both inputs and outputs may be zero or negative.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Elementy są odejmowane z *iterowalnego* lub z innego *mapowania* (lub licznika). Jak :meth:`dict.update` ale odejmuje liczby zamiast je zastępować. Zarówno wejścia jak i wyjścia mogą być zerowe lub ujemne.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2) &gt;&gt;&gt; d = Counter(a=1, b=2, c=3, d=4) &gt;&gt;&gt; c.subtract(d) Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2) &gt;&gt;&gt; d = Counter(a=1, b=2, c=3, d=4) &gt;&gt;&gt; c.subtract(d) Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual dictionary methods are available for :class:`Counter` objects except for two which work differently for counters.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Typowe sposoby postępowania są dostępne dla przedmiotów :class:`Counter` z wyjątkiem dwóch które działają inaczej dla liczników.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class method is not implemented for :class:`Counter` objects.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Ten sposób postępowania nie jest wypełniony dla przedmiotów :class:`Counter`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elements are counted from an *iterable* or added-in from another *mapping* (or counter).  Like :meth:`dict.update` but adds counts instead of replacing them.  Also, the *iterable* is expected to be a sequence of elements, not a sequence of ``(key, value)`` pairs.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Elementy są zliczane z *iterowalnego* lub dodanej z innego *mapowania* lub licznika. Jak :meth:`dict.update` ale dodaje liczby zamiast zamieniać je. Także oczekuje się, że *iterowalny* będzie sekwencją elementów, nie sekwencją par ``(klucz, wartość)``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common patterns for working with :class:`Counter` objects::</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wspólne wzorce dla pracy z przedmiotami :class:`Counter`::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sum(c.values())                 # total of all counts c.clear()                       # reset all counts list(c)                         # list unique elements set(c)                          # convert to a set dict(c)                         # convert to a regular dictionary c.items()                       # convert to a list of (elem, cnt) pairs Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs c.most_common()[:-n:-1]         # n least common elements c += Counter()                  # remove zero and negative counts</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>sum(c.values())                 # suma wszystkich liczb c.clear()                       # resetuj wszystkie liczby list(c)                         # listuj niepowtarzalne elementy set(c)                          # zamień na zbiór dict(c)                         # zamień na regularny słownik c.items()                       # zamień na listę par (elem, cnt) Counter(dict(list_of_pairs))    # zamień z listy par (elem, cnt) c.most_common()[:-n:-1]         # n najrzadszych elementów c += Counter()                  # usuń zerowe i ujemne liczby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Several mathematical operations are provided for combining :class:`Counter` objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements.  Intersection and union return the minimum and maximum of corresponding counts.  Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Kilka matematycznych operacji jest dostępnych dla łączenia przedmiotów :class:`Counter` aby stworzyć wielozbiory (liczniki które mają liczby większe niż zero). Dodawanie i odejmowanie łączą liczniki przez dodawanie i odejmowanie liczb odpowiadających elementów. Przecięcie i suma zwracają minimalne i maksymalne wartości odpowiadających sobie liczb. Każda operacja może akceptować wejście z liczbami ze znakiem, ale wyjście będzie odrzucało wyniki z liczbami mniejszymi lub równymi zero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;&gt;&gt; c = Counter(a=3, b=1) &gt;&gt;&gt; d = Counter(a=1, b=2) &gt;&gt;&gt; c + d                       # add two counters together:  c[x] + d[x] Counter({'a': 4, 'b': 3}) &gt;&gt;&gt; c - d                       # subtract (keeping only positive counts) Counter({'a': 2}) &gt;&gt;&gt; c &amp; d                       # intersection:  min(c[x], d[x]) Counter({'a': 1, 'b': 1}) &gt;&gt;&gt; c | d                       # union:  max(c[x], d[x]) Counter({'a': 3, 'b': 2})</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>&gt;&gt;&gt; c = Counter(a=3, b=1) &gt;&gt;&gt; d = Counter(a=1, b=2) &gt;&gt;&gt; c + d                       # dodaj dwa liczniki razem:  c[x] + d[x] Counter({'a': 4, 'b': 3}) &gt;&gt;&gt; c - d                       # odejmij (zatrzymując tylko dodatnie liczby) Counter({'a': 2}) &gt;&gt;&gt; c &amp; d                       # przecięcie:  min(c[x], d[x]) Counter({'a': 1, 'b': 1}) &gt;&gt;&gt; c | d                       # suma:  max(c[x], d[x]) Counter({'a': 3, 'b': 2})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values.  To help with those use cases, this section documents the minimum range and type restrictions.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Liczniki są przede wszystkim zaprojektowane do pracy z dodatnimi liczbami całkowitymi aby reprezentować bieżące liczby; jednakże, zatroszczono się aby bez potrzeby nie wykluczyć przypadków użycia wymagających innego typu ujemnych wartości. Aby pomóc w tych przypadkach, ten rozdział dokumentuje obostrzenia minimalnego zakresu i typu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :class:`Counter` class itself is a dictionary subclass with no restrictions on its keys and values.  The values are intended to be numbers representing counts, but you *could* store anything in the value field.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Uogólnienie :class:`Counter` samo w sobie jest podrzędnym uogólnieniem słownika bez ograniczeń co do kluczy i wartości. Wartości są przeznaczone aby były liczbami reprezentującymi wartości zliczane, ale *możesz* wpisać cokolwiek do pola wartości.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`most_common` method requires only that the values be orderable.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`most_common` - z ang. - 'najczęstszy' - wymaga jedynie aby wartości były możliwe do uporządkowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For in-place operations such as ``c[key] += 1``, the value type need only support addition and subtraction.  So fractions, floats, and decimals would work and negative values are supported.  The same is also true for :meth:`update` and :meth:`subtract` which allow negative and zero values for both inputs and outputs.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla operacji w miejscu takich jak ``c[klucz] += 1``, typ wartości wymaga tylko wsparcia dla dodawania i odejmowania. Więc ułamki, liczby zmiennoprzecinkowe i dziesiątkowe będą działać i wartości ujemne są wspierane. To samo jest także prawdziwe dla :meth:`update` i :meth:`subtract` które pozwalają na wartości ujemne i zerowe dla zarówno wejść jak i wyjść.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The multiset methods are designed only for use cases with positive values. The inputs may be negative or zero, but only outputs with positive values are created.  There are no type restrictions, but the value type needs to support support addition, subtraction, and comparison.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposoby postępowania wielozbiorów są zaprojektowane tylko dla przypadków użycia wartości dodatnich. Wejścia mogą być ujemne lub zerowe, ale tylko wyjścia z dodatnimi wartościami są tworzone. Nie ma ograniczeń typu, ale wartość musi wspierać dodawanie odejmowanie i porównania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The :meth:`elements` method requires integer counts.  It ignores zero and negative counts.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Sposób postępowania :meth:`elements` wymaga liczb całkowitych do zliczania. Ignoruje zerowe i ujemne liczby.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Counter class &lt;http://code.activestate.com/recipes/576611/&gt;`_ adapted for Python 2.5 and an early `Bag recipe &lt;http://code.activestate.com/recipes/259174/&gt;`_ for Python 2.4.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>`Uogólnienie licznika &lt;http://code.activestate.com/recipes/576611/&gt;`_  zaadaptowane dla języka pytonowskiego 2.5 i wczesna recepta na `Torebki &lt;http://code.activestate.com/recipes/259174/&gt;`_ dla języka pytonowskiego 2.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bag class &lt;http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html&gt;`_ in Smalltalk.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>`Uogólnienie Torebek &lt;http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html&gt;`_ w Smalltalku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wikipedia entry for `Multisets &lt;http://en.wikipedia.org/wiki/Multiset&gt;`_\.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Wpis na Wikipedii dla `Wielozbiorów &lt;http://en.wikipedia.org/wiki/Multizbiór&gt;`_\.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`C++ multisets &lt;http://www.demo2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm&gt;`_ tutorial with examples.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>`Wielozbiory C++  &lt;http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/0120__multiset.htm&gt;`_ samouczek z przykładami.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For mathematical operations on multisets and their use cases, see *Knuth, Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise 19*\.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dla matematycznych operacji na wielozbiorach i ich przypadkach użycia, zobacz *Knuth, Donald. Sztuka programowania komputerów Tom II, Rozdział 4.6.3, Ćwiczenie 19*\.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enumerate all distinct multisets of a given size over a given set of elements, see :func:`itertools.combinations_with_replacement`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Aby wyliczyć wszystkie różne wielozbiory danego rozmiaru ponad danym zbiorem elementów, zobacz :func:`itertools.combinations_with_replacement`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>map(Counter, combinations_with_replacement('ABC', 2)) --&gt; AA AB AC BB BC CC</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>map(Counter, combinations_with_replacement('ABC', 2)) --&gt; AA AB AC BB BC CC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:class:`deque` objects</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>przedmioty :class:`deque`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns a new deque object initialized left-to-right (using :meth:`append`) with data from *iterable*.  If *iterable* is not specified, the new deque is empty.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zwraca nowy przedmiot dwukońcowej kolejki zainicjowany od lewej strony do prawej (używając sposobu postępowania :meth:`append`) z danymi z przedmiotu *iterowalnego*. Jeśli przedmiot *iterowalny* jest nieokreślony, nowy przedmiot dwukońcowej kolejki jest pusty.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deques are a generalization of stacks and queues (the name is pronounced "deck" and is short for "double-ended queue").  Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty dwukońcowej kolejki - deque - są uogólnieniem sterty i kolejki (nazwa jest wymawiana jak "deck" i jest skrótem od "dwukońcowej kolejki"). Dwukońcowe kolejki wspierają bezpieczne dla wątków, efektywne pod względem wykorzystania pamięci działania dodania na koniec i pobrania z każdego z dwóch końców dwukońcowej kolejki z w przybliżeniu tą samą prędkością O(1) w każdym kierunku.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Though :class:`list` objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for ``pop(0)`` and ``insert(0, v)`` operations which change both the size and position of the underlying data representation.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Chociaż przedmioty :class:`list` wspierają podobne operacje, są optymalizowane dla szybkich stałej długości operacji i ponoszą koszty przenoszenia pamięci O(n) dla ``pop(0) i ``insert(0, v)`` które zmieniają zarówno rozmiar jak i pozycję leżących u podstaw reprezentacji danych.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If *maxlen* is not specified or is *None*, deques may grow to an arbitrary length.  Otherwise, the deque is bounded to the specified maximum length.  Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end.  Bounded length deques provide functionality similar to the ``tail`` filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Jeśli *maxlen* nie jest określona lub jest *None*, podwójnie zakończone kolejki mogą rozrosnąć się do dowolnej długości. W przeciwnym razie, podwójnie zakończone kolejki są ograniczone do określonej maksymalnej długości. Gdy określonej długości kolejka jest pełna, gdy nowe elementy są dodawane, odpowiadająca liczba elementów jest odrzucana z przeciwnego końca. Określonej długości kolejki dostarczają funkcjonalności podobnej do filtra ``ogona`` - z ang. - ``tail`` w Unix-ie. Są one także użyteczne dla podążania za transakcjami i innego rodzaju danymi, gdzie tylko najświeższe aktywności są przedmiotem zainteresowania.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deque objects support the following methods:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty podwójnie zakończonych kolejek wspierają następujące sposoby postępowania:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *x* to the right side of the deque.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj *x* do prawej strony podwójnie zakończonej kolejki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add *x* to the left side of the deque.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Dodaj *x* do lewej strony podwójnie zakończonej kolejki.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove all elements from the deque leaving it with length 0.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdejmij wszystkie elementy podwójnie zakończonej kolejki zostawiając ją z długością 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Count the number of deque elements equal to *x*.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Policz liczbę elementów podwójnie zakończonej kolejki równych *x*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extend the right side of the deque by appending elements from the iterable argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerz prawą stronę podwójnie zakończonej kolejki przez doklejenie elementów z iterowalnego parametru.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extend the left side of the deque by appending elements from *iterable*. Note, the series of left appends results in reversing the order of elements in the iterable argument.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Rozszerz lewą stronę podwójnie zakończonej kolejki przez doklejenie elementów z *iterowalnego* parametru. Zauważ, że seria lewych doklejeń powoduje odwrócenie kolejności elementów w parametrze iterowalnym.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove and return an element from the right side of the deque. If no elements are present, raises an :exc:`IndexError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdejmij i zwróć element z prawej strony podwójnie zakończonej kolejki. Jeśli żadne elementy nie są obecne, zgłoś :exc:`IndexError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove and return an element from the left side of the deque. If no elements are present, raises an :exc:`IndexError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdejmij i zwróć element z lewej strony podwójnie zakończonej kolejki. Jeśli żadne elementy nie są obecne zgłoś :exc:`IndexError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removed the first occurrence of *value*.  If not found, raises a :exc:`ValueError`.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Zdejmij pierwsze napotkane wystąpienie *wartości*. Jeśli nie znaleziono, zgłasza :exc:`ValueError`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reverse the elements of the deque in-place and then return ``None``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Odwróć elementy podwójnie zakończonej kolejki na-miejscu a potem zwróć ``None`` - z ang. - ``Żaden``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the left.  Rotating one step to the right is equivalent to: ``d.appendleft(d.pop())``.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Obróć podwójnie zakończoną kolejkę *n* razy w prawo. Jeśli *n* jest ujemne obróć w lewo. Obrócenie jeden raz w prawo jest równoważne: ``d.appendleft(d.pop())``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deque objects also provide one read-only attribute:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przedmioty podwójnie zakończonej kolejki dostarczają także jedną właściwość tylko do odczytu:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maximum size of a deque or *None* if unbounded.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Maksymalny rozmiar podwójnie zakończonej kolejki lub *Żaden* - z ang. - *None* jeśli bez ograniczenia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the above, deques support iteration, pickling, ``len(d)``, ``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing with the :keyword:`in` operator, and subscript references such as ``d[-1]``.  Indexed access is O(1) at both ends but slows to O(n) in the middle.  For fast random access, use lists instead.</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>W dodatku do powyższego podwójnie zakończone kolejki wspierają iterację, peklowanie, ``len(d)`` - długość, ``reversed(d)`` - odwróconą kolejność, ``copy.copy(d)`` - kopię, ``copy.deepcopy(d)`` - głęboką kopię, sprawdzanie przynależności z użyciem operatora :keyword:`in` i odniesieniami w podtekście takimi, jak ``d[-1]``. Indeksowany dostęp jest O(1) na obu końcach ale zwalnia do O(n) w środku. Dla szybkich przypadkowych dostępów, użyj list zamiast tego.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="pl">
        <seg>Przykład:</seg>
      </tuv>
    </tu>
  </body>
</tmx>
